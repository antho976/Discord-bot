/* ====================== 
   IMPORTS & SETUP
====================== */
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import crypto from 'crypto';
import { createServer } from 'http';
import express from 'express';
import multer from 'multer';
import { Server } from 'socket.io';
import {
  Client,
  GatewayIntentBits,
  Partials,
  EmbedBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  REST,
  Routes,
  SlashCommandBuilder,
  PermissionsBitField,
  AuditLogEvent,
  AttachmentBuilder
} from 'discord.js';
import RPGBot from './Discord bot - test branch/rpg/RPGBot.js';
import contentRoutes from './Discord bot - test branch/rpg/api/content-routes.js';
import { ITEMS } from './Discord bot - test branch/rpg/data/items.js';
import { RECIPES } from './Discord bot - test branch/rpg/data/professions.js';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.GuildVoiceStates
  ],
  partials: [
    Partials.Message,
    Partials.Channel,
    Partials.Reaction,
    Partials.User,
    Partials.GuildMember
  ],
  // Sweep old cached messages to reduce memory usage
  sweepers: {
    messages: { interval: 300, lifetime: 600 },       // Sweep messages older than 10min, check every 5min
  }
});

const AUDIT_LOG_FLUSH_MS = 2000;
const AUDIT_LOG_MAX_EMBEDS = 10;
const auditLogQueue = [];
let auditLogFlushTimer = null;
let auditLogFlushRunning = false;
const auditExecutorCache = new Map();

// ========== RESOURCE OPTIMIZATIONS ==========
// Debounced saveState â€” writes at most once per 5 seconds
let _saveStateTimer = null;
let _saveStatePending = false;
function debouncedSaveState() {
  _saveStatePending = true;
  if (!_saveStateTimer) {
    _saveStateTimer = setTimeout(() => {
      _saveStateTimer = null;
      if (_saveStatePending) {
        _saveStatePending = false;
        saveState();
      }
    }, 5000);
  }
}

// Debounced log writes â€” flush at most once per 3 seconds
let _logWriteTimer = null;
let _logDirty = false;
function flushLogs() {
  if (_logDirty) {
    _logDirty = false;
    try { fs.writeFileSync(LOG_FILE, JSON.stringify(logs, null, 2)); } catch {}
  }
}
function scheduleLogFlush() {
  _logDirty = true;
  if (!_logWriteTimer) {
    _logWriteTimer = setTimeout(() => {
      _logWriteTimer = null;
      flushLogs();
    }, 3000);
  }
}

// Analytics tab cache â€” re-renders only every 30 seconds
const _analyticsCache = {};
const ANALYTICS_CACHE_TTL = 30000; // 30s
function getCachedAnalytics(tabKey, renderFn) {
  const entry = _analyticsCache[tabKey];
  if (entry && (Date.now() - entry.time) < ANALYTICS_CACHE_TTL) return entry.html;
  const html = renderFn();
  _analyticsCache[tabKey] = { html, time: Date.now() };
  return html;
}
function invalidateAnalyticsCache() {
  Object.keys(_analyticsCache).forEach(k => delete _analyticsCache[k]);
}

// RPG file cache â€” caches parsed JSON for 10 seconds
const _rpgFileCache = {};
const RPG_CACHE_TTL = 10000;
function cachedReadJSON(filePath) {
  const entry = _rpgFileCache[filePath];
  if (entry && (Date.now() - entry.time) < RPG_CACHE_TTL) return entry.data;
  const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
  _rpgFileCache[filePath] = { data, time: Date.now() };
  return data;
}
function invalidateRPGCache(filePath) {
  if (filePath) delete _rpgFileCache[filePath];
  else Object.keys(_rpgFileCache).forEach(k => delete _rpgFileCache[k]);
}
// ========== END OPTIMIZATIONS ==========

// Initialize RPG system
const rpgBot = new RPGBot(client);

/* ======================
   FILE STORAGE
====================== */
const SOURCE_DATA_DIR = path.join(__dirname, 'data');
const DATA_DIR = process.env.PERSISTENT_DATA_DIR ? path.join(process.env.PERSISTENT_DATA_DIR, 'data') : './data';
const UPLOADS_PERSIST_DIR = process.env.PERSISTENT_DATA_DIR ? path.join(process.env.PERSISTENT_DATA_DIR, 'uploads') : path.join(__dirname, 'uploads');
if (!fs.existsSync(DATA_DIR)) fs.mkdirSync(DATA_DIR, { recursive: true });
if (!fs.existsSync(UPLOADS_PERSIST_DIR)) fs.mkdirSync(UPLOADS_PERSIST_DIR, { recursive: true });

// Seed persistent data dir from repo on first run
if (process.env.PERSISTENT_DATA_DIR && fs.existsSync(SOURCE_DATA_DIR)) {
  const sourceFiles = fs.readdirSync(SOURCE_DATA_DIR).filter(f => f.endsWith('.json'));
  for (const file of sourceFiles) {
    const dest = path.join(DATA_DIR, file);
    if (!fs.existsSync(dest)) {
      fs.copyFileSync(path.join(SOURCE_DATA_DIR, file), dest);
      console.log(`[Persist] Seeded ${file} to persistent storage`);
    }
  }
}

// Fix any absolute image URLs in pets.json to relative paths
// Also merge any new catalog pets from repo into persistent storage
try {
  const petsFile = path.join(DATA_DIR, 'pets.json');
  const sourcePetsFile = path.join(SOURCE_DATA_DIR, 'pets.json');
  if (fs.existsSync(petsFile) && fs.existsSync(sourcePetsFile)) {
    const pData = JSON.parse(fs.readFileSync(petsFile, 'utf8'));
    const srcData = JSON.parse(fs.readFileSync(sourcePetsFile, 'utf8'));
    let fixed = false;

    // Merge new catalog entries from repo that don't exist in persistent
    const existingIds = new Set((pData.catalog || []).map(p => p.id));
    for (const srcPet of (srcData.catalog || [])) {
      if (!existingIds.has(srcPet.id)) {
        pData.catalog = pData.catalog || [];
        pData.catalog.push(srcPet);
        fixed = true;
        console.log(`[Persist] Merged new pet "${srcPet.name}" into persistent catalog`);
      }
    }

    // Merge new categories from repo
    if (srcData.categories && Array.isArray(srcData.categories)) {
      pData.categories = pData.categories || [];
      for (const cat of srcData.categories) {
        if (!pData.categories.includes(cat)) {
          pData.categories.push(cat);
          fixed = true;
        }
      }
    }

    // Fix absolute image URLs to relative
    for (const p of (pData.catalog || [])) {
      if (p.imageUrl && p.imageUrl.includes('/uploads/') && p.imageUrl.startsWith('http')) {
        p.imageUrl = '/uploads/' + p.imageUrl.split('/uploads/').pop();
        fixed = true;
      }
      if (p.animatedUrl && p.animatedUrl.includes('/uploads/') && p.animatedUrl.startsWith('http')) {
        p.animatedUrl = '/uploads/' + p.animatedUrl.split('/uploads/').pop();
        fixed = true;
      }
    }
    if (fixed) {
      fs.writeFileSync(petsFile, JSON.stringify(pData, null, 2));
      console.log('[Persist] Updated pets.json in persistent storage');
    }
  }
} catch (e) { console.error('[Persist] Error fixing pet image URLs:', e.message); }

// Seed state.json to persistent storage on first run
// Also merge history/stats from repo if persistent state is empty
if (process.env.PERSISTENT_DATA_DIR) {
  const persistStatePath = path.join(process.env.PERSISTENT_DATA_DIR, 'state.json');
  const repoStatePath = path.resolve('./state.json');
  if (!fs.existsSync(persistStatePath) && fs.existsSync(repoStatePath)) {
    fs.copyFileSync(repoStatePath, persistStatePath);
    console.log('[Persist] Seeded state.json to persistent storage');
  } else if (fs.existsSync(persistStatePath) && fs.existsSync(repoStatePath)) {
    // Merge: if persistent state has no history but repo does, copy it over
    try {
      const persistState = JSON.parse(fs.readFileSync(persistStatePath, 'utf8'));
      const repoState = JSON.parse(fs.readFileSync(repoStatePath, 'utf8'));
      let merged = false;
      if ((!persistState.history || persistState.history.length === 0) && repoState.history && repoState.history.length > 0) {
        persistState.history = repoState.history;
        merged = true;
        console.log(`[Persist] Merged ${repoState.history.length} history entries from repo`);
      }
      if ((!persistState.stats || persistState.stats.totalStreams === 0) && repoState.stats && repoState.stats.totalStreams > 0) {
        persistState.stats = repoState.stats;
        merged = true;
        console.log('[Persist] Merged stats from repo');
      }
      if (merged) {
        fs.writeFileSync(persistStatePath, JSON.stringify(persistState, null, 2));
        console.log('[Persist] Updated persistent state.json with merged data');
      }
    } catch (e) { console.error('[Persist] Error merging state:', e.message); }
  }
}

const LOG_FILE = `${DATA_DIR}/logs.json`;
const CONFIG_FILE = `${DATA_DIR}/config.json`;
const STATE_PATH = process.env.PERSISTENT_DATA_DIR ? path.join(process.env.PERSISTENT_DATA_DIR, 'state.json') : path.resolve('./state.json');
const RPG_WORLDS_FILE = path.join(DATA_DIR, 'rpg-worlds.json');

function loadRPGWorlds() {
  try {
    if (fs.existsSync(RPG_WORLDS_FILE)) {
      const data = fs.readFileSync(RPG_WORLDS_FILE, 'utf8');
      global.rpgWorlds = JSON.parse(data);
      let migrated = false;
      for (const world of Object.values(global.rpgWorlds || {})) {
        if (!world.entities) {
          world.entities = { monsters: {}, items: {}, npcs: {}, locations: {}, dungeons: {}, raids: {}, worldBosses: {}, quests: {} };
          migrated = true;
        }
        if (!world.entities.quests) {
          world.entities.quests = {};
          migrated = true;
        }
        if (world.quests && typeof world.quests === 'object') {
          for (const [category, list] of Object.entries(world.quests)) {
            if (!Array.isArray(list)) continue;
            list.forEach(q => {
              if (!q?.id) return;
              if (!world.entities.quests[q.id]) {
                world.entities.quests[q.id] = {
                  ...q,
                  type: q.type || category,
                  category: q.category || category
                };
                migrated = true;
              }
            });
          }
        }
      }
      if (migrated) saveRPGWorlds();
      console.log(`[INFO] Loaded ${Object.keys(global.rpgWorlds).length} RPG worlds from file`);
    } else {
      global.rpgWorlds = {};
      console.log('[INFO] No RPG worlds file found, starting fresh');
    }
  } catch (err) {
    console.error('[ERROR] Failed to load RPG worlds:', err);
    global.rpgWorlds = {};
  }
}

function saveRPGWorlds() {
  try {
    const dir = path.dirname(RPG_WORLDS_FILE);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(RPG_WORLDS_FILE, JSON.stringify(global.rpgWorlds, null, 2));
  } catch (err) {
    console.error('[ERROR] Failed to save RPG worlds:', err);
  }
}

const DAY_MAP = {
  sun: 'sunday', sunday: 'sunday',
  mon: 'monday', monday: 'monday',
  tue: 'tuesday', tues: 'tuesday', tuesday: 'tuesday',
  wed: 'wednesday', weds: 'wednesday', wednesday: 'wednesday',
  thu: 'thursday', thur: 'thursday', thursday: 'thursday',
  fri: 'friday', friday: 'friday',
  sat: 'saturday', saturday: 'saturday'
};

const DAY_INDEX = {
  sunday: 0,
  monday: 1,
  tuesday: 2,
  wednesday: 3,
  thursday: 4,
  friday: 5,
  saturday: 6
};

/* ======================
   LOAD LOGS
====================== */
let logs = [];
if (fs.existsSync(LOG_FILE)) {
  try { logs = JSON.parse(fs.readFileSync(LOG_FILE, 'utf8')); } catch {}
}

function addLog(type, msg) {
  const time = new Date().toLocaleTimeString();
  const entry = { time, type, msg };

  logs.unshift(entry);
  if (logs.length > 200) logs.pop();

  scheduleLogFlush();
  console.log(`[${time}] [${type.toUpperCase()}] ${msg}`);

  // SAFEGUARD: Auto-refresh token if we detect auth errors
  if (type === 'error' && msg.toLowerCase().includes('token') && (msg.toLowerCase().includes('invalid') || msg.toLowerCase().includes('unauthorized') || msg.toLowerCase().includes('expired'))) {
    const now = Date.now();
    // Only attempt refresh once every 5 minutes to avoid spam
    if (!lastTokenRefreshAttempt || (now - lastTokenRefreshAttempt) > 5 * 60 * 1000) {
      lastTokenRefreshAttempt = now;
      addLog('warn', 'ðŸ›¡ï¸ Token error detected! Auto-attempting refresh...');
      refreshTwitchToken().then(success => {
        if (success) {
          addLog('info', 'âœ… Safeguard activated: Token auto-refreshed successfully!');
        } else {
          addLog('error', 'âš ï¸ Safeguard: Token auto-refresh failed. Check your refresh token.');
        }
      }).catch(err => {
        addLog('error', `Safeguard refresh error: ${err.message}`);
      });
    }
  }
}

function addAuditLogEntry(entry) {
  // Store in audit log history for searchable dashboard
  addToAuditLogHistory(entry);
}

function isExcludedBySettings({ userId, channelId, roleIds }) {
  if (!auditLogSettings?.enabled) return true;
  if (channelId && Array.isArray(auditLogSettings.excludedChannels) && auditLogSettings.excludedChannels.includes(channelId)) return true;
  if (userId && Array.isArray(auditLogSettings.excludedUsers) && auditLogSettings.excludedUsers.includes(userId)) return true;
  if (roleIds && Array.isArray(auditLogSettings.excludedRoles) && auditLogSettings.excludedRoles.length) {
    if (roleIds.some(id => auditLogSettings.excludedRoles.includes(id))) return true;
  }
  return false;
}

async function getAuditExecutor(guild, auditType, targetId) {
  try {
    const cacheKey = `${auditType}:${targetId}`;
    const cached = auditExecutorCache.get(cacheKey);
    if (cached && cached.expiresAt > Date.now()) return cached.value;
    if (!guild?.members?.me?.permissions?.has(PermissionsBitField.Flags.ViewAuditLog)) return null;
    const logs = await guild.fetchAuditLogs({ type: auditType, limit: 6 });
    const entry = logs.entries.find(e => e?.target?.id === targetId && (Date.now() - e.createdTimestamp) < 15000);
    if (!entry) return null;
    const result = {
      id: entry.executor?.id || null,
      tag: entry.executor?.tag || entry.executor?.username || null,
      reason: entry.reason || null
    };
    auditExecutorCache.set(cacheKey, { value: result, expiresAt: Date.now() + 15000 });
    return result;
  } catch {
    return null;
  }
}

function getMemberRoleIds(member) {
  if (!member?.roles?.cache) return [];
  return [...member.roles.cache.keys()];
}

process.on('unhandledRejection', (reason) => {
  const message = reason instanceof Error ? reason.stack || reason.message : String(reason);
  try { addLog('error', `Unhandled promise rejection: ${message}`); } catch {}
});

process.on('uncaughtException', (err) => {
  try { addLog('error', `Uncaught exception: ${err?.stack || err?.message || String(err)}`); } catch {}
  try { saveState(); } catch {}
  process.exit(1);
});

function truncateLogText(text, max = 900) {
  if (text === null || text === undefined) return '';
  const str = String(text);
  if (str.length <= max) return str;
  return str.slice(0, max - 3) + '...';
}

async function sendAuditLog(payload) {
  try {
    if (!auditLogSettings?.enabled) return;
    const eventType = payload.eventType || 'unknown';
    const perEventChannel = auditLogSettings.perEventChannels?.[eventType];
    const mainChannel = auditLogSettings.channelId;
    if (!mainChannel && !perEventChannel) return;
    payload.targetChannel = perEventChannel || mainChannel;
    payload.targetPings = auditLogSettings.perEventPings?.[eventType] || [];
    auditLogQueue.push(payload);
    if (!auditLogFlushTimer) {
      auditLogFlushTimer = setInterval(() => {
        flushAuditLogQueue().catch(() => {});
      }, AUDIT_LOG_FLUSH_MS);
    }
  } catch (err) {
    addLog('error', `Audit log send failed: ${err.message}`);
  }
}

async function flushAuditLogQueue() {
  if (auditLogFlushRunning) return;
  if (auditLogQueue.length === 0) return;
  auditLogFlushRunning = true;
  try {
    const queueByChannel = {};
    while (auditLogQueue.length > 0) {
      const next = auditLogQueue.shift();
      const targetChannel = next.targetChannel;
      if (!targetChannel) continue;
      if (!queueByChannel[targetChannel]) queueByChannel[targetChannel] = [];
      if (next?.embeds?.length) {
        for (const e of next.embeds) {
          queueByChannel[targetChannel].push({ embed: e, pings: next.targetPings });
        }
      }
    }
    for (const [channelId, items] of Object.entries(queueByChannel)) {
      const channel = await client.channels.fetch(channelId).catch(() => null);
      if (!channel || !channel.isTextBased()) continue;
      const batches = [];
      for (let i = 0; i < items.length; i += AUDIT_LOG_MAX_EMBEDS) {
        batches.push(items.slice(i, i + AUDIT_LOG_MAX_EMBEDS));
      }
      for (const batch of batches) {
        const embeds = batch.map(x => x.embed);
        const allPings = [...new Set(batch.flatMap(x => x.pings))];
        const content = allPings.length > 0 ? allPings.join(' ') : '';
        await channel.send({ content, embeds });
      }
    }
  } catch (err) {
    addLog('error', `Audit log flush failed: ${err.message}`);
  } finally {
    auditLogFlushRunning = false;
  }
}

function logNotification(type, message, details = {}) {
  const entry = { type, message, timestamp: new Date().toISOString(), details };
  notificationHistory.unshift(entry);
  if (notificationHistory.length > 100) notificationHistory.pop();
  saveState();
}

function recomputeStreamStatsFromHistory() {
  try {
    if (!Array.isArray(history)) return;
    const totalStreams = history.length;
    let peakViewers = 0;
    let totalViewers = 0;
    let avgViewersSum = 0;
    let avgCount = 0;

    for (const h of history) {
      if (!h) continue;
      const peak = h.peakViewers ?? h.viewers ?? 0;
      if (peak > peakViewers) peakViewers = peak;

      const avg = h.avgViewers ?? h.viewers ?? 0;
      avgViewersSum += avg;
      if (avg > 0) avgCount++;

      totalViewers += avg;
    }

    stats.totalStreams = totalStreams;
    stats.peakViewers = peakViewers;
    stats.totalViewers = totalViewers;
    stats.avgViewers = avgCount ? Math.round(avgViewersSum / avgCount) : 0;
  } catch (err) {
    addLog('error', `recomputeStreamStatsFromHistory failed: ${err.message}`);
  }
}

function isOnCooldown(key, cooldownMs = 300000) {
  const lastTime = alertCooldowns[key];
  if (!lastTime) return false;
  const elapsed = Date.now() - lastTime;
  return elapsed < cooldownMs;
}

function setCooldown(key) {
  alertCooldowns[key] = Date.now();
  debouncedSaveState();
}

function trackActivity(viewers) {
  const hour = new Date().getHours();
  const key = `${new Date().toISOString().split('T')[0]}_${hour}`;
  if (!activityHeatmap[key]) activityHeatmap[key] = [];
  activityHeatmap[key].push(viewers);
  debouncedSaveState();
}

function trackStreamViewers(viewers) {
  const now = Date.now();
  currentStreamViewerData.push({
    timestamp: now,
    viewers: viewers,
    time: new Date(now).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
  });
  if (currentStreamViewerData.length > 1000) {
    currentStreamViewerData.shift();
  }
  debouncedSaveState();
}

function ensureCurrentStreamGameTimelineInitialized(initialGame = null) {
  if (!isLive) return;
  if (!lastStreamId) return;
  if (!Array.isArray(currentStreamGameTimeline)) currentStreamGameTimeline = [];
  if (currentStreamGameTimeline.length > 0) {
    const first = currentStreamGameTimeline[0];
    if (first && first.streamId && lastStreamId && first.streamId !== lastStreamId) {
      currentStreamGameTimeline = [];
    } else {
      return;
    }
  }
  const game = (initialGame || (history[history.length - 1]?.game) || '').toString().trim();
  if (!game) return;
  currentStreamGameTimeline = [{
    streamId: lastStreamId,
    game,
    startMs: Date.now(),
    endMs: null
  }];
  saveState();
}

const defaultState = {
  isLive: false,
  lastStreamId: null,
  announcementMessageId: null,
  stats: { totalStreams: 0, peakViewers: 0, totalViewers: 0 },
  history: [],
  schedule: {
    nextStreamAt: null,
    alertsSent: { oneHour: false, tenMin: false },
    noStreamToday: false,
    streamDelayed: false,
    alertsEnabledToday: true,
    weekly: {}
  },
  streamMetadata: {
    lastTitle: null,
    lastGame: null,
    lastFollowers: 0,
    lastSubs: 0,
    streamStartTime: null,
    titleChangeDetected: false,
    gameChangeDetected: false,
    lastVodCheck: null
  },
  engagementSettings: {
    titleChangeNotif: true,
    gameChangeNotif: true,
    vodNotif: true,
    raidNotif: true,
    clipNotif: true,
    followMilestones: [100, 500, 1000, 5000, 10000],
    viewerMilestones: [100, 250, 500, 1000],
    lastFollowerMilestone: 0,
    lastViewerMilestone: 0,
    autoDeleteTitleChange: false,
    autoDeleteGameChange: false,
    autoDeleteVod: false,
    autoDeleteRaid: false,
    autoDeleteClip: false,
    autoDeleteFollowerMilestone: false,
    autoDeleteViewerMilestone: false,
    autoDeleteDelay: 60000
  },
  suggestions: [],
  warnings: {},
  startTime: Date.now(),
  botTimezone: 'America/Toronto',
  notificationHistory: [],
  customCommands: [],
  commandUsage: {},
  activityHeatmap: {},
  followerHistory: [],
  subHistory: [],
  alertCooldowns: {},
  dashboardSettings: {
    customLiveMessage: null,
    offlineThreshold: 120000,
    suggestionCooldownMinutes: 60,
    alertRoles: {
      liveAlert: null,
      scheduleAlert: null,
      suggestionAlert: null
    },
    hitMilestonesThisStream: {},
    levelUpChannelId: null,
    levelUpPingPlayer: true,
    welcomeSettings: {
      enabled: false,
      channelId: null,
      message: 'Welcome {user} to {server}!',
      autoRoles: []
    },
    auditLogSettings: {
      enabled: false,
      channelId: null,
      logMessageEdits: true,
      logMessageDeletes: true,
      logMessageBulkDeletes: true,
      logMessagePins: true,
      logUsernameChanges: true,
      logAvatarChanges: true,
      logNicknameChanges: true,
      logRoleChanges: true,
      logMemberJoins: true,
      logMemberLeaves: true,
      logMemberBans: true,
      logMemberUnbans: true,
      logMemberTimeouts: true,
      logMemberMutes: true,
      logMemberBoosts: true,
      logJoinPosition: true,
      logServerUpdates: true,
      logIntegrations: true,
      warnNewAccounts: true,
      newAccountThresholdDays: 7,
      excludedChannels: [],
      excludedRoles: [],
      excludedUsers: [],
      muteRoleIds: []
    },
    rpgSettings: {
      channelRestrictionEnabled: false,
      allowedChannelIds: []
    }
  },
  leveling: {},
  levelingConfig: {
    xpPerMessageMin: 15,
    xpPerMessageMax: 25,
    messageCooldownMs: 45000,
    xpPerVoiceMinute: 5,
    xpPerReaction: 2,
    xpMultiplier: 1,
    multiplierEndTime: null,
    levelMilestones: [10, 25, 50, 100],
    roleRewards: {},
    xpMode: 'increment',
    baseXp: 100,
    xpIncrement: 50,
    customXpPerLevel: {},
    prestigeThresholds: {}
  },
  prestige: {},
  weeklyLeveling: {},
  lastWeeklyReset: Date.now(),
  currentStreamViewerData: [],
  currentStreamGameTimeline: [],
  viewerGraphHistory: [],
  giveaways: [],
  polls: [],
  reminders: [],
  notificationFilters: [],
  streamGoals: {
    monthlyFollowers: 0,
    monthlyHours: 0,
    monthlyStreams: 0,
    monthlyPeakViewers: 0,
    resetDay: 1
  },
  rpgTestMode: false,
  rpgEvents: {
    milestoneEvents: [
      { id: 'xp_boost_50', viewerThreshold: 50, type: 'xp_boost', multiplier: 2, duration: 30, name: 'âš¡ Double XP', description: '2x XP for 30 minutes!', emoji: 'âš¡', enabled: true },
      { id: 'secret_dungeon_100', viewerThreshold: 100, type: 'secret_dungeon', dungeonId: 'viewers_cave', duration: 60, name: 'ðŸ° Secret Dungeon', description: 'A hidden dungeon unlocks for 1 hour!', emoji: 'ðŸ°', enabled: true },
      { id: 'gold_rain_150', viewerThreshold: 150, type: 'gold_rain', goldAmount: 5000, name: 'ðŸ’° Gold Rain', description: 'All active players receive 5000 gold!', emoji: 'ðŸ’°', enabled: true },
      { id: 'boss_spawn_200', viewerThreshold: 200, type: 'boss_spawn', bossName: 'Viewer Dragon', duration: 45, name: 'ðŸ‰ World Boss', description: 'A massive world boss appears!', emoji: 'ðŸ‰', enabled: true },
      { id: 'loot_boost_250', viewerThreshold: 250, type: 'loot_boost', multiplier: 3, duration: 30, name: 'ðŸŽ Triple Loot', description: '3x loot drops for 30 minutes!', emoji: 'ðŸŽ', enabled: true }
    ],
    activeEvents: [],
    eventHistory: [],
    triggeredThisStream: {}
  }
};

function loadState() {
  try {
    if (!fs.existsSync(STATE_PATH))
      return JSON.parse(JSON.stringify(defaultState));

    const raw = fs.readFileSync(STATE_PATH, 'utf8');
    if (!raw.trim())
      return JSON.parse(JSON.stringify(defaultState));

    const parsed = JSON.parse(raw);

    return {
      ...defaultState,
      ...parsed,
      stats: {
        ...defaultState.stats,
        ...(parsed.stats || {})
      },
      schedule: {
        ...defaultState.schedule,
        ...(parsed.schedule || {}),
        alertsSent: {
          ...defaultState.schedule.alertsSent,
          ...(parsed.schedule?.alertsSent || {})
        }
      },
      streamMetadata: {
        ...defaultState.streamMetadata,
        ...(parsed.streamMetadata || {})
      },
      engagementSettings: {
        ...defaultState.engagementSettings,
        ...(parsed.engagementSettings || {})
      },
      suggestions: parsed.suggestions || [],
      warnings: parsed.warnings || {},
      startTime: parsed.startTime || Date.now(),
      botTimezone: parsed.botTimezone || 'America/Toronto',
      notificationHistory: parsed.notificationHistory || [],
      customCommands: (parsed.customCommands || []).map(cmd => ({
        ...cmd,
        imageUrl: cmd.imageUrl || ''
      })),
      activityHeatmap: parsed.activityHeatmap || {},
      followerHistory: parsed.followerHistory || [],
      subHistory: parsed.subHistory || [],
      alertCooldowns: parsed.alertCooldowns || {},
      dashboardSettings: {
        ...defaultState.dashboardSettings,
        ...(parsed.dashboardSettings || {})
      },
      leveling: parsed.leveling || {},
      levelingConfig: {
        ...defaultState.levelingConfig,
        ...(parsed.levelingConfig || {})
      },
      prestige: parsed.prestige || {},
      weeklyLeveling: parsed.weeklyLeveling || {},
      lastWeeklyReset: parsed.lastWeeklyReset || Date.now(),
      currentStreamViewerData: parsed.currentStreamViewerData || [],
      currentStreamGameTimeline: parsed.currentStreamGameTimeline || [],
      viewerGraphHistory: parsed.viewerGraphHistory || [],
      giveaways: parsed.giveaways || [],
      polls: parsed.polls || [],
      reminders: parsed.reminders || [],
      notificationFilters: parsed.notificationFilters || [],
      twitchTokens: parsed.twitchTokens || { access_token: null, refresh_token: null, expires_at: null }
    };
  } catch {
    return JSON.parse(JSON.stringify(defaultState));
  }
}

const state = loadState();

let isLive = state.isLive ?? defaultState.isLive;
let lastStreamId = state.lastStreamId ?? defaultState.lastStreamId;
let announcementMessageId = state.announcementMessageId ?? defaultState.announcementMessageId;
let stats = state.stats ?? JSON.parse(JSON.stringify(defaultState.stats));
let history = state.history ?? [];
// Normalize: duration is stored in seconds, compute durationMinutes for all analytics
history.forEach(s => { if (s.duration != null && s.durationMinutes == null) s.durationMinutes = Math.round(s.duration / 60); });
let schedule = state.schedule ?? JSON.parse(JSON.stringify(defaultState.schedule));
let streamMetadata = state.streamMetadata ?? JSON.parse(JSON.stringify(defaultState.streamMetadata));
let engagementSettings = state.engagementSettings ?? JSON.parse(JSON.stringify(defaultState.engagementSettings));
let suggestions = state.suggestions ?? [];
let warnings = state.warnings ?? {};
let startTime = state.startTime ?? Date.now();
let notificationHistory = state.notificationHistory ?? [];
let customCommands = state.customCommands ?? [];
let activityHeatmap = state.activityHeatmap ?? {};
let followerHistory = state.followerHistory ?? [];
let subHistory = state.subHistory ?? [];
let alertCooldowns = state.alertCooldowns ?? {};
let lastResetDate = state.lastResetDate ?? null;
let leveling = state.leveling ?? {};
let rpgTestMode = state.rpgTestMode ?? false;
let rpgEvents = state.rpgEvents ?? JSON.parse(JSON.stringify(defaultState.rpgEvents));
let streamGoals = state.streamGoals ?? JSON.parse(JSON.stringify(defaultState.streamGoals));
let levelingConfig = {
  ...defaultState.levelingConfig,
  ...(state.levelingConfig || {})
};
let prestigeHistory = state.prestigeHistory || []; // Array of {userId, username, prestigeLevel, timestamp}
let twitchTokens = state.twitchTokens ?? { access_token: null, refresh_token: null, expires_at: null };
let lastTokenRefreshAttempt = null; // Cooldown for token refresh attempts
const defaultDashboardSettings = {
  customLiveMessage: null,
  offlineThreshold: 120000, // 2 minutes in ms
  suggestionCooldownMinutes: 60,
  alertRoles: {
    liveAlert: null,
    scheduleAlert: null,
    suggestionAlert: null
  },
  hitMilestonesThisStream: {},
  levelUpChannelId: null,
  levelUpPingPlayer: true,
  auditLogSettings: {
    enabled: false,
    channelId: null,
    logMessageEdits: true,
    logMessageDeletes: true,
    logMessageBulkDeletes: true,
    logMessagePins: true,
    logUsernameChanges: true,
    logAvatarChanges: true,
    logNicknameChanges: true,
    logRoleChanges: true,
    logMemberJoins: true,
    logMemberLeaves: true,
    logMemberBans: true,
    logMemberUnbans: true,
    logMemberTimeouts: true,
    logMemberMutes: true,
    logMemberBoosts: true,
    logJoinPosition: true,
    logServerUpdates: true,
    logIntegrations: true,
    warnNewAccounts: true,
    newAccountThresholdDays: 7,
    excludedChannels: [],
    excludedRoles: [],
    excludedUsers: [],
    muteRoleIds: []
  },
  rpgSettings: {
    channelRestrictionEnabled: false,
    allowedChannelIds: []
  }
};

let dashboardSettings = {
  ...defaultDashboardSettings,
  ...(state.dashboardSettings || {})
};

function getRpgSettings() {
  return {
    ...defaultDashboardSettings.rpgSettings,
    ...(dashboardSettings.rpgSettings || {})
  };
}

function isRpgChannelAllowed(channelId, channel = null) {
  const settings = getRpgSettings();
  if (!settings.channelRestrictionEnabled) return true;
  if (!channelId) return false;

  // Check if the channel itself is allowed
  if (Array.isArray(settings.allowedChannelIds) && settings.allowedChannelIds.includes(channelId)) {
    return true;
  }

  // If it's a thread, check if the parent channel is allowed
  if (channel && channel.isThread && channel.parentId) {
    if (Array.isArray(settings.allowedChannelIds) && settings.allowedChannelIds.includes(channel.parentId)) {
      return true;
    }
  }

  return false;
}

function getRpgRestrictionMessage() {
  const settings = getRpgSettings();
  const allowed = Array.isArray(settings.allowedChannelIds) ? settings.allowedChannelIds : [];
  if (!settings.channelRestrictionEnabled || allowed.length === 0) {
    return 'âŒ RPG is currently disabled.';
  }
  const channels = allowed.map(id => `<#${id}>`).join(', ');
  return `âŒ RPG is restricted to: ${channels}`;
}

let welcomeSettings = {
  enabled: false,
  channelId: null,
  message: 'Welcome {user} to {server}!',
  autoRoles: [],
  // Embed settings
  useEmbed: false,
  embedTitle: 'Welcome to {server}! ðŸ‘‹',
  embedDescription: 'Hey {user}, welcome to **{server}**! We now have **{count}** members!',
  embedColor: '#9146ff',
  embedThumbnail: 'avatar', // 'avatar', 'custom', or 'none'
  embedThumbnailUrl: '',
  embedImage: '',
  embedFooter: 'Member #{position} â€¢ Joined {time}',
  embedFields: [], // [{name: '', value: '', inline: false}]
  // Multiple messages
  messages: [], // Array of message objects for rotation
  messageMode: 'single', // 'single', 'random', 'cycle'
  cycleIndex: 0,
  // DM welcome
  dmEnabled: false,
  dmMessage: 'Welcome to {server}, {username}! Please check out the rules.',
  dmUseEmbed: false,
  // Anti-spam
  antiSpamEnabled: false,
  antiSpamRoles: [], // Don't send welcome if user has these roles (re-joins)
  // Goodbye/Leave messages
  goodbyeEnabled: false,
  goodbyeChannelId: null,
  goodbyeMessage: 'Goodbye {username}, we\'ll miss you! ðŸ‘‹',
  goodbyeUseEmbed: false,
  goodbyeEmbedTitle: 'Goodbye! ðŸ‘‹',
  goodbyeEmbedDescription: '{username} has left us. We now have **{count}** members.',
  goodbyeEmbedColor: '#E74C3C',
  goodbyeEmbedThumbnail: 'avatar',
  goodbyeEmbedThumbnailUrl: '',
  goodbyeEmbedImage: '',
  goodbyeEmbedFooter: 'We\'ll miss you!',
  goodbyeMessages: [],
  goodbyeMessageMode: 'single',
  // Auto-roles settings
  autoRoleConditions: [], // [{roleId, condition: 'always'|'accountAge', minAccountAge: 7}]
  ...(state.dashboardSettings?.welcomeSettings || {})
};

let auditLogSettings = {
  enabled: false,
  channelId: null,
  logLevel: 'all',
  logMessageEdits: true,
  logMessageDeletes: true,
  logMessageBulkDeletes: true,
  logMessagePins: true,
  logUsernameChanges: true,
  logAvatarChanges: true,
  logNicknameChanges: true,
  logRoleChanges: true,
  logMemberJoins: true,
  logMemberLeaves: true,
  logMemberBans: true,
  logMemberUnbans: true,
  logMemberTimeouts: true,
  logMemberMutes: true,
  logMemberBoosts: true,
  logJoinPosition: true,
  logServerUpdates: true,
  logIntegrations: true,
  warnNewAccounts: true,
  newAccountThresholdDays: 7,
  excludedChannels: [],
  excludedRoles: [],
  excludedUsers: [],
  muteRoleIds: [],
  perEventChannels: {},
  perEventExclusions: {},
  perEventPings: {},
  // Log Retention & Cleanup
  logRetentionDays: 30,
  autoCleanupEnabled: false,
  // Severity/Color Coding
  eventColors: {
    ban: '#E74C3C',
    timeout: '#E67E22',
    mute: '#F39C12',
    kick: '#E74C3C',
    join: '#2ECC71',
    leave: '#95A5A6',
    boost: '#F47FFF',
    edit: '#3498DB',
    delete: '#E74C3C',
    roleChange: '#9B59B6',
    nameChange: '#1ABC9C',
    serverUpdate: '#7289DA'
  },
  // Keyword/Phrase Alerts
  alertKeywords: [],
  alertUserId: null, // User ID to ping on keyword match
  alertEnabled: false,
  // DM/Webhook Notifications for Critical Events
  dmNotificationsEnabled: false,
  dmNotifyUserId: null,
  dmNotifyEvents: {
    bans: true,
    newAccounts: true,
    serverChanges: false,
    botChanges: true
  },
  webhookUrl: null,
  webhookEnabled: false,
  // Auto-detect mute role
  autoDetectMuteRole: false,
  ...(state.dashboardSettings?.auditLogSettings || {})
};

// Audit log history for searchable dashboard (stored separately to avoid bloat)
let auditLogHistory = [];
const AUDIT_LOG_HISTORY_MAX = 5000;

// Load audit log history from file
const AUDIT_HISTORY_FILE = `${DATA_DIR}/audit-history.json`;
if (fs.existsSync(AUDIT_HISTORY_FILE)) {
  try { auditLogHistory = JSON.parse(fs.readFileSync(AUDIT_HISTORY_FILE, 'utf8')); } catch {}
}

function saveAuditLogHistory() {
  try {
    fs.writeFileSync(AUDIT_HISTORY_FILE, JSON.stringify(auditLogHistory, null, 2));
  } catch (err) {
    addLog('error', `Failed to save audit history: ${err.message}`);
  }
}

function addToAuditLogHistory(entry) {
  const historyEntry = {
    id: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
    timestamp: new Date().toISOString(),
    ...entry
  };
  auditLogHistory.unshift(historyEntry);
  if (auditLogHistory.length > AUDIT_LOG_HISTORY_MAX) {
    auditLogHistory = auditLogHistory.slice(0, AUDIT_LOG_HISTORY_MAX);
  }
  saveAuditLogHistory();
  
  // Check for keyword alerts
  checkKeywordAlerts(historyEntry);
  
  return historyEntry;
}

async function checkKeywordAlerts(entry) {
  if (!auditLogSettings.alertEnabled || !auditLogSettings.alertKeywords?.length) return;
  if (!auditLogSettings.alertUserId) return;
  
  const textToSearch = [
    entry.userTag,
    entry.action,
    entry.details?.summary,
    entry.details?.reason,
    JSON.stringify(entry.details)
  ].filter(Boolean).join(' ').toLowerCase();
  
  const matchedKeyword = auditLogSettings.alertKeywords.find(kw => 
    textToSearch.includes(kw.toLowerCase())
  );
  
  if (matchedKeyword) {
    try {
      const user = await client.users.fetch(auditLogSettings.alertUserId).catch(() => null);
      if (user) {
        const embed = new EmbedBuilder()
          .setColor(0xFF6B6B)
          .setTitle('ðŸ”” Keyword Alert Triggered')
          .setDescription(`Keyword **"${matchedKeyword}"** detected in audit log`)
          .addFields(
            { name: 'Event Type', value: entry.action || 'Unknown', inline: true },
            { name: 'User', value: entry.userTag || 'Unknown', inline: true },
            { name: 'Details', value: entry.details?.summary || 'No details' }
          )
          .setTimestamp();
        await user.send({ embeds: [embed] }).catch(() => {});
      }
    } catch (err) {
      addLog('error', `Keyword alert DM failed: ${err.message}`);
    }
  }
}

async function sendCriticalEventDM(eventType, details) {
  if (!auditLogSettings.dmNotificationsEnabled || !auditLogSettings.dmNotifyUserId) return;
  if (!auditLogSettings.dmNotifyEvents[eventType]) return;
  
  try {
    const user = await client.users.fetch(auditLogSettings.dmNotifyUserId).catch(() => null);
    if (!user) return;
    
    const embed = new EmbedBuilder()
      .setColor(0xFF4444)
      .setTitle(`âš ï¸ Critical Event: ${eventType.toUpperCase()}`)
      .setDescription(details.summary || 'A critical event occurred')
      .setTimestamp();
    
    if (details.userId) embed.addFields({ name: 'User ID', value: details.userId, inline: true });
    if (details.userTag) embed.addFields({ name: 'User', value: details.userTag, inline: true });
    if (details.reason) embed.addFields({ name: 'Reason', value: details.reason });
    
    await user.send({ embeds: [embed] }).catch(() => {});
    
    // Also send to webhook if configured
    if (auditLogSettings.webhookEnabled && auditLogSettings.webhookUrl) {
      await fetch(auditLogSettings.webhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: `âš ï¸ **Critical Event: ${eventType.toUpperCase()}**`,
          embeds: [embed.toJSON()]
        })
      }).catch(() => {});
    }
  } catch (err) {
    addLog('error', `Critical event DM failed: ${err.message}`);
  }
}

// Log cleanup function
async function cleanupOldAuditLogs() {
  if (!auditLogSettings.autoCleanupEnabled || !auditLogSettings.logRetentionDays) return;
  
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - auditLogSettings.logRetentionDays);
  
  const oldLength = auditLogHistory.length;
  auditLogHistory = auditLogHistory.filter(entry => 
    new Date(entry.timestamp) > cutoffDate
  );
  
  if (auditLogHistory.length < oldLength) {
    saveAuditLogHistory();
    addLog('info', `Cleaned up ${oldLength - auditLogHistory.length} old audit log entries`);
  }
}

// Run cleanup daily
setInterval(cleanupOldAuditLogs, 24 * 60 * 60 * 1000);

// Get color for event type
function getEventColor(eventType) {
  const colorMap = {
    member_ban: auditLogSettings.eventColors?.ban || '#E74C3C',
    member_unban: auditLogSettings.eventColors?.ban || '#E74C3C',
    member_timeout: auditLogSettings.eventColors?.timeout || '#E67E22',
    member_mute: auditLogSettings.eventColors?.mute || '#F39C12',
    member_join: auditLogSettings.eventColors?.join || '#2ECC71',
    member_leave: auditLogSettings.eventColors?.leave || '#95A5A6',
    member_boost: auditLogSettings.eventColors?.boost || '#F47FFF',
    message_edit: auditLogSettings.eventColors?.edit || '#3498DB',
    message_delete: auditLogSettings.eventColors?.delete || '#E74C3C',
    role_change: auditLogSettings.eventColors?.roleChange || '#9B59B6',
    name_change: auditLogSettings.eventColors?.nameChange || '#1ABC9C',
    server_update: auditLogSettings.eventColors?.serverUpdate || '#7289DA'
  };
  return colorMap[eventType] || '#7289DA';
}

let botTimezone = state.botTimezone || defaultState.botTimezone || 'America/Toronto';

function saveState() {
  state.isLive = isLive;
  state.lastStreamId = lastStreamId;
  state.announcementMessageId = announcementMessageId;
  state.stats = stats;
  state.history = history;
  state.schedule = schedule;
  state.streamMetadata = streamMetadata;
  state.engagementSettings = engagementSettings;
  state.suggestions = suggestions;
  state.warnings = warnings;
  state.startTime = startTime;
  state.botTimezone = botTimezone;
  state.notificationHistory = notificationHistory;
  state.customCommands = customCommands;
  state.activityHeatmap = activityHeatmap;
  state.followerHistory = followerHistory;
  state.subHistory = subHistory;
  state.alertCooldowns = alertCooldowns;
  state.lastResetDate = lastResetDate;
  state.dashboardSettings = {
    ...dashboardSettings,
    welcomeSettings: welcomeSettings,
    auditLogSettings: auditLogSettings
  };
  state.leveling = leveling;
  state.levelingConfig = levelingConfig;
  state.prestige = prestige;
  state.weeklyLeveling = weeklyLeveling;
  state.prestigeHistory = prestigeHistory;
  state.lastWeeklyReset = lastWeeklyReset;
  state.currentStreamViewerData = currentStreamViewerData;
  state.currentStreamGameTimeline = currentStreamGameTimeline;
  state.twitchTokens = twitchTokens;
  state.viewerGraphHistory = viewerGraphHistory;
  state.giveaways = giveaways;
  state.polls = polls;
  state.reminders = reminders;
  state.notificationFilters = notificationFilters;
  state.commandUsage = commandUsage;
  state.config = config;
  state.rpgEvents = rpgEvents;
  state.streamGoals = streamGoals;

  // Cap viewerGraphHistory to last 30 streams to prevent unbounded growth
  if (state.viewerGraphHistory && state.viewerGraphHistory.length > 30) {
    state.viewerGraphHistory = state.viewerGraphHistory.slice(-30);
    viewerGraphHistory = state.viewerGraphHistory;
  }
  // Cap history to last 100 entries
  if (state.history && state.history.length > 100) {
    state.history = state.history.slice(-100);
    history = state.history;
  }
  // Prune activityHeatmap older than 90 days
  const heatmapCutoff = Date.now() - 90 * 24 * 60 * 60 * 1000;
  if (state.activityHeatmap) {
    for (const key of Object.keys(state.activityHeatmap)) {
      const dateStr = key.split('_')[0];
      if (new Date(dateStr).getTime() < heatmapCutoff) delete state.activityHeatmap[key];
    }
  }
  // Cap notificationHistory
  if (state.notificationHistory && state.notificationHistory.length > 200) {
    state.notificationHistory = state.notificationHistory.slice(-200);
    notificationHistory = state.notificationHistory;
  }

  // Invalidate analytics cache on state change
  invalidateAnalyticsCache();

  try {
    fs.writeFileSync(STATE_PATH, JSON.stringify(state, null, 2));
  } catch {}
}

function saveConfig() {
  saveState();
}

// ========== RPG EVENT SYSTEM ==========
function checkRPGMilestoneEvents(currentViewers) {
  if (!rpgEvents || !rpgEvents.milestoneEvents) return;
  const milestones = rpgEvents.milestoneEvents.filter(m => m.enabled);
  for (const milestone of milestones) {
    // Skip if already triggered this stream
    if (rpgEvents.triggeredThisStream[milestone.id]) continue;
    // Check if viewer count meets threshold
    if (currentViewers >= milestone.viewerThreshold) {
      triggerRPGEvent(milestone, currentViewers);
    }
  }
}

function triggerRPGEvent(milestone, viewerCount) {
  const now = Date.now();
  const durationMs = (milestone.duration || 30) * 60 * 1000;
  const activeEvent = {
    id: milestone.id,
    name: milestone.name,
    type: milestone.type,
    emoji: milestone.emoji || 'ðŸŽ®',
    description: milestone.description || '',
    duration: milestone.duration || 30,
    startedAt: now,
    endsAt: now + durationMs,
    viewerCount: viewerCount,
    multiplier: milestone.multiplier || 1,
    goldAmount: milestone.goldAmount || 0,
    bossName: milestone.bossName || '',
    dungeonId: milestone.dungeonId || ''
  };
  rpgEvents.activeEvents.push(activeEvent);
  rpgEvents.triggeredThisStream[milestone.id] = true;
  rpgEvents.eventHistory.push({
    ...activeEvent,
    triggeredAt: now,
    completed: false
  });
  // Cap event history to 100
  if (rpgEvents.eventHistory.length > 100) {
    rpgEvents.eventHistory = rpgEvents.eventHistory.slice(-100);
  }
  debouncedSaveState();
  addLog('info', `RPG Event triggered: ${milestone.emoji} ${milestone.name} (${viewerCount} viewers)`);
  // Send Discord notification
  sendEmbedNotification(
    `${milestone.emoji} **RPG Event: ${milestone.name}!**`,
    `${milestone.description}\n\nðŸŽ¯ Triggered at **${viewerCount}** viewers\nâ±ï¸ Duration: **${milestone.duration}** minutes`,
    milestone.type === 'xp_boost' ? 0x5b5bff : milestone.type === 'gold_rain' ? 0xFFD700 : milestone.type === 'loot_boost' ? 0x4caf50 : milestone.type === 'boss_spawn' ? 0xe91e63 : 0x9c27b0
  ).catch(() => {});
}

function expireRPGEvents() {
  if (!rpgEvents || !rpgEvents.activeEvents) return;
  const now = Date.now();
  const expired = rpgEvents.activeEvents.filter(e => e.endsAt && e.endsAt <= now);
  if (expired.length > 0) {
    rpgEvents.activeEvents = rpgEvents.activeEvents.filter(e => !e.endsAt || e.endsAt > now);
    // Mark completed in history
    for (const exp of expired) {
      const histEntry = rpgEvents.eventHistory.find(h => h.id === exp.id && h.startedAt === exp.startedAt);
      if (histEntry) histEntry.completed = true;
      addLog('info', `RPG Event expired: ${exp.emoji} ${exp.name}`);
      sendEmbedNotification(
        `â±ï¸ **RPG Event Ended: ${exp.name}**`,
        `The ${exp.emoji} ${exp.name} event has ended!`,
        0x666666
      ).catch(() => {});
    }
    debouncedSaveState();
  }
}
// ========== END RPG EVENT SYSTEM ==========

// Get current time in bot's timezone
function nowQuebec() {
  const utcNow = new Date();
  const tzString = utcNow.toLocaleString('en-US', { timeZone: botTimezone });
  return new Date(tzString);
}

// Safer bot-timezone date (UTC date representing bot wall-clock time)
function getNowInBotTimezone() {
  const formatter = new Intl.DateTimeFormat('en-US', {
    timeZone: botTimezone,
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  });
  const parts = formatter.formatToParts(new Date());
  const map = {};
  parts.forEach(p => {
    if (p.type !== 'literal') map[p.type] = p.value;
  });
  return new Date(Date.UTC(
    Number(map.year),
    Number(map.month) - 1,
    Number(map.day),
    Number(map.hour),
    Number(map.minute),
    Number(map.second)
  ));
}

function getTimeZoneParts(date, timeZone) {
  const formatter = new Intl.DateTimeFormat('en-US', {
    timeZone,
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: false
  });
  const parts = formatter.formatToParts(date);
  const map = {};
  parts.forEach(p => {
    if (p.type !== 'literal') map[p.type] = p.value;
  });
  return {
    year: Number(map.year),
    month: Number(map.month),
    day: Number(map.day),
    hour: Number(map.hour),
    minute: Number(map.minute),
    second: Number(map.second)
  };
}

function zonedTimeToUtcMillis(parts, timeZone) {
  const utcGuess = Date.UTC(
    parts.year,
    parts.month - 1,
    parts.day,
    parts.hour,
    parts.minute,
    parts.second || 0
  );
  const tzParts = getTimeZoneParts(new Date(utcGuess), timeZone);
  const tzAsUtc = Date.UTC(
    tzParts.year,
    tzParts.month - 1,
    tzParts.day,
    tzParts.hour,
    tzParts.minute,
    tzParts.second || 0
  );
  const offsetMs = tzAsUtc - utcGuess;
  return utcGuess - offsetMs;
}

function getNextOccurrenceUtcMs(timeZone, targetDayIndex, hour, minute, now = Date.now()) {
  const nowParts = getTimeZoneParts(new Date(now), timeZone);
  const localNow = new Date(Date.UTC(
    nowParts.year,
    nowParts.month - 1,
    nowParts.day,
    nowParts.hour,
    nowParts.minute,
    nowParts.second
  ));
  const localDayIndex = localNow.getUTCDay();

  let diff = targetDayIndex - localDayIndex;
  if (diff < 0) diff += 7;

  const localCandidate = new Date(localNow.getTime());
  localCandidate.setUTCHours(hour, minute, 0, 0);

  if (diff === 0 && localCandidate.getTime() <= localNow.getTime()) diff = 7;
  localCandidate.setUTCDate(localCandidate.getUTCDate() + diff);

  return zonedTimeToUtcMillis({
    year: localCandidate.getUTCFullYear(),
    month: localCandidate.getUTCMonth() + 1,
    day: localCandidate.getUTCDate(),
    hour,
    minute,
    second: 0
  }, timeZone);
}

// Cache for user names (populated on-demand)
let userNameCache = {};

async function fetchUserName(userId) {
  if (userNameCache[userId]) {
    return userNameCache[userId];
  }
  try {
    const user = await client.users.fetch(userId);
    userNameCache[userId] = user.username;
    return user.username;
  } catch (err) {
    userNameCache[userId] = `Unknown (${userId})`;
    return userNameCache[userId];
  }
}

function getUserNameSync(userId) {
  return userNameCache[userId] || userId;
}

// XP requirement helper (cumulative XP to reach a level)
function getXpForLevel(level) {
  if (!level || level <= 0) return 0;
  const cfg = levelingConfig || {};
  const mode = cfg.xpMode === 'custom' ? 'custom' : 'increment';
  const base = Number(cfg.baseXp) || 100;
  const inc = Number(cfg.xpIncrement) || 50;

  if (mode === 'custom' && cfg.customXpPerLevel) {
    let total = 0;
    for (let i = 1; i <= level; i++) {
      const raw = Number(cfg.customXpPerLevel[i]);
      const perLevel = Number.isFinite(raw) ? raw : 0;
      total += Math.max(0, perLevel);
    }
    return total;
  }

  return Math.floor(base * level + inc * (level * (level - 1) / 2));
}

// NEW: User prestige tracking
let prestige = state.prestige ?? {};

// Configuration object for dashboard settings
let config = {
  ROLE_ID: null,
  notificationRoles: {},
  notificationEnabled: {},
  notificationPing: {},
  notificationChannels: {},
  CUSTOM_CHANNEL_ID: null,
  ...(state.config || {})
};

if (!config.commandCooldowns) config.commandCooldowns = {};
if (!config.commandPinned) config.commandPinned = {};
if (!config.commandDisabled) config.commandDisabled = {};

// NEW: Weekly leveling reset
let weeklyLeveling = state.weeklyLeveling ?? {};
let lastWeeklyReset = state.lastWeeklyReset ?? Date.now();

// NEW: Viewer tracking data (current stream)
let currentStreamViewerData = state.currentStreamViewerData ?? [];
// NEW: Game timeline tracking data (current stream)
let currentStreamGameTimeline = state.currentStreamGameTimeline ?? [];
// NEW: Historical viewer data for all streams
let viewerGraphHistory = state.viewerGraphHistory ?? [];

// NEW: Giveaways
let giveaways = state.giveaways ?? [];

// NEW: Command usage tracking
let commandUsage = state.commandUsage ?? {};

// NEW: Polls
let polls = state.polls ?? [];

// NEW: Reminders
let reminders = state.reminders ?? [];

// NEW: Notification Filters
let notificationFilters = state.notificationFilters ?? [];

// Suggestion cooldown tracker
let suggestionCooldowns = {};

// Backfill older history entries (fixes existing Stats page issues after upgrades)
(function reconcileHistoryWithViewerGraphs() {
  try {
    if (!Array.isArray(history) || !Array.isArray(viewerGraphHistory) || viewerGraphHistory.length === 0) return;

    for (const h of history) {
      if (!h) continue;
      const match = viewerGraphHistory.find(g =>
        (h.streamId && g.streamId && h.streamId === g.streamId) ||
        (h.startedAt && g.startedAt && h.startedAt === g.startedAt)
      );
      if (!match) continue;

      if (!h.streamId && match.streamId) h.streamId = match.streamId;
      if (h.peakViewers == null && match.peakViewers != null) h.peakViewers = match.peakViewers;
      if (h.avgViewers == null && match.avgViewers != null) h.avgViewers = match.avgViewers;
      if (!h.endedAt && match.endedAt) h.endedAt = match.endedAt;

      if (h.duration == null && h.startedAt && (h.endedAt || match.endedAt)) {
        const startMs = new Date(h.startedAt).getTime();
        const endMs = new Date(h.endedAt || match.endedAt).getTime();
        if (!isNaN(startMs) && !isNaN(endMs)) {
          h.duration = Math.max(0, Math.floor((endMs - startMs) / 1000));
        }
      }
    }

    recomputeStreamStatsFromHistory();
    saveState();
  } catch (e) {
    console.log('[STATS] reconcileHistoryWithViewerGraphs failed:', e?.message || e);
  }
})();

// Clean up live timeline: remove placeholder entries
(function cleanupLiveTimeline() {
  try {
    if (!Array.isArray(currentStreamGameTimeline)) return;
    
    // Filter out placeholder games
    currentStreamGameTimeline = currentStreamGameTimeline.filter(seg => {
      const game = (seg.game || '').toString().trim();
      return game && game !== '\u2014' && game !== '\u2013' && game !== '\u2022';
    });
    
    if (isLive && currentStreamGameTimeline.length === 0 && history.length > 0) {
      // If timeline is now empty but we're live, initialize with the current history game
      const lastStream = history[history.length - 1];
      if (lastStream && lastStream.game && lastStream.game !== '\u2014') {
        currentStreamGameTimeline = [{
          streamId: lastStreamId || lastStream.streamId,
          game: lastStream.game,
          startMs: Date.now(),
          endMs: null
        }];
      }
    }
    
    saveState();
  } catch (e) {
    console.log('[TIMELINE] cleanupLiveTimeline failed:', e?.message || e);
  }
})();

// Fix custom command names (strip leading ! if present)
(function fixCustomCommandNames() {
  try {
    let changed = false;
    customCommands.forEach(cmd => {
      if (cmd.name && cmd.name.startsWith('!')) {
        cmd.name = cmd.name.slice(1).toLowerCase();
        changed = true;
      }
    });
    if (changed) {
      saveState();
      console.log('[CUSTOMCMDS] Fixed command names by stripping ! prefix');
    }
  } catch (e) {
    console.log('[CUSTOMCMDS] fixCustomCommandNames failed:', e?.message || e);
  }
})();

// NEW: Dashboard settings
// (already initialized above)

// Track when stream was first detected as offline
let offlineDetectedAt = null;
// Track last time we polled Twitch
let lastStreamCheckAt = null;

function normalizeSchedule() {
  if (!schedule) schedule = {};
  if (!schedule.weekly) schedule.weekly = {};
  if (!schedule.alertsSent) {
    schedule.alertsSent = {
      oneHour: false,
      tenMin: false
    };
  }

  if (schedule.streamDelayed === undefined) schedule.streamDelayed = false;
  if (schedule.noStreamToday === undefined) schedule.noStreamToday = false;
}

// âœ… NOW it is safe
normalizeSchedule();

// runtime-only flags
let suppressNextAnnounce = false;


// ======================
// STREAM CHECK LOCK
// ======================
let isCheckingStream = false; // mutex to prevent overlapping checks



// ALWAYS exists so dashboard + discord donâ€™t crash
let streamInfo = {
  title: 'â€”',
  game: 'â€”',
  viewers: 0,
  thumbnail: null,
  startedAt: null
};

// FIX: Initialize stream info from history when isLive is true
if (isLive && history.length > 0 && !streamInfo.startedAt) {
  const lastStream = history[history.length - 1];
  if (lastStream && lastStream.startedAt) {
    streamInfo = {
      title: lastStream.title || 'â€”',
      game: lastStream.game || lastStream.gameName || 'â€”',
      viewers: lastStream.viewers || 0,
      thumbnail: null,
      startedAt: lastStream.startedAt
    };
  }
}

// Twitch API token - prefer state.json (persisted refresh) over env var
let TWITCH_ACCESS_TOKEN = twitchTokens.access_token || process.env.TWITCH_ACCESS_TOKEN || '';
if (twitchTokens.access_token && twitchTokens.access_token !== process.env.TWITCH_ACCESS_TOKEN) {
  console.log('[Twitch] Using persisted token from state.json (may be newer than env var)');
}

// Twitch Broadcaster ID - will be loaded from .env or fetched from API
let BROADCASTER_ID = process.env.BROADCASTER_ID || null;

/* ======================
   EXPRESS & SOCKET.IO
====================== */
const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Setup file uploads
const uploadsDir = UPLOADS_PERSIST_DIR;
if (!fs.existsSync(uploadsDir)) {
  fs.mkdirSync(uploadsDir, { recursive: true });
}
app.use('/uploads', express.static(uploadsDir));

// Serve static files from public folder
const publicDir = path.join(__dirname, 'public');
app.use(express.static(publicDir));

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadsDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  }
});
const upload = multer({ 
  storage: storage,
  limits: { fileSize: 8 * 1024 * 1024 }, // 8MB limit
  fileFilter: function (req, file, cb) {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed'));
    }
  }
});

const httpServer = createServer(app);
const io = new Server(httpServer);

io.on('connection', socket => {
  console.log('Socket connected');
  socket.emit('streamUpdate', streamInfo); // send current info on connect
});

/* ======================
   DASHBOARD AUTH - Multi-Account Tiered System
   Tiers: owner > admin > moderator > viewer
====================== */
const DASHBOARD_PASSWORD = process.env.DASHBOARD_PASSWORD || 'changeme123';
const ACCOUNTS_PATH = path.join(DATA_DIR, 'accounts.json');

// Tier hierarchy & permissions
const TIER_LEVELS = { owner: 4, admin: 3, moderator: 2, viewer: 1 };
const TIER_COLORS = { owner: '#ff4444', admin: '#9146ff', moderator: '#4caf50', viewer: '#8b8fa3' };
const TIER_LABELS = { owner: 'Owner', admin: 'Admin', moderator: 'Moderator', viewer: 'Viewer' };
const TIER_ACCESS = {
  owner: ['core','community','analytics','rpg','config','accounts','tools'],
  admin: ['core','community','analytics','rpg','config','tools'],
  moderator: ['core','community','analytics','tools'],
  viewer: ['community','analytics']
};
const TIER_CAN_EDIT = { owner: true, admin: true, moderator: true, viewer: false };

function hashPassword(password) {
  const salt = crypto.randomBytes(16).toString('hex');
  const hash = crypto.scryptSync(password, salt, 64).toString('hex');
  return salt + ':' + hash;
}

function verifyPassword(password, stored) {
  const [salt, hash] = stored.split(':');
  if (!salt || !hash) return password === stored; // fallback for plain text migration
  const test = crypto.scryptSync(password, salt, 64).toString('hex');
  return test === hash;
}

function loadAccounts() {
  try {
    const raw = fs.readFileSync(ACCOUNTS_PATH, 'utf8');
    const data = JSON.parse(raw);
    return data.accounts || [];
  } catch { return []; }
}

function saveAccounts(accounts) {
  fs.writeFileSync(ACCOUNTS_PATH, JSON.stringify({ accounts, initialized: true }, null, 2));
}

// Auto-create owner account from DASHBOARD_PASSWORD if no accounts exist
(function initAccounts() {
  const accounts = loadAccounts();
  if (accounts.length === 0) {
    accounts.push({
      id: crypto.randomUUID(),
      username: 'admin',
      password: hashPassword(DASHBOARD_PASSWORD),
      tier: 'owner',
      createdAt: Date.now(),
      lastLogin: null
    });
    saveAccounts(accounts);
    console.log('[Dashboard] Created default owner account: admin / (your DASHBOARD_PASSWORD)');
  }
})();

// Session management
const activeSessionTokens = new Map(); // token -> { loginTime, guildId, userId, username, tier }

function generateSessionToken() {
  return crypto.randomBytes(32).toString('hex');
}

function getSessionFromCookie(req) {
  const token = req.headers.cookie?.match(/session=([^;]+)/)?.[1];
  if (!token) return null;
  return activeSessionTokens.get(token) || null;
}

function getSelectedGuildId(req) {
  const session = getSessionFromCookie(req);
  return session?.guildId || null;
}

function getUserTier(req) {
  const session = getSessionFromCookie(req);
  return session?.tier || 'viewer';
}

function getUserName(req) {
  const session = getSessionFromCookie(req);
  return session?.username || 'Unknown';
}

function requireAuth(req, res, next) {
  const session = getSessionFromCookie(req);
  if (!session) {
    if (req.path.startsWith('/api/') || req.path.startsWith('/upload/')) return res.status(401).json({ success: false, error: 'Not authenticated' });
    return res.redirect('/login');
  }
  if (!session.guildId) {
    if (req.path.startsWith('/api/') || req.path.startsWith('/upload/')) return res.status(401).json({ success: false, error: 'No server selected' });
    return res.redirect('/select-server');
  }
  req.guildId = session.guildId;
  req.userTier = session.tier;
  req.userName = session.username;
  return next();
}

function requireAuthOnly(req, res, next) {
  const session = getSessionFromCookie(req);
  if (!session) {
    if (req.path.startsWith('/api/') || req.path.startsWith('/upload/')) return res.status(401).json({ success: false, error: 'Not authenticated' });
    return res.redirect('/login');
  }
  req.userTier = session.tier;
  req.userName = session.username;
  return next();
}

function requireTier(minTier) {
  return (req, res, next) => {
    const session = getSessionFromCookie(req);
    if (!session) {
      if (req.path.startsWith('/api/') || req.path.startsWith('/upload/')) return res.status(401).json({ success: false, error: 'Not authenticated' });
      return res.redirect('/login');
    }
    const userLevel = TIER_LEVELS[session.tier] || 0;
    const requiredLevel = TIER_LEVELS[minTier] || 0;
    if (userLevel < requiredLevel) {
      if (req.path.startsWith('/api/') || req.path.startsWith('/upload/')) return res.status(403).json({ success: false, error: 'Access denied. Requires ' + TIER_LABELS[minTier] + ' or higher.' });
      return res.status(403).send('<div style="text-align:center;padding:60px;font-family:Segoe UI;color:#ff6b6b;background:#0e0e10;min-height:100vh;display:flex;align-items:center;justify-content:center"><div><h1>ðŸ”’ Access Denied</h1><p style="color:#8b8fa3">You need <b>' + TIER_LABELS[minTier] + '</b> access or higher.</p><a href="/" style="color:#9146ff">â† Back to Dashboard</a></div></div>');
    }
    req.guildId = session.guildId;
    req.userTier = session.tier;
    req.userName = session.username;
    return next();
  };
}

function canAccessCategory(tier, category) {
  return (TIER_ACCESS[tier] || []).includes(category);
}

// Login page
app.get('/login', (req, res) => {
  const session = getSessionFromCookie(req);
  if (session) {
    if (!session.guildId) return res.redirect('/select-server');
    return res.redirect(session.tier === 'viewer' ? '/pets' : '/');
  }
  const error = req.query.error === '1' ? '<div style="color:#ff6b6b;background:#ff6b6b15;border:1px solid #ff6b6b44;padding:10px 16px;border-radius:6px;margin-bottom:16px;font-size:13px">Invalid username or password.</div>' : '';
  const created = req.query.created === '1' ? '<div style="color:#4caf50;background:#4caf5015;border:1px solid #4caf5044;padding:10px 16px;border-radius:6px;margin-bottom:16px;font-size:13px">Account created! Please sign in.</div>' : '';
  res.send(`<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Dashboard Login</title>
  <style>
    * { box-sizing: border-box; }
    body { background: #0e0e10; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; }
    .login-box { background: #1f1f23; padding: 40px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); width: 380px; border: 1px solid #2a2f3a; }
    .login-header { text-align: center; margin-bottom: 28px; }
    .login-header h2 { margin: 0 0 6px 0; color: #fff; font-size: 22px; }
    .login-header p { margin: 0; color: #8b8fa3; font-size: 13px; }
    .login-icon { font-size: 48px; margin-bottom: 12px; display: block; }
    label { display: block; color: #8b8fa3; font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 6px; margin-top: 14px; }
    input { width: 100%; padding: 12px 14px; border: 1px solid #3a3a42; border-radius: 6px; background: #2a2f3a; color: #e0e0e0; font-size: 14px; transition: border-color 0.2s; outline: none; box-sizing: border-box; }
    input:focus { border-color: #9146ff; box-shadow: 0 0 0 3px rgba(145,70,255,0.15); }
    button { width: 100%; padding: 12px; background: linear-gradient(135deg, #9146ff, #7b3ad9); border: none; border-radius: 6px; color: white; font-weight: 600; cursor: pointer; margin-top: 20px; font-size: 14px; transition: all 0.2s; }
    button:hover { background: linear-gradient(135deg, #a55aff, #8b44e9); transform: translateY(-1px); box-shadow: 0 4px 12px rgba(145,70,255,0.3); }
  </style>
</head>
<body>
  <div class="login-box">
    <div class="login-header">
      <span class="login-icon">ðŸ›¡ï¸</span>
      <h2>Dashboard Login</h2>
      <p>Sign in with your account</p>
    </div>
    ${error}${created}
    <form method="POST" action="/auth">
      <label for="username">Username</label>
      <input type="text" id="username" name="username" placeholder="Enter username" required autofocus autocomplete="username">
      <label for="password">Password</label>
      <input type="password" id="password" name="password" placeholder="Enter password" required autocomplete="current-password">
      <button type="submit">Sign In</button>
    </form>
  </div>
</body>
</html>`);
});

// Auth handler
app.post('/auth', (req, res) => {
  const { username, password } = req.body;
  if (!username || !password) return res.redirect('/login?error=1');
  
  const accounts = loadAccounts();
  const account = accounts.find(a => a.username.toLowerCase() === username.toLowerCase().trim());
  
  if (!account || !verifyPassword(password, account.password)) {
    return res.redirect('/login?error=1');
  }
  
  // Update last login
  account.lastLogin = Date.now();
  saveAccounts(accounts);
  
  const token = generateSessionToken();
  activeSessionTokens.set(token, { 
    loginTime: Date.now(), 
    guildId: null, 
    userId: account.id, 
    username: account.username, 
    tier: account.tier 
  });
  
  // Clean old sessions (older than 24h)
  const cutoff = Date.now() - 86400000;
  for (const [t, s] of activeSessionTokens) { if (s.loginTime < cutoff) activeSessionTokens.delete(t); }
  
  res.setHeader('Set-Cookie', `session=${token}; Path=/; HttpOnly; Max-Age=86400; SameSite=Lax`);
  res.redirect('/select-server');
});

// Server selection
app.get('/select-server', requireAuthOnly, async (req, res) => {
  // If bot isn't ready yet, show a loading page that auto-retries
  if (!client.isReady()) {
    return res.send(`<!DOCTYPE html>
<html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Loading...</title>
<style>*{box-sizing:border-box}body{background:#0e0e10;color:#e0e0e0;font-family:'Segoe UI',Tahoma,sans-serif;display:flex;justify-content:center;align-items:center;min-height:100vh;margin:0}
.loader{text-align:center}.spinner{width:48px;height:48px;border:4px solid #2a2f3a;border-top-color:#9146ff;border-radius:50%;animation:spin 1s linear infinite;margin:0 auto 20px}
@keyframes spin{to{transform:rotate(360deg)}}h2{margin:0 0 8px;color:#fff}p{color:#8b8fa3;font-size:13px}</style>
</head><body><div class="loader"><div class="spinner"></div><h2>Connecting to Discord...</h2><p>Please wait, the bot is starting up.</p></div>
<script>setTimeout(()=>location.reload(),3000);</script></body></html>`);
  }

  let guilds = client.guilds.cache;

  try {
    // Fetch guilds from API to refresh cache, then use the cache
    // (cache has full Guild objects with iconURL, memberCount, etc.)
    await client.guilds.fetch();
    guilds = client.guilds.cache;
  } catch (err) {
    addLog('warn', `Failed to refresh guild list for dashboard: ${err.message}`);
  }

  const guildCards = Array.from(guilds.values()).map(g => {
    const memberCount = g.memberCount || g.members?.cache?.size || '?';
    let icon = null;
    try { icon = typeof g.iconURL === 'function' ? g.iconURL({ size: 128, dynamic: true }) : null; } catch(e) {}
    const initials = (g.name || 'Server').split(' ').map(w => w[0]).join('').slice(0,3).toUpperCase();
    return ` 
      <button class="server-card" onclick="selectServer('${g.id}')">
        <div class="server-icon">${icon ? '<img src="' + icon + '" alt="">' : '<span>' + initials + '</span>'}</div>
        <div class="server-info">
          <div class="server-name">${g.name}</div>
          <div class="server-meta">${memberCount} members</div>
        </div>
        <div class="server-arrow">â†’</div>
      </button>`;
  }).join('');

  res.send(`<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Select Server</title>
  <style>
    * { box-sizing: border-box; }
    body { background: #0e0e10; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; padding: 20px; }
    .select-box { background: #1f1f23; padding: 36px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.5); width: 460px; max-width: 100%; border: 1px solid #2a2f3a; }
    .select-header { text-align: center; margin-bottom: 28px; }
    .select-header h2 { margin: 0 0 6px 0; color: #fff; font-size: 22px; }
    .select-header p { margin: 0; color: #8b8fa3; font-size: 13px; }
    .select-icon { font-size: 48px; margin-bottom: 12px; display: block; }
    .user-badge { text-align: center; margin-bottom: 20px; padding: 8px 16px; background: #2a2f3a; border-radius: 6px; font-size: 13px; }
    .user-badge .tier { font-weight: 600; text-transform: uppercase; font-size: 11px; letter-spacing: 0.5px; }
    .server-list { display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto; padding-right: 4px; }
    .server-list::-webkit-scrollbar { width: 6px; }
    .server-list::-webkit-scrollbar-thumb { background: #3a3a42; border-radius: 3px; }
    .server-list::-webkit-scrollbar-track { background: transparent; }
    .server-card { display: flex; align-items: center; gap: 14px; width: 100%; padding: 14px 16px; background: #2a2f3a; border: 1px solid #3a3a42; border-radius: 8px; cursor: pointer; transition: all 0.2s; color: #e0e0e0; font-family: inherit; font-size: 14px; text-align: left; }
    .server-card:hover { background: #353a48; border-color: #9146ff; transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    .server-icon { width: 48px; height: 48px; border-radius: 50%; background: #1f1f23; display: flex; align-items: center; justify-content: center; overflow: hidden; flex-shrink: 0; }
    .server-icon img { width: 100%; height: 100%; object-fit: cover; }
    .server-icon span { font-size: 14px; font-weight: 700; color: #9146ff; }
    .server-info { flex: 1; min-width: 0; }
    .server-name { font-weight: 600; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .server-meta { font-size: 12px; color: #8b8fa3; margin-top: 2px; }
    .server-arrow { color: #8b8fa3; font-size: 18px; flex-shrink: 0; transition: transform 0.2s; }
    .server-card:hover .server-arrow { transform: translateX(3px); color: #9146ff; }
    .logout-link { display: block; text-align: center; margin-top: 20px; color: #8b8fa3; font-size: 13px; text-decoration: none; }
    .logout-link:hover { color: #ff6b6b; }
    .no-servers { text-align: center; padding: 40px 20px; color: #72767d; }
  </style>
</head>
<body>
  <div class="select-box">
    <div class="select-header">
      <span class="select-icon">ðŸ–¥ï¸</span>
      <h2>Select a Server</h2>
      <p>Choose which server you want to manage</p>
    </div>
    <div class="user-badge">
      Signed in as <b>${req.userName}</b> 
      <span class="tier" style="color:${TIER_COLORS[req.userTier] || '#8b8fa3'}">(${TIER_LABELS[req.userTier] || req.userTier})</span>
    </div>
    <div class="server-list">
      ${guildCards || '<div class="no-servers">No servers found. Retrying...</div>'}
    </div>
    <a href="/logout" class="logout-link">â† Sign out</a>
  </div>
  <script>
    function selectServer(guildId) {
      fetch('/api/select-server', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ guildId }) })
        .then(r => r.json())
        .then(d => { if (d.success) window.location.href = '/'; else alert(d.error || 'Error'); });
    }
    ${guildCards ? '' : 'setTimeout(()=>location.reload(),3000);'}
  </script>
</body>
</html>`);
});

app.post('/api/select-server', requireAuthOnly, async (req, res) => {
  const { guildId } = req.body;
  let guild = client.guilds.cache.get(guildId);
  if (!guild && client.isReady()) {
    guild = await client.guilds.fetch(guildId).catch(() => null);
  }
  if (!guild) return res.json({ success: false, error: 'Server not found' });
  const token = req.headers.cookie?.match(/session=([^;]+)/)?.[1];
  if (!token || !activeSessionTokens.has(token)) return res.json({ success: false, error: 'Session expired' });
  const session = activeSessionTokens.get(token);
  session.guildId = guildId;
  res.json({ success: true });
});

app.get('/logout', (req, res) => {
  const token = req.headers.cookie?.match(/session=([^;]+)/)?.[1];
  if (token) activeSessionTokens.delete(token);
  res.setHeader('Set-Cookie', 'session=; Path=/; HttpOnly; Max-Age=0');
  res.redirect('/login');
});

app.get('/switch-server', requireAuthOnly, (req, res) => {
  const token = req.headers.cookie?.match(/session=([^;]+)/)?.[1];
  if (token && activeSessionTokens.has(token)) {
    activeSessionTokens.get(token).guildId = null;
  }
  res.redirect('/select-server');
});

// === Account Management API (Owner-only) ===
app.get('/api/accounts', requireAuth, requireTier('owner'), (req, res) => {
  const accounts = loadAccounts().map(a => ({
    id: a.id,
    username: a.username,
    tier: a.tier,
    createdAt: a.createdAt,
    lastLogin: a.lastLogin
  }));
  res.json({ success: true, accounts });
});

app.post('/api/accounts/create', requireAuth, requireTier('owner'), (req, res) => {
  const { username, password, tier } = req.body;
  if (!username || !password || !tier) return res.json({ success: false, error: 'Missing fields' });
  if (!['owner','admin','moderator','viewer'].includes(tier)) return res.json({ success: false, error: 'Invalid tier' });
  if (username.length < 3 || username.length > 32) return res.json({ success: false, error: 'Username must be 3-32 characters' });
  if (password.length < 6) return res.json({ success: false, error: 'Password must be at least 6 characters' });
  if (!/^[a-zA-Z0-9_-]+$/.test(username)) return res.json({ success: false, error: 'Username can only contain letters, numbers, _ and -' });
  
  const accounts = loadAccounts();
  if (accounts.find(a => a.username.toLowerCase() === username.toLowerCase())) {
    return res.json({ success: false, error: 'Username already exists' });
  }
  
  accounts.push({
    id: crypto.randomUUID(),
    username: username.trim(),
    password: hashPassword(password),
    tier,
    createdAt: Date.now(),
    lastLogin: null
  });
  saveAccounts(accounts);
  res.json({ success: true });
});

app.post('/api/accounts/delete', requireAuth, requireTier('owner'), (req, res) => {
  const { id } = req.body;
  const session = getSessionFromCookie(req);
  const accounts = loadAccounts();
  const target = accounts.find(a => a.id === id);
  if (!target) return res.json({ success: false, error: 'Account not found' });
  if (target.id === session.userId) return res.json({ success: false, error: 'Cannot delete your own account' });
  
  const remaining = accounts.filter(a => a.id !== id);
  saveAccounts(remaining);
  
  // Invalidate their sessions
  for (const [t, s] of activeSessionTokens) {
    if (s.userId === id) activeSessionTokens.delete(t);
  }
  res.json({ success: true });
});

app.post('/api/accounts/update-tier', requireAuth, requireTier('owner'), (req, res) => {
  const { id, tier } = req.body;
  if (!['owner','admin','moderator','viewer'].includes(tier)) return res.json({ success: false, error: 'Invalid tier' });
  const session = getSessionFromCookie(req);
  if (id === session.userId) return res.json({ success: false, error: 'Cannot change your own tier' });
  
  const accounts = loadAccounts();
  const account = accounts.find(a => a.id === id);
  if (!account) return res.json({ success: false, error: 'Account not found' });
  
  account.tier = tier;
  saveAccounts(accounts);
  
  // Update active sessions for this user
  for (const [, s] of activeSessionTokens) {
    if (s.userId === id) s.tier = tier;
  }
  res.json({ success: true });
});

app.post('/api/accounts/reset-password', requireAuth, requireTier('owner'), (req, res) => {
  const { id, newPassword } = req.body;
  if (!newPassword || newPassword.length < 6) return res.json({ success: false, error: 'Password must be at least 6 characters' });
  
  const accounts = loadAccounts();
  const account = accounts.find(a => a.id === id);
  if (!account) return res.json({ success: false, error: 'Account not found' });
  
  account.password = hashPassword(newPassword);
  saveAccounts(accounts);
  res.json({ success: true });
});

app.post('/api/accounts/change-own-password', requireAuth, (req, res) => {
  const { currentPassword, newPassword } = req.body;
  if (!newPassword || newPassword.length < 6) return res.json({ success: false, error: 'New password must be at least 6 characters' });
  
  const session = getSessionFromCookie(req);
  const accounts = loadAccounts();
  const account = accounts.find(a => a.id === session.userId);
  if (!account) return res.json({ success: false, error: 'Account not found' });
  if (!verifyPassword(currentPassword, account.password)) return res.json({ success: false, error: 'Current password is incorrect' });
  
  account.password = hashPassword(newPassword);
  saveAccounts(accounts);
  res.json({ success: true });
});

// Global middleware: block viewers from POST/PUT/DELETE API calls (except password change)
app.use('/api', (req, res, next) => {
  if (req.method === 'GET' || req.path === '/select-server') return next();
  if (req.path === '/accounts/change-own-password') return next();
  const session = getSessionFromCookie(req);
  if (session && !TIER_CAN_EDIT[session.tier]) {
    return res.status(403).json({ success: false, error: 'Read-only access. Your account tier does not allow modifications.' });
  }
  return next();
});

/* ======================
   FEATURE DATA STORES
====================== */
const MEMBER_GROWTH_PATH = path.join(DATA_DIR, 'member-growth.json');
const CMD_USAGE_PATH = path.join(DATA_DIR, 'command-usage.json');
const DASH_AUDIT_PATH = path.join(DATA_DIR, 'dashboard-audit.json');
const SCHED_MSG_PATH = path.join(DATA_DIR, 'scheduled-messages.json');
const REACTION_ROLES_PATH = path.join(DATA_DIR, 'reaction-roles.json');
const TICKETS_PATH = path.join(DATA_DIR, 'tickets.json');
const STARBOARD_PATH = path.join(DATA_DIR, 'starboard.json');
const AUTOMOD_PATH = path.join(DATA_DIR, 'automod.json');
const API_KEYS_PATH = path.join(DATA_DIR, 'api-keys.json');
const WEBHOOKS_PATH = path.join(DATA_DIR, 'webhooks.json');
const MODERATION_PATH = path.join(DATA_DIR, 'moderation.json');
const PETS_PATH = path.join(DATA_DIR, 'pets.json');

function loadJSON(fp, def) { try { return JSON.parse(fs.readFileSync(fp,'utf8')); } catch { return def; } }
function saveJSON(fp, data) { fs.writeFileSync(fp, JSON.stringify(data, null, 2)); }

// Activity feed buffer (in-memory, last 200 events)
const activityFeed = [];
function pushActivity(type, data) {
  const evt = { type, ...data, ts: Date.now() };
  activityFeed.unshift(evt);
  if (activityFeed.length > 200) activityFeed.length = 200;
  io.emit('activity', evt);
}

// Dashboard audit log
function dashAudit(user, action, details) {
  const data = loadJSON(DASH_AUDIT_PATH, {entries:[]});
  data.entries.unshift({ user, action, details, ts: Date.now() });
  if (data.entries.length > 1000) data.entries.length = 1000;
  saveJSON(DASH_AUDIT_PATH, data);
  pushActivity('dash-audit', { user, action, details });
}

// Member growth tracking
function trackMemberGrowth(type) {
  const data = loadJSON(MEMBER_GROWTH_PATH, {daily:[],hourlyActivity:[]});
  const today = new Date().toISOString().slice(0,10);
  let day = data.daily.find(d => d.date === today);
  if (!day) { day = { date: today, joins: 0, leaves: 0 }; data.daily.push(day); }
  if (type === 'join') day.joins++;
  if (type === 'leave') day.leaves++;
  if (data.daily.length > 365) data.daily = data.daily.slice(-365);
  saveJSON(MEMBER_GROWTH_PATH, data);
}

// Command usage tracking
function trackCommand(name, userId) {
  const data = loadJSON(CMD_USAGE_PATH, {commands:{},hourly:[]});
  if (!data.commands[name]) data.commands[name] = { count: 0, users: {}, lastUsed: 0 };
  data.commands[name].count++;
  data.commands[name].lastUsed = Date.now();
  data.commands[name].users[userId] = (data.commands[name].users[userId]||0) + 1;
  const hour = new Date().toISOString().slice(0,13);
  let h = data.hourly.find(x => x.hour === hour);
  if (!h) { h = { hour, count: 0 }; data.hourly.push(h); }
  h.count++;
  if (data.hourly.length > 720) data.hourly = data.hourly.slice(-720);
  saveJSON(CMD_USAGE_PATH, data);
}

// Scheduled messages checker
const scheduledMsgIntervals = new Map();
function checkScheduledMessages() {
  const data = loadJSON(SCHED_MSG_PATH, {messages:[]});
  const now = Date.now();
  let changed = false;
  for (const msg of data.messages) {
    if (msg.sent || msg.sendAt > now) continue;
    const channel = client.channels?.cache?.get(msg.channelId);
    if (channel) {
      if (msg.embed) {
        channel.send({ embeds: [msg.embed] }).catch(() => {});
      } else {
        channel.send(msg.content || 'Scheduled message').catch(() => {});
      }
      msg.sent = true;
      changed = true;
      pushActivity('scheduled-msg', { content: (msg.content||'').slice(0,50), channelId: msg.channelId });
    }
  }
  if (changed) saveJSON(SCHED_MSG_PATH, data);
}
setInterval(checkScheduledMessages, 15000);

// Auto-mod message spam tracker
const spamTracker = new Map();

/* ======================
   FEATURE API ROUTES
====================== */

// --- Activity Feed API ---
app.get('/api/activity-feed', requireAuth, (req, res) => {
  res.json({ success: true, feed: activityFeed.slice(0, 100) });
});

// --- Dashboard Audit Log API ---
app.get('/api/dashboard-audit', requireAuth, requireTier('admin'), (req, res) => {
  const data = loadJSON(DASH_AUDIT_PATH, {entries:[]});
  res.json({ success: true, entries: data.entries.slice(0, 200) });
});

// --- Member Growth API ---
app.get('/api/member-growth', requireAuth, (req, res) => {
  const data = loadJSON(MEMBER_GROWTH_PATH, {daily:[]});
  res.json({ success: true, daily: data.daily.slice(-90) });
});

// --- Command Usage API ---
app.get('/api/command-usage', requireAuth, (req, res) => {
  const data = loadJSON(CMD_USAGE_PATH, {commands:{},hourly:[]});
  const sorted = Object.entries(data.commands).sort((a,b) => b[1].count - a[1].count);
  res.json({ success: true, commands: sorted.slice(0,50).map(([n,d])=>({name:n,count:d.count,lastUsed:d.lastUsed,uniqueUsers:Object.keys(d.users).length})), hourly: data.hourly.slice(-168) });
});

// --- Moderation API ---
app.get('/api/moderation', requireAuth, requireTier('moderator'), (req, res) => {
  const data = loadJSON(MODERATION_PATH, {warnings:[],cases:[]});
  res.json({ success: true, warnings: data.warnings.slice(0,200), cases: data.cases.slice(0,200) });
});

app.post('/api/moderation/warn', requireAuth, requireTier('moderator'), async (req, res) => {
  const { userId, reason } = req.body;
  if (!userId || !reason) return res.json({ success: false, error: 'Missing userId or reason' });
  const data = loadJSON(MODERATION_PATH, {warnings:[],cases:[]});
  const warn = { id: crypto.randomUUID(), odId: userId, reason, moderator: req.userName, ts: Date.now() };
  data.warnings.push(warn);
  data.cases.push({ type: 'warn', ...warn });
  saveJSON(MODERATION_PATH, data);
  dashAudit(req.userName, 'warn-user', 'Warned user ' + userId + ': ' + reason);
  pushActivity('moderation', { action: 'warn', userId, reason, moderator: req.userName });
  res.json({ success: true, warning: warn });
});

app.post('/api/moderation/timeout', requireAuth, requireTier('moderator'), async (req, res) => {
  const { userId, duration, reason, guildId } = req.body;
  if (!userId) return res.json({ success: false, error: 'Missing userId' });
  try {
    const guild = client.guilds.cache.get(guildId || req.guildId);
    const member = await guild?.members?.fetch(userId).catch(() => null);
    if (!member) return res.json({ success: false, error: 'Member not found' });
    await member.timeout((duration || 60) * 1000, reason || 'Dashboard timeout');
    const data = loadJSON(MODERATION_PATH, {warnings:[],cases:[]});
    data.cases.push({ type: 'timeout', id: crypto.randomUUID(), userId, duration: duration||60, reason: reason||'Dashboard timeout', moderator: req.userName, ts: Date.now() });
    saveJSON(MODERATION_PATH, data);
    dashAudit(req.userName, 'timeout-user', 'Timed out ' + userId + ' for ' + (duration||60) + 's');
    pushActivity('moderation', { action: 'timeout', userId, moderator: req.userName });
    res.json({ success: true });
  } catch(e) { res.json({ success: false, error: e.message }); }
});

app.post('/api/moderation/kick', requireAuth, requireTier('admin'), async (req, res) => {
  const { userId, reason, guildId } = req.body;
  if (!userId) return res.json({ success: false, error: 'Missing userId' });
  try {
    const guild = client.guilds.cache.get(guildId || req.guildId);
    const member = await guild?.members?.fetch(userId).catch(() => null);
    if (!member) return res.json({ success: false, error: 'Member not found' });
    await member.kick(reason || 'Dashboard kick');
    const data = loadJSON(MODERATION_PATH, {warnings:[],cases:[]});
    data.cases.push({ type: 'kick', id: crypto.randomUUID(), userId, reason: reason||'Dashboard kick', moderator: req.userName, ts: Date.now() });
    saveJSON(MODERATION_PATH, data);
    dashAudit(req.userName, 'kick-user', 'Kicked ' + userId);
    res.json({ success: true });
  } catch(e) { res.json({ success: false, error: e.message }); }
});

app.post('/api/moderation/ban', requireAuth, requireTier('admin'), async (req, res) => {
  const { userId, reason, deleteMessageDays, guildId } = req.body;
  if (!userId) return res.json({ success: false, error: 'Missing userId' });
  try {
    const guild = client.guilds.cache.get(guildId || req.guildId);
    await guild.members.ban(userId, { reason: reason || 'Dashboard ban', deleteMessageSeconds: (deleteMessageDays||0)*86400 });
    const data = loadJSON(MODERATION_PATH, {warnings:[],cases:[]});
    data.cases.push({ type: 'ban', id: crypto.randomUUID(), userId, reason: reason||'Dashboard ban', moderator: req.userName, ts: Date.now() });
    saveJSON(MODERATION_PATH, data);
    dashAudit(req.userName, 'ban-user', 'Banned ' + userId);
    res.json({ success: true });
  } catch(e) { res.json({ success: false, error: e.message }); }
});

app.post('/api/moderation/unban', requireAuth, requireTier('admin'), async (req, res) => {
  const { userId, guildId } = req.body;
  try {
    const guild = client.guilds.cache.get(guildId || req.guildId);
    await guild.members.unban(userId);
    dashAudit(req.userName, 'unban-user', 'Unbanned ' + userId);
    res.json({ success: true });
  } catch(e) { res.json({ success: false, error: e.message }); }
});

app.post('/api/moderation/clear-warnings', requireAuth, requireTier('admin'), (req, res) => {
  const { userId } = req.body;
  const data = loadJSON(MODERATION_PATH, {warnings:[],cases:[]});
  data.warnings = data.warnings.filter(w => w.userId !== userId);
  saveJSON(MODERATION_PATH, data);
  dashAudit(req.userName, 'clear-warnings', 'Cleared warnings for ' + userId);
  res.json({ success: true });
});

// --- Ticket System API ---
app.get('/api/tickets', requireAuth, requireTier('moderator'), (req, res) => {
  const data = loadJSON(TICKETS_PATH, {tickets:[],settings:{}});
  res.json({ success: true, tickets: data.tickets.slice(0,100), settings: data.settings });
});

app.post('/api/tickets/settings', requireAuth, requireTier('admin'), (req, res) => {
  const data = loadJSON(TICKETS_PATH, {tickets:[],settings:{}});
  data.settings = { ...data.settings, ...req.body };
  saveJSON(TICKETS_PATH, data);
  dashAudit(req.userName, 'update-ticket-settings', JSON.stringify(req.body).slice(0,100));
  res.json({ success: true });
});

app.post('/api/tickets/close', requireAuth, requireTier('moderator'), async (req, res) => {
  const { ticketId } = req.body;
  const data = loadJSON(TICKETS_PATH, {tickets:[],settings:{}});
  const ticket = data.tickets.find(t => t.id === ticketId);
  if (!ticket) return res.json({ success: false, error: 'Ticket not found' });
  ticket.status = 'closed';
  ticket.closedBy = req.userName;
  ticket.closedAt = Date.now();
  saveJSON(TICKETS_PATH, data);
  // Try to delete the Discord channel
  const ch = client.channels?.cache?.get(ticket.channelId);
  if (ch) await ch.delete('Ticket closed from dashboard').catch(() => {});
  dashAudit(req.userName, 'close-ticket', 'Closed ticket #' + ticket.number);
  res.json({ success: true });
});

app.post('/api/tickets/send-panel', requireAuth, requireTier('admin'), async (req, res) => {
  const { channelId } = req.body;
  const ch = client.channels?.cache?.get(channelId);
  if (!ch) return res.json({ success: false, error: 'Channel not found' });
  const { ActionRowBuilder, ButtonBuilder, ButtonStyle, EmbedBuilder } = await import('discord.js');
  const embed = new EmbedBuilder().setTitle('ðŸŽ« Support Tickets').setDescription('Click the button below to open a support ticket.').setColor(0x9146ff);
  const row = new ActionRowBuilder().addComponents(new ButtonBuilder().setCustomId('ticket_open').setLabel('Open Ticket').setStyle(ButtonStyle.Primary).setEmoji('ðŸŽ«'));
  await ch.send({ embeds: [embed], components: [row] });
  dashAudit(req.userName, 'send-ticket-panel', 'Sent ticket panel to channel ' + channelId);
  res.json({ success: true });
});

// --- Reaction Roles API ---
app.get('/api/reaction-roles', requireAuth, (req, res) => {
  const data = loadJSON(REACTION_ROLES_PATH, {panels:[]});
  res.json({ success: true, panels: data.panels });
});

app.post('/api/reaction-roles/create', requireAuth, requireTier('admin'), async (req, res) => {
  const { channelId, title, description, roles, mode } = req.body;
  if (!channelId || !roles?.length) return res.json({ success: false, error: 'Missing fields' });
  const ch = client.channels?.cache?.get(channelId);
  if (!ch) return res.json({ success: false, error: 'Channel not found' });
  const { ActionRowBuilder, ButtonBuilder, ButtonStyle, EmbedBuilder } = await import('discord.js');
  const embed = new EmbedBuilder().setTitle(title || 'ðŸŽ­ Reaction Roles').setDescription(description || 'Click a button to get/remove a role!').setColor(0x9146ff);
  let desc = '';
  const rows = [];
  let currentRow = new ActionRowBuilder();
  let count = 0;
  for (const r of roles.slice(0,25)) {
    desc += (r.emoji||'ðŸ”¹') + ' ' + (r.label||r.roleId) + '\n';
    currentRow.addComponents(new ButtonBuilder().setCustomId('rr_' + r.roleId).setLabel(r.label || 'Role').setStyle(ButtonStyle.Secondary).setEmoji(r.emoji || undefined));
    count++;
    if (count % 5 === 0) { rows.push(currentRow); currentRow = new ActionRowBuilder(); }
  }
  if (count % 5 !== 0) rows.push(currentRow);
  embed.setDescription(desc || 'Select a role below');
  const msg = await ch.send({ embeds: [embed], components: rows });
  const data = loadJSON(REACTION_ROLES_PATH, {panels:[]});
  data.panels.push({ id: msg.id, channelId, messageId: msg.id, roles, mode: mode || 'toggle', createdAt: Date.now() });
  saveJSON(REACTION_ROLES_PATH, data);
  dashAudit(req.userName, 'create-reaction-roles', 'Created panel in ' + channelId);
  res.json({ success: true });
});

app.post('/api/reaction-roles/delete', requireAuth, requireTier('admin'), async (req, res) => {
  const { panelId } = req.body;
  const data = loadJSON(REACTION_ROLES_PATH, {panels:[]});
  const panel = data.panels.find(p => p.id === panelId);
  if (panel) {
    const ch = client.channels?.cache?.get(panel.channelId);
    if (ch) { const m = await ch.messages?.fetch(panel.messageId).catch(()=>null); if (m) m.delete().catch(()=>{}); }
  }
  data.panels = data.panels.filter(p => p.id !== panelId);
  saveJSON(REACTION_ROLES_PATH, data);
  dashAudit(req.userName, 'delete-reaction-roles', 'Deleted panel ' + panelId);
  res.json({ success: true });
});

// --- Scheduled Messages API ---
app.get('/api/scheduled-messages', requireAuth, requireTier('moderator'), (req, res) => {
  const data = loadJSON(SCHED_MSG_PATH, {messages:[]});
  res.json({ success: true, messages: data.messages });
});

app.post('/api/scheduled-messages/create', requireAuth, requireTier('moderator'), (req, res) => {
  const { channelId, content, sendAt, embed } = req.body;
  if (!channelId || !sendAt) return res.json({ success: false, error: 'Missing fields' });
  const data = loadJSON(SCHED_MSG_PATH, {messages:[]});
  const msg = { id: crypto.randomUUID(), channelId, content: content || '', embed: embed || null, sendAt: new Date(sendAt).getTime(), sent: false, createdBy: req.userName, createdAt: Date.now() };
  data.messages.push(msg);
  saveJSON(SCHED_MSG_PATH, data);
  dashAudit(req.userName, 'schedule-message', 'Scheduled for ' + new Date(msg.sendAt).toLocaleString());
  res.json({ success: true, message: msg });
});

app.post('/api/scheduled-messages/delete', requireAuth, requireTier('moderator'), (req, res) => {
  const { id } = req.body;
  const data = loadJSON(SCHED_MSG_PATH, {messages:[]});
  data.messages = data.messages.filter(m => m.id !== id);
  saveJSON(SCHED_MSG_PATH, data);
  dashAudit(req.userName, 'delete-scheduled-message', 'Deleted ' + id);
  res.json({ success: true });
});

// --- Auto-Mod API ---
app.get('/api/automod', requireAuth, requireTier('moderator'), (req, res) => {
  const data = loadJSON(AUTOMOD_PATH, {});
  res.json({ success: true, config: data });
});

app.post('/api/automod/save', requireAuth, requireTier('admin'), (req, res) => {
  saveJSON(AUTOMOD_PATH, req.body);
  dashAudit(req.userName, 'update-automod', 'Updated auto-mod settings');
  res.json({ success: true });
});

// --- Starboard API ---
app.get('/api/starboard', requireAuth, (req, res) => {
  const data = loadJSON(STARBOARD_PATH, {});
  res.json({ success: true, config: { ...data, posts: (data.posts||[]).slice(0,50) } });
});

app.post('/api/starboard/save', requireAuth, requireTier('admin'), (req, res) => {
  const old = loadJSON(STARBOARD_PATH, {});
  const updated = { ...old, ...req.body, posts: old.posts || [] };
  saveJSON(STARBOARD_PATH, updated);
  dashAudit(req.userName, 'update-starboard', 'Updated starboard settings');
  res.json({ success: true });
});

// --- Export API ---
app.get('/api/export/:type', requireAuth, requireTier('admin'), (req, res) => {
  const { type } = req.params;
  const format = req.query.format || 'json';
  let data;
  switch(type) {
    case 'members': {
      const guild = client.guilds.cache.get(req.guildId);
      data = guild?.members?.cache?.map(m => ({ id: m.id, tag: m.user.tag, displayName: m.displayName, joinedAt: m.joinedAt?.toISOString(), roles: m.roles.cache.map(r=>r.name).join(', ') })) || [];
      break;
    }
    case 'moderation': data = loadJSON(MODERATION_PATH, {warnings:[],cases:[]}).cases; break;
    case 'audit-log': data = loadJSON(DASH_AUDIT_PATH, {entries:[]}).entries; break;
    case 'member-growth': data = loadJSON(MEMBER_GROWTH_PATH, {daily:[]}).daily; break;
    case 'command-usage': { const d = loadJSON(CMD_USAGE_PATH, {commands:{}}); data = Object.entries(d.commands).map(([n,v])=>({command:n,...v})); break; }
    case 'warnings': data = loadJSON(MODERATION_PATH, {warnings:[]}).warnings; break;
    case 'starboard': data = loadJSON(STARBOARD_PATH, {posts:[]}).posts; break;
    default: return res.json({ success: false, error: 'Unknown type' });
  }
  dashAudit(req.userName, 'export-data', 'Exported ' + type + ' as ' + format);
  if (format === 'csv') {
    if (!data.length) return res.send('');
    const keys = Object.keys(data[0]);
    const csv = [keys.join(','), ...data.map(r => keys.map(k => JSON.stringify(r[k]??'')).join(','))].join('\n');
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename=' + type + '.csv');
    return res.send(csv);
  }
  res.setHeader('Content-Type', 'application/json');
  res.setHeader('Content-Disposition', 'attachment; filename=' + type + '.json');
  res.json(data);
});

// --- Backup & Restore API ---
app.get('/api/backups', requireAuth, requireTier('owner'), (req, res) => {
  const backupDir = path.join(DATA_DIR, 'backups');
  if (!fs.existsSync(backupDir)) fs.mkdirSync(backupDir, { recursive: true });
  const files = fs.readdirSync(backupDir).filter(f => f.endsWith('.json')).sort().reverse();
  res.json({ success: true, backups: files.map(f => ({ name: f, size: fs.statSync(path.join(backupDir,f)).size, date: fs.statSync(path.join(backupDir,f)).mtime })) });
});

app.post('/api/backups/create', requireAuth, requireTier('owner'), (req, res) => {
  const backupDir = path.join(DATA_DIR, 'backups');
  if (!fs.existsSync(backupDir)) fs.mkdirSync(backupDir, { recursive: true });
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  const files = fs.readdirSync(DATA_DIR).filter(f => f.endsWith('.json') && f !== 'backups');
  const backup = {};
  for (const f of files) { try { backup[f] = JSON.parse(fs.readFileSync(path.join(DATA_DIR, f), 'utf8')); } catch {} }
  fs.writeFileSync(path.join(backupDir, 'backup-' + ts + '.json'), JSON.stringify(backup, null, 2));
  dashAudit(req.userName, 'create-backup', 'Created backup backup-' + ts);
  res.json({ success: true, name: 'backup-' + ts + '.json' });
});

app.post('/api/backups/restore', requireAuth, requireTier('owner'), (req, res) => {
  const { name } = req.body;
  const fp = path.join(DATA_DIR, 'backups', name);
  if (!fs.existsSync(fp)) return res.json({ success: false, error: 'Backup not found' });
  try {
    const backup = JSON.parse(fs.readFileSync(fp, 'utf8'));
    for (const [filename, content] of Object.entries(backup)) {
      fs.writeFileSync(path.join(DATA_DIR, filename), JSON.stringify(content, null, 2));
    }
    dashAudit(req.userName, 'restore-backup', 'Restored from ' + name);
    res.json({ success: true });
  } catch(e) { res.json({ success: false, error: e.message }); }
});

app.post('/api/backups/delete', requireAuth, requireTier('owner'), (req, res) => {
  const { name } = req.body;
  const fp = path.join(DATA_DIR, 'backups', name);
  if (fs.existsSync(fp)) fs.unlinkSync(fp);
  res.json({ success: true });
});

// --- Webhook Integrations API ---
app.get('/api/webhooks', requireAuth, requireTier('admin'), (req, res) => {
  const data = loadJSON(WEBHOOKS_PATH, {webhooks:[]});
  res.json({ success: true, webhooks: data.webhooks });
});

app.post('/api/webhooks/create', requireAuth, requireTier('admin'), (req, res) => {
  const { name, url, events } = req.body;
  if (!name || !url) return res.json({ success: false, error: 'Missing fields' });
  const data = loadJSON(WEBHOOKS_PATH, {webhooks:[]});
  data.webhooks.push({ id: crypto.randomUUID(), name, url, events: events || ['all'], enabled: true, createdAt: Date.now(), lastSent: null, failures: 0 });
  saveJSON(WEBHOOKS_PATH, data);
  dashAudit(req.userName, 'create-webhook', 'Created webhook: ' + name);
  res.json({ success: true });
});

app.post('/api/webhooks/delete', requireAuth, requireTier('admin'), (req, res) => {
  const { id } = req.body;
  const data = loadJSON(WEBHOOKS_PATH, {webhooks:[]});
  data.webhooks = data.webhooks.filter(w => w.id !== id);
  saveJSON(WEBHOOKS_PATH, data);
  res.json({ success: true });
});

app.post('/api/webhooks/toggle', requireAuth, requireTier('admin'), (req, res) => {
  const { id } = req.body;
  const data = loadJSON(WEBHOOKS_PATH, {webhooks:[]});
  const wh = data.webhooks.find(w => w.id === id);
  if (wh) wh.enabled = !wh.enabled;
  saveJSON(WEBHOOKS_PATH, data);
  res.json({ success: true });
});

app.post('/api/webhooks/test', requireAuth, requireTier('admin'), async (req, res) => {
  const { id } = req.body;
  const data = loadJSON(WEBHOOKS_PATH, {webhooks:[]});
  const wh = data.webhooks.find(w => w.id === id);
  if (!wh) return res.json({ success: false, error: 'Webhook not found' });
  try {
    const resp = await fetch(wh.url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ event: 'test', message: 'Test webhook from dashboard', ts: Date.now() }) });
    wh.lastSent = Date.now();
    if (!resp.ok) wh.failures++;
    saveJSON(WEBHOOKS_PATH, data);
    res.json({ success: resp.ok, status: resp.status });
  } catch(e) { wh.failures++; saveJSON(WEBHOOKS_PATH, data); res.json({ success: false, error: e.message }); }
});

// Fire webhooks for events
function fireWebhooks(event, payload) {
  const data = loadJSON(WEBHOOKS_PATH, {webhooks:[]});
  for (const wh of data.webhooks) {
    if (!wh.enabled) continue;
    if (!wh.events.includes('all') && !wh.events.includes(event)) continue;
    fetch(wh.url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ event, ...payload, ts: Date.now() }) }).catch(() => {});
  }
}

// --- API Keys API ---
app.get('/api/api-keys', requireAuth, requireTier('owner'), (req, res) => {
  const data = loadJSON(API_KEYS_PATH, {keys:[]});
  res.json({ success: true, keys: data.keys.map(k => ({ ...k, key: k.key.slice(0,8) + '...' })) });
});

app.post('/api/api-keys/create', requireAuth, requireTier('owner'), (req, res) => {
  const { name, permissions } = req.body;
  if (!name) return res.json({ success: false, error: 'Name required' });
  const key = 'dk_' + crypto.randomBytes(24).toString('hex');
  const data = loadJSON(API_KEYS_PATH, {keys:[]});
  data.keys.push({ id: crypto.randomUUID(), name, key, permissions: permissions || ['read'], createdAt: Date.now(), lastUsed: null, uses: 0 });
  saveJSON(API_KEYS_PATH, data);
  dashAudit(req.userName, 'create-api-key', 'Created key: ' + name);
  res.json({ success: true, key });
});

app.post('/api/api-keys/delete', requireAuth, requireTier('owner'), (req, res) => {
  const { id } = req.body;
  const data = loadJSON(API_KEYS_PATH, {keys:[]});
  data.keys = data.keys.filter(k => k.id !== id);
  saveJSON(API_KEYS_PATH, data);
  res.json({ success: true });
});

// Public API (authenticated via API key)
app.get('/api/v1/:resource', (req, res) => {
  const apiKey = req.headers['x-api-key'] || req.query.key;
  if (!apiKey) return res.status(401).json({ error: 'API key required' });
  const data = loadJSON(API_KEYS_PATH, {keys:[]});
  const keyObj = data.keys.find(k => k.key === apiKey);
  if (!keyObj) return res.status(401).json({ error: 'Invalid API key' });
  keyObj.lastUsed = Date.now();
  keyObj.uses++;
  saveJSON(API_KEYS_PATH, data);
  const { resource } = req.params;
  switch(resource) {
    case 'stats': return res.json({ streams: stats.totalStreams, viewers: streamInfo.viewers, isLive: !!streamInfo.startedAt });
    case 'members': { const g = client.guilds.cache.first(); return res.json({ count: g?.memberCount || 0, name: g?.name }); }
    case 'commands': { const d = loadJSON(CMD_USAGE_PATH, {commands:{}}); return res.json(Object.entries(d.commands).map(([n,v])=>({name:n,count:v.count}))); }
    case 'growth': return res.json(loadJSON(MEMBER_GROWTH_PATH, {daily:[]}).daily.slice(-30));
    default: return res.status(404).json({ error: 'Unknown resource' });
  }
});

// --- Theme Preference API ---
app.post('/api/theme', requireAuth, (req, res) => {
  const { theme } = req.body;
  const token = req.headers.cookie?.match(/session=([^;]+)/)?.[1];
  if (token && activeSessionTokens.has(token)) {
    activeSessionTokens.get(token).theme = theme || 'dark';
  }
  res.json({ success: true });
});

/* ======================
   RPG CONTENT EDITOR API
====================== */
app.use('/api', requireAuth, contentRoutes);

// Serve the content editor dashboard
app.get('/editor', requireAuth, (req, res) => {
  res.sendFile(path.join(__dirname, 'rpg', 'dashboard', 'ContentEditor.html'));
});

/* ======================
   DASHBOARD TEMPLATE
====================== */
function renderPage(tab, req){
  // Get selected server info
  const guildId = req ? getSelectedGuildId(req) : null;
  const guild = guildId ? client.guilds.cache.get(guildId) : client.guilds.cache.first();
  const guildName = guild?.name || 'No Server';
  const guildIcon = guild?.iconURL?.({ size: 64, dynamic: true }) || '';
  const guildInitials = guildName.split(' ').map(w => w[0]).join('').slice(0,2).toUpperCase();
  const userTier = req ? getUserTier(req) : 'viewer';
  const userName = req ? getUserName(req) : 'Unknown';
  const userAccess = TIER_ACCESS[userTier] || [];
  const _catMap = {core:['overview','health','logs'],community:['welcome','audit','customcmds','leveling','suggestions','events','events-giveaways','events-polls','events-reminders','notifications','pets','pet-giveaways','moderation','tickets','reaction-roles','scheduled-msgs','automod','starboard'],analytics:['stats','stats-engagement','stats-trends','stats-games','stats-viewers','stats-ai','stats-reports','stats-community','stats-rpg','stats-rpg-events','stats-rpg-economy','stats-rpg-quests','stats-compare','member-growth','command-usage'],rpg:['rpg-editor','rpg-entities','rpg-systems','rpg-ai','rpg-flags','rpg-simulators','rpg-admin','rpg-guild','rpg-guild-stats'],config:['commands','commands-config','config-commands','embeds'],accounts:['accounts'],tools:['export','backups','webhooks','api-keys','dash-audit']};
  const activeCategory = Object.entries(_catMap).find(([_,t])=>t.includes(tab))?.[0]||'core';
  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${guildName} â€” Dashboard</title>
<style>
body{margin:0;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;background:#0e0e10;color:#e0e0e0}
.topbar{position:fixed;top:0;left:0;right:0;height:48px;background:#111114;border-bottom:1px solid #2a2f3a;display:flex;align-items:center;justify-content:space-between;padding:0 16px 0 20px;z-index:200}
.topbar-tabs{display:flex;gap:2px}
.topbar-tab{padding:8px 18px;border-radius:6px;font-size:13px;font-weight:600;color:#8b8fa3;background:none;text-decoration:none;transition:all 0.15s;white-space:nowrap}
.topbar-tab:hover{background:#1f1f23;color:#fff;text-decoration:none}
.topbar-tab.active{background:#9146ff;color:#fff}
.topbar-tab.active:hover{background:#a955ff;text-decoration:none}
.topbar-search{position:relative;width:280px;flex-shrink:0}
.topbar-search input{width:100%;padding:7px 12px 7px 32px;background:#1a1a1d;border:1px solid #2a2f3a;border-radius:6px;color:#e0e0e0;font-size:13px;margin:0;outline:none;box-sizing:border-box}
.topbar-search input:focus{border-color:#9146ff;box-shadow:0 0 0 2px rgba(145,70,255,0.15)}
.topbar-search-icon{position:absolute;left:10px;top:50%;transform:translateY(-50%);color:#8b8fa3;font-size:13px;pointer-events:none}
.search-results{position:absolute;top:calc(100% + 4px);left:0;right:0;background:#1a1a1d;border:1px solid #2a2f3a;border-radius:6px;max-height:420px;overflow-y:auto;display:none;z-index:300;box-shadow:0 8px 24px rgba(0,0,0,0.5)}
.search-results.visible{display:block}
.search-result{padding:10px 14px;cursor:pointer;font-size:13px;border-bottom:1px solid #222228;display:flex;align-items:center;gap:10px;color:#e0e0e0;text-decoration:none}
.search-result:hover{background:#2a2f3a;text-decoration:none}
.search-result:last-child{border-bottom:none}
.search-result-icon{font-size:15px;flex-shrink:0}
.search-result-label{flex:1}
.search-result-cat{font-size:10px;padding:2px 8px;border-radius:3px;background:#2a2f3a;color:#8b8fa3;text-transform:uppercase;flex-shrink:0;letter-spacing:0.5px}
.search-no-results{padding:16px;text-align:center;color:#8b8fa3;font-size:13px}
.sidebar{width:220px;background:#1a1a1d;height:calc(100vh - 48px);position:fixed;top:48px;left:0;box-shadow:2px 0 8px rgba(0,0,0,0.3);display:flex;flex-direction:column;z-index:100}
.sidebar-server{padding:14px 16px;border-bottom:1px solid #2a2f3a;background:#15151a;flex-shrink:0}
.sidebar-server-info{display:flex;align-items:center;gap:10px;margin-bottom:8px}
.sidebar-server-icon{width:32px;height:32px;border-radius:50%;background:#2a2f3a;display:flex;align-items:center;justify-content:center;overflow:hidden;flex-shrink:0}
.sidebar-server-icon img{width:100%;height:100%;object-fit:cover}
.sidebar-server-icon span{font-size:11px;font-weight:700;color:#9146ff}
.sidebar-server-name{font-size:13px;font-weight:600;color:#fff;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex:1}
.sidebar-server-actions{display:flex;gap:6px}
.sidebar-server-actions a{padding:4px 10px;font-size:11px;border-radius:4px;color:#8b8fa3;background:#2a2f3a;text-decoration:none;transition:all 0.15s;border:none;cursor:pointer}
.sidebar-server-actions a:hover{background:#3a3f4a;color:#fff;text-decoration:none}
.sidebar-nav{flex:1;overflow-y:auto;overflow-x:hidden;padding-bottom:12px}
.sidebar-nav::-webkit-scrollbar{width:5px}
.sidebar-nav::-webkit-scrollbar-thumb{background:#3a3a42;border-radius:3px}
.sidebar-nav::-webkit-scrollbar-thumb:hover{background:#4a4a52}
.sidebar-nav::-webkit-scrollbar-track{background:transparent}
.sidebar a{display:block;padding:10px 16px;color:#b0b0b0;text-decoration:none;border-left:3px solid transparent;transition:all 0.15s;font-size:13px}
.sidebar a:hover{background:#2a2a2f;color:#fff;border-left-color:#9146ff;text-decoration:none}
.sidebar a.active{background:#2a2a2f;color:#fff;border-left-color:#9146ff;font-weight:600}
.sidebar-group{margin:2px 0}
.sidebar-group-header{width:100%;text-align:left;background:none;border:none;color:#b0b0b0;padding:10px 16px;cursor:pointer;border-left:3px solid transparent;transition:all 0.15s;font-size:13px;font-family:inherit}
.sidebar-group-header:hover{background:#2a2a2f;color:#fff;border-left-color:#9146ff}
.sidebar-group-header.active{background:#2a2a2f;color:#fff;border-left-color:#9146ff;font-weight:600}
.sidebar-sub{display:none;padding-left:8px}
.sidebar-group.open .sidebar-sub{display:block}
.sidebar-sub a{padding:7px 16px;margin-left:8px;border-left:2px solid #3a3a42;font-size:12px}
.main{margin-left:220px;padding:68px 20px 20px;max-width:1200px;opacity:0;transform:translateY(6px);transition:opacity 180ms ease-out, transform 220ms ease-out}
.main.content-loaded{opacity:1;transform:translateY(0)}
.card{background:#1f1f23;padding:20px;border-radius:8px;margin-bottom:15px;border:1px solid #2a2f3a}
.card h2{margin-top:0;color:#fff;display:flex;align-items:center;gap:8px}
input,textarea,button,select{width:100%;margin:8px 0;padding:10px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0;font-size:14px;box-sizing:border-box}
input[type="checkbox"]{width:auto;margin:0 6px 0 0;padding:0}
.inline-row{display:flex;gap:10px;align-items:center;margin:0}
.inline-input{width:auto;flex:1;min-width:0;margin:0}
.inline-button{width:auto;margin:0;flex-shrink:0}
textarea{resize:vertical;min-height:100px}
button{cursor:pointer;background:#9146ff;color:white;font-weight:500;transition:all 0.2s}
button:hover{background:#a955ff;transform:translateY(-1px)}
button.small{padding:8px 12px;font-size:12px;width:auto;flex-shrink:0}
button.danger{background:#c43c3c}
button.danger:hover{background:#d94c4c}
.log{padding:8px 12px;margin:3px 0;border-radius:4px;font-family:'Courier New',monospace;font-size:12px;border-left:3px solid}
.log.info{color:#6ab7ff;background:#1a2a3a;border-left-color:#6ab7ff}
.log.live{color:#4caf50;background:#1a2f1a;border-left-color:#4caf50;font-weight:bold}
.log.offline{color:#ffca28;background:#2f2a1a;border-left-color:#ffca28}
.log.error{color:#ef5350;background:#2f1a1a;border-left-color:#ef5350;font-weight:bold}
.log.milestone{color:#ffd700;background:#2f2a1a;border-left-color:#ffd700}
.chart-wrapper {max-width: 600px;height: 300px;margin-top: 15px}
.cmd-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:15px;margin-top:15px}
.cmd-card{background:#2a2f3a;padding:18px;border-radius:6px;border:1px solid #3a3a42}
.cmd-card .cmd-header{display:flex;flex-direction:column;align-items:flex-start;gap:6px}
.cmd-card .cmd-title{display:flex;align-items:center;gap:8px;min-width:0}
.cmd-card .cmd-actions{display:flex;gap:6px;align-items:center;flex-wrap:nowrap}
.command-filters{display:flex;gap:8px;flex-wrap:nowrap;overflow-x:auto;margin-bottom:12px;padding-bottom:2px}
.command-filters::-webkit-scrollbar{height:6px}
.command-filters::-webkit-scrollbar-thumb{background:#3a3a42;border-radius:999px}
.command-filters::-webkit-scrollbar-track{background:transparent}
.cmd-sections{display:flex;flex-direction:column;gap:14px;margin-top:15px}
.cmd-section{background:#1f1f23;border:1px solid #2a2f3a;border-radius:8px;padding:12px}
.cmd-section-title{display:flex;align-items:center;gap:8px;color:#d6d6d6;font-size:14px;font-weight:700}
.cmd-section-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:15px;margin-top:10px}
.leaderboard-controls{display:flex;flex-direction:column;gap:8px;margin-bottom:12px}
.leaderboard-row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.leaderboard-row .leaderboard-spacer{flex:1 1 auto}
.leaderboard-controls input,.leaderboard-controls select{width:auto}
.leaderboard-checkbox{display:flex;align-items:center;gap:6px;color:#b0b0b0;font-size:12px}
.leaderboard-pagination{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap}
.leaderboard-highlight{outline:2px solid #9146ff;box-shadow:0 0 0 2px rgba(145,70,255,0.25)}
.prestige-row{background:#1f2a1f}
.cmd-card .cmd-actions button.small{margin:0;height:26px;line-height:1;display:inline-flex;align-items:center;justify-content:center}
.cmd-card .name{color:#9146ff;font-weight:bold;font-size:14px;margin-bottom:5px}
.cmd-card .desc{color:#b0b0b0;font-size:13px;margin-bottom:8px}
.cmd-card .usage{background:#1f1f23;padding:8px;border-radius:4px;font-family:monospace;font-size:11px;color:#6ab7ff;overflow-x:auto}
.cmd-card .badge{display:inline-block;padding:4px 8px;border-radius:3px;font-size:11px;font-weight:bold;margin-right:5px;margin-bottom:8px}
.cmd-name{color:#9aa4ff;font-weight:700;font-size:14px;cursor:pointer}
.cmd-name:hover{text-decoration:underline}
.status-dot{width:8px;height:8px;border-radius:50%;display:inline-block}
.status-enabled{background:#57f287}
.status-cooldown{background:#ffca28}
.status-disabled{background:#ed4245}
.badge.admin{background:#c43c3c;color:white}
.badge.community{background:#4caf50;color:white}
.badge.info{background:#2196f3;color:white}
table{width:100%;border-collapse:collapse}
table th{background:#2a2f3a;padding:10px;text-align:left;border:1px solid #3a3a42;font-weight:bold;color:#fff}
table td{padding:10px;border:1px solid #3a3a42}
table tr:hover{background:#252529}
details{margin:10px 0}
details summary{cursor:pointer;color:#9146ff;font-weight:bold}
a{color:#9146ff;text-decoration:none}
a:hover{text-decoration:underline}
pre{background:#1a1a1d;padding:10px;border-radius:4px;overflow-x:auto}
</style>
</head>
<body>
<div class="topbar">
  <div class="topbar-tabs">
    ${userAccess.includes('core')?'<a class="topbar-tab '+(activeCategory==='core'?'active':'')+'" href="/">ðŸ“Š Core</a>':''}
    ${userAccess.includes('community')?'<a class="topbar-tab '+(activeCategory==='community'?'active':'')+'" href="'+(userTier==='viewer'?'/pets':'/welcome')+'">ðŸ‘¥ Community</a>':''}
    ${userAccess.includes('analytics')?'<a class="topbar-tab '+(activeCategory==='analytics'?'active':'')+'" href="/stats">ðŸ“ˆ Analytics</a>':''}
    ${userAccess.includes('rpg')?'<a class="topbar-tab '+(activeCategory==='rpg'?'active':'')+'" href="/rpg?tab=rpg-editor">ðŸŽ® RPG</a>':''}
    ${userAccess.includes('config')?'<a class="topbar-tab '+(activeCategory==='config'?'active':'')+'" href="/commands">âš™ï¸ Config</a>':''}
    ${userAccess.includes('tools')?'<a class="topbar-tab '+(activeCategory==='tools'?'active':'')+'" href="/export">ðŸ”§ Tools</a>':''}
    ${userAccess.includes('accounts')?'<a class="topbar-tab '+(activeCategory==='accounts'?'active':'')+'" href="/accounts">ðŸ” Accounts</a>':''}
  </div>
  <div class="topbar-right" style="display:flex;align-items:center;gap:12px">
    <div class="topbar-user" style="display:flex;align-items:center;gap:6px;font-size:12px;color:#8b8fa3">
      <span style="color:#e0e0e0;font-weight:600">${userName}</span>
      <span style="color:${TIER_COLORS[userTier]||'#8b8fa3'};font-weight:700;font-size:10px;text-transform:uppercase;letter-spacing:0.5px;padding:2px 6px;background:${TIER_COLORS[userTier]||'#8b8fa3'}20;border-radius:3px">${TIER_LABELS[userTier]||userTier}</span>
    </div>
    <div class="topbar-search">
      <span class="topbar-search-icon">ðŸ”</span>
      <input type="text" placeholder="Search everywhere..." id="globalSearch" autocomplete="off">
      <div class="search-results" id="searchResults"></div>
    </div>
  </div>
</div>
<div class="sidebar">
<div class="sidebar-server">
  <div class="sidebar-server-info">
    <div class="sidebar-server-icon">${guildIcon ? '<img src="' + guildIcon + '" alt="">' : '<span>' + guildInitials + '</span>'}</div>
    <div class="sidebar-server-name" title="${guildName}">${guildName}</div>
  </div>
  <div class="sidebar-server-actions">
    <a href="/switch-server">Switch</a>
    <a href="/logout">Sign out</a>
  </div>
  ${!TIER_CAN_EDIT[userTier] ? '<div style="margin-top:6px;padding:4px 8px;background:#ffca2815;border:1px solid #ffca2833;border-radius:4px;font-size:10px;color:#ffca28;text-align:center">ðŸ”’ Read-only access</div>' : ''}
</div>
<div class="sidebar-nav">
${activeCategory==='core'?`
    <a href="/" class="${tab==='overview'?'active':''}">ðŸ“Š Overview</a>
    <a href="/health" class="${tab==='health'?'active':''}">ðŸ’“ Health</a>
    <a href="/logs" class="${tab==='logs'?'active':''}">ðŸ“‹ Logs</a>
`:activeCategory==='community'?`
    ${userTier!=='viewer'?`<a href="/welcome" class="${tab==='welcome'?'active':''}">ðŸ‘‹ Welcome</a>
    <a href="/audit" class="${tab==='audit'?'active':''}">ðŸ•µï¸ Member Logs</a>
    <a href="/customcmds" class="${tab==='customcmds'?'active':''}">ðŸ·ï¸ Tags/Custom</a>
    <a href="/leveling" class="${tab==='leveling'?'active':''}">ðŸ† Leveling</a>
    <a href="/suggestions" class="${tab==='suggestions'?'active':''}">ðŸ’¡ Suggestions</a>
    <a href="/events" class="${tab==='events'||tab==='events-giveaways'||tab==='events-polls'||tab==='events-reminders'?'active':''}">ðŸŽª Events</a>
    <a href="/notifications" class="${tab==='notifications'?'active':''}">ðŸ”” Notifications</a>`:''}
    <a href="/pets" class="${tab==='pets'?'active':''}">ðŸ¾ Pets</a>
    <a href="/pet-giveaways" class="${tab==='pet-giveaways'?'active':''}">ðŸŽ Pet Giveaways</a>
`:activeCategory==='analytics'?`
    <a href="/stats?tab=stats" class="${tab==='stats'?'active':''}">ðŸ“ˆ Dashboard</a>
    <a href="/stats?tab=stats-engagement" class="${tab==='stats-engagement'?'active':''}">ðŸ‘¥ Engagement</a>
    <a href="/stats?tab=stats-trends" class="${tab==='stats-trends'?'active':''}">ðŸ“Š Trends</a>
    <a href="/stats?tab=stats-games" class="${tab==='stats-games'?'active':''}">ðŸŽ® Game Performance</a>
    <a href="/stats?tab=stats-viewers" class="${tab==='stats-viewers'?'active':''}">ðŸ‘€ Viewer Patterns</a>
    <a href="/stats?tab=stats-ai" class="${tab==='stats-ai'?'active':''}">ðŸ¤– AI Insights</a>
    <a href="/stats?tab=stats-reports" class="${tab==='stats-reports'?'active':''}">ðŸ“‹ Reports</a>
    <a href="/stats?tab=stats-community" class="${tab==='stats-community'?'active':''}">ðŸ¤ Community & Bot</a>
    <a href="/stats?tab=stats-rpg" class="${tab==='stats-rpg'?'active':''}">ðŸŽ® RPG Analytics</a>
    <a href="/stats?tab=stats-rpg-events" class="${tab==='stats-rpg-events'?'active':''}">âš¡ RPG Events</a>
    <a href="/stats?tab=stats-rpg-economy" class="${tab==='stats-rpg-economy'?'active':''}">ðŸ’° RPG Economy</a>
    <a href="/stats?tab=stats-rpg-quests" class="${tab==='stats-rpg-quests'?'active':''}">ðŸ“œ RPG Quests & Combat</a>
    <a href="/stats?tab=stats-compare" class="${tab==='stats-compare'?'active':''}">ðŸ†š Stream Compare</a>
`:activeCategory==='rpg'?`
    <a href="/rpg?tab=rpg-editor" class="${tab==='rpg-editor'?'active':''}">âœï¸ Content Editor</a>
    <a href="/rpg?tab=rpg-entities" class="${tab==='rpg-entities'?'active':''}">ðŸ‘¥ Entities</a>
    <a href="/rpg?tab=rpg-systems" class="${tab==='rpg-systems'?'active':''}">âš™ï¸ Systems</a>
    <a href="/rpg?tab=rpg-ai" class="${tab==='rpg-ai'?'active':''}">ðŸ¤– AI & Combat</a>
    <a href="/rpg?tab=rpg-flags" class="${tab==='rpg-flags'?'active':''}">ðŸš© Flags & Modifiers</a>
    <a href="/rpg?tab=rpg-simulators" class="${tab==='rpg-simulators'?'active':''}">ðŸ§ª Simulators</a>
    <a href="/rpg?tab=rpg-guild" class="${tab==='rpg-guild'?'active':''}">ðŸ›ï¸ Adventurers Guild</a>
    <a href="/rpg?tab=rpg-guild-stats" class="${tab==='rpg-guild-stats'?'active':''}">ðŸ“Š Guild Stats</a>
    <a href="/rpg?tab=rpg-admin" class="${tab==='rpg-admin'?'active':''}">ðŸ”‘ Admin</a>
`:`
    <a href="/commands" class="${tab==='commands'||tab==='commands-config'||tab==='config-commands'?'active':''}">âš™ï¸ Config</a>
    <a href="/embeds" class="${tab==='embeds'?'active':''}">âœ¨ Embeds</a>
`}
${activeCategory==='accounts'?`
    <a href="/accounts" class="${tab==='accounts'?'active':''}">ðŸ” Manage Accounts</a>
`:''}
</div>
</div>
<div class="main">${renderTab(tab, userTier)}</div>
<script>
var _userAccess = ${JSON.stringify(userAccess)};
var _allPages = [
  {l:'Overview',c:'Core',u:'/',i:'ðŸ“Š',k:'overview dashboard home bot status giveaway stream'},
  {l:'Health',c:'Core',u:'/health',i:'ðŸ’“',k:'health monitoring uptime memory cpu'},
  {l:'Logs',c:'Core',u:'/logs',i:'ðŸ“‹',k:'logs activity stream events history'},
  ${userTier!=='viewer'?`{l:'Welcome',c:'Community',u:'/welcome',i:'ðŸ‘‹',k:'welcome greet join message auto role'},
  {l:'Member Logs',c:'Community',u:'/audit',i:'ðŸ•µï¸',k:'audit member logs join leave ban role changes moderation'},
  {l:'Tags/Custom',c:'Community',u:'/customcmds',i:'ðŸ·ï¸',k:'tags custom commands responses auto reply'},
  {l:'Leveling',c:'Community',u:'/leveling',i:'ðŸ†',k:'leveling xp level rank prestige rewards roles'},
  {l:'Suggestions',c:'Community',u:'/suggestions',i:'ðŸ’¡',k:'suggestions feedback ideas vote'},
  {l:'Events',c:'Community',u:'/events',i:'ðŸŽª',k:'events giveaways polls reminders schedule'},
  {l:'Notifications',c:'Community',u:'/notifications',i:'ðŸ””',k:'notifications alerts ping'},`:''}
  {l:'Pets',c:'Community',u:'/pets',i:'ðŸ¾',k:'pets animals companions collection add remove'},
  {l:'Pet Giveaways',c:'Community',u:'/pet-giveaways',i:'ðŸŽ',k:'pet giveaway trade history confirm'},
  {l:'Pet Stats',c:'Community',u:'/pet-stats',i:'ðŸ“Š',k:'pet statistics analytics graphs charts collection data'},
  {l:'Dashboard',c:'Analytics',u:'/stats?tab=stats',i:'ðŸ“ˆ',k:'stats dashboard overview numbers summary'},
  {l:'Engagement',c:'Analytics',u:'/stats?tab=stats-engagement',i:'ðŸ‘¥',k:'engagement activity viewers chatters'},
  {l:'Trends',c:'Analytics',u:'/stats?tab=stats-trends',i:'ðŸ“Š',k:'trends growth over time graphs charts'},
  {l:'Game Performance',c:'Analytics',u:'/stats?tab=stats-games',i:'ðŸŽ®',k:'games performance categories played'},
  {l:'Viewer Patterns',c:'Analytics',u:'/stats?tab=stats-viewers',i:'ðŸ‘€',k:'viewers patterns watch time peak hours'},
  {l:'AI Insights',c:'Analytics',u:'/stats?tab=stats-ai',i:'ðŸ¤–',k:'ai insights predictions analysis'},
  {l:'Reports',c:'Analytics',u:'/stats?tab=stats-reports',i:'ðŸ“‹',k:'reports summary export'},
  {l:'Community & Bot',c:'Analytics',u:'/stats?tab=stats-community',i:'ðŸ¤',k:'community bot analytics usage'},
  {l:'RPG Analytics',c:'Analytics',u:'/stats?tab=stats-rpg',i:'ðŸŽ®',k:'rpg analytics players economy combat'},
  {l:'RPG Events',c:'Analytics',u:'/stats?tab=stats-rpg-events',i:'âš¡',k:'rpg events world boss raids'},
  {l:'RPG Economy',c:'Analytics',u:'/stats?tab=stats-rpg-economy',i:'ðŸ’°',k:'rpg economy gold market trading'},
  {l:'RPG Quests & Combat',c:'Analytics',u:'/stats?tab=stats-rpg-quests',i:'ðŸ“œ',k:'rpg quests combat battles arena'},
  {l:'Stream Compare',c:'Analytics',u:'/stats?tab=stats-compare',i:'ðŸ†š',k:'compare streams side by side'},
  {l:'Content Editor',c:'RPG',u:'/rpg?tab=rpg-editor',i:'âœï¸',k:'rpg content editor items monsters worlds'},
  {l:'Entities',c:'RPG',u:'/rpg?tab=rpg-entities',i:'ðŸ‘¥',k:'rpg entities players monsters npcs characters'},
  {l:'Systems',c:'RPG',u:'/rpg?tab=rpg-systems',i:'âš™ï¸',k:'rpg systems crafting gathering professions skills'},
  {l:'AI & Combat',c:'RPG',u:'/rpg?tab=rpg-ai',i:'ðŸ¤–',k:'rpg ai combat battle simulation'},
  {l:'Flags & Modifiers',c:'RPG',u:'/rpg?tab=rpg-flags',i:'ðŸš©',k:'rpg flags modifiers settings buffs debuffs'},
  {l:'Simulators',c:'RPG',u:'/rpg?tab=rpg-simulators',i:'ðŸ§ª',k:'rpg simulators test balance'},
  {l:'Adventurers Guild',c:'RPG',u:'/rpg?tab=rpg-guild',i:'ðŸ›ï¸',k:'rpg guild adventurers members'},
  {l:'Guild Stats',c:'RPG',u:'/rpg?tab=rpg-guild-stats',i:'ðŸ“Š',k:'rpg guild stats leaderboard'},
  {l:'Admin',c:'RPG',u:'/rpg?tab=rpg-admin',i:'ðŸ”‘',k:'rpg admin manage reset'},
  {l:'Config',c:'Config',u:'/commands',i:'âš™ï¸',k:'config commands settings bot configuration'},
  {l:'Embeds',c:'Config',u:'/embeds',i:'âœ¨',k:'embeds custom messages rich embed builder'}
];

function highlightOnPage(text) {
  var sr = document.getElementById('searchResults');
  if (sr) sr.classList.remove('visible');
  var els = document.querySelectorAll('.card h2, .card h3, label, table th, details summary, .cmd-card .name');
  for (var i = 0; i < els.length; i++) {
    if (els[i].textContent.trim() === text) {
      els[i].scrollIntoView({ behavior: 'smooth', block: 'center' });
      els[i].style.transition = 'background 0.3s';
      els[i].style.background = 'rgba(145,70,255,0.3)';
      els[i].style.borderRadius = '4px';
      setTimeout(function(el) { el.style.background = ''; }.bind(null, els[i]), 2500);
      break;
    }
  }
}

document.addEventListener('DOMContentLoaded', function() {
  var main = document.querySelector('.main');
  if (main) main.classList.add('content-loaded');

  var si = document.getElementById('globalSearch');
  var sr = document.getElementById('searchResults');
  if (!si || !sr) return;

  var debounce;
  si.addEventListener('input', function() {
    clearTimeout(debounce);
    debounce = setTimeout(function() {
      var q = si.value.trim().toLowerCase();
      if (q.length < 2) { sr.classList.remove('visible'); sr.innerHTML = ''; return; }

      var pageMatches = _allPages.filter(function(p) {
        if (!_userAccess.includes(p.c.toLowerCase())) return false;
        return p.l.toLowerCase().indexOf(q) !== -1 || p.k.indexOf(q) !== -1 || p.c.toLowerCase().indexOf(q) !== -1;
      });

      var domMatches = [];
      var seen = {};
      document.querySelectorAll('.card h2, .card h3, label, table th, details summary, .cmd-card .name').forEach(function(el) {
        var txt = el.textContent.trim();
        if (txt.toLowerCase().indexOf(q) !== -1 && !seen[txt] && txt.length > 1) {
          seen[txt] = true;
          domMatches.push(txt);
        }
      });

      if (pageMatches.length === 0 && domMatches.length === 0) {
        sr.innerHTML = '<div class="search-no-results">No results for &quot;' + q + '&quot;</div>';
        sr.classList.add('visible');
        return;
      }

      var html = '';
      pageMatches.forEach(function(p) {
        html += '<a class="search-result" href="' + p.u + '">' +
          '<span class="search-result-icon">' + p.i + '</span>' +
          '<span class="search-result-label">' + p.l + '</span>' +
          '<span class="search-result-cat">' + p.c + '</span></a>';
      });
      if (domMatches.length > 0) {
        html += '<div style="padding:6px 14px;font-size:11px;color:#8b8fa3;text-transform:uppercase;letter-spacing:0.5px;border-top:1px solid #2a2f3a;margin-top:2px">On this page</div>';
        domMatches.slice(0, 10).forEach(function(txt) {
          html += '<div class="search-result" data-highlight="' + txt.replace(/"/g, '&quot;') + '">' +
            '<span class="search-result-icon">ðŸ“Œ</span>' +
            '<span class="search-result-label">' + txt + '</span>' +
            '<span class="search-result-cat">Current</span></div>';
        });
      }
      sr.innerHTML = html;
      sr.classList.add('visible');
    }, 180);
  });

  sr.addEventListener('click', function(e) {
    var item = e.target.closest('[data-highlight]');
    if (item) highlightOnPage(item.getAttribute('data-highlight'));
  });

  si.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') { sr.classList.remove('visible'); si.value = ''; si.blur(); }
  });

  document.addEventListener('click', function(e) {
    if (!e.target.closest('.topbar-search')) sr.classList.remove('visible');
  });

  document.addEventListener('keydown', function(e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 'k') { e.preventDefault(); si.focus(); si.select(); }
  });
});

// Member Logs (Audit) helpers available on all pages
let auditPerEventChannelsDraft = {};
let auditPerEventPingsDraft = {};

const auditEventLabels = {
  logMemberJoins: 'Member joins & join position',
  logMemberLeaves: 'Member leaves',
  logMemberBans: 'Member bans & unbans',
  logMemberBoosts: 'Boosts / stops boosting',
  warnNewAccounts: 'Warn on new accounts',
  logUsernameChanges: 'Name changes',
  logAvatarChanges: 'Avatar changes',
  logRoleChanges: 'Role updates',
  logMemberTimeouts: 'Timeouts',
  logMemberMutes: 'Mute roles',
  logMessageEdits: 'Message edits',
  logMessageDeletes: 'Message deletes',
  logMessagePins: 'Message pins',
  logServerUpdates: 'Server updates',
  logIntegrations: 'Integrations'
};

const auditPingLabels = {
  logMemberBans: 'Member bans & unbans',
  logRoleChanges: 'Role updates',
  logMemberTimeouts: 'Timeouts',
  logMemberMutes: 'Mute roles'
};

const auditPreviewTexts = {
  logMemberJoins: 'âœ… User Antho#1234 joined the server (ID: 123, Position: #42)',
  logMemberLeaves: 'âŒ User Antho#1234 left the server (ID: 123)',
  logMemberBans: 'â›” User Antho#1234 was banned (Reason: spam)',
  logMemberBoosts: 'ðŸ’œ User Antho#1234 started boosting the server',
  warnNewAccounts: 'âš ï¸ New account detected: Antho#1234 (created 2 days ago)',
  logUsernameChanges: 'âœï¸ Username/Nickname changed: OldName â†’ NewName',
  logAvatarChanges: 'ðŸ–¼ï¸ Avatar updated for User Antho#1234',
  logRoleChanges: 'ðŸ”§ Roles updated: +@Mod -@Guest (2 added, 1 removed)',
  logMemberTimeouts: 'â±ï¸ User Antho#1234 timed out for 10 minutes',
  logMemberMutes: 'ðŸ”‡ User Antho#1234 muted (Mute Role)',
  logMessageEdits: 'âœï¸ Message edited in #general: "old text" â†’ "new text"',
  logMessageDeletes: 'ðŸ—‘ï¸ Message deleted in #general (by Antho#1234)',
  logMessagePins: 'ðŸ“Œ Message pinned in #general (by Antho#1234)',
  logServerUpdates: 'âš™ï¸ Server name changed: OldName â†’ NewName',
  logIntegrations: 'ðŸ¤– Discord Bot Integration added'
};

function updateAuditChannelDropdown() {
  updateAuditChannelName();
}

function updateAuditLogLevel() {
  // Placeholder for log level change handler
}

function updateLivePreview() {
  const selected = [];
  const events = ['logMemberJoins', 'logMemberLeaves', 'logMemberBans', 'logMemberBoosts', 'warnNewAccounts', 'logUsernameChanges', 'logAvatarChanges', 'logRoleChanges', 'logMemberTimeouts', 'logMemberMutes', 'logMessageEdits', 'logMessageDeletes', 'logMessagePins', 'logServerUpdates', 'logIntegrations'];
  
  events.forEach(eventId => {
    const elem = document.getElementById(eventId);
    if (elem && elem.checked) selected.push(eventId);
  });

  const preview = document.getElementById('livePreviewContent');
  if (!preview) return;
  if (selected.length === 0) {
    preview.innerHTML = '<span style="color:#666">Select events above to see preview...</span>';
  } else {
    var html = '';
    for (var i = 0; i < selected.length; i++) {
      html += '<div style="padding:6px 0;border-bottom:1px solid #333">' + auditPreviewTexts[selected[i]] + '</div>';
    }
    preview.innerHTML = html;
  }
}

function ensureGenericModal() {
  let backdrop = document.getElementById('genericModalBackdrop');
  let modal = document.getElementById('genericModal');
  if (backdrop && modal) return { backdrop, modal };

  backdrop = document.createElement('div');
  backdrop.id = 'genericModalBackdrop';
  backdrop.style.position = 'fixed';
  backdrop.style.top = '0';
  backdrop.style.left = '0';
  backdrop.style.width = '100vw';
  backdrop.style.height = '100vh';
  backdrop.style.background = 'rgba(0,0,0,0.85)';
  backdrop.style.zIndex = '1000';
  backdrop.style.display = 'none';

  modal = document.createElement('div');
  modal.id = 'genericModal';
  modal.style.position = 'fixed';
  modal.style.top = '50%';
  modal.style.left = '50%';
  modal.style.transform = 'translate(-50%, -50%)';
  modal.style.background = '#1a1a1f';
  modal.style.padding = '0';
  modal.style.borderRadius = '12px';
  modal.style.maxWidth = '680px';
  modal.style.width = '95%';
  modal.style.zIndex = '1001';
  modal.style.display = 'none';
  modal.style.border = '2px solid #9146ff';
  modal.style.maxHeight = '85vh';
  modal.style.height = '85vh';
  modal.style.boxShadow = '0 12px 48px rgba(0,0,0,0.8)';
  modal.style.color = '#ffffff';
  modal.style.boxSizing = 'border-box';
  modal.style.overflow = 'hidden';
  modal.style.display = 'flex';
  modal.style.flexDirection = 'column';

  document.body.appendChild(backdrop);
  document.body.appendChild(modal);

  backdrop.addEventListener('click', hideCustomModal);
  return { backdrop, modal };
}

function showCustomModal(html, onSave) {
  const { backdrop, modal } = ensureGenericModal();
  let title = 'Details';
  let cleaned = html;
  const openTag = '<h3';
  const closeTag = '</h3>';
  const openIdx = html.indexOf(openTag);
  if (openIdx !== -1) {
    const startText = html.indexOf('>', openIdx);
    const endIdx = html.indexOf(closeTag, startText + 1);
    if (startText !== -1 && endIdx !== -1) {
      title = html.slice(startText + 1, endIdx).trim() || 'Details';
      cleaned = html.slice(0, openIdx) + html.slice(endIdx + closeTag.length);
    }
  }

  const saveButton = onSave ? '<button type="button" id="modalSaveBtn" style="background:#9146ff;color:#ffffff;border:1px solid #9146ff;padding:10px 24px;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500;transition:all 0.2s" onmouseover="this.style.background=&#39;#7c3aed&#39;" onmouseout="this.style.background=&#39;#9146ff&#39;">Save Changes</button>' : '';
  const actionBar = '<div style="display:flex;gap:10px;justify-content:flex-end;margin-top:18px">'
    + '<button type="button" onclick="hideCustomModal()" style="background:#3a3a42;color:#ffffff;border:1px solid #4a4a52;padding:10px 24px;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500;transition:all 0.2s" onmouseover="this.style.background=&#39;#4a4a52&#39;" onmouseout="this.style.background=&#39;#3a3a42&#39;">Close</button>'
    + saveButton
    + '</div>';

  modal.innerHTML = '<div style="background:#23232b;padding:20px 24px;border-bottom:1px solid #2f2f3a">'
    + '<div style="display:flex;align-items:center;justify-content:space-between">'
    + '<h2 style="margin:0;font-size:22px;font-weight:600;color:#ffffff">' + title + '</h2>'
    + '<button type="button" onclick="hideCustomModal()" style="background:transparent;border:none;color:#b0b0b0;font-size:24px;cursor:pointer;padding:0;width:32px;height:32px;border-radius:4px;transition:all 0.2s" onmouseover="this.style.background=&#39;#3a3a42&#39;" onmouseout="this.style.background=&#39;transparent&#39;">Ã—</button>'
    + '</div></div>'
    + '<div style="padding:24px;overflow-y:auto;max-height:70vh">'
    + cleaned
    + actionBar
    + '</div>';

  if (onSave) {
    setTimeout(() => {
      const btn = document.getElementById('modalSaveBtn');
      if (btn) btn.addEventListener('click', onSave);
    }, 0);
  }

  backdrop.style.display = 'block';
  modal.style.display = 'block';
}

function hideCustomModal() {
  const backdrop = document.getElementById('genericModalBackdrop');
  const modal = document.getElementById('genericModal');
  if (backdrop) backdrop.style.display = 'none';
  if (modal) modal.style.display = 'none';
}

function openPerEventChannelsModal() {
  const rows = Object.entries(auditEventLabels).map(([id, label]) => {
    const value = auditPerEventChannelsDraft[id] || '';
    return '<div style="background:#23232b;padding:16px;border-radius:8px;margin-bottom:12px;border:1px solid #2f2f3a">'
      + '<label style="display:block;color:#b9bbbe;font-size:14px;font-weight:500;margin-bottom:10px">' + label + '</label>'
      + '<input type="text" id="perEventChannel_' + id + '" value="' + value + '" placeholder="Enter Channel ID or leave empty"'
      + ' style="background:#0f0f12;border:1px solid #3a3a42;border-radius:6px;padding:12px 14px;color:#ffffff;width:100%;box-sizing:border-box;font-size:14px;transition:border 0.2s" '
      + 'onfocus="this.style.borderColor=&#39;#9146ff&#39;" onblur="this.style.borderColor=&#39;#3a3a42&#39;" />'
      + '</div>';
  }).join('');

  const actionBar = '<div style="display:flex;gap:10px;justify-content:flex-end;margin-top:18px">'
    + '<button type="button" id="perEventChannelsClose" style="background:#3a3a42;color:#ffffff;border:1px solid #4a4a52;padding:10px 24px;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500">Close</button>'
    + '<button type="button" id="perEventChannelsSave" style="background:#9146ff;color:#ffffff;border:1px solid #9146ff;padding:10px 24px;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500">Save Changes</button>'
    + '</div>';

  showCustomModal('<div><h3 style="margin:0 0 6px 0;font-size:18px;font-weight:600">Per-Event Channel Routing</h3>'
    + '<p style="color:#72767d;margin:0 0 20px 0;font-size:13px;line-height:1.5">Configure individual channel destinations for each audit event type. Leave empty to use the main log channel.</p>'
    + '<div style="max-height:450px;overflow-y:auto;padding-right:4px">' + rows + '</div>'
    + actionBar
    + '</div>');

  Object.keys(auditEventLabels).forEach(id => {
    const input = document.getElementById('perEventChannel_' + id);
    if (!input) return;
    input.addEventListener('input', () => {
      auditPerEventChannelsDraft[id] = input.value.trim();
    });
  });

  const closeBtn = document.getElementById('perEventChannelsClose');
  if (closeBtn) closeBtn.addEventListener('click', hideCustomModal);
  const saveBtn = document.getElementById('perEventChannelsSave');
  if (saveBtn) saveBtn.addEventListener('click', () => {
    Object.keys(auditEventLabels).forEach(id => {
      const input = document.getElementById('perEventChannel_' + id);
      if (input) auditPerEventChannelsDraft[id] = input.value.trim();
    });
    saveAuditLogSettings();
  });
}

function openPerEventPingsModal() {
  const rows = Object.entries(auditPingLabels).map(([id, label]) => {
    const value = Array.isArray(auditPerEventPingsDraft[id]) ? auditPerEventPingsDraft[id].join(' ') : (auditPerEventPingsDraft[id] || '');
    return '<div style="background:#23232b;padding:16px;border-radius:8px;margin-bottom:12px;border:1px solid #2f2f3a">'
      + '<label style="display:block;color:#b9bbbe;font-size:14px;font-weight:500;margin-bottom:10px">' + label + '</label>'
      + '<input type="text" id="perEventPing_' + id + '" value="' + value + '" placeholder="Enter Role/User IDs (space or comma separated)"'
      + ' style="background:#0f0f12;border:1px solid #3a3a42;border-radius:6px;padding:12px 14px;color:#ffffff;width:100%;box-sizing:border-box;font-size:14px;transition:border 0.2s" '
      + 'onfocus="this.style.borderColor=&#39;#9146ff&#39;" onblur="this.style.borderColor=&#39;#3a3a42&#39;" />'
      + '</div>';
  }).join('');

  const actionBar = '<div style="display:flex;gap:10px;justify-content:flex-end;margin-top:18px">'
    + '<button type="button" id="perEventPingsClose" style="background:#3a3a42;color:#ffffff;border:1px solid #4a4a52;padding:10px 24px;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500">Close</button>'
    + '<button type="button" id="perEventPingsSave" style="background:#9146ff;color:#ffffff;border:1px solid #9146ff;padding:10px 24px;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500">Save Changes</button>'
    + '</div>';

  showCustomModal('<div><h3 style="margin:0 0 6px 0;font-size:18px;font-weight:600">Event Pings</h3>'
    + '<p style="color:#72767d;margin:0 0 20px 0;font-size:13px;line-height:1.5">Configure role or user mentions for specific audit events. Enter IDs separated by spaces or commas. Leave empty for no pings.</p>'
    + '<div style="max-height:450px;overflow-y:auto;padding-right:4px">' + rows + '</div>'
    + actionBar
    + '</div>');

  Object.keys(auditPingLabels).forEach(id => {
    const input = document.getElementById('perEventPing_' + id);
    if (!input) return;
    input.addEventListener('input', () => {
      auditPerEventPingsDraft[id] = splitIdTokens(input.value);
    });
  });

  const closeBtn = document.getElementById('perEventPingsClose');
  if (closeBtn) closeBtn.addEventListener('click', hideCustomModal);
  const saveBtn = document.getElementById('perEventPingsSave');
  if (saveBtn) saveBtn.addEventListener('click', () => {
    Object.keys(auditPingLabels).forEach(id => {
      const input = document.getElementById('perEventPing_' + id);
      if (input) auditPerEventPingsDraft[id] = splitIdTokens(input.value);
    });
    saveAuditLogSettings();
  });
}

function openLivePreviewModal() {
  const preview = document.getElementById('livePreviewContent');
  const html = preview ? preview.innerHTML : '<div style="color:#72767d;font-size:14px;padding:20px;text-align:center">Select events above to see preview...</div>';
  const actionBar = '<div style="display:flex;gap:10px;justify-content:flex-end;margin-top:18px">'
    + '<button type="button" id="livePreviewClose" style="background:#3a3a42;color:#ffffff;border:1px solid #4a4a52;padding:10px 24px;border-radius:6px;cursor:pointer;font-size:14px;font-weight:500">Close</button>'
    + '</div>';
  showCustomModal('<div><h3 style="margin:0 0 6px 0;font-size:18px;font-weight:600">Live Preview</h3>'
    + '<p style="color:#72767d;margin:0 0 16px 0;font-size:13px">Preview of how your audit log messages will appear in the configured channel.</p>'
    + '<div style="background:#0f0f12;border:1px solid #2f2f3a;border-radius:8px;padding:16px;max-height:500px;overflow-y:auto">' + html + '</div>'
    + actionBar
    + '</div>');

  const closeBtn = document.getElementById('livePreviewClose');
  if (closeBtn) closeBtn.addEventListener('click', hideCustomModal);
}

function splitIdTokens(value) {
  const out = [];
  let buf = '';
  const text = value || '';
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (ch === ',' || ch === ' ' || ch === '\\n' || ch === '\\t' || ch === '\\r') {
      const trimmed = buf.trim();
      if (trimmed) out.push(trimmed);
      buf = '';
      continue;
    }
    buf += ch;
  }
  const last = buf.trim();
  if (last) out.push(last);
  return out;
}

function parseIdList(inputId) {
  const input = document.getElementById(inputId);
  const raw = input ? input.value : '';
  if (!raw || !raw.trim()) return [];
  const normalized = raw.split('\\r').join('');
  const lines = normalized.split('\\n');
  const result = [];
  for (let i = 0; i < lines.length; i++) {
    const parts = lines[i].split(',');
    for (let j = 0; j < parts.length; j++) {
      const trimmed = parts[j].trim();
      if (trimmed) result.push(trimmed);
    }
  }
  return result;
}

function saveAuditLogSettings() {
  const nameChangesChecked = document.getElementById('logUsernameChanges').checked;
  const bansChecked = document.getElementById('logMemberBans').checked;
  const joinsChecked = document.getElementById('logMemberJoins').checked;
  const deletesChecked = document.getElementById('logMessageDeletes').checked;

  const perEventChannels = {};
  const perEventPings = {};

  const channelInputs = document.querySelectorAll('[id^="perEventChannel_"]');
  if (channelInputs.length) {
    channelInputs.forEach(input => {
      const eventId = input.id.replace('perEventChannel_', '');
      const value = input.value.trim();
      if (value) perEventChannels[eventId] = value;
    });
  } else {
    Object.keys(auditPerEventChannelsDraft || {}).forEach(eventId => {
      const value = (auditPerEventChannelsDraft[eventId] || '').trim();
      if (value) perEventChannels[eventId] = value;
    });
  }

  const pingInputs = document.querySelectorAll('[id^="perEventPing_"]');
  if (pingInputs.length) {
    pingInputs.forEach(input => {
      const eventId = input.id.replace('perEventPing_', '');
      if (input.value.trim()) {
        perEventPings[eventId] = splitIdTokens(input.value);
      }
    });
  } else {
    Object.keys(auditPerEventPingsDraft || {}).forEach(eventId => {
      const list = Array.isArray(auditPerEventPingsDraft[eventId]) ? auditPerEventPingsDraft[eventId] : splitIdTokens(String(auditPerEventPingsDraft[eventId] || ''));
      if (list.length) perEventPings[eventId] = list;
    });
  }

  const settings = {
    enabled: document.getElementById('auditEnabled').checked,
    channelId: document.getElementById('auditChannelId').value.trim(),
    logLevel: document.getElementById('auditLogLevel').value,
    logMessageEdits: document.getElementById('logMessageEdits').checked,
    logMessageDeletes: deletesChecked,
    logMessageBulkDeletes: deletesChecked,
    logMessagePins: document.getElementById('logMessagePins').checked,
    logUsernameChanges: nameChangesChecked,
    logAvatarChanges: document.getElementById('logAvatarChanges').checked,
    logNicknameChanges: nameChangesChecked,
    logRoleChanges: document.getElementById('logRoleChanges').checked,
    logMemberJoins: joinsChecked,
    logMemberLeaves: document.getElementById('logMemberLeaves').checked,
    logMemberBans: bansChecked,
    logMemberUnbans: bansChecked,
    logMemberTimeouts: document.getElementById('logMemberTimeouts').checked,
    logMemberMutes: document.getElementById('logMemberMutes').checked,
    logMemberBoosts: document.getElementById('logMemberBoosts').checked,
    logJoinPosition: joinsChecked,
    logServerUpdates: document.getElementById('logServerUpdates').checked,
    logIntegrations: document.getElementById('logIntegrations').checked,
    warnNewAccounts: document.getElementById('warnNewAccounts').checked,
    newAccountThresholdDays: parseInt(document.getElementById('newAccountThresholdDays').value, 10) || 7,
    excludedChannels: parseIdList('excludedChannelsInput'),
    excludedRoles: parseIdList('excludedRolesInput'),
    excludedUsers: parseIdList('excludedUsersInput'),
    muteRoleIds: parseIdList('muteRoleIdsInput'),
    perEventChannels,
    perEventPings
  };

  fetch('/api/audit-log-settings', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(settings)
  })
  .then(r => r.json())
  .then(data => {
    if (data.success) {
      alert('âœ… Member log settings saved!');
      location.reload();
    } else {
      alert('âŒ Error: ' + (data.error || 'Unknown error'));
    }
  })
  .catch(err => alert('âŒ Error: ' + err.message));
}

function updateAuditChannelName() {
  const input = document.getElementById('auditChannelId');
  const label = document.getElementById('auditChannelName');
  if (!input || !label) return;
  const id = input.value.trim();
  if (!id) {
    label.textContent = 'Leave empty to disable logging';
    return;
  }
  fetch('/channel/info/' + id)
    .then(r => r.json())
    .then(data => {
      if (data && data.name) {
        label.textContent = 'Channel: #' + data.name + ' (' + id + ')';
      } else {
        label.textContent = 'Channel not found';
      }
    })
    .catch(() => {
      label.textContent = 'Channel lookup failed';
    });
}

function showLogPreview(type) {
  const previews = {
    memberJoins: 'User {user} joined the server. Example: "âœ… User Antho joined the server (ID: 123)"',
    memberLeaves: 'User {user} left the server. Example: "âŒ User Antho left the server (ID: 123)"',
    memberBans: 'User {user} was banned. Example: "â›” User Antho banned (Reason: spam)"',
    memberUnbans: 'User {user} was unbanned. Example: "âœ… User Antho unbanned"',
    memberTimeouts: 'User {user} timed out or timeout expired. Example: "â±ï¸ User Antho timed out (10m)"',
    memberMutes: 'Mute role added/removed. Example: "ðŸ”‡ User Antho muted (Mute Role)"',
    memberBoosts: 'Boost started or ended. Example: "ðŸ’œ User Antho started boosting"',
    joinPosition: 'Join position is recorded. Example: "#152 joined"',
    warnNew: 'New account detected: {user} created {age} days ago. Example: "âš ï¸ New account: User Antho (2 days old)"',
    username: 'Username changed from OldName to NewName. Example: "âœï¸ Username changed: OldName â†’ NewName"',
    nickname: 'Nickname changed from OldNick to NewNick. Example: "âœï¸ Nickname changed: OldNick â†’ NewNick"',
    avatar: 'Avatar changed. Example: "ðŸ–¼ï¸ Avatar updated for User Antho"',
    role: 'Roles updated: added @Mod, removed @Guest. Example: "ðŸ”§ Roles updated for User Antho: +@Mod -@Guest"',
    messageEdits: 'Message edited. Example: "âœï¸ Message edited by User Antho: before â†’ after"',
    messageDeletes: 'Message deleted. Example: "ðŸ—‘ï¸ Message deleted in #general"',
    messageBulkDeletes: 'Bulk delete. Example: "ðŸ§¹ 25 messages deleted in #general"',
    messagePins: 'Message pinned/unpinned. Example: "ðŸ“Œ Message pinned by User Antho"',
    serverUpdates: 'Server settings updated. Example: "âš™ï¸ Server name changed"',
    integrations: 'Integrations or bots updated. Example: "ðŸ”Œ Integration added by Mod"'
  };

  const text = previews[type] || 'No preview available for this item.';
  if (typeof showCustomModal === 'function') {
    showCustomModal('<div style="padding:12px"><h3 style="margin-top:0">Preview</h3><div style="color:#ddd;font-size:13px;white-space:pre-wrap">' + text + '</div></div>');
  } else {
    alert(text);
  }
}

document.addEventListener('DOMContentLoaded', function() {
  const data = document.getElementById('auditLogData');
  if (data) {
    try {
      auditPerEventChannelsDraft = JSON.parse(data.getAttribute('data-per-event-channels') || '{}') || {};
    } catch {
      auditPerEventChannelsDraft = {};
    }
    try {
      auditPerEventPingsDraft = JSON.parse(data.getAttribute('data-per-event-pings') || '{}') || {};
    } catch {
      auditPerEventPingsDraft = {};
    }
  }
  if (document.getElementById('auditChannelId')) {
    updateAuditChannelName();
  }
  if (document.getElementById('livePreviewContent')) {
    updateLivePreview();
  }
});
</script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="/socket.io/socket.io.js"></script>
<script src="/dashboard-actions.js?v=6" defer></script>
</body>
</html>`;
}

/* ======================
   TABS
====================== */

function renderEventsTab(tab) {
  const subTab = tab === 'events' ? 'events-giveaways' : tab;
  const isGiveaways = subTab === 'events-giveaways';
  const isPolls = subTab === 'events-polls';
  const isReminders = subTab === 'events-reminders';
  
  return `
<div class="card" style="margin-bottom:20px">
  <div style="display:flex;gap:8px;flex-wrap:wrap;border-bottom:2px solid #3a3a42;padding-bottom:10px">
    <button class="small" style="width:auto;background:${isGiveaways ? '#9146ff' : '#2a2f3a'};color:white" onclick="location.href='/events?tab=events-giveaways'">ðŸŽ Giveaways</button>
    <button class="small" style="width:auto;background:${isPolls ? '#9146ff' : '#2a2f3a'};color:white" onclick="location.href='/events?tab=events-polls'">ðŸ“Š Polls</button>
    <button class="small" style="width:auto;background:${isReminders ? '#9146ff' : '#2a2f3a'};color:white" onclick="location.href='/events?tab=events-reminders'">â° Reminders</button>
  </div>
</div>

${isGiveaways ? renderGiveawaysContent() : isPolls ? renderPollsContent() : renderRemindersContent()}
`;
}

function renderGiveawaysContent() {
  return renderGiveawaysTab();
}

function renderPollsContent() {
  return renderPollsTab();
}

function renderRemindersContent() {
  return renderRemindersTab();
}

function renderTab(tab, userTier){
 if(tab==='overview') return `
${(() => {
  const totalGiveaways = giveaways.length;
  const activeGiveaways = giveaways.filter(g => g.active && g.endTime > Date.now() && !g.paused).length;
  const avgEntries = totalGiveaways === 0 ? 0 : Math.round(giveaways.reduce((sum, g) => {
    const count = Number.isFinite(g.entryCount)
      ? g.entryCount
      : (Array.isArray(g.entries) ? g.entries.length : (Array.isArray(g.participants) ? g.participants.length : 0));
    return sum + count;
  }, 0) / totalGiveaways);
  const tagCounts = giveaways.reduce((acc, g) => {
    const tag = g.tag || 'none';
    acc[tag] = (acc[tag] || 0) + 1;
    return acc;
  }, {});
  const topTags = Object.entries(tagCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([tag, count]) => `${tag} (${count})`)
    .join(', ') || 'N/A';

  return `
  <div class="card">
    <h2>ðŸ“ˆ Giveaway Stats</h2>
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px">
      <div style="padding:10px;background:#26262c;border-radius:6px">Total: <b>${totalGiveaways}</b></div>
      <div style="padding:10px;background:#26262c;border-radius:6px">Active: <b>${activeGiveaways}</b></div>
      <div style="padding:10px;background:#26262c;border-radius:6px">Avg Entries: <b>${avgEntries}</b></div>
      <div style="padding:10px;background:#26262c;border-radius:6px">Top Tags: <b>${topTags}</b></div>
    </div>
  </div>
  `;
})()}

<div class="card">
  <h2>ðŸ¤– Bot Status</h2>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:15px;margin:15px 0">
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;text-align:center">
      <div style="font-size:12px;color:#b0b0b0">Stream Status</div>
      <div style="font-size:24px;margin:10px 0">${streamInfo.startedAt?'ðŸ”´':'âš«'}</div>
      <div style="font-weight:bold">${streamInfo.startedAt?'LIVE':'OFFLINE'}</div>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;text-align:center">
      <div style="font-size:12px;color:#b0b0b0">Viewers</div>
      <div style="font-size:24px;margin:10px 0;color:#9146ff">${streamInfo.viewers}</div>
      <div style="font-weight:bold">Current</div>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;text-align:center">
      <div style="font-size:12px;color:#b0b0b0">Total Streams</div>
      <div style="font-size:24px;margin:10px 0;color:#4caf50">${stats.totalStreams}</div>
      <div style="font-weight:bold">All Time</div>
    </div>
  </div>
  <p style="font-size:13px;color:#999;margin-top:15px">ðŸŒ <b>Timezone:</b> ${botTimezone} | ðŸ”‘ <b>Auth:</b> ${TWITCH_ACCESS_TOKEN ? 'âœ… Active' : 'âŒ Not set'}</p>
  <p style="font-size:13px;color:#999;margin-top:4px">â±ï¸ <b>Last stream check:</b> ${lastStreamCheckAt ? new Date(lastStreamCheckAt).toLocaleTimeString() : 'â€”'}</p>
</div>

<div class="card">
  <h2>âš™ï¸ Quick Actions</h2>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <button class="small" onclick="showVIPs()">ðŸ‘‘ View VIPs</button>
    <button class="small" onclick="fetch('/test-live',{method:'POST'}).then(()=>alert('Fake live triggered'))">â–¶ï¸ Fake Live</button>
    <button class="small" onclick="fetch('/test-end',{method:'POST'}).then(()=>alert('Fake end triggered'))">â¹ï¸ Fake End</button>
    <button class="small" onclick="testAlert('1h')">ðŸ”” Test 1h Alert</button>
    <button class="small" onclick="testAlert('10m')">ðŸ”” Test 10m Alert</button>
    <button class="small" onclick="if(confirm('Reset delay mark?'))fetch('/reset-delay-mark',{method:'POST'}).then(()=>location.reload())">ðŸ§¹ Reset Delay Mark</button>
    <button class="small danger" onclick="if(confirm('Reset live state?'))fetch('/reset-live',{method:'POST'}).then(()=>location.reload())">ðŸ”„ Reset Live</button>
  </div>
</div>

<div class="card">
  <h2>ðŸ” Twitch Authorization</h2>
  <p>Status: ${TWITCH_ACCESS_TOKEN ? '<span style="color:#4caf50">âœ… Token Active</span>' : '<span style="color:#ef5350">âŒ Not Authorized</span>'}</p>
  ${twitchTokens.expires_at ? `<p style="font-size:12px;color:#999">Expires: <strong>${new Date(twitchTokens.expires_at).toLocaleString()}</strong></p>` : ''}
  <a href="/auth/twitch" style="display:inline-block;background:#9146ff;color:white;padding:10px 20px;border-radius:4px;text-decoration:none;font-weight:bold;margin:10px 0">Authorize with Twitch</a>
  <button class="small" style="width:auto" onclick="fetch('/twitch/reload',{method:'POST'}).then(r=>r.json()).then(d=>{ if(d.success){ alert('Twitch reloaded. Refreshing...'); location.reload(); } else { alert('Reload failed: ' + (d.error||'Unknown')); } }).catch(e=>alert('Reload failed'))">Reload token from .env</button>
  <button class="small" style="width:auto" onclick="fetch('/twitch/refresh',{method:'POST'}).then(r=>r.json()).then(d=>{ alert(d.message); if(d.success) location.reload(); }).catch(e=>alert('Refresh failed'))">ðŸ”„ Refresh Token Now</button>
  <p style="font-size:11px;color:#888;margin-top:10px">ðŸ¤– <strong>Automatic refresh:</strong> Every 20 minutes</p>
  <p style="font-size:11px;color:#27ae60;margin-top:4px">ðŸ›¡ï¸ <strong>Safeguard active:</strong> Auto-refreshes on token errors (5min cooldown)</p>
  <p style="font-size:12px;color:#999;margin-top:10px">Need help? <a href="#" onclick="document.getElementById('setup').style.display='block';return false">View Setup Instructions</a></p>
  
  <details id="setup" style="margin-top:15px">
    <summary style="cursor:pointer;color:#9146ff;font-weight:bold">ðŸ“‹ Setup Instructions</summary>
    <ol style="color:#b0b0b0;margin-top:10px">
      <li>Go to <a href="https://dev.twitch.tv/console/apps" target="_blank">Twitch Developer Console</a></li>
      <li>Create or edit your application</li>
      <li>Set <b>OAuth Redirect URL</b> to: <code>http://localhost:3000/auth/twitch/callback</code></li>
      <li>Copy <b>Client ID</b> and <b>Client Secret</b></li>
      <li>Add to .env file:
        <pre>TWITCH_CLIENT_ID=your_client_id
TWITCH_CLIENT_SECRET=your_client_secret
TWITCH_REDIRECT_URI=http://localhost:3000/auth/twitch/callback</pre>
      </li>
      <li>Restart the bot</li>
      <li>Click the authorization button above</li>
    </ol>
  </details>
</div>

<div class="card">
  <h2>ðŸ“Š Current Stream Info</h2>
  <table>
    <tr>
      <td><b>Title:</b></td>
      <td>${streamInfo.title}</td>
    </tr>
    <tr>
      <td><b>Game:</b></td>
      <td>${streamInfo.game}</td>
    </tr>
    <tr>
      <td><b>Peak Viewers:</b></td>
      <td>${stats.peakViewers}</td>
    </tr>
    <tr>
      <td><b>Total Engagement (Avg Sum):</b></td>
      <td>${stats.totalViewers}</td>
    </tr>
  </table>
</div>

<div class="card">
  <h2>ðŸ“– Getting Started</h2>
  <p>View all available commands in the <a href="/commands"><b>Commands</b></a> tab.</p>
  <p>Common tasks:</p>
  <ul>
    <li><a href="/commands">View all slash commands</a></li>
    <li><a href="/options">Configure notification role</a></li>
    <li><a href="/settings">Manage notification preferences</a></li>
    <li><a href="/logs">View bot activity logs</a></li>
    <li><a href="/stats">View stream statistics</a></li>
  </ul>
</div>

<div id="vipModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:1000;align-items:center;justify-content:center">
  <div style="background:#1f1f23;padding:30px;border-radius:8px;max-width:600px;width:90%;max-height:80vh;overflow-y:auto;position:relative">
    <button onclick="closeVIPModal()" style="position:absolute;top:10px;right:10px;width:auto;padding:5px 10px;background:#c43c3c">âœ–</button>
    <h2 style="margin-top:0;color:#9146ff">ðŸ‘‘ Channel VIPs</h2>
    <div id="vipContent">Loading...</div>
  </div>
</div>

<script>
function showVIPs() {
  const modal = document.getElementById('vipModal');
  modal.style.display = 'flex';
  
  fetch('/api/vips')
    .then(r => r.json())
    .then(data => {
      const content = document.getElementById('vipContent');
      if (data.error) {
        content.innerHTML = '<p style="color:#ef5350">âŒ Error: ' + data.error + '</p><p style="color:#999;font-size:13px">Note: Your Twitch token may need additional scopes (channel:read:vips or moderator:read:chat_settings)</p>';
      } else if (data.vips && data.vips.length > 0) {
        content.innerHTML = '<div style="display:grid;gap:10px">' + 
          data.vips.map(vip => 
            '<div style="background:#2a2f3a;padding:15px;border-radius:6px;display:flex;justify-content:space-between;align-items:center">' +
            '<div><div style="font-weight:bold;color:#e0e0e0">' + vip.user_name + '</div>' +
            '<div style="font-size:12px;color:#999">ID: ' + vip.user_id + '</div></div>' +
            '<span style="background:#9146ff;color:white;padding:4px 8px;border-radius:4px;font-size:12px">VIP</span>' +
            '</div>'
          ).join('') + 
          '</div><p style="color:#999;margin-top:15px">Total VIPs: ' + data.vips.length + '</p>';
      } else {
        content.innerHTML = '<p style="color:#999;font-style:italic">No VIPs found for this channel.</p>';
      }
    })
    .catch(err => {
      document.getElementById('vipContent').innerHTML = '<p style="color:#ef5350">Failed to load VIPs: ' + err.message + '</p>';
    });
}

function closeVIPModal() {
  document.getElementById('vipModal').style.display = 'none';
}

function testAlert(type) {
  fetch('/api/test-alert/' + type, { method: 'POST' })
    .then(r => {
      if (!r.ok) throw new Error('Server error');
      return r.json();
    })
    .then(() => alert('Test alert sent: ' + type))
    .catch(err => {
      console.error(err);
      alert('Failed to send test alert');
    });
}
</script>
`;

  if(tab==='logs') return `
<div class="card">
<h2>ðŸ“‹ Logs</h2>
<p style="color:#b0b0b0">Total logs: ${logs.length} | Showing last 500 entries</p>

<div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:15px">
  <input id="search" placeholder="ðŸ” Search logs..." style="flex:1;min-width:200px">
  <input id="startDate" type="date" style="width:140px" onchange="filterLogs()">
  <input id="endDate" type="date" style="width:140px" onchange="filterLogs()">
</div>

<div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:15px">
  <button class="small" onclick="filterType('all')">All Types</button>
  <button class="small" onclick="filterType('info')">â„¹ï¸ Info</button>
  <button class="small" onclick="filterType('live')">ðŸ”´ Live</button>
  <button class="small" onclick="filterType('offline')">âš« Offline</button>
  <button class="small" onclick="filterType('error')">âŒ Error</button>
  <button class="small" onclick="filterType('milestone')">ðŸ† Milestone</button>
  <button class="small" onclick="filterType('warning')">âš ï¸ Warning</button>
</div>

<div style="display:flex;gap:8px;flex-wrap:wrap">
  <button class="small" onclick="sortLogs('newest')" style="background:#5b5bff">â¬†ï¸ Newest First</button>
  <button class="small" onclick="sortLogs('oldest')">â¬‡ï¸ Oldest First</button>
  <button class="small" onclick="exportLogs()" style="margin-left:auto">â¬‡ï¸ Export</button>
  <button class="small danger" onclick="clearLogs()">ðŸ—‘ï¸ Clear All</button>
</div>

<div style="margin-top:15px;max-height:600px;overflow-y:auto;border:1px solid #3a3a42;border-radius:4px;padding:10px;background:#1a1a1d">
<div id="logbox">
${logs.slice(0, 500).map(l=>`<div class="log ${l.type}" style="margin-bottom:5px" data-time="${l.time}" data-type="${l.type}">[${l.time}] ${l.msg}</div>`).join('')}
</div>
</div>
</div>

<script>
let currentFilter = 'all';
let currentSort = 'newest';

function filterType(type) {
  currentFilter = type;
  document.querySelectorAll('button.small').forEach(b => b.style.background = '');
  event.target.style.background = '#5b5bff';
  filterLogs();
}

function filterLogs() {
  const search = document.getElementById('search').value.toLowerCase();
  const startDate = document.getElementById('startDate').value;
  const endDate = document.getElementById('endDate').value;
  
  document.querySelectorAll('.log').forEach(el => {
    const typeMatch = currentFilter === 'all' || el.classList.contains(currentFilter);
    const textMatch = el.textContent.toLowerCase().includes(search);
    
    let dateMatch = true;
    if (startDate || endDate) {
      const logTime = el.getAttribute('data-time');
      const logDate = logTime ? logTime.split(' ')[0] : '';
      if (startDate && logDate < startDate) dateMatch = false;
      if (endDate && logDate > endDate) dateMatch = false;
    }
    
    el.style.display = typeMatch && textMatch && dateMatch ? 'block' : 'none';
  });
}

function sortLogs(order) {
  currentSort = order;
  const container = document.getElementById('logbox');
  const logs = [...container.querySelectorAll('.log')];
  
  if (order === 'oldest') {
    logs.reverse();
  }
  
  container.innerHTML = '';
  logs.forEach(log => container.appendChild(log));
}

function clearLogs() {
  if (confirm('âš ï¸ Are you sure? This will delete ALL logs.')) {
    fetch('/logs/clear', {method: 'POST'}).then(() => location.reload());
  }
}

function exportLogs() {
  const logData = ${JSON.stringify(logs)};
  const json = JSON.stringify(logData, null, 2);
  const blob = new Blob([json], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'logs_' + new Date().toISOString().split('T')[0] + '.json';
  a.click();
}

document.getElementById('search').addEventListener('input', filterLogs);
</script>`;


  if(tab==='options' || tab==='settings' || tab==='config') return renderConfigTab();
  if (tab === 'stats') return getCachedAnalytics('stats', renderAnalyticsTab);
  if (tab === 'stats-engagement') return getCachedAnalytics('stats-engagement', renderEngagementStatsTab);
  if (tab === 'stats-trends') return getCachedAnalytics('stats-trends', renderTrendsStatsTab);
  if (tab === 'stats-games') return getCachedAnalytics('stats-games', renderGamePerformanceTab);
  if (tab === 'stats-viewers') return getCachedAnalytics('stats-viewers', renderViewerPatternsTab);
  if (tab === 'stats-ai') return getCachedAnalytics('stats-ai', renderAIInsightsTab);
  if (tab === 'stats-reports') return getCachedAnalytics('stats-reports', renderReportsTab);
  if (tab === 'stats-community') return getCachedAnalytics('stats-community', renderCommunityStatsTab);
  if (tab === 'stats-rpg') return getCachedAnalytics('stats-rpg', renderRPGAnalyticsTab);
  if (tab === 'stats-rpg-events') return renderRPGEventsTab();
  if (tab === 'stats-rpg-economy') return getCachedAnalytics('stats-rpg-economy', renderRPGEconomyTab);
  if (tab === 'stats-rpg-quests') return getCachedAnalytics('stats-rpg-quests', renderRPGQuestsCombatTab);
  if (tab === 'stats-compare') return getCachedAnalytics('stats-compare', renderStreamCompareTab);

  if (tab === 'suggestions') return renderSuggestionsTab();
  if (tab === 'settings') return renderSettingsTab();
  if (tab === 'commands' || tab === 'commands-config' || tab === 'config-commands') return renderCommandsAndConfigTab(tab);
  if (tab === 'config') return renderConfigTab();
  if (tab === 'notifications') return renderNotificationsTab();
  if (tab === 'customcmds') return renderCustomCommandsTab();
  if (tab === 'leveling') return renderLevelingTab();
  if (tab === 'giveaways') return renderGiveawaysTab();
  if (tab === 'polls') return renderPollsTab();
  if (tab === 'reminders') return renderRemindersTab();
  if (tab === 'events' || tab === 'events-giveaways' || tab === 'events-polls' || tab === 'events-reminders') return renderEventsTab(tab);
  if (tab === 'embeds') return renderEmbedsTab();
  if (tab === 'welcome') return renderWelcomeTab();
  if (tab === 'audit') return renderAuditLogTab();
  if (tab === 'health') return renderHealthTab();
  if (tab === 'rpg-editor') return renderRPGEditorTab();
  if (tab === 'rpg-worlds') return renderRPGWorldsTab();
  if (tab === 'rpg-entities') return renderRPGEntitiesTab();
  if (tab === 'rpg-systems') return renderRPGSystemsTab();
  if (tab === 'rpg-ai') return renderRPGAITab();
  if (tab === 'rpg-flags') return renderRPGFlagsTab();
  if (tab === 'rpg-simulators') return renderRPGSimulatorsTab();
  if (tab === 'rpg-guild') return renderRPGGuildTab();
  if (tab === 'rpg-guild-stats') return renderRPGGuildStatsTab();
  if (tab === 'rpg-admin') return renderRPGAdminTab();
  if (tab === 'pets') return renderPetsTab(userTier);
  if (tab === 'pet-giveaways') return renderPetGiveawaysTab(userTier);
  if (tab === 'pet-stats') return renderPetStatsTab(userTier);
  if (tab === 'accounts') return renderAccountsTab();

  return `<div class="card"><h2>Unknown Tab</h2></div>`;
}

// ====================== PETS TAB ======================
function renderPetsTab(userTier) {
  const canEdit = userTier !== 'viewer';
  const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
  const catalog = petsData.catalog || [];
  const pets = petsData.pets || [];
  const categories = petsData.categories || [...new Set(catalog.map(p => p.category).filter(Boolean))];
  const giveawaysData = loadJSON(GIVEAWAYS_PATH, { history: [] });
  const pendingGiveaways = (giveawaysData.history || []).filter(g => !g.confirmed);

  // Serialize data for client-side use - escape properly for inline JavaScript
  const catalogJSON = JSON.stringify(catalog);
  const petsJSON = JSON.stringify(pets);
  const categoriesJSON = JSON.stringify(categories);
  const pendingJSON = JSON.stringify(pendingGiveaways.map(g => ({ petId: g.petId, winner: g.winner, giver: g.giver })));
  console.log('[Pets Server] Rendering tab with', catalog.length, 'catalog pets,', pets.length, 'owned,', categories.length, 'categories');

  return '<div class="card">'
    + '<h2>ðŸ¾ Server Pets</h2>'
    + '<p style="color:#8b8fa3;font-size:13px;margin-top:-4px">Manage your server\'s pet collection. Members can add pets via the <code>/pet add</code> command.</p>'
    + '<div id="pets-stats" style="display:flex;gap:12px;margin:16px 0;flex-wrap:wrap"></div>'
    + '</div>'

    // Filters
    + '<div class="card">'
    + '<h2>ðŸ” Filters</h2>'
    + '<div style="margin-bottom:12px"><input type="text" id="filter-search" oninput="applyFilters()" placeholder="Search pets by name..." style="width:100%;padding:8px 14px;background:#16161a;border:1px solid #333;border-radius:8px;color:#e0e0e0;font-size:14px;outline:none;box-sizing:border-box" onfocus="this.style.borderColor=\'#9146ff\'" onblur="this.style.borderColor=\'#333\'"></div>'
    + '<div style="display:flex;gap:12px;flex-wrap:wrap;align-items:end">'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase;letter-spacing:.5px">Rarity</label>'
    + '<select id="filter-rarity" onchange="applyFilters()" style="margin:4px 0"><option value="">All Rarities</option><option value="common">Common</option><option value="uncommon">Uncommon</option><option value="rare">Rare</option><option value="legendary">Legendary</option></select></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase;letter-spacing:.5px">Category</label>'
    + '<select id="filter-category" onchange="applyFilters()" style="margin:4px 0"><option value="">All Categories</option></select></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase;letter-spacing:.5px">Owned Count â‰¥</label>'
    + '<input type="number" id="filter-count" min="0" value="" placeholder="e.g. 1" onchange="applyFilters()" style="margin:4px 0;width:80px"></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase;letter-spacing:.5px">Show Hidden</label>'
    + '<select id="filter-hidden" onchange="applyFilters()" style="margin:4px 0"><option value="no">Hide Hidden</option><option value="yes">Show All</option></select></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase;letter-spacing:.5px">Given By</label>'
    + '<select id="filter-givenby" onchange="applyFilters()" style="margin:4px 0"><option value="">All Givers</option></select></div>'
    + '<button onclick="clearFilters()" style="padding:6px 14px;background:#333;color:#ccc;border:1px solid #555;border-radius:6px;cursor:pointer;margin-bottom:4px;height:36px">Clear</button>'
    + '</div></div>'

    // Our Pets section
    + '<div class="card">'
    + '<h2 style="cursor:pointer;user-select:none" onclick="toggleSection(\'owned-section\',this)">ðŸ“¦ Our Pets (<span id="owned-count">0</span>) <span style="font-size:12px;color:#8b8fa3;margin-left:8px">â–¼</span></h2>'
    + (canEdit ? '<div style="display:flex;flex-direction:row;gap:8px;margin-bottom:12px;align-items:center">'
    + '<button onclick="clearAllPets()" style="padding:8px 16px;background:#e74c3c22;color:#e74c3c;border:1px solid #e74c3c44;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;white-space:nowrap">ðŸ—‘ï¸ Clear All Pets</button>'
    + '<button onclick="openRandomPicker()" style="padding:8px 16px;background:#9b59b622;color:#9b59b6;border:1px solid #9b59b644;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;white-space:nowrap">ðŸŽ² Random Pet</button>'
    + '<button onclick="openSuggestBest()" style="padding:8px 16px;background:#f39c1222;color:#f39c12;border:1px solid #f39c1244;border-radius:6px;cursor:pointer;font-size:13px;font-weight:600;white-space:nowrap">ðŸ’¡ Suggest Best</button>'
    + '</div>' : '')
    + '<div id="owned-section"></div>'
    + '</div>'

    // Catalog sections (dynamically rendered)
    + '<div id="catalog-sections"></div>'

    // Edit modal
    + '<div id="edit-modal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.85);z-index:2000;align-items:center;justify-content:center;padding:20px;box-sizing:border-box">'
    + '<div style="background:#1e1e1e;padding:30px;border-radius:12px;max-width:520px;width:100%;max-height:80vh;overflow-y:auto">'
    + '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px"><h2 id="edit-title" style="margin:0">Edit Pet</h2><button onclick="closeEditModal()" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">&times;</button></div>'
    + '<input type="hidden" id="edit-id">'
    + '<div style="display:grid;gap:12px">'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Rarity</label><select id="edit-rarity" style="margin:4px 0"><option value="common">Common</option><option value="uncommon">Uncommon</option><option value="rare">Rare</option><option value="legendary">Legendary</option></select></div>'
    + '<div style="display:grid;grid-template-columns:1fr 1fr;gap:8px"><div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Tier Rank</label><select id="edit-tier" style="margin:4px 0"><option value="">No Tier</option><option value="S">S Rank</option><option value="A">A Rank</option><option value="B">B Rank</option><option value="C">C Rank</option><option value="D">D Rank</option></select></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Tier Points (0-100)</label><input type="number" id="edit-tierPoints" min="0" max="100" value="" placeholder="0-100" style="margin:4px 0;width:100%"></div></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Description</label><textarea id="edit-description" rows="3" style="margin:4px 0;resize:vertical"></textarea></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Bonus / Effect</label><input type="text" id="edit-bonus" placeholder="e.g. +10% XP, +5 Luck" style="margin:4px 0"></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Static Image <span style="color:#555">(.png, .jpg, .webp)</span></label>'
    + '<div id="drop-imageUrl" style="margin:4px 0;border:2px dashed #444;border-radius:8px;padding:16px;text-align:center;cursor:pointer;transition:border-color .2s,background .2s;min-height:80px;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px" onclick="document.getElementById(\'file-imageUrl\').click()" ondragover="event.preventDefault();this.style.borderColor=\'#9146ff\';this.style.background=\'#9146ff11\'" ondragleave="this.style.borderColor=\'#444\';this.style.background=\'\'" ondrop="event.preventDefault();this.style.borderColor=\'#444\';this.style.background=\'\';handleDrop(event,\'imageUrl\')">'  
    + '<div id="drop-imageUrl-preview"></div>'
    + '<div id="drop-imageUrl-text" style="color:#8b8fa3;font-size:12px">ðŸ“ Drag &amp; drop image here or click to browse</div>'
    + '<input type="file" id="file-imageUrl" accept="image/png,image/jpeg,image/webp" style="display:none" onchange="handleFileSelect(this,\'imageUrl\')">'
    + '<input type="hidden" id="edit-imageUrl">'
    + '<div id="drop-imageUrl-loading" style="display:none;color:#9146ff;font-size:12px">â³ Uploading...</div>'
    + '</div></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Animated Image <span style="color:#555">(.gif) â€” optional override</span></label>'
    + '<div id="drop-animatedUrl" style="margin:4px 0;border:2px dashed #444;border-radius:8px;padding:16px;text-align:center;cursor:pointer;transition:border-color .2s,background .2s;min-height:80px;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px" onclick="document.getElementById(\'file-animatedUrl\').click()" ondragover="event.preventDefault();this.style.borderColor=\'#9146ff\';this.style.background=\'#9146ff11\'" ondragleave="this.style.borderColor=\'#444\';this.style.background=\'\'" ondrop="event.preventDefault();this.style.borderColor=\'#444\';this.style.background=\'\';handleDrop(event,\'animatedUrl\')">'  
    + '<div id="drop-animatedUrl-preview"></div>'
    + '<div id="drop-animatedUrl-text" style="color:#8b8fa3;font-size:12px">ðŸ“ Drag &amp; drop .gif here or click to browse</div>'
    + '<input type="file" id="file-animatedUrl" accept="image/gif" style="display:none" onchange="handleFileSelect(this,\'animatedUrl\')">'
    + '<input type="hidden" id="edit-animatedUrl">'
    + '<div id="drop-animatedUrl-loading" style="display:none;color:#9146ff;font-size:12px">â³ Uploading...</div>'
    + '</div></div>'
    + '<div style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="edit-hidden"><label for="edit-hidden" style="font-size:12px;color:#b0b0b0;cursor:pointer">Hidden (hide from catalog & our pets)</label></div>'
    + '<div id="edit-preview" style="text-align:center;padding:10px;background:#111;border-radius:8px;min-height:80px"></div>'
    + '<div style="display:flex;gap:10px;margin-top:8px">'
    + '<button onclick="saveEdit()" style="flex:1;padding:10px;background:#9146ff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:700">ðŸ’¾ Save Changes</button>'
    + '<button onclick="closeEditModal()" style="flex:1;padding:10px;background:#333;color:#ccc;border:1px solid #555;border-radius:6px;cursor:pointer">Cancel</button>'
    + '</div></div></div></div>'

    // Giveaway modal
    + '<div id="giveaway-modal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.85);z-index:2000;align-items:center;justify-content:center;padding:20px;box-sizing:border-box">'
    + '<div style="background:#1e1e1e;padding:30px;border-radius:12px;max-width:480px;width:100%;max-height:80vh;overflow-y:auto">'
    + '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px"><h2 style="margin:0">ðŸŽ Pet Giveaway</h2><button onclick="closeGiveawayModal()" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">&times;</button></div>'
    + '<input type="hidden" id="giveaway-petId">'
    + '<div id="giveaway-pet-info" style="text-align:center;margin-bottom:16px"></div>'
    + '<div style="display:grid;gap:12px">'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Winner Name</label><input type="text" id="giveaway-winner" placeholder="Discord username of the winner" style="margin:4px 0"></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Given By</label>'
    + '<select id="giveaway-giver-select" onchange="onGiveawayGiverChange()" style="margin:4px 0;width:100%"><option value="">(select)</option></select></div>'
    + '<div><input type="text" id="giveaway-giver-other" placeholder="Type a name..." style="margin:4px 0;width:100%;display:none;box-sizing:border-box"></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Notes (optional)</label><input type="text" id="giveaway-notes" placeholder="Any extra info..." style="margin:4px 0"></div>'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Auto-cancel after (hours, optional)</label><input type="number" id="giveaway-expiration" placeholder="0" min="0" step="0.5" style="margin:4px 0;width:100%"></div>'
    + '<div style="display:flex;gap:16px;margin:8px 0">'
    + '<label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:12px;color:#b0b0b0"><input type="checkbox" id="giveaway-ping-giver"><span>ðŸ”” Ping Giver</span></label>'
    + '<label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:12px;color:#b0b0b0"><input type="checkbox" id="giveaway-ping-receiver" checked><span>ðŸ”” Ping Receiver</span></label>'
    + '</div>'
    + '<button onclick="submitGiveaway()" style="padding:10px;background:#2ecc71;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:700">ðŸŽ Submit Giveaway</button>'
    + '</div></div></div>'

    // Random picker modal
    + '<div id="random-modal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.85);z-index:2000;align-items:center;justify-content:center;padding:20px;box-sizing:border-box">'
    + '<div style="background:#1e1e1e;padding:30px;border-radius:12px;max-width:520px;width:100%;max-height:80vh;overflow-y:auto">'
    + '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px"><h2 style="margin:0">ðŸŽ² Random Pet Picker</h2><button onclick="closeRandomModal()" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">&times;</button></div>'
    + '<p style="color:#8b8fa3;font-size:12px;margin-top:0">Select which owned pets to include, then spin!</p>'
    + '<div style="margin-bottom:12px"><button onclick="randomSelectAll(true)" style="padding:4px 12px;background:#333;color:#ccc;border:1px solid #555;border-radius:4px;cursor:pointer;font-size:11px;margin-right:6px">Select All</button><button onclick="randomSelectAll(false)" style="padding:4px 12px;background:#333;color:#ccc;border:1px solid #555;border-radius:4px;cursor:pointer;font-size:11px">Deselect All</button></div>'
    + '<div id="random-pet-list" style="max-height:300px;overflow-y:auto;margin-bottom:16px"></div>'
    + '<button onclick="spinRandom()" style="width:100%;padding:12px;background:#9b59b6;color:#fff;border:none;border-radius:8px;cursor:pointer;font-weight:700;font-size:16px">ðŸŽ² SPIN!</button>'
    + '<div id="random-result" style="margin-top:16px;text-align:center;min-height:60px"></div>'
    + '</div></div>'

    // Suggest best modal
    + '<div id="suggest-modal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.85);z-index:2000;align-items:center;justify-content:center;padding:20px;box-sizing:border-box">'
    + '<div style="background:#1e1e1e;padding:30px;border-radius:12px;max-width:480px;width:100%;max-height:80vh;overflow-y:auto">'
    + '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px"><h2 style="margin:0">ðŸ’¡ Suggested Best Pet</h2><button onclick="closeSuggestModal()" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">&times;</button></div>'
    + '<p style="color:#8b8fa3;font-size:12px;margin-top:0">The best pet you do not own yet, based on tier rank and points.</p>'
    + '<div id="suggest-result" style="text-align:center;min-height:100px"></div>'
    + '</div></div>'

    // GivenBy selector modal
    + '<div id="givenby-modal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.85);z-index:2000;align-items:center;justify-content:center;padding:20px;box-sizing:border-box">'
    + '<div style="background:#1e1e1e;padding:30px;border-radius:12px;max-width:400px;width:100%">'
    + '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px"><h2 style="margin:0">ðŸŽ Given By</h2><button onclick="closeGivenByModal()" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">&times;</button></div>'
    + '<p style="color:#8b8fa3;font-size:12px;margin-top:0">Who gave this pet? Pick from the list or type a new name.</p>'
    + '<div style="display:grid;gap:12px">'
    + '<div><label style="font-size:11px;color:#8b8fa3;text-transform:uppercase">Select Giver</label>'
    + '<select id="givenby-select" onchange="onGivenBySelectChange()" style="margin:4px 0;width:100%"><option value="">(no one)</option></select></div>'
    + '<div><input type="text" id="givenby-other" placeholder="Type a name..." style="margin:4px 0;width:100%;display:none;box-sizing:border-box"></div>'
    + '<div style="display:flex;gap:10px;margin-top:8px">'
    + '<button onclick="confirmAddPet()" style="flex:1;padding:10px;background:#9146ff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:700">âž• Add Pet</button>'
    + '<button onclick="closeGivenByModal()" style="flex:1;padding:10px;background:#333;color:#ccc;border:1px solid #555;border-radius:6px;cursor:pointer">Cancel</button>'
    + '</div></div></div></div>'

    // Remove picker modal
    + '<div id="remove-picker-modal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.85);z-index:2000;align-items:center;justify-content:center;padding:20px;box-sizing:border-box">'
    + '<div style="background:#1e1e1e;padding:30px;border-radius:12px;max-width:400px;width:100%">'
    + '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px"><h2 id="remove-picker-title" style="margin:0">Remove Pet</h2><button onclick="document.getElementById(\'remove-picker-modal\').style.display=\'none\'" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">&times;</button></div>'
    + '<p style="color:#8b8fa3;font-size:12px;margin-top:0">Choose which giver\'s pet to remove:</p>'
    + '<div id="remove-picker-list"></div>'
    + '<button onclick="document.getElementById(\'remove-picker-modal\').style.display=\'none\'" style="margin-top:12px;width:100%;padding:8px;background:#333;color:#ccc;border:1px solid #555;border-radius:6px;cursor:pointer">Cancel</button>'
    + '</div></div>'

    // Script
    + '<script>'
    + 'console.log("[Pets] Script tag loaded");'
    + '(function(){'
    + 'console.log("[Pets] IIFE starting");'
    + '["edit-modal","giveaway-modal","random-modal","suggest-modal","givenby-modal","remove-picker-modal"].forEach(function(id){var m=document.getElementById(id);if(m)document.body.appendChild(m);});'
    + 'try{'
    + 'console.log("[Pets] Initializing...");'
    + 'var catalog=' + catalogJSON + ';'
    + 'var pets=' + petsJSON + ';'
    + 'var categories=' + categoriesJSON + ';'
    + 'var canEdit=' + (canEdit ? 'true' : 'false') + ';'
    + 'var pendingGiveaways=' + pendingJSON + ';'
    + 'console.log("[Pets] Loaded:",catalog.length,"pets in catalog,",pets.length,"owned,",categories.length,"categories");'
    + 'var rarityColors={common:"#8b8fa3",uncommon:"#2ecc71",rare:"#3498db",legendary:"#f39c12"};'
    + 'var categoryIcons={"Legacy Companions":"ðŸ›ï¸","Fallen Spirits":"ðŸ‘»","Shallow Waters":"ðŸŒŠ","Exclusive Companions":"â­"};'
    + 'var collapsedCats={};'
    + 'window._petCatalog=catalog;'
    + 'window._petPets=pets;'

    // Populate category filter
    + 'var catSel=document.getElementById("filter-category");'
    + 'categories.forEach(function(c){var o=document.createElement("option");o.value=c;o.textContent=c;catSel.appendChild(o);});'

    // Image helper â€” handle broken images gracefully
    + 'function imgTag(src,name,emoji,size){'
    + '  size=size||80;'
    + '  if(!src) return \'<div style="width:\'+size+\'px;height:\'+size+\'px;display:flex;align-items:center;justify-content:center;font-size:\'+(size*0.6)+\'px;border-radius:8px;background:#1a1a2e">\'+emoji+\'</div>\';'
    + '  return \'<img src="\'+src+\'" alt="\'+name+\'" style="width:\'+size+\'px;height:\'+size+\'px;object-fit:contain;border-radius:8px;image-rendering:auto;image-rendering:high-quality" onerror="this.style.display=\\\'none\\\';this.insertAdjacentHTML(\\\'afterend\\\',\\\'<div style=&quot;width:\'+size+\'px;height:\'+size+\'px;display:flex;align-items:center;justify-content:center;font-size:\'+(size*0.6)+\'px;border-radius:8px;background:#1a1a2e&quot;>\'+emoji+\'</div>\\\')"/>\';'
    + '}'

    // Render stats
    + 'function renderStats(){'
    + '  var owned=pets.length,total=catalog.length,leg=catalog.filter(function(c){return c.rarity==="legendary"}).length;'
    + '  document.getElementById("pets-stats").innerHTML='
    + '    \'<div style="padding:10px 18px;background:#9146ff15;border:1px solid #9146ff33;border-radius:8px;text-align:center"><div style="font-size:22px;font-weight:700;color:#9146ff">\'+owned+\'</div><div style="font-size:11px;color:#8b8fa3">Pets Owned</div></div>\''
    + '    +\'<div style="padding:10px 18px;background:#2ecc7115;border:1px solid #2ecc7133;border-radius:8px;text-align:center"><div style="font-size:22px;font-weight:700;color:#2ecc71">\'+total+\'</div><div style="font-size:11px;color:#8b8fa3">Available</div></div>\''
    + '    +\'<div style="padding:10px 18px;background:#3498db15;border:1px solid #3498db33;border-radius:8px;text-align:center"><div style="font-size:22px;font-weight:700;color:#3498db">\'+categories.length+\'</div><div style="font-size:11px;color:#8b8fa3">Categories</div></div>\''
    + '    +\'<div style="padding:10px 18px;background:#f39c1215;border:1px solid #f39c1233;border-radius:8px;text-align:center"><div style="font-size:22px;font-weight:700;color:#f39c12">\'+leg+\'</div><div style="font-size:11px;color:#8b8fa3">Legendary</div></div>\';'
    + '}'

    // Count how many times a catalogId is owned
    + 'function ownedCount(petId){return pets.filter(function(p){return p.petId===petId}).length;}'

    // Apply filters
    + 'window.applyFilters=function(){'
    + '  var rarity=document.getElementById("filter-rarity").value;'
    + '  var category=document.getElementById("filter-category").value;'
    + '  var minCount=parseInt(document.getElementById("filter-count").value)||0;'
    + '  var showHidden=document.getElementById("filter-hidden").value==="yes";'
    + '  var search=(document.getElementById("filter-search").value||"").toLowerCase().trim();'
    + '  var givenBy=document.getElementById("filter-givenby").value;'
    + '  populateGiverFilter(givenBy);'
    + '  renderOwned(rarity,category,minCount,showHidden,search,givenBy);'
    + '  renderCatalog(rarity,category,minCount,showHidden,search);'
    + '};'
    + 'window.clearFilters=function(){'
    + '  document.getElementById("filter-rarity").value="";'
    + '  document.getElementById("filter-category").value="";'
    + '  document.getElementById("filter-count").value="";'
    + '  document.getElementById("filter-hidden").value="no";'
    + '  document.getElementById("filter-search").value="";'
    + '  document.getElementById("filter-givenby").value="";'
    + '  applyFilters();'
    + '};'

    // Populate giver filter dropdown dynamically
    + 'function populateGiverFilter(currentVal){'
    + '  var sel=document.getElementById("filter-givenby");'
    + '  if(!sel) return;'
    + '  var givers={};'
    + '  pets.forEach(function(p){if(p.givenBy && p.givenBy.trim()){givers[p.givenBy.trim()]=true}});'
    + '  var sorted=Object.keys(givers).sort();'
    + '  sel.innerHTML=\'<option value="">All Givers</option>\';'
    + '  sorted.forEach(function(g){var o=document.createElement("option");o.value=g;o.textContent=g;sel.appendChild(o)});'
    + '  if(currentVal) sel.value=currentVal;'
    + '}'

    // Render owned pets â€” compact grid grouped by pet type
    + 'function renderOwned(fRarity,fCat,fMinCount,showHidden,search,fGivenBy){'
    + '  var container=document.getElementById("owned-section");'
    + '  if(!container) return;'
    + '  var grouped={};'
    + '  pets.forEach(function(op){'
    + '    var c=catalog.find(function(x){return x.id===op.petId});'
    + '    if(!c) return;'
    + '    if(!showHidden && c.hidden) return;'
    + '    if(fRarity && c.rarity!==fRarity) return;'
    + '    if(fCat && c.category!==fCat) return;'
    + '    if(search && c.name.toLowerCase().indexOf(search)===-1) return;'
    + '    if(fGivenBy && (!op.givenBy || op.givenBy.trim()!==fGivenBy)) return;'
    + '    if(!grouped[c.id]) grouped[c.id]={cat:c,count:0};'
    + '    grouped[c.id].count++;'
    + '  });'
    + '  var keys=Object.keys(grouped);'
    + '  if(fMinCount>0) keys=keys.filter(function(k){return grouped[k].count>=fMinCount});'
    + '  var totalOwned=keys.reduce(function(s,k){return s+grouped[k].count},0);'
    + '  document.getElementById("owned-count").textContent=totalOwned;'
    + '  if(keys.length===0){container.innerHTML=\'<p style="color:#8b8fa3;font-size:13px">No pets yet. Use the catalog below or <code>/pet add</code> in Discord!</p>\';return;}'
    + '  var html="";'
    + '  keys.forEach(function(k){'
    + '    var g=grouped[k],c=g.cat,cnt=g.count;'
    + '    var bc=rarityColors[c.rarity]||"#8b8fa3";'
    + '    var src=c.animatedUrl||c.imageUrl||"";'
    + '    var bonusTag=c.bonus?\'<div style="font-size:9px;color:#f1c40f;margin-top:2px">âš¡ \'+c.bonus+\'</div>\':"";'
    + '    var tierTag=c.tier?\'<div style="font-size:10px;font-weight:700;margin-top:2px;color:\'+(c.tier==="S"?"#ff4444":c.tier==="A"?"#f39c12":c.tier==="B"?"#3498db":c.tier==="C"?"#2ecc71":"#8b8fa3")+\'">\'+c.tier+\' Rank\'+(c.tierPoints?\" \u2022 \"+c.tierPoints+\"pts\":\"\")+\'</div>\':"";'
    + '    var givers=[];pets.forEach(function(op){if(op.petId===c.id && op.givenBy && op.givenBy.trim()){var g=op.givenBy.trim();if(givers.indexOf(g)===-1)givers.push(g)}});'
    + '    var giverTag=givers.length>0?\'<div style="font-size:9px;color:#9b59b6;margin-top:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis" title="\'+givers.join(", ")+\'">ðŸŽ \'+givers.join(", ")+\'</div>\':"";'
    + '    var pendingCnt=pendingGiveaways.filter(function(pg){return pg.petId===c.id}).length;'
    + '    var pendingTag=pendingCnt>0?\'<div style="font-size:9px;color:#e67e22;margin-top:2px;font-weight:700">â³ Pending: \'+pendingCnt+\'</div>\':"";'
    + '    html+=\'<div style="border:2px solid \'+bc+\'44;border-radius:10px;padding:10px;background:#16161a;text-align:center;min-width:110px;max-width:140px;position:relative;transition:transform .15s" onmouseover="this.style.transform=\\\'scale(1.04)\\\'" onmouseout="this.style.transform=\\\'\\\'">\''
    + '      +(cnt>1?\'<div style="position:absolute;top:-6px;right:-6px;background:#9146ff;color:#fff;font-size:11px;font-weight:700;min-width:22px;height:22px;line-height:22px;border-radius:12px;text-align:center;padding:0 4px">x\'+cnt+\'</div>\':"")'
    + '      +\'<div style="position:absolute;top:4px;right:4px;display:flex;gap:2px">\''
    + '      +(canEdit?\'<button onclick="event.stopPropagation();addPet(\\\'\'+c.id+\'\\\')" style="background:none;border:none;color:#2ecc71;cursor:pointer;font-size:18px;padding:2px 4px;line-height:1" title="Add another">+</button>\':"")'
    + '      +(canEdit?\'<button onclick="event.stopPropagation();removeOnePet(\\\'\'+c.id+\'\\\')" style="background:none;border:none;color:#e74c3c;cursor:pointer;font-size:18px;padding:2px 4px;line-height:1" title="Remove one">&minus;</button>\':"")'
    + '      +(canEdit?\'<button onclick="event.stopPropagation();openGiveawayModal(\\\'\'+c.id+\'\\\')" style="background:none;border:none;color:#f39c12;cursor:pointer;font-size:18px;padding:2px 4px;line-height:1" title="Giveaway">ðŸŽ</button>\':"")'
    + '      +\'</div>\''
    + '      +\'<div style="margin:4px auto">\'+imgTag(src,c.name,c.emoji,72)+\'</div>\''
    + '      +\'<div style="font-weight:700;font-size:12px;margin:2px 0;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">\'+c.emoji+" "+c.name+\'</div>\''
    + '      +\'<div style="font-size:9px;color:\'+bc+\';text-transform:uppercase;letter-spacing:.5px">\'+c.rarity+\'</div>\''
    + '      +tierTag'
    + '      +bonusTag'
    + '      +giverTag'
    + '      +pendingTag'
    + '      +\'</div>\';'
    + '  });'
    + '  container.innerHTML=\'<div style="display:flex;flex-wrap:wrap;gap:10px">\'+html+\'</div>\';'
    + '}'

    // Render catalog
    + 'function renderCatalog(fRarity,fCat,fMinCount,showHidden,search){'
    + '  var container=document.getElementById("catalog-sections");'
    + '  if(!container){console.error("[Pets] catalog-sections not found!");return;}'
    + '  var html="";'
    + '  var catsToShow=fCat?[fCat]:categories;'
    + '  console.log("[Pets] Categories to show:",catsToShow);'
    + '  catsToShow.forEach(function(cat){'
    + '    var icon=categoryIcons[cat]||"ðŸ“‚";'
    + '    var catPets=catalog.filter(function(p){'
    + '      if(p.category!==cat) return false;'
    + '      if(!showHidden && p.hidden) return false;'
    + '      if(fRarity && p.rarity!==fRarity) return false;'
    + '      if(search && p.name.toLowerCase().indexOf(search)===-1) return false;'
    + '      if(fMinCount>0 && ownedCount(p.id)<fMinCount) return false;'
    + '      return true;'
    + '    });'
    + '    console.log("[Pets] Category",cat,"has",catPets.length,"pets after filtering");'
    + '    var collapsed=collapsedCats[cat];'
    + '    var arrow=collapsed?"â–¶":"â–¼";'
    + '    html+=\'<div class="card"><h2 style="cursor:pointer;user-select:none" onclick="toggleCat(this.dataset.cat)" data-cat="\'+cat+\'">\'+icon+" "+cat+" ("+catPets.length+\') <span style="font-size:12px;color:#8b8fa3;margin-left:8px">\'+arrow+\'</span></h2>\';'
    + '    html+=\'<div id="cat-\'+cat.replace(/[^a-zA-Z]/g,"")+\'" style="display:\'+(collapsed?"none":"flex")+\';flex-wrap:wrap;gap:14px;margin-top:12px">\';'
    + '    catPets.forEach(function(p){'
    + '      var owned=pets.find(function(op){return op.petId===p.id});'
    + '      var bc=rarityColors[p.rarity]||"#8b8fa3";'
    + '      var src=p.animatedUrl||p.imageUrl||"";'
    + '      var cnt=ownedCount(p.id);'
    + '      var ownedHtml="";'
    + '      if(cnt>0){ownedHtml=\'<div style="display:flex;align-items:center;justify-content:center;gap:6px"><span style="color:#2ecc71;font-size:11px;font-weight:600">âœ… x\'+cnt+\'</span>\'+(canEdit?\'<button onclick="addPet(\\\'\'+p.id+\'\\\')" style="background:none;border:none;color:#2ecc71;cursor:pointer;font-size:16px;padding:0;line-height:1" title="Add another">+</button>\':\'\')+\'</div>\';}'    + '      else if(canEdit){ownedHtml=\'<button onclick="addPet(\\\'\'+p.id+\'\\\')" style="padding:6px 16px;background:#9146ff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:12px;font-weight:600;transition:background .2s" onmouseover="this.style.background=\\\'#a955ff\\\'" onmouseout="this.style.background=\\\'#9146ff\\\'">âž• Add Pet</button>\';}'
    + '      var bonusTag=p.bonus?\'<div style="font-size:10px;color:#f1c40f;margin:4px 0">âš¡ \'+p.bonus+\'</div>\':"";'
    + '      var tierTag=p.tier?\'<div style="font-size:10px;font-weight:700;margin:2px 0;color:\'+(p.tier==="S"?"#ff4444":p.tier==="A"?"#f39c12":p.tier==="B"?"#3498db":p.tier==="C"?"#2ecc71":"#8b8fa3")+\'">\'+p.tier+\' Rank\'+(p.tierPoints?\" \u2022 \"+p.tierPoints+\"pts\":\"\")+\'</div>\':"";'
    + '      var hiddenBadge=p.hidden?\'<div style="font-size:9px;color:#e74c3c;margin-top:4px">ðŸš« HIDDEN</div>\':"";'
    + '      html+=\'<div style="border:2px solid \'+bc+\';border-radius:12px;padding:16px;background:#16161a;text-align:center;position:relative;min-width:150px;max-width:180px;transition:transform .2s,box-shadow .2s;\'+(p.hidden?"opacity:.5;":"")+\'" onmouseover="this.style.transform=\\\'translateY(-4px)\\\';this.style.boxShadow=\\\'0 8px 24px rgba(0,0,0,.4)\\\'" onmouseout="this.style.transform=\\\'\\\';this.style.boxShadow=\\\'\\\'">\''
    + '        +\'<div style="position:absolute;top:8px;right:8px;font-size:10px;font-weight:700;text-transform:uppercase;color:\'+bc+\';letter-spacing:1px">\'+p.rarity+\'</div>\''
    + '        +(canEdit?\'<div style="position:absolute;top:8px;left:8px"><button onclick="openEditModal(\\\'\'+p.id+\'\\\')" style="background:none;border:none;color:#8b8fa3;cursor:pointer;font-size:14px;padding:2px" title="Edit pet">âœï¸</button></div>\':\'\')'
    + '        +\'<div style="margin:8px auto">\'+imgTag(src,p.name,p.emoji,96)+\'</div>\''
    + '        +\'<div style="font-weight:700;font-size:15px;margin:6px 0">\'+p.emoji+" "+p.name+\'</div>\''
    + '        +\'<div style="font-size:11px;color:#8b8fa3;margin-bottom:4px">\'+p.description+\'</div>\''
    + '        +bonusTag+tierTag+hiddenBadge'
    + '        +ownedHtml'
    + '        +\'</div>\';'
    + '    });'
    + '    html+=\'</div></div>\';'
    + '  });'
    + '  console.log("[Pets] Generated",html.length,"chars of HTML for",catsToShow.length,"categories");'
    + '  if(html.length===0||html.indexOf("<div")===  -1){'
    + '    container.innerHTML=\'<div style="padding:20px;background:#ff6b6b22;border:1px solid #ff6b6b;border-radius:8px;color:#ff6b6b"><strong>âš ï¸ Debug:</strong> No HTML generated. Categories: \'+catsToShow.length+\', Total catalog: \'+catalog.length+\'</div>\';'
    + '    return;'
    + '  }'
    + '  container.innerHTML=html;'
    + '  console.log("[Pets] Catalog rendered successfully");'
    + '}'

    // Toggle category collapse
    + 'window.toggleCat=function(el){'
    + '  var cat=typeof el==="string"?el:el.getAttribute("data-cat");'
    + '  collapsedCats[cat]=!collapsedCats[cat];'
    + '  applyFilters();'
    + '};'
    + 'window.toggleSection=function(id,el){'
    + '  var sec=document.getElementById(id);'
    + '  if(sec.style.display==="none"){sec.style.display="";el.querySelector("span:last-child").textContent="â–¼";}else{sec.style.display="none";el.querySelector("span:last-child").textContent="â–¶";}'
    + '};'

    // Edit modal
    + 'window.openEditModal=function(petId){'
    + '  var p=catalog.find(function(c){return c.id===petId});'
    + '  if(!p) return;'
    + '  document.getElementById("edit-id").value=p.id;'
    + '  document.getElementById("edit-title").textContent="âœï¸ Edit "+p.name;'
    + '  document.getElementById("edit-rarity").value=p.rarity||"common";'
    + '  document.getElementById("edit-description").value=p.description||"";'
    + '  document.getElementById("edit-bonus").value=p.bonus||"";'
    + '  document.getElementById("edit-tier").value=p.tier||"";'
    + '  document.getElementById("edit-tierPoints").value=p.tierPoints||"";'
    + '  document.getElementById("edit-imageUrl").value=p.imageUrl||"";'
    + '  document.getElementById("edit-animatedUrl").value=p.animatedUrl||"";'
    + '  document.getElementById("edit-hidden").checked=!!p.hidden;'
    + '  setDropPreview("imageUrl",p.imageUrl,p.emoji);'
    + '  setDropPreview("animatedUrl",p.animatedUrl,p.emoji);'
    + '  updateEditPreview(p);'
    + '  var modal=document.getElementById("edit-modal");'
    + '  modal.style.display="flex";'
    + '};'
    + 'function updateEditPreview(p){'
    + '  var src=document.getElementById("edit-animatedUrl").value||document.getElementById("edit-imageUrl").value||"";'
    + '  var prev=document.getElementById("edit-preview");'
    + '  if(src){prev.innerHTML=\'<img src="\'+src+\'" style="max-width:120px;max-height:120px;border-radius:8px" onerror="this.outerHTML=\\\'<div style=&amp;quot;color:#e74c3c;font-size:12px&amp;quot;>Image failed to load. Use a direct image URL (.png, .jpg, .gif)</div>\\\'"/>\';}'
    + '  else{prev.innerHTML=\'<div style="font-size:48px">\'+p.emoji+\'</div><div style="font-size:11px;color:#555">No image set</div>\';}'
    + '}'

    // Drag-and-drop / file upload helpers
    + 'function setDropPreview(field,url,emoji){'
    + '  var prev=document.getElementById("drop-"+field+"-preview");'
    + '  var txt=document.getElementById("drop-"+field+"-text");'
    + '  document.getElementById("edit-"+field).value=url||"";'
    + '  if(url){'
    + '    prev.innerHTML=\'<img src="\'+url+\'" style="max-width:80px;max-height:80px;border-radius:6px"><button onclick="event.stopPropagation();clearDrop(\\\'\'+field+\'\\\')" style="display:block;margin:4px auto 0;background:none;border:none;color:#e74c3c;cursor:pointer;font-size:11px">Remove</button>\';'
    + '    txt.style.display="none";'
    + '  }else{'
    + '    prev.innerHTML="";'
    + '    txt.style.display="";'
    + '  }'
    + '}'
    + 'window.clearDrop=function(field){'
    + '  document.getElementById("edit-"+field).value="";'
    + '  setDropPreview(field,"","");'
    + '  var p=catalog.find(function(c){return c.id===document.getElementById("edit-id").value});'
    + '  if(p) updateEditPreview(p);'
    + '};'
    + 'function uploadFile(file,field){'
    + '  var loading=document.getElementById("drop-"+field+"-loading");'
    + '  loading.style.display="";'
    + '  var fd=new FormData();fd.append("image",file);'
    + '  fetch("/upload/image",{method:"POST",body:fd}).then(function(r){var ct=r.headers.get("content-type")||"";if(!ct.includes("application/json")){throw new Error("Session expired or server error. Please refresh the page.");}return r.json()}).then(function(d){'
    + '    loading.style.display="none";'
    + '    if(d.success){'
    + '      document.getElementById("edit-"+field).value=d.url;'
    + '      var p=catalog.find(function(c){return c.id===document.getElementById("edit-id").value});'
    + '      setDropPreview(field,d.url,p?p.emoji:"");'
    + '      if(p) updateEditPreview(p);'
    + '    }else{alert(d.error||"Upload failed");}'
    + '  }).catch(function(e){loading.style.display="none";alert("Upload error: "+e.message)});'
    + '}'
    + 'window.handleDrop=function(e,field){'
    + '  var file=e.dataTransfer.files[0];'
    + '  if(file&&file.type.startsWith("image/")) uploadFile(file,field);'
    + '  else alert("Please drop an image file");'
    + '};'
    + 'window.handleFileSelect=function(input,field){'
    + '  if(input.files[0]) uploadFile(input.files[0],field);'
    + '};'

    + 'window.closeEditModal=function(){document.getElementById("edit-modal").style.display="none";};'
    + 'window.saveEdit=function(){'
    + '  var id=document.getElementById("edit-id").value;'
    + '  var body={id:id,rarity:document.getElementById("edit-rarity").value,description:document.getElementById("edit-description").value,bonus:document.getElementById("edit-bonus").value,tier:document.getElementById("edit-tier").value,tierPoints:parseInt(document.getElementById("edit-tierPoints").value)||0,imageUrl:document.getElementById("edit-imageUrl").value,animatedUrl:document.getElementById("edit-animatedUrl").value,hidden:document.getElementById("edit-hidden").checked};'
    + '  fetch("/api/pets/catalog/edit",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(body)}).then(function(r){var ct=r.headers.get("content-type")||"";if(!ct.includes("application/json")){throw new Error("Session expired or server error. Please refresh the page.");}return r.json()}).then(function(d){'
    + '    if(d.success){var idx=catalog.findIndex(function(c){return c.id===id});if(idx>=0){Object.assign(catalog[idx],body);}renderStats();applyFilters();closeEditModal();}'
    + '    else{alert(d.error||"Failed to save");}'
    + '  }).catch(function(e){alert("Error: "+e.message)});'
    + '};'

    // Collect known givers for the selector
    + 'function getKnownGivers(){'
    + '  var givers={};'
    + '  pets.forEach(function(p){if(p.givenBy && p.givenBy.trim()){givers[p.givenBy.trim()]=true}});'
    + '  return Object.keys(givers).sort();'
    + '}'

    // Add / Remove pet â€” opens a givenBy selector modal
    + 'window._pendingAddPetId=null;'
    + 'window.addPet=function(petId){'
    + '  window._pendingAddPetId=petId;'
    + '  var givers=getKnownGivers();'
    + '  var sel=document.getElementById("givenby-select");'
    + '  sel.innerHTML="<option value=\\\"\\\">(no one)</option>";'
    + '  givers.forEach(function(g){var o=document.createElement("option");o.value=g;o.textContent=g;sel.appendChild(o)});'
    + '  var otherOpt=document.createElement("option");otherOpt.value="__other__";otherOpt.textContent="âœï¸ Other (type a name)";sel.appendChild(otherOpt);'
    + '  document.getElementById("givenby-other").style.display="none";'
    + '  document.getElementById("givenby-other").value="";'
    + '  sel.value="";'
    + '  document.getElementById("givenby-modal").style.display="flex";'
    + '};'
    + 'window.onGivenBySelectChange=function(){'
    + '  var v=document.getElementById("givenby-select").value;'
    + '  document.getElementById("givenby-other").style.display=v==="__other__"?"block":"none";'
    + '};'
    + 'window.closeGivenByModal=function(){document.getElementById("givenby-modal").style.display="none";window._pendingAddPetId=null;};'
    + 'window.confirmAddPet=function(){'
    + '  var petId=window._pendingAddPetId;'
    + '  if(!petId) return;'
    + '  var sel=document.getElementById("givenby-select").value;'
    + '  var givenBy=sel==="__other__"?document.getElementById("givenby-other").value.trim():sel;'
    + '  fetch("/api/pets/add",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({petId:petId,givenBy:givenBy||""})}).then(function(r){var ct=r.headers.get("content-type")||"";if(!ct.includes("application/json")){throw new Error("Session expired or server error. Please refresh the page.");}return r.json()}).then(function(d){'
    + '    if(d.success){pets.push(d.pet);renderStats();applyFilters();closeGivenByModal();}'
    + '    else{alert(d.error||"Failed to add pet");}'
    + '  }).catch(function(e){alert("Error adding pet: "+e.message)});'
    + '};'
    + 'window.removeOnePet=function(petId){'
    + '  var instances=pets.filter(function(p){return p.petId===petId});'
    + '  if(instances.length===0){alert("No owned instance found");return;}'
    + '  var petName=(catalog.find(function(c){return c.id===petId})||{}).name||petId;'
    + '  var giverMap={};instances.forEach(function(p){var g=p.givenBy&&p.givenBy.trim()?p.givenBy.trim():"(no giver)";if(!giverMap[g])giverMap[g]=[];giverMap[g].push(p)});'
    + '  var giverNames=Object.keys(giverMap);'
    + '  if(giverNames.length<=1){'
    + '    var entry=instances[instances.length-1];'
    + '    var gLabel=entry.givenBy&&entry.givenBy.trim()?" (given by "+entry.givenBy.trim()+")":"";'
    + '    if(!confirm("Remove one "+petName+gLabel+"?")) return;'
    + '    doRemovePet(entry.id);'
    + '  } else {'
    + '    var html="<div style=\\"display:grid;gap:8px\\">";'
    + '    giverNames.forEach(function(g){'
    + '      var cnt=giverMap[g].length;'
    + '      html+=\'<button onclick="event.stopPropagation();doRemoveByGiver(\\\'\'+(g==="(no giver)"?"":g)+\'\\\',\\\'\'+ petId +\'\\\')" style="padding:10px;background:#2a2a2e;border:1px solid #444;border-radius:8px;color:#e0e0e0;cursor:pointer;text-align:left"><span style="font-weight:700">\'+ g +\'</span> <span style="color:#8b8fa3;font-size:11px">(x\'+ cnt +\')</span></button>\';'
    + '    });'
    + '    html+="</div>";'
    + '    var m=document.getElementById("remove-picker-modal");'
    + '    document.getElementById("remove-picker-title").textContent="Remove one "+petName;'
    + '    document.getElementById("remove-picker-list").innerHTML=html;'
    + '    m.style.display="flex";'
    + '  }'
    + '};'
    + 'window.doRemoveByGiver=function(giverName,petId){'
    + '  var entry=pets.slice().reverse().find(function(p){return p.petId===petId&&(giverName===""?(!(p.givenBy)||!p.givenBy.trim()):p.givenBy&&p.givenBy.trim()===giverName)});'
    + '  if(!entry){alert("No matching instance found");return;}'
    + '  doRemovePet(entry.id);'
    + '  document.getElementById("remove-picker-modal").style.display="none";'
    + '};'
    + 'window.doRemovePet=function(entryId){'
    + '  fetch("/api/pets/"+entryId,{method:"DELETE"}).then(function(r){var ct=r.headers.get("content-type")||"";if(!ct.includes("application/json")){throw new Error("Session expired or server error. Please refresh the page.");}return r.json()}).then(function(d){'
    + '    if(d.success){pets.splice(pets.findIndex(function(p){return p.id===entryId}),1);renderStats();applyFilters();}'
    + '    else{alert(d.error||"Failed to remove pet");}'
    + '  }).catch(function(e){alert("Error removing pet: "+e.message)});'
    + '};'

    // Clear all pets
    + 'window.clearAllPets=function(){'
    + '  if(!confirm("Are you sure you want to remove ALL owned pets? This cannot be undone!")) return;'
    + '  if(!confirm("Really? This will clear the entire collection!")) return;'
    + '  fetch("/api/pets/clear-all",{method:"POST",headers:{"Content-Type":"application/json"}}).then(function(r){var ct=r.headers.get("content-type")||"";if(!ct.includes("application/json")){throw new Error("Session expired.");}return r.json()}).then(function(d){'
    + '    if(d.success){pets.length=0;renderStats();applyFilters();}'
    + '    else{alert(d.error||"Failed to clear");}'
    + '  }).catch(function(e){alert("Error: "+e.message)});'
    + '};'

    // Giveaway modal
    + 'window.onGiveawayGiverChange=function(){'
    + '  var v=document.getElementById("giveaway-giver-select").value;'
    + '  document.getElementById("giveaway-giver-other").style.display=v==="__other__"?"block":"none";'
    + '};'
    + 'window.openGiveawayModal=function(petId){'
    + '  var c=catalog.find(function(x){return x.id===petId});'
    + '  if(!c) return;'
    + '  document.getElementById("giveaway-petId").value=petId;'
    + '  var src=c.animatedUrl||c.imageUrl||"";'
    + '  document.getElementById("giveaway-pet-info").innerHTML=imgTag(src,c.name,c.emoji,64)+\'<div style="font-weight:700;margin-top:6px">\'+c.emoji+" "+c.name+\'</div><div style="font-size:11px;color:#8b8fa3">\'+c.rarity+\'</div>\';'
    + '  document.getElementById("giveaway-winner").value="";'
    + '  var givers=getKnownGivers();'
    + '  var sel=document.getElementById("giveaway-giver-select");'
    + '  sel.innerHTML="<option value=\\\"\\\">(select)</option>";'
    + '  givers.forEach(function(g){var o=document.createElement("option");o.value=g;o.textContent=g;sel.appendChild(o)});'
    + '  var otherOpt=document.createElement("option");otherOpt.value="__other__";otherOpt.textContent="âœï¸ Other (type a name)";sel.appendChild(otherOpt);'
    + '  sel.value="";'
    + '  document.getElementById("giveaway-giver-other").style.display="none";'
    + '  document.getElementById("giveaway-giver-other").value="";'
    + '  document.getElementById("giveaway-notes").value="";'
    + '  document.getElementById("giveaway-expiration").value="";'
    + '  document.getElementById("giveaway-ping-giver").checked=false;'
    + '  document.getElementById("giveaway-ping-receiver").checked=true;'
    + '  document.getElementById("giveaway-modal").style.display="flex";'
    + '};'
    + 'window.closeGiveawayModal=function(){document.getElementById("giveaway-modal").style.display="none";};'
    + 'window.submitGiveaway=function(){'
    + '  var petId=document.getElementById("giveaway-petId").value;'
    + '  var winner=document.getElementById("giveaway-winner").value.trim();'
    + '  var selVal=document.getElementById("giveaway-giver-select").value;'
    + '  var giver=selVal==="__other__"?document.getElementById("giveaway-giver-other").value.trim():selVal;'
    + '  var notes=document.getElementById("giveaway-notes").value.trim();'
    + '  var expirationHours=parseFloat(document.getElementById("giveaway-expiration").value)||0;'
    + '  var expirationTime=expirationHours>0?(expirationHours*60):0;'
    + '  var pingGiver=document.getElementById("giveaway-ping-giver").checked;'
    + '  var pingReceiver=document.getElementById("giveaway-ping-receiver").checked;'
    + '  if(!winner||!giver){alert("Please fill in winner and giver names.");return;}'
    + '  fetch("/api/pets/giveaway",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({petId:petId,winner:winner,giver:giver,notes:notes,expirationTime:expirationTime,pingGiver:pingGiver,pingReceiver:pingReceiver})}).then(function(r){var ct=r.headers.get("content-type")||"";if(!ct.includes("application/json")){throw new Error("Session expired.");}return r.json()}).then(function(d){'
    + '    if(d.success){alert("Giveaway submitted! An admin can confirm it in the Pet Giveaway History tab.");closeGiveawayModal();}'
    + '    else{alert(d.error||"Failed");}'
    + '  }).catch(function(e){alert("Error: "+e.message)});'
    + '};'

    // Random pet picker
    + 'window.openRandomPicker=function(){'
    + '  var ownedIds=[...new Set(pets.map(function(p){return p.petId}))];'
    + '  if(ownedIds.length===0){alert("No pets owned to pick from!");return;}'
    + '  var html="";'
    + '  ownedIds.forEach(function(id){'
    + '    var c=catalog.find(function(x){return x.id===id});'
    + '    if(!c) return;'
    + '    html+=\'<label style="display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:6px;cursor:pointer;margin-bottom:4px;background:#16161a"><input type="checkbox" class="random-check" value="\'+c.id+\'" checked><span>\'+c.emoji+" "+c.name+\'</span><span style="font-size:10px;color:#8b8fa3">\'+c.rarity+\'</span></label>\';'
    + '  });'
    + '  document.getElementById("random-pet-list").innerHTML=html;'
    + '  document.getElementById("random-result").innerHTML="";'
    + '  document.getElementById("random-modal").style.display="flex";'
    + '};'
    + 'window.closeRandomModal=function(){document.getElementById("random-modal").style.display="none";};'
    + 'window.randomSelectAll=function(v){document.querySelectorAll(".random-check").forEach(function(cb){cb.checked=v});};'
    + 'window.spinRandom=function(){'
    + '  var selected=[];document.querySelectorAll(".random-check:checked").forEach(function(cb){selected.push(cb.value)});'
    + '  if(selected.length===0){alert("Select at least one pet!");return;}'
    + '  var resultEl=document.getElementById("random-result");'
    + '  var spins=0,maxSpins=15,interval=setInterval(function(){'
    + '    var rId=selected[Math.floor(Math.random()*selected.length)];'
    + '    var c=catalog.find(function(x){return x.id===rId});'
    + '    if(c) resultEl.innerHTML=\'<div style="font-size:40px;animation:pulse .3s">\'+c.emoji+\'</div><div style="font-weight:700">\'+c.name+\'</div>\';'
    + '    spins++;'
    + '    if(spins>=maxSpins){clearInterval(interval);'
    + '      var winnerId=selected[Math.floor(Math.random()*selected.length)];'
    + '      var w=catalog.find(function(x){return x.id===winnerId});'
    + '      if(w){var src=w.animatedUrl||w.imageUrl||"";'
    + '        resultEl.innerHTML=\'<div style="font-size:14px;color:#f39c12;margin-bottom:8px">ðŸŽ‰ Winner!</div>\'+imgTag(src,w.name,w.emoji,80)+\'<div style="font-weight:700;font-size:18px;margin-top:8px">\'+w.emoji+" "+w.name+\'</div><div style="font-size:12px;color:\'+rarityColors[w.rarity]+\'">\'+w.rarity+\'</div>\';'
    + '      }'
    + '    }'
    + '  },100);'
    + '};'

    // Suggest best pet (highest tier/points not owned)
    + 'window.openSuggestBest=function(){'
    + '  var ownedIds=new Set(pets.map(function(p){return p.petId}));'
    + '  var tierOrder={S:5,A:4,B:3,C:2,D:1};'
    + '  var unowned=catalog.filter(function(c){return !ownedIds.has(c.id)&&!c.hidden});'
    + '  if(unowned.length===0){document.getElementById("suggest-result").innerHTML=\'<div style="color:#2ecc71;font-size:16px;font-weight:700;padding:20px">ðŸŽ‰ You own all available pets!</div>\';document.getElementById("suggest-modal").style.display="flex";return;}'
    + '  unowned.sort(function(a,b){'
    + '    var ta=tierOrder[a.tier]||0,tb=tierOrder[b.tier]||0;'
    + '    if(tb!==ta) return tb-ta;'
    + '    return (b.tierPoints||0)-(a.tierPoints||0);'
    + '  });'
    + '  var best=unowned[0];'
    + '  var src=best.animatedUrl||best.imageUrl||"";'
    + '  var bc=rarityColors[best.rarity]||"#8b8fa3";'
    + '  var tierColor=best.tier==="S"?"#ff4444":best.tier==="A"?"#f39c12":best.tier==="B"?"#3498db":best.tier==="C"?"#2ecc71":"#8b8fa3";'
    + '  document.getElementById("suggest-result").innerHTML='
    + '    \'<div style="margin-bottom:12px;color:#f39c12;font-size:14px">We recommend getting:</div>\''
    + '    +imgTag(src,best.name,best.emoji,96)'
    + '    +\'<div style="font-weight:700;font-size:20px;margin-top:10px">\'+best.emoji+" "+best.name+\'</div>\''
    + '    +\'<div style="color:\'+bc+\';font-size:12px;text-transform:uppercase">\'+best.rarity+\'</div>\''
    + '    +(best.tier?\'<div style="font-weight:700;color:\'+tierColor+\';font-size:14px;margin-top:4px">\'+best.tier+\' Rank\'+(best.tierPoints?" \\u2022 "+best.tierPoints+"pts":"")+\'</div>\':"<div style=\\"font-size:11px;color:#555;margin-top:4px\\">No tier assigned</div>")'
    + '    +(best.bonus?\'<div style="color:#f1c40f;font-size:11px;margin-top:4px">\\u26a1 \'+best.bonus+\'</div>\':"")'
    + '    +\'<div style="margin-top:12px"><button onclick="addPet(\\\'\'+best.id+\'\\\');closeSuggestModal()" style="padding:8px 24px;background:#9146ff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:700">\\u2795 Add This Pet</button></div>\';'
    + '  document.getElementById("suggest-modal").style.display="flex";'
    + '};'
    + 'window.closeSuggestModal=function(){document.getElementById("suggest-modal").style.display="none";};'

    // Initial render
    + 'console.log("[Pets] Calling initial render...");'
    + 'renderStats();applyFilters();'
    + 'console.log("[Pets] Initial render complete");'

    // Instant updates via Server-Sent Events
    + 'var petsEventSource=new EventSource("/api/pets/stream");'
    + 'petsEventSource.onmessage=function(ev){'
    + '  if(ev.data==="update"){'
    + '    fetch("/api/pets").then(function(r){return r.json()}).then(function(d){'
    + '      if(d && d.pets && d.catalog){'
    + '        pets.length=0;d.pets.forEach(function(p){pets.push(p)});'
    + '        catalog.length=0;d.catalog.forEach(function(c){catalog.push(c)});'
    + '        if(d.pendingGiveaways){pendingGiveaways.length=0;d.pendingGiveaways.forEach(function(pg){pendingGiveaways.push(pg)});}'
    + '        renderStats();applyFilters();'
    + '        console.log("[Pets] Live update: "+pets.length+" pets");'
    + '      }'
    + '    }).catch(function(){});'
    + '  }'
    + '};'
    + 'petsEventSource.onerror=function(){console.warn("[Pets] SSE connection lost, retrying...");};'

    + '}catch(err){console.error("[Pets] Error:",err);alert("Pet system error: "+err.message);}'
    + '})();'
    + '</script>';
}

// ====================== PET GIVEAWAY HISTORY TAB ======================
function renderPetGiveawaysTab(userTier) {
  const giveaways = loadJSON(path.join(DATA_DIR, 'pet-giveaways.json'), { history: [] });
  const bans = loadJSON(path.join(DATA_DIR, 'pet-giveaway-bans.json'), { banned: [] });
  const history = giveaways.history || [];
  const giveawaysJSON = JSON.stringify(history);
  const bansJSON = JSON.stringify(bans.banned || []);
  const isAdmin = userTier === 'admin' || userTier === 'owner';

  return '<div class="card">'
    + '<h2>ðŸŽ Pet Giveaway Management</h2>'
    + '<p style="color:#8b8fa3;font-size:13px;margin-top:-4px">Track pet giveaways, comments, stats, and manage banned givers.</p>'
    + '</div>'
    + '<div class="card">'
    + '<div style="display:flex;gap:8px;margin-bottom:20px;border-bottom:1px solid #333;padding-bottom:12px;flex-wrap:wrap;align-items:center;justify-content:flex-start">'
    + '<button onclick="switchGiveawayTab(\'history\')" id="tab-history" style="padding:8px 16px;background:#9146ff;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:600;width:auto;display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;white-space:nowrap;">ðŸ“‹ History</button>'
    + '<button onclick="switchGiveawayTab(\'comments\')" id="tab-comments" style="padding:8px 16px;background:#16161a;color:#ccc;border:1px solid #333;border-radius:4px;cursor:pointer;width:auto;display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;white-space:nowrap;">ðŸ’¬ Comments</button>'
    + '<button onclick="switchGiveawayTab(\'stats\')" id="tab-stats" style="padding:8px 16px;background:#16161a;color:#ccc;border:1px solid #333;border-radius:4px;cursor:pointer;width:auto;display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;white-space:nowrap;">ðŸ“Š Stats</button>'
    + (isAdmin ? '<button onclick="switchGiveawayTab(\'bans\')" id="tab-bans" style="padding:8px 16px;background:#16161a;color:#ccc;border:1px solid #333;border-radius:4px;cursor:pointer;width:auto;display:inline-flex;align-items:center;justify-content:center;flex:0 0 auto;white-space:nowrap;">ðŸš« Ban List</button>' : '')
    + '</div>'
    
    // History Tab
    + '<div id="giveaway-history-tab" style="display:block">'
    + '<div style="display:flex;gap:12px;margin-bottom:16px;flex-wrap:wrap;align-items:center">'
    + '<select id="giveaway-filter" onchange="filterGiveaways()" style="padding:6px 12px"><option value="">All</option><option value="pending">Pending</option><option value="confirmed">Confirmed</option></select>'
    + '<input type="text" id="giveaway-search" oninput="filterGiveaways()" placeholder="Search by pet, winner, giver..." style="padding:6px 12px;background:#16161a;border:1px solid #333;border-radius:6px;color:#e0e0e0;flex:1;min-width:200px">'
    + '</div>'
    + '<div id="giveaway-list"></div>'
    + '</div>'
    
    // Comments Tab
    + '<div id="giveaway-comments-tab" style="display:none">'
    + '<p style="color:#8b8fa3;margin-bottom:16px">Click on a giveaway to view and manage comments. Admins/Mods can add comments.</p>'
    + '<div id="giveaway-comments-list"></div>'
    + '</div>'
    
    // Stats Tab
    + '<div id="giveaway-stats-tab" style="display:none">'
    + '<div id="giveaway-stats-content"></div>'
    + '</div>'
    
    // Bans Tab (admin only)
    + (isAdmin ? '<div id="giveaway-bans-tab" style="display:none">'
    + '<div style="margin-bottom:20px;padding:12px;background:#e74c3c22;border:1px solid #e74c3c44;border-radius:8px">'
    + '<label style="color:#e0e0e0;display:block;margin-bottom:8px">Ban a giver from giving out pets:</label>'
    + '<div style="display:flex;gap:8px;flex-wrap:wrap">'
    + '<input type="text" id="ban-user-id" placeholder="User ID or Discord name" style="padding:6px 12px;background:#16161a;border:1px solid #333;border-radius:6px;color:#e0e0e0;flex:1;min-width:200px">'
    + '<input type="text" id="ban-reason" placeholder="Reason (optional)" style="padding:6px 12px;background:#16161a;border:1px solid #333;border-radius:6px;color:#e0e0e0;flex:1;min-width:200px">'
    + '<button onclick="addBan()" style="padding:6px 16px;background:#e74c3c;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:600;">Ban User</button>'
    + '</div>'
    + '</div>'
    + '<div id="giveaway-bans-list"></div>'
    + '</div>' : '')
    
    + '</div>'
    + '<script>'
    + '(function(){'
    + 'var history=' + giveawaysJSON + ';'
    + 'var bans=' + bansJSON + ';'
    + 'var isAdmin=' + (isAdmin ? 'true' : 'false') + ';'
    + 'var rarityColors={common:"#8b8fa3",uncommon:"#2ecc71",rare:"#3498db",epic:"#9146ff",legendary:"#f39c12"};'

    + 'window.switchGiveawayTab=function(tab){'
    + '  document.getElementById("giveaway-history-tab").style.display=(tab==="history"?"block":"none");'
    + '  document.getElementById("giveaway-comments-tab").style.display=(tab==="comments"?"block":"none");'
    + '  document.getElementById("giveaway-stats-tab").style.display=(tab==="stats"?"block":"none");'
    + '  if(isAdmin) document.getElementById("giveaway-bans-tab").style.display=(tab==="bans"?"block":"none");'
    + '  ["history","comments","stats"' + (isAdmin ? ',"bans"' : '') + '].forEach(function(t){'
    + '    var el=document.getElementById("tab-"+t);'
    + '    if(el) el.style.background=(t===tab?"#9146ff":"#16161a");'
    + '    if(el) el.style.color=(t===tab?"#fff":"#ccc");'
    + '    if(el) el.style.border=(t===tab?"none":"1px solid #333");'
    + '  });'
    + '  if(tab==="stats") renderStatsTab();'
    + '  if(tab==="comments") renderCommentsTab();'
    + '  if(tab==="bans") renderBansTab();'
    + '};'

    + 'function renderStatsTab(){'
    + '  fetch("/api/pets/giveaway/stats").then(function(r){return r.json()}).then(function(stats){'
    + '    var html="<div style=\\"display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;margin-bottom:20px\\">";'
    + '    html+="<div style=\\"padding:16px;background:#9146ff15;border:1px solid #9146ff33;border-radius:8px;text-align:center\\">";'
    + '      html+="<div style=\\"font-size:24px;font-weight:700;color:#9146ff\\">"+stats.totalGiveaways+"</div>";'
    + '      html+="<div style=\\"font-size:11px;color:#8b8fa3;margin-top:4px\\">Total Giveaways</div>";'
    + '    html+="</div>";'
    + '    html+="<div style=\\"padding:16px;background:#2ecc7115;border:1px solid #2ecc7133;border-radius:8px;text-align:center\\">";'
    + '      html+="<div style=\\"font-size:24px;font-weight:700;color:#2ecc71\\">"+stats.confirmedGiveaways+"</div>";'
    + '      html+="<div style=\\"font-size:11px;color:#8b8fa3;margin-top:4px\\">Confirmed</div>";'
    + '    html+="</div>";'
    + '    html+="<div style=\\"padding:16px;background:#f39c1215;border:1px solid #f39c1233;border-radius:8px;text-align:center\\">";'
    + '      html+="<div style=\\"font-size:24px;font-weight:700;color:#f39c12\\">"+stats.pendingGiveaways+"</div>";'
    + '      html+="<div style=\\"font-size:11px;color:#8b8fa3;margin-top:4px\\">Pending</div>";'
    + '    html+="</div>";'
    + '    html+="<div style=\\"padding:16px;background:#3498db15;border:1px solid #3498db33;border-radius:8px;text-align:center\\">";'
    + '      html+="<div style=\\"font-size:24px;font-weight:700;color:#3498db\\">"+stats.confirmationRate+"%</div>";'
    + '      html+="<div style=\\"font-size:11px;color:#8b8fa3;margin-top:4px\\">Confirmation Rate</div>";'
    + '    html+="</div>";'
    + '    html+="</div>";'
    + '    html+="<h3 style=\\"margin:20px 0 12px\\">ðŸ† Top Givers</h3>";'
    + '    if(stats.topGivers.length>0){'
    + '      html+="<div style=\\"background:#16161a;border:1px solid #2a2a3a;border-radius:8px;padding:12px\\">";'
    + '      stats.topGivers.forEach(function(g,i){'
    + '        html+="<div style=\\"display:flex;justify-content:space-between;padding:8px 0;border-bottom:"+(i<stats.topGivers.length-1?"1px solid #333":"none")+"\\">";'
    + '        html+="<span style=\\"color:#e0e0e0\\">"+g.name+"</span>";'
    + '        html+="<span style=\\"color:#9146ff;font-weight:600\\">"+g.count+" pets</span>";'
    + '        html+="</div>";'
    + '      });'
    + '      html+="</div>";'
    + '    }'
    + '    html+="<h3 style=\\"margin:20px 0 12px\\">ðŸ¾ Most Given Pets</h3>";'
    + '    if(stats.topPets.length>0){'
    + '      html+="<div style=\\"background:#16161a;border:1px solid #2a2a3a;border-radius:8px;padding:12px\\">";'
    + '      stats.topPets.forEach(function(p,i){'
    + '        html+="<div style=\\"display:flex;justify-content:space-between;padding:8px 0;border-bottom:"+(i<stats.topPets.length-1?"1px solid #333":"none")+"\\">";'
    + '        html+="<span style=\\"color:#e0e0e0\\">"+p.name+"</span>";'
    + '        html+="<span style=\\"color:#2ecc71;font-weight:600\\">"+p.count+" times</span>";'
    + '        html+="</div>";'
    + '      });'
    + '      html+="</div>";'
    + '    }'
    + '    html+="<h3 style=\\"margin:20px 0 12px\\">ðŸ’Ž Rarity Breakdown</h3>";'
    + '    if(stats.rarityBreakdown.length>0){'
    + '      html+="<div style=\\"background:#16161a;border:1px solid #2a2a3a;border-radius:8px;padding:12px\\">";'
    + '      stats.rarityBreakdown.forEach(function(r,i){'
    + '        var rColor=rarityColors[r.rarity]||"#8b8fa3";'
    + '        var pct=Math.round((r.count/stats.totalGiveaways)*100);'
    + '        html+="<div style=\\"display:flex;align-items:center;gap:8px;padding:8px 0;border-bottom:"+(i<stats.rarityBreakdown.length-1?"1px solid #333":"none")+"\\">";'
    + '        html+="<span style=\\"color:"+rColor+";font-weight:600;min-width:70px\\">"+r.rarity+"</span>";'
    + '        html+="<div style=\\"flex:1;height:24px;background:#333;border-radius:4px;overflow:hidden\\"><div style=\\"height:100%;background:"+rColor+";width:"+pct+"%\\"></div></div>";'
    + '        html+="<span style=\\"color:#8b8fa3;font-size:12px;min-width:60px\\">" + r.count + " ("+pct+"%)</span>";'
    + '        html+="</div>";'
    + '      });'
    + '      html+="</div>";'
    + '    }'
    + '    document.getElementById("giveaway-stats-content").innerHTML=html;'
    + '  });'
    + '};'

    + 'function renderCommentsTab(){'
    + '  var html="";'
    + '  var withComments=history.filter(function(g){return g.comments&&g.comments.length>0});'
    + '  if(withComments.length===0){html="<p style=\\"color:#8b8fa3\\">No giveaways have comments yet.</p>";document.getElementById("giveaway-comments-list").innerHTML=html;return;}'
    + '  withComments.forEach(function(g){'
    + '    var bc=rarityColors[g.petRarity]||"#8b8fa3";'
    + '    html+="<div style=\\"padding:12px;background:#16161a;border:1px solid #2a2a3a;border-left:4px solid "+bc+";border-radius:8px;margin-bottom:12px\\">";'
    + '    html+="<div style=\\"font-weight:700;color:#e0e0e0\\">"+g.petEmoji+" "+g.petName+" ("+g.winner+" â† "+g.giver+")</div>";'
    + '    if(g.comments.length>0){'
    + '      g.comments.forEach(function(c){'
    + '        html+="<div style=\\"margin-top:8px;padding:8px;background:#0a0a0e;border-left:2px solid #9146ff;border-radius:4px\\">";'
    + '        html+="<div style=\\"font-weight:600;color:#9146ff;font-size:11px\\">"+c.author+"</div>";'
    + '        html+="<div style=\\"color:#ccc;font-size:12px;margin-top:4px\\">"+c.text+"</div>";'
    + '        html+="<div style=\\"color:#555;font-size:10px;margin-top:4px\\">"+new Date(c.timestamp).toLocaleString()+"</div>";'
    + '      });'
    + '    }'
    + '    html+="<div style=\\"margin-top:8px\\">";'
    + '    html+="<input type=\\"text\\" placeholder=\\"Add comment...\\" id=\\"comment-input-"+g.id+"\\" style=\\"padding:6px;background:#0a0a0e;border:1px solid #333;color:#e0e0e0;width:100%;border-radius:4px;\\"/>";'
    + '    html+="<button onclick=\\"addComment(\'"+g.id+"\')\\" style=\\"margin-top:4px;padding:4px 10px;background:#9146ff;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px\\">Post Comment</button>";'
    + '    html+="</div>";'
    + '    html+="</div>";'
    + '  });'
    + '  document.getElementById("giveaway-comments-list").innerHTML=html;'
    + '};'

    + 'window.addComment=function(id){'
    + '  var input=document.getElementById("comment-input-"+id);'
    + '  var text=input?input.value.trim():"";'
    + '  if(!text){alert("Comment cannot be empty");return;}'
    + '  fetch("/api/pets/giveaway/"+id+"/comment",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({comment:text})}).then(function(r){return r.json()}).then(function(d){'
    + '    if(d.success){var g=history.find(function(x){return x.id===id});if(g){if(!g.comments)g.comments=[];g.comments.push({author:"You",text:text,timestamp:new Date().toISOString()});renderCommentsTab();}}'
    + '    else{alert(d.error||"Failed");}'
    + '  });'
    + '};'

    + 'function renderBansTab(){'
    + '  if(!isAdmin){document.getElementById("giveaway-bans-list").innerHTML="<p style=\\"color:#8b8fa3\\">Admin only.</p>";return;}'
    + '  var html="<h3 style=\\"margin-bottom:12px\\">Banned Givers ("+bans.length+")</h3>";'
    + '  if(bans.length===0){html+="<p style=\\"color:#8b8fa3\\">No banned users.</p>";document.getElementById("giveaway-bans-list").innerHTML=html;return;}'
    + '  html+="<div style=\\"background:#16161a;border:1px solid #2a2a3a;border-radius:8px\\">";'
    + '  bans.forEach(function(b,i){'
    + '    html+="<div style=\\"display:flex;justify-content:space-between;align-items:center;padding:12px;border-bottom:"+(i<bans.length-1?"1px solid #333":"none")+"\\">";'
    + '    html+="<div style=\\"flex:1\\">";'
    + '    html+="<div style=\\"color:#e0e0e0;font-weight:600\\">"+b.userId+"</div>";'
    + '    html+="<div style=\\"color:#8b8fa3;font-size:12px;margin-top:2px\\">Reason: "+b.reason+"</div>";'
    + '    html+="<div style=\\"color:#555;font-size:10px;margin-top:2px\\">Banned by "+b.bannedBy+" on "+new Date(b.bannedAt).toLocaleDateString()+"</div>";'
    + '    html+="</div>";'
    + '    html+="<button onclick=\\\"removeBan(\"+b.userId+\")\\\" style=\\\"padding:4px 12px;background:#2ecc7122;color:#2ecc71;border:1px solid #2ecc7144;border-radius:4px;cursor:pointer;font-size:11px\\\">Unban</button>";'
    + '    html+="</div>";'
    + '  });'
    + '  html+="</div>";'
    + '  document.getElementById("giveaway-bans-list").innerHTML=html;'
    + '};'

    + 'window.addBan=function(){'
    + '  var userId=document.getElementById("ban-user-id").value.trim();'
    + '  var reason=document.getElementById("ban-reason").value.trim();'
    + '  if(!userId){alert("User ID required");return;}'
    + '  fetch("/api/pets/giveaway/ban/add",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:userId,reason:reason})}).then(function(r){return r.json()}).then(function(d){'
    + '    if(d.success){bans.push({userId:userId,reason:reason,bannedAt:new Date().toISOString(),bannedBy:"You"});document.getElementById("ban-user-id").value="";document.getElementById("ban-reason").value="";renderBansTab();}'
    + '    else{alert(d.error||"Failed");}'
    + '  });'
    + '};'

    + 'window.removeBan=function(userId){'
    + '  if(!confirm("Unban this user?")) return;'
    + '  fetch("/api/pets/giveaway/ban/remove",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({userId:userId})}).then(function(r){return r.json()}).then(function(d){'
    + '    if(d.success){bans=bans.filter(function(b){return b.userId!==userId});renderBansTab();}'
    + '    else{alert(d.error||"Failed");}'
    + '  });'
    + '};'

    + 'window.filterGiveaways=function(){'
    + '  var filter=document.getElementById("giveaway-filter").value;'
    + '  var search=(document.getElementById("giveaway-search").value||"").toLowerCase().trim();'
    + '  var filtered=history.filter(function(g){'
    + '    if(filter==="pending"&&g.confirmed) return false;'
    + '    if(filter==="confirmed"&&!g.confirmed) return false;'
    + '    if(search){'
    + '      var haystack=(g.petName+" "+g.winner+" "+g.giver+" "+g.notes+" "+g.petEmoji).toLowerCase();'
    + '      if(haystack.indexOf(search)===-1) return false;'
    + '    }'
    + '    return true;'
    + '  });'
    + '  if(filtered.length===0){document.getElementById("giveaway-list").innerHTML=\'<p style="color:#8b8fa3">No giveaways found.</p>\';return;}'
    + '  var html="";'
    + '  filtered.forEach(function(g){'
    + '    var bc=rarityColors[g.petRarity]||"#8b8fa3";'
    + '    var statusBadge=g.confirmed'
    + '      ?\'<span style="background:#2ecc7122;color:#2ecc71;padding:2px 8px;border-radius:4px;font-size:10px;font-weight:600">âœ… Confirmed</span>\''
    + '      :\'<span style="background:#f39c1222;color:#f39c12;padding:2px 8px;border-radius:4px;font-size:10px;font-weight:600">â³ Pending</span>\';'
    + '    var date=new Date(g.submittedAt).toLocaleDateString();'
    + '    var timeLeft="";'
    + '    if(g.expiresAt){var diff=g.expiresAt-Date.now();if(diff>0){var mins=Math.floor(diff/60000);timeLeft=" | â° Expires in "+mins+"m";}else{timeLeft=" | â° Expired";}}'
    + '    var pingIcons=(g.pingGiver?"ðŸ””":"")+(g.pingReceiver?"ðŸ””":"");'
    + '    html+=\'<div style="display:flex;align-items:center;gap:16px;padding:12px;background:#16161a;border:1px solid #2a2a3a;border-left:4px solid \'+bc+\';border-radius:8px;margin-bottom:8px">\''
    + '      +\'<div style="font-size:32px;min-width:40px;text-align:center">\'+g.petEmoji+\'</div>\''
    + '      +\'<div style="flex:1">\''
    + '      +\'<div style="font-weight:700;font-size:14px">\'+g.petName+\' <span style="font-weight:400;color:\'+bc+\';font-size:11px">\'+g.petRarity+\'</span></div>\''
    + '      +\'<div style="font-size:12px;color:#ccc;margin-top:2px">ðŸ† Winner: <b>\'+g.winner+\'</b> â€¢ ðŸŽ Given by: <b>\'+g.giver+\'</b>\' + (pingIcons ? \' \' + pingIcons : \"\") + \'</div>\''
    + '      +(g.notes?\'<div style="font-size:11px;color:#8b8fa3;margin-top:2px">ðŸ“ \'+g.notes+\'</div>\':"")'
    + '      +\'<div style="font-size:10px;color:#555;margin-top:4px">\'+date+timeLeft+\' â€¢ Submitted by \'+g.submittedBy+(g.confirmed?" â€¢ Confirmed by "+g.confirmedBy:"")+\'</div>\''
    + '      +\'</div>\''
    + '      +\'<div style="display:flex;flex-direction:column;gap:4px;align-items:end">\'+statusBadge'
    + '      +(!g.confirmed?\'<button onclick="confirmGiveaway(\\\'\'+g.id+\'\\\')" style="padding:4px 10px;background:#2ecc71;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:11px;font-weight:600">Confirm</button>\':"")'
    + '      +\'<button onclick="deletePetGiveaway(\\\'\'+g.id+\'\\\')" style="padding:4px 10px;background:#e74c3c22;color:#e74c3c;border:1px solid #e74c3c44;border-radius:4px;cursor:pointer;font-size:11px">Delete</button>\''
    + '      +\'</div></div>\';'
    + '  });'
    + '  document.getElementById("giveaway-list").innerHTML=html;'
    + '};'

    + 'window.confirmGiveaway=function(id){'
    + '  if(!confirm("Confirm this giveaway/trade happened?")) return;'
    + '  fetch("/api/pets/giveaway/confirm",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:id})}).then(function(r){var ct=r.headers.get("content-type")||"";if(!ct.includes("application/json")){throw new Error("Session expired. Please refresh.");}return r.json()}).then(function(d){'
    + '    if(d.success){var g=history.find(function(x){return x.id===id});if(g){g.confirmed=true;g.confirmedBy="You";}filterGiveaways();}'
    + '    else{alert(d.error||"Failed");}'
    + '  }).catch(function(e){alert("Error: "+e.message)});'
    + '};'

    + 'window.deletePetGiveaway=function(id){'
    + '  if(!confirm("Delete this giveaway entry?")) return;'
    + '  fetch("/api/pets/giveaway/delete",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:id})}).then(function(r){var ct=r.headers.get("content-type")||"";if(!ct.includes("application/json")){throw new Error("Session expired. Please refresh.");}return r.json()}).then(function(d){'
    + '    if(d.success){history=history.filter(function(x){return x.id!==id});filterGiveaways();}'
    + '    else{alert(d.error||"Failed");}'
    + '  }).catch(function(e){alert("Error: "+e.message)});'
    + '};'

    + 'filterGiveaways();'
    + '})();'
    + '</script>';
}

// ====================== PET STATS TAB ======================
function renderPetStatsTab(userTier) {
  const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
  const pets = petsData.pets || [];
  const catalog = petsData.catalog || [];
  const categories = petsData.categories || [];
  
  // Calculate statistics
  const totalPets = pets.length;
  const uniquePets = new Set(pets.map(p => p.petId)).size;
  const catalogSize = catalog.length;
  const collectionPercentage = catalogSize > 0 ? Math.round((uniquePets / catalogSize) * 100) : 0;
  
  // Category breakdown
  const categoryStats = {};
  pets.forEach(p => {
    const catEntry = catalog.find(c => c.id === p.petId);
    if (catEntry && catEntry.category) {
      categoryStats[catEntry.category] = (categoryStats[catEntry.category] || 0) + 1;
    }
  });
  
  // Rarity breakdown
  const rarityStats = {};
  pets.forEach(p => {
    const catEntry = catalog.find(c => c.id === p.petId);
    if (catEntry && catEntry.rarity) {
      rarityStats[catEntry.rarity] = (rarityStats[catEntry.rarity] || 0) + 1;
    }
  });
  
  // Top 10 most owned pets
  const petCounts = {};
  pets.forEach(p => {
    petCounts[p.petId] = (petCounts[p.petId] || 0) + 1;
  });
  const topPets = Object.entries(petCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10)
    .map(([petId, count]) => {
      const catEntry = catalog.find(c => c.id === petId);
      return { id: petId, name: catEntry?.name || petId, emoji: catEntry?.emoji || 'â“', count, rarity: catEntry?.rarity || 'unknown' };
    });
    
  // Giver statistics
  const giverStats = {};
  pets.forEach(p => {
    if (p.givenBy) {
      giverStats[p.givenBy] = (giverStats[p.givenBy] || 0) + 1;
    }
  });
  const topGivers = Object.entries(giverStats)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10)
    .map(([name, count]) => ({ name, count }));
    
  // Prepare data for charts
  const categoryData = JSON.stringify(categoryStats);
  const rarityData = JSON.stringify(rarityStats);
  const topPetsData = JSON.stringify(topPets.map(p => ({ label: p.emoji + ' ' + p.name, value: p.count })));
  const topGiversData = JSON.stringify(topGivers.map(g => ({ label: g.name, value: g.count })));
  
  const rarityColors = {
    common: '#95a5a6',
    uncommon: '#2ecc71',
    rare: '#3498db',
    epic: '#9b59b6',
    legendary: '#f39c12',
    mythic: '#e74c3c'
  };
  
  return '<div class="card">'
    + '<h2>ðŸ“Š Pet Collection Statistics</h2>'
    + '<p style="color:#8b8fa3;font-size:13px;margin-top:-4px">Comprehensive overview of your pet collection with charts and analytics.</p>'
    + '</div>'
    
    // Overview stats
    + '<div class="card">'
    + '<h3 style="margin-top:0">ðŸ“ˆ Overview</h3>'
    + '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px">'
    + '<div style="padding:16px;background:#9146ff15;border:1px solid #9146ff33;border-radius:8px;text-align:center">'
    + '<div style="font-size:24px;font-weight:700;color:#9146ff">' + totalPets + '</div>'
    + '<div style="font-size:11px;color:#8b8fa3;margin-top:4px">Total Pets Owned</div>'
    + '</div>'
    + '<div style="padding:16px;background:#2ecc7115;border:1px solid #2ecc7133;border-radius:8px;text-align:center">'
    + '<div style="font-size:24px;font-weight:700;color:#2ecc71">' + uniquePets + '</div>'
    + '<div style="font-size:11px;color:#8b8fa3;margin-top:4px">Unique Species</div>'
    + '</div>'
    + '<div style="padding:16px;background:#3498db15;border:1px solid #3498db33;border-radius:8px;text-align:center">'
    + '<div style="font-size:24px;font-weight:700;color:#3498db">' + catalogSize + '</div>'
    + '<div style="font-size:11px;color:#8b8fa3;margin-top:4px">Total Available</div>'
    + '</div>'
    + '<div style="padding:16px;background:#f39c1215;border:1px solid #f39c1233;border-radius:8px;text-align:center">'
    + '<div style="font-size:24px;font-weight:700;color:#f39c12">' + collectionPercentage + '%</div>'
    + '<div style="font-size:11px;color:#8b8fa3;margin-top:4px">Collection Complete</div>'
    + '</div>'
    + '</div>'
    + '</div>'
    
    // Charts
    + '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(400px,1fr));gap:15px">'
    
    // Category breakdown chart
    + '<div class="card">'
    + '<h3 style="margin-top:0">ðŸ“¦ By Category</h3>'
    + '<canvas id="categoryChart" style="max-height:300px"></canvas>'
    + '</div>'
    
    // Rarity breakdown chart
    + '<div class="card">'
    + '<h3 style="margin-top:0">ðŸ’Ž By Rarity</h3>'
    + '<canvas id="rarityChart" style="max-height:300px"></canvas>'
    + '</div>'
    
    + '</div>'
    
    // Top 10 pets
    + '<div class="card">'
    + '<h3 style="margin-top:0">ðŸ† Top 10 Most Owned Pets</h3>'
    + '<div style="background:#16161a;border:1px solid #2a2a3a;border-radius:8px;padding:12px">'
    + (topPets.length > 0 ? topPets.map((p, i) => {
      const rarityColor = rarityColors[p.rarity] || '#8b8fa3';
      return '<div style="display:flex;justify-content:space-between;padding:8px 0;border-bottom:' + (i < topPets.length - 1 ? '1px solid #333' : 'none') + '">'
        + '<span style="color:#e0e0e0"><span style="color:#8b8fa3;margin-right:8px">#' + (i + 1) + '</span>' + p.emoji + ' ' + p.name + ' <span style="font-size:10px;color:' + rarityColor + '">' + p.rarity + '</span></span>'
        + '<span style="color:#9146ff;font-weight:600">' + p.count + ' owned</span>'
        + '</div>';
    }).join('') : '<div style="color:#8b8fa3;text-align:center;padding:20px">No pets owned yet</div>')
    + '</div>'
    + '</div>'
    
    // Top givers
    + '<div class="card">'
    + '<h3 style="margin-top:0">ðŸŽ Top 10 Pet Givers</h3>'
    + '<div style="background:#16161a;border:1px solid #2a2a3a;border-radius:8px;padding:12px">'
    + (topGivers.length > 0 ? topGivers.map((g, i) => {
      return '<div style="display:flex;justify-content:space-between;padding:8px 0;border-bottom:' + (i < topGivers.length - 1 ? '1px solid #333' : 'none') + '">'
        + '<span style="color:#e0e0e0"><span style="color:#8b8fa3;margin-right:8px">#' + (i + 1) + '</span>' + g.name + '</span>'
        + '<span style="color:#2ecc71;font-weight:600">' + g.count + ' pets</span>'
        + '</div>';
    }).join('') : '<div style="color:#8b8fa3;text-align:center;padding:20px">No givers recorded yet</div>')
    + '</div>'
    + '</div>'
    
    // Script for charts
    + '<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>'
    + '<script>'
    + '(function(){'
    + '  var categoryData=' + categoryData + ';'
    + '  var rarityData=' + rarityData + ';'
    
    // Category chart
    + '  if(Object.keys(categoryData).length>0){'
    + '    var ctxCat=document.getElementById("categoryChart").getContext("2d");'
    + '    new Chart(ctxCat,{'
    + '      type:"doughnut",'
    + '      data:{'
    + '        labels:Object.keys(categoryData),'
    + '        datasets:[{data:Object.values(categoryData),backgroundColor:["#9146ff","#2ecc71","#3498db","#f39c12","#e74c3c","#9b59b6","#1abc9c"]}]'
    + '      },'
    + '      options:{responsive:true,maintainAspectRatio:true,plugins:{legend:{labels:{color:"#e0e0e0"}}}}'
    + '    });'
    + '  }'
    
    // Rarity chart
    + '  if(Object.keys(rarityData).length>0){'
    + '    var ctxRar=document.getElementById("rarityChart").getContext("2d");'
    + '    var rarityColors={common:"#95a5a6",uncommon:"#2ecc71",rare:"#3498db",epic:"#9b59b6",legendary:"#f39c12",mythic:"#e74c3c"};'
    + '    var rarityBgColors=Object.keys(rarityData).map(function(r){return rarityColors[r]||"#8b8fa3"});'
    + '    new Chart(ctxRar,{'
    + '      type:"bar",'
    + '      data:{'
    + '        labels:Object.keys(rarityData),'
    + '        datasets:[{label:"Count",data:Object.values(rarityData),backgroundColor:rarityBgColors}]'
    + '      },'
    + '      options:{responsive:true,maintainAspectRatio:true,plugins:{legend:{display:false}},scales:{y:{beginAtZero:true,ticks:{color:"#e0e0e0"}},x:{ticks:{color:"#e0e0e0"}}}}'
    + '    });'
    + '  }'
    
    + '})();'
    + '</script>';
}

// Account Management Tab (Owner-only)
function renderAccountsTab() {
  return `
<div class="card">
  <h2>ðŸ” Account Management</h2>
  <p style="color:#8b8fa3;font-size:13px;margin-top:-4px">Create, manage and control access for dashboard accounts. Only owners can access this page.</p>
</div>

<div class="card">
  <h2>âž• Create New Account</h2>
  <div style="display:grid;grid-template-columns:1fr 1fr 1fr auto;gap:10px;align-items:end">
    <div>
      <label style="font-size:11px;color:#8b8fa3;text-transform:uppercase;letter-spacing:0.5px">Username</label>
      <input type="text" id="newUsername" placeholder="e.g. moderator1" style="margin:4px 0">
    </div>
    <div>
      <label style="font-size:11px;color:#8b8fa3;text-transform:uppercase;letter-spacing:0.5px">Password</label>
      <input type="password" id="newPassword" placeholder="Min 6 characters" style="margin:4px 0">
    </div>
    <div>
      <label style="font-size:11px;color:#8b8fa3;text-transform:uppercase;letter-spacing:0.5px">Tier</label>
      <select id="newTier" style="margin:4px 0">
        <option value="viewer">ðŸ‘ï¸ Viewer (read-only)</option>
        <option value="moderator">ðŸ›¡ï¸ Moderator</option>
        <option value="admin">âš¡ Admin</option>
        <option value="owner">ðŸ‘‘ Owner</option>
      </select>
    </div>
    <div>
      <button class="small" onclick="createAccount()" style="margin:4px 0;height:38px;padding:0 16px">Create</button>
    </div>
  </div>
  <div id="createResult" style="margin-top:8px"></div>
</div>

<div class="card">
  <h2>ðŸ“‹ Existing Accounts</h2>
  <div id="accountsList" style="margin-top:10px">
    <div style="text-align:center;padding:20px;color:#8b8fa3">Loading accounts...</div>
  </div>
</div>

<div class="card">
  <h2>ðŸ”‘ Tier Permissions Reference</h2>
  <table>
    <thead>
      <tr>
        <th>Tier</th>
        <th>Access</th>
        <th>Can Edit</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span style="color:#ff4444;font-weight:700">ðŸ‘‘ Owner</span></td>
        <td>All sections + Account Management</td>
        <td>âœ… Yes</td>
      </tr>
      <tr>
        <td><span style="color:#9146ff;font-weight:700">âš¡ Admin</span></td>
        <td>Core, Community, Analytics, RPG, Config</td>
        <td>âœ… Yes</td>
      </tr>
      <tr>
        <td><span style="color:#4caf50;font-weight:700">ðŸ›¡ï¸ Moderator</span></td>
        <td>Core, Community, Analytics</td>
        <td>âœ… Yes</td>
      </tr>
      <tr>
        <td><span style="color:#8b8fa3;font-weight:700">ðŸ‘ï¸ Viewer</span></td>
        <td>Core, Analytics</td>
        <td>âŒ Read-only</td>
      </tr>
    </tbody>
  </table>
</div>

<script>
const tierColors = {owner:'#ff4444',admin:'#9146ff',moderator:'#4caf50',viewer:'#8b8fa3'};
const tierIcons = {owner:'ðŸ‘‘',admin:'âš¡',moderator:'ðŸ›¡ï¸',viewer:'ðŸ‘ï¸'};
const tierLabels = {owner:'Owner',admin:'Admin',moderator:'Moderator',viewer:'Viewer'};

function loadAccounts() {
  fetch('/api/accounts').then(r=>r.json()).then(d=>{
    if(!d.success) { document.getElementById('accountsList').innerHTML='<div style="color:#ff6b6b">Error loading accounts</div>'; return; }
    const accts = d.accounts;
    if(accts.length===0) { document.getElementById('accountsList').innerHTML='<div style="color:#8b8fa3">No accounts found.</div>'; return; }
    let html = '<table><thead><tr><th>Username</th><th>Tier</th><th>Last Login</th><th>Created</th><th style="width:260px">Actions</th></tr></thead><tbody>';
    accts.forEach(function(a) {
      const lastLogin = a.lastLogin ? new Date(a.lastLogin).toLocaleString() : 'Never';
      const created = new Date(a.createdAt).toLocaleDateString();
      const color = tierColors[a.tier]||'#8b8fa3';
      const icon = tierIcons[a.tier]||'';
      html += '<tr>';
      html += '<td style="font-weight:600">' + a.username + '</td>';
      html += '<td><span style="color:' + color + ';font-weight:700">' + icon + ' ' + (tierLabels[a.tier]||a.tier) + '</span></td>';
      html += '<td style="font-size:12px;color:#8b8fa3">' + lastLogin + '</td>';
      html += '<td style="font-size:12px;color:#8b8fa3">' + created + '</td>';
      html += '<td style="display:flex;gap:6px;flex-wrap:wrap">';
      html += '<select id="tier-' + a.id + '" style="width:auto;margin:0;padding:4px 8px;font-size:11px">';
      ['owner','admin','moderator','viewer'].forEach(function(t) {
        html += '<option value="' + t + '"' + (a.tier===t?' selected':'') + '>' + (tierLabels[t]||t) + '</option>';
      });
      html += '</select>';
      html += '<button class="small" style="margin:0;padding:4px 10px;font-size:11px" onclick="changeTier(\\'' + a.id + '\\')">Update</button>';
      html += '<button class="small" style="margin:0;padding:4px 10px;font-size:11px;background:#e67e22" onclick="resetPassword(\\'' + a.id + '\\',\\'' + a.username + '\\')">Reset PW</button>';
      html += '<button class="small danger" style="margin:0;padding:4px 10px;font-size:11px" onclick="deleteAccount(\\'' + a.id + '\\',\\'' + a.username + '\\')">Delete</button>';
      html += '</td></tr>';
    });
    html += '</tbody></table>';
    document.getElementById('accountsList').innerHTML = html;
  });
}

function createAccount() {
  var un = document.getElementById('newUsername').value.trim();
  var pw = document.getElementById('newPassword').value;
  var tier = document.getElementById('newTier').value;
  if(!un||!pw) { showResult('createResult','Please fill all fields','#ff6b6b'); return; }
  fetch('/api/accounts/create',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({username:un,password:pw,tier:tier})})
    .then(function(r){return r.json()}).then(function(d){
      if(d.success) {
        showResult('createResult','Account created successfully!','#4caf50');
        document.getElementById('newUsername').value='';
        document.getElementById('newPassword').value='';
        loadAccounts();
      } else {
        showResult('createResult',d.error||'Error creating account','#ff6b6b');
      }
    });
}

function changeTier(id) {
  var sel = document.getElementById('tier-'+id);
  if(!sel) return;
  var newTier = sel.value;
  fetch('/api/accounts/update-tier',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({id:id,tier:newTier})})
    .then(function(r){return r.json()}).then(function(d){
      if(d.success) { loadAccounts(); } else { alert(d.error||'Error updating tier'); }
    });
}

function resetPassword(id, username) {
  var newPw = prompt('Enter new password for '+username+' (min 6 chars):');
  if(!newPw) return;
  if(newPw.length<6) { alert('Password must be at least 6 characters'); return; }
  fetch('/api/accounts/reset-password',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({id:id,newPassword:newPw})})
    .then(function(r){return r.json()}).then(function(d){
      if(d.success) { alert('Password reset successfully for '+username); } else { alert(d.error||'Error resetting password'); }
    });
}

function deleteAccount(id, username) {
  if(!confirm('Are you sure you want to delete the account "'+username+'"? This cannot be undone.')) return;
  fetch('/api/accounts/delete',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({id:id})})
    .then(function(r){return r.json()}).then(function(d){
      if(d.success) { loadAccounts(); } else { alert(d.error||'Error deleting account'); }
    });
}

function showResult(elId, msg, color) {
  var el = document.getElementById(elId);
  if(!el) return;
  el.innerHTML = '<div style="color:'+color+';font-size:13px;padding:6px 12px;background:'+color+'15;border:1px solid '+color+'33;border-radius:4px">'+msg+'</div>';
  setTimeout(function(){ el.innerHTML=''; }, 5000);
}

loadAccounts();
</script>`;
}

// NEW: Health tab
function renderHealthTab() {
  const formatMs = (ms) => {
    if (!ms || ms < 0) return 'N/A';
    const d = Math.floor(ms / (1000 * 60 * 60 * 24));
    const h = Math.floor((ms % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const m = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    return `${d}d ${h}h ${m}m`;
  };

  const botUptimeMs = Date.now() - startTime;
  const streamLive = !!streamInfo.startedAt && isLive;
  const streamUptime = streamInfo.startedAt ? formatMs(Date.now() - new Date(streamInfo.startedAt).getTime()) : 'N/A';
  const scheduleDelay = schedule?.streamDelayed ? 'Yes' : 'No';
  const delaySince = schedule?.streamDelayed && schedule?.nextStreamAt
    ? new Date(schedule.nextStreamAt).toLocaleString()
    : 'N/A';

  const mem = process.memoryUsage();
  const memRss = Math.round(mem.rss / 1024 / 1024);
  const memHeap = Math.round(mem.heapUsed / 1024 / 1024);
  const processUptime = formatMs(process.uptime() * 1000);

  const wsPing = client?.ws?.ping ?? 'N/A';
  const guildCount = client?.guilds?.cache?.size ?? 0;
  const userTag = client?.user?.tag ?? 'N/A';

  return `
<div class="card">
  <h2>ðŸ’“ Bot & Stream Health</h2>
  <p style="color:#b0b0b0">Live status, bot health, and schedule state</p>

  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;margin-top:12px">
    <div class="card" style="margin:0">
      <h3 style="margin:0 0 8px 0">Bot</h3>
      <div>Bot Uptime: <strong>${formatMs(botUptimeMs)}</strong></div>
      <div>Process Uptime: <strong>${processUptime}</strong></div>
      <div>Memory: <strong>${memHeap} MB heap / ${memRss} MB RSS</strong></div>
      <div>Node: <strong>${process.version}</strong></div>
      <div>PID: <strong>${process.pid}</strong></div>
    </div>

    <div class="card" style="margin:0">
      <h3 style="margin:0 0 8px 0">Discord</h3>
      <div>Client: <strong>${userTag}</strong></div>
      <div>Guilds: <strong>${guildCount}</strong></div>
      <div>WebSocket Ping: <strong>${wsPing} ms</strong></div>
      <div>Timezone: <strong>${botTimezone || 'N/A'}</strong></div>
    </div>

    <div class="card" style="margin:0">
      <h3 style="margin:0 0 8px 0">Stream</h3>
      <div>Status: <strong style="color:${streamLive ? '#4caf50' : '#ff6b6b'}">${streamLive ? 'ðŸŸ¢ LIVE' : 'ðŸ”´ OFFLINE'}</strong></div>
      <div>Uptime: <strong>${streamUptime}</strong></div>
      <div>Delayed: <strong>${scheduleDelay}</strong></div>
      <div>Delay Since: <strong>${delaySince}</strong></div>
    </div>
  </div>
</div>
`;
}

// Analytics dashboard tab
function renderAnalyticsTab() {
  // Calculate stats
  const h = history || [];
  const totalStreams = h.length;
  const totalMinutes = h.reduce((sum, s) => sum + (s.durationMinutes || 0), 0);
  const totalHours = (totalMinutes / 60).toFixed(1);
  const avgViewers = totalStreams > 0 ? Math.round(h.reduce((sum, s) => sum + (s.peakViewers || 0), 0) / totalStreams) : 0;
  const peakViewers = h.reduce((max, s) => Math.max(max, s.peakViewers || 0), 0);
  const avgDuration = totalStreams > 0 ? Math.round(totalMinutes / totalStreams) : 0;
  const medianViewers = (() => { const sorted = h.map(s => s.peakViewers || 0).sort((a, b) => a - b); return sorted.length > 0 ? sorted[Math.floor(sorted.length / 2)] : 0; })();
  const totalFollowers = h.reduce((s, x) => s + (x.followers || x.newFollowers || 0), 0);
  const totalSubs = h.reduce((s, x) => s + (x.subscribers || x.newSubs || 0), 0);
  const avgFollowersPerStream = totalStreams > 0 ? (totalFollowers / totalStreams).toFixed(1) : '0.0';
  const avgSubsPerStream = totalStreams > 0 ? (totalSubs / totalStreams).toFixed(1) : '0.0';
  const viewerMinutes = h.reduce((sum, s) => sum + ((s.peakViewers || 0) * (s.durationMinutes || 0)), 0);
  const viewerHours = (viewerMinutes / 60).toFixed(0);

  // Stream frequency
  const sortedDates = h.map(s => new Date(s.startedAt || s.date)).sort((a, b) => b - a);
  let avgDaysBetween = 0;
  if (sortedDates.length > 1) {
    const gaps = [];
    for (let i = 0; i < sortedDates.length - 1; i++) gaps.push((sortedDates[i] - sortedDates[i + 1]) / (1000 * 60 * 60 * 24));
    avgDaysBetween = (gaps.reduce((a, b) => a + b, 0) / gaps.length).toFixed(1);
  }
  const streamsPerWeek = avgDaysBetween > 0 ? (7 / parseFloat(avgDaysBetween)).toFixed(1) : '0.0';

  // Day since last stream
  const lastStreamDate = sortedDates.length > 0 ? sortedDates[0] : null;
  const daysSinceLast = lastStreamDate ? Math.floor((Date.now() - lastStreamDate) / (1000 * 60 * 60 * 24)) : 0;

  // Longest & shortest stream
  const longestStream = h.reduce((best, s) => (s.durationMinutes || 0) > (best.durationMinutes || 0) ? s : best, h[0] || {});
  const shortestStream = h.reduce((worst, s) => (s.durationMinutes || 0) < (worst.durationMinutes || 0) && (s.durationMinutes || 0) > 0 ? s : worst, h[0] || {});

  // Game stats
  const gameTime = {};
  h.forEach(s => {
    const game = s.game || s.gameName || 'Unknown';
    gameTime[game] = (gameTime[game] || 0) + (s.durationMinutes || 0);
  });
  const topGames = Object.entries(gameTime).sort((a, b) => b[1] - a[1]).slice(0, 5);
  const maxGameTime = topGames.length > 0 ? topGames[0][1] : 1;
  const uniqueGames = Object.keys(gameTime).length;

  // Build top games HTML
  let topGamesHtml = '';
  if (topGames.length > 0) {
    topGames.forEach((g, i) => {
      const pct = Math.round((g[1] / maxGameTime) * 100);
      const rankClass = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
      const hours = (g[1] / 60).toFixed(1);
      topGamesHtml += '<div class="game-item">' +
        '<div class="game-rank ' + rankClass + '">' + (i + 1) + '</div>' +
        '<div class="game-info"><div class="game-name">' + g[0] + '</div>' +
        '<div class="game-hours">' + hours + ' hours</div></div>' +
        '<div class="game-bar-wrap"><div class="game-bar" style="width:' + pct + '%"></div></div></div>';
    });
  } else {
    topGamesHtml = '<div class="empty-state"><div class="empty-icon">ðŸŽ®</div><p>No games tracked yet</p></div>';
  }

  // Build recent streams table
  const recentStreams = h.slice(-10).reverse();
  let streamsTableHtml = '';
  if (recentStreams.length > 0) {
    streamsTableHtml = '<table class="streams-table"><thead><tr><th>Date</th><th>Game</th><th>Peak Viewers</th><th>Duration</th></tr></thead><tbody>';
    recentStreams.forEach(s => {
      const date = new Date(s.startedAt || s.date);
      const formattedDate = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      const hrs = Math.floor((s.durationMinutes || 0) / 60);
      const mins = (s.durationMinutes || 0) % 60;
      const duration = hrs > 0 ? hrs + 'h ' + mins + 'm' : mins + 'm';
      const game = s.game || s.gameName || 'Unknown';
      streamsTableHtml += '<tr><td>' + formattedDate + '</td><td><span class="game-tag">' + game + '</span></td>' +
        '<td class="viewers">' + (s.peakViewers || 0) + '</td><td class="duration">' + duration + '</td></tr>';
    });
    streamsTableHtml += '</tbody></table>';
  } else {
    streamsTableHtml = '<div class="empty-state"><div class="empty-icon">ðŸ“º</div><p>No streams recorded yet</p></div>';
  }

  // Monthly stats
  const monthlyStats = {};
  h.forEach(s => {
    const date = new Date(s.startedAt || s.date);
    const key = date.toLocaleString('default', { month: 'short', year: 'numeric' });
    if (!monthlyStats[key]) monthlyStats[key] = { streams: 0, viewers: 0, hours: 0 };
    monthlyStats[key].streams++;
    monthlyStats[key].viewers += (s.peakViewers || 0);
    monthlyStats[key].hours += (s.durationMinutes || 0) / 60;
  });

  let monthlyHtml = '';
  const monthKeys = Object.keys(monthlyStats).slice(0, 5);
  if (monthKeys.length > 0) {
    monthKeys.forEach(month => {
      const data = monthlyStats[month];
      const avgV = data.streams > 0 ? Math.round(data.viewers / data.streams) : 0;
      monthlyHtml += '<div class="monthly-item"><div class="monthly-label">' + month + '</div>' +
        '<div class="monthly-stats"><div class="monthly-stat"><div class="val">' + data.streams + '</div><div class="lbl">Streams</div></div>' +
        '<div class="monthly-stat"><div class="val">' + avgV + '</div><div class="lbl">Avg Viewers</div></div>' +
        '<div class="monthly-stat"><div class="val">' + data.hours.toFixed(1) + 'h</div><div class="lbl">Hours</div></div></div></div>';
    });
  } else {
    monthlyHtml = '<div class="empty-state"><div class="empty-icon">ðŸ“…</div><p>No monthly data yet</p></div>';
  }

  // AI Insights
  let insightsHtml = '';
  if (totalStreams > 0) {
    insightsHtml = '<div class="insight-item"><span class="insight-icon">ðŸ’¡</span><span class="insight-text">You have streamed <strong>' + totalStreams + '</strong> times for a total of <strong>' + totalHours + ' hours</strong>.</span></div>';
    if (topGames.length > 0) {
      insightsHtml += '<div class="insight-item"><span class="insight-icon">ðŸŽ®</span><span class="insight-text">Your most played game is <strong>' + topGames[0][0] + '</strong> with ' + (topGames[0][1] / 60).toFixed(1) + ' hours.</span></div>';
    }
    insightsHtml += '<div class="insight-item"><span class="insight-icon">ðŸ“Š</span><span class="insight-text">Your average peak viewers is <strong>' + avgViewers + '</strong> (median: <strong>' + medianViewers + '</strong>).</span></div>';
    insightsHtml += '<div class="insight-item"><span class="insight-icon">ðŸ“…</span><span class="insight-text">You stream about <strong>' + streamsPerWeek + '</strong> times per week (every <strong>' + avgDaysBetween + '</strong> days).</span></div>';
    insightsHtml += '<div class="insight-item"><span class="insight-icon">ðŸ‘ï¸</span><span class="insight-text">Total viewer-hours generated: <strong>' + viewerHours + '</strong>.</span></div>';
  } else {
    insightsHtml = '<div class="insight-item"><span class="insight-icon">ðŸš€</span><span class="insight-text">Start streaming to see personalized insights!</span></div>';
  }

  // Live banner
  const isCurrentlyLive = !!streamInfo?.startedAt;
  const currentViewers = stats?.viewers || 0;
  const liveBannerHtml = isCurrentlyLive ?
    '<div class="live-banner"><div class="live-dot"></div><span class="live-text">ðŸ”´ Currently Live</span><span class="live-viewers">ðŸ‘ ' + currentViewers + ' viewers</span></div>' : '';

  return `
<style>
#stats-dashboard{padding:0}
.stats-header{background:#1f1f23;padding:30px;border-radius:8px;margin-bottom:20px;border:1px solid #2a2f3a}
.stats-header h2{margin:0 0 8px 0;font-size:24px;color:#fff}
.stats-header p{margin:0;color:#b0b0b0}
.filter-row{display:flex;gap:8px;margin-top:20px;flex-wrap:wrap}
.filter-btn{padding:10px 20px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#b0b0b0;cursor:pointer;font-size:13px;font-weight:500;transition:all 0.2s;width:auto}
.filter-btn:hover{background:#3a3a42;color:#fff;transform:translateY(-1px)}
.filter-btn.active{background:#9146ff;color:#fff;border-color:#9146ff}
.export-btn{padding:10px 20px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#4caf50;cursor:pointer;font-size:13px;font-weight:500;margin-left:auto;width:auto}
.export-btn:hover{background:#3a3a42}
.metrics-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:12px;margin-bottom:20px}
.metric-card{background:#1f1f23;padding:18px;border-radius:8px;border:1px solid #2a2f3a;position:relative;overflow:hidden}
.metric-card::before{content:'';position:absolute;top:0;left:0;right:0;height:3px;background:var(--accent,#9146ff)}
.metric-card .icon{font-size:22px;margin-bottom:6px}
.metric-card .value{font-size:24px;font-weight:700;color:#fff;margin-bottom:4px;font-family:monospace}
.metric-card .label{color:#b0b0b0;font-size:11px;text-transform:uppercase;letter-spacing:0.5px}
.two-col{display:grid;grid-template-columns:repeat(auto-fit,minmax(350px,1fr));gap:15px;margin-bottom:20px}
.stats-card{background:#1f1f23;border-radius:8px;border:1px solid #2a2f3a;overflow:hidden}
.stats-card-header{padding:16px 20px;border-bottom:1px solid #2a2f3a;display:flex;align-items:center;gap:10px}
.stats-card-header h3{margin:0;font-size:15px;color:#fff;font-weight:600}
.stats-card-body{padding:16px 20px}
.game-item{display:flex;align-items:center;padding:12px 0;border-bottom:1px solid #2a2f3a}
.game-item:last-child{border-bottom:none}
.game-rank{width:26px;height:26px;background:#9146ff;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:11px;font-weight:700;color:#fff;margin-right:12px;flex-shrink:0}
.game-rank.gold{background:#ffd700;color:#000}
.game-rank.silver{background:#c0c0c0;color:#000}
.game-rank.bronze{background:#cd7f32;color:#fff}
.game-info{flex:1;min-width:0}
.game-name{color:#fff;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:14px}
.game-hours{color:#b0b0b0;font-size:11px;margin-top:2px}
.game-bar-wrap{width:80px;height:6px;background:#2a2f3a;border-radius:3px;overflow:hidden;margin-left:12px}
.game-bar{height:100%;background:#9146ff;border-radius:3px}
.streams-table{width:100%;border-collapse:separate;border-spacing:0}
.streams-table th{background:#2a2f3a;padding:12px 14px;text-align:left;font-size:11px;text-transform:uppercase;letter-spacing:0.5px;color:#b0b0b0;font-weight:600;border:none}
.streams-table th:first-child{border-radius:4px 0 0 0}
.streams-table th:last-child{border-radius:0 4px 0 0}
.streams-table td{padding:14px;border-bottom:1px solid #2a2f3a;color:#e0e0e0;font-size:13px}
.streams-table tr:hover td{background:#252529}
.streams-table .viewers{color:#9146ff;font-weight:600;font-family:monospace}
.streams-table .duration{color:#4caf50;font-family:monospace}
.streams-table .game-tag{display:inline-block;padding:4px 8px;background:#2a2f3a;border-radius:4px;font-size:11px;color:#b0b0b0}
.monthly-item{display:flex;align-items:center;padding:12px;background:#2a2f3a;border-radius:4px;margin-bottom:10px}
.monthly-item:last-child{margin-bottom:0}
.monthly-label{min-width:90px;font-weight:600;color:#fff;font-size:13px}
.monthly-stats{display:flex;gap:20px;flex:1;justify-content:flex-end}
.monthly-stat{text-align:center}
.monthly-stat .val{font-size:16px;font-weight:700;color:#9146ff;font-family:monospace}
.monthly-stat .lbl{font-size:10px;color:#b0b0b0;text-transform:uppercase}
.chart-container{position:relative;height:280px;margin-top:16px}
.insight-box{background:#2a2f3a;border:1px solid #3a3a42;border-radius:8px;padding:18px}
.insight-item{display:flex;align-items:flex-start;gap:12px;padding:10px 0;border-bottom:1px solid #3a3a42}
.insight-item:last-child{border-bottom:none}
.insight-icon{font-size:18px}
.insight-text{color:#e0e0e0;line-height:1.5;font-size:14px}
.insight-text strong{color:#fff}
.empty-state{text-align:center;padding:40px 20px;color:#b0b0b0}
.empty-state .empty-icon{font-size:36px;margin-bottom:12px;opacity:0.5}
.live-banner{background:#c43c3c;padding:14px 22px;border-radius:8px;display:flex;align-items:center;gap:14px;margin-bottom:20px}
.live-dot{width:10px;height:10px;background:#fff;border-radius:50%;animation:blink 1s infinite}
@keyframes blink{0%,100%{opacity:1}50%{opacity:0.4}}
.live-text{font-weight:700;font-size:15px;color:#fff}
.live-viewers{margin-left:auto;background:rgba(255,255,255,0.2);padding:6px 14px;border-radius:20px;font-weight:600;color:#fff;font-size:13px}
</style>

<div id="stats-dashboard">
  <div class="stats-header">
    <h2>ðŸ“Š Stream Analytics</h2>
    <p>Track your streaming performance and growth over time</p>
    <div class="filter-row">
      <button class="filter-btn active" data-filter="all">All Time</button>
      <button class="filter-btn" data-filter="30days">Last 30 Days</button>
      <button class="filter-btn" data-filter="7days">Last 7 Days</button>
      <button class="export-btn" onclick="exportStats()">ðŸ“¥ Export CSV</button>
    </div>
  </div>

  ${liveBannerHtml}

  <div class="metrics-grid">
    <div class="metric-card" style="--accent:#9146ff"><div class="icon">ðŸ“º</div><div class="value">${totalStreams}</div><div class="label">Total Streams</div></div>
    <div class="metric-card" style="--accent:#ff6b9d"><div class="icon">â±ï¸</div><div class="value">${totalHours}h</div><div class="label">Hours Streamed</div></div>
    <div class="metric-card" style="--accent:#7fdfb4"><div class="icon">ðŸ‘¥</div><div class="value">${avgViewers}</div><div class="label">Avg Peak Viewers</div></div>
    <div class="metric-card" style="--accent:#ffd700"><div class="icon">ðŸ†</div><div class="value">${peakViewers}</div><div class="label">All-Time Peak</div></div>
    <div class="metric-card" style="--accent:#64b5f6"><div class="icon">ðŸ“Š</div><div class="value">${avgDuration}m</div><div class="label">Avg Duration</div></div>
    <div class="metric-card" style="--accent:#ce93d8"><div class="icon">ðŸ“ˆ</div><div class="value">${medianViewers}</div><div class="label">Median Viewers</div></div>
    <div class="metric-card" style="--accent:#4caf50"><div class="icon">ðŸ‘¤</div><div class="value">${totalFollowers}</div><div class="label">Total Followers</div></div>
    <div class="metric-card" style="--accent:#e91e63"><div class="icon">ðŸ’Ž</div><div class="value">${totalSubs}</div><div class="label">Total Subs</div></div>
    <div class="metric-card" style="--accent:#00bcd4"><div class="icon">ðŸ‘ï¸</div><div class="value">${viewerHours}</div><div class="label">Viewer-Hours</div></div>
    <div class="metric-card" style="--accent:#ff9800"><div class="icon">ðŸŽ®</div><div class="value">${uniqueGames}</div><div class="label">Games Played</div></div>
    <div class="metric-card" style="--accent:#8bc34a"><div class="icon">ðŸ“…</div><div class="value">${streamsPerWeek}/wk</div><div class="label">Stream Frequency</div></div>
    <div class="metric-card" style="--accent:#ff5722"><div class="icon">â°</div><div class="value">${daysSinceLast}d</div><div class="label">Since Last Stream</div></div>
    <div class="metric-card" style="--accent:#9c27b0"><div class="icon">âž•</div><div class="value">${avgFollowersPerStream}</div><div class="label">Follows/Stream</div></div>
    <div class="metric-card" style="--accent:#3f51b5"><div class="icon">â­</div><div class="value">${avgSubsPerStream}</div><div class="label">Subs/Stream</div></div>
  </div>

  ${(() => {
    // Monthly goals progress
    const g = streamGoals || {};
    const hasGoals = g.monthlyFollowers > 0 || g.monthlyHours > 0 || g.monthlyStreams > 0 || g.monthlyPeakViewers > 0;
    const now = new Date();
    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
    const thisMonthStreams = (history || []).filter(s => new Date(s.startedAt || s.date) >= monthStart);
    const monthStreams = thisMonthStreams.length;
    const monthHours = parseFloat((thisMonthStreams.reduce((sum, s) => sum + (s.durationMinutes || 0), 0) / 60).toFixed(1));
    const monthFollows = thisMonthStreams.reduce((sum, s) => sum + (s.followers || s.newFollowers || 0), 0);
    const monthPeak = thisMonthStreams.reduce((max, s) => Math.max(max, s.peakViewers || 0), 0);
    const monthName = now.toLocaleString('en-US', { month: 'long', year: 'numeric' });

    function goalBar(label, current, target, color, icon) {
      if (!target || target <= 0) return '';
      const pct = Math.min(100, (current / target * 100)).toFixed(0);
      const done = current >= target;
      return '<div style="margin-bottom:14px">' +
        '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:5px">' +
        '<span style="color:#e0e0e0;font-size:13px;font-weight:600">' + icon + ' ' + label + '</span>' +
        '<span style="color:' + (done ? '#4caf50' : color) + ';font-size:13px;font-weight:700">' + current + ' / ' + target + (done ? ' âœ“' : '') + '</span>' +
        '</div>' +
        '<div style="background:#222;border-radius:6px;height:10px;overflow:hidden">' +
        '<div style="background:' + (done ? '#4caf50' : 'linear-gradient(90deg,' + color + ',' + color + 'cc)') + ';height:100%;width:' + pct + '%;border-radius:6px;transition:width 0.5s"></div>' +
        '</div>' +
        '<div style="text-align:right;color:#72767d;font-size:11px;margin-top:3px">' + pct + '%</div>' +
        '</div>';
    }

    return '<div class="card" style="margin:20px 0;border:1px solid ' + (hasGoals ? '#5b5bff33' : '#33333888') + '">' +
      '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:15px">' +
      '<h3 style="margin:0;font-size:16px;color:#e0e0e0">ðŸŽ¯ Monthly Goals â€” ' + monthName + '</h3>' +
      '<button onclick="document.getElementById(\'goal-config\').style.display=document.getElementById(\'goal-config\').style.display===\'none\'?\'block\':\'none\'" style="padding:6px 14px;background:#2a2e35;border:1px solid #5b5bff44;border-radius:6px;color:#8b8fa3;cursor:pointer;font-size:12px">âš™ï¸ Configure</button>' +
      '</div>' +
      (hasGoals ?
        goalBar('Streams', monthStreams, g.monthlyStreams, '#9146ff', 'ðŸ“º') +
        goalBar('Hours Streamed', monthHours, g.monthlyHours, '#e91e63', 'â±ï¸') +
        goalBar('Followers', monthFollows, g.monthlyFollowers, '#4caf50', 'â¤ï¸') +
        goalBar('Peak Viewers', monthPeak, g.monthlyPeakViewers, '#ff9800', 'ðŸ†')
        : '<div style="text-align:center;padding:20px;color:#72767d">No goals set yet. Click Configure to set your monthly streaming goals!</div>'
      ) +
      '<div id="goal-config" style="display:none;margin-top:20px;padding:20px;background:#1a1a2e;border-radius:10px">' +
      '<h4 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">âš™ï¸ Set Monthly Goals</h4>' +
      '<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">' +
      '<div><label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:4px">ðŸ“º Monthly Streams</label><input type="number" id="goalStreams" value="' + (g.monthlyStreams || '') + '" min="0" placeholder="e.g. 12" style="width:100%;padding:8px;background:#2a2e35;border:1px solid #444;border-radius:6px;color:#fff;font-size:13px" onclick="this.focus()" onkeydown="event.stopPropagation()" onkeypress="event.stopPropagation()" onkeyup="event.stopPropagation()"></div>' +
      '<div><label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:4px">â±ï¸ Monthly Hours</label><input type="number" id="goalHours" value="' + (g.monthlyHours || '') + '" min="0" placeholder="e.g. 40" style="width:100%;padding:8px;background:#2a2e35;border:1px solid #444;border-radius:6px;color:#fff;font-size:13px" onclick="this.focus()" onkeydown="event.stopPropagation()" onkeypress="event.stopPropagation()" onkeyup="event.stopPropagation()"></div>' +
      '<div><label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:4px">â¤ï¸ Monthly Followers</label><input type="number" id="goalFollowers" value="' + (g.monthlyFollowers || '') + '" min="0" placeholder="e.g. 50" style="width:100%;padding:8px;background:#2a2e35;border:1px solid #444;border-radius:6px;color:#fff;font-size:13px" onclick="this.focus()" onkeydown="event.stopPropagation()" onkeypress="event.stopPropagation()" onkeyup="event.stopPropagation()"></div>' +
      '<div><label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:4px">ðŸ† Monthly Peak Viewers</label><input type="number" id="goalPeak" value="' + (g.monthlyPeakViewers || '') + '" min="0" placeholder="e.g. 100" style="width:100%;padding:8px;background:#2a2e35;border:1px solid #444;border-radius:6px;color:#fff;font-size:13px" onclick="this.focus()" onkeydown="event.stopPropagation()" onkeypress="event.stopPropagation()" onkeyup="event.stopPropagation()"></div>' +
      '</div>' +
      '<button onclick="saveStreamGoals()" style="margin-top:12px;padding:10px 24px;background:#5b5bff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;font-size:14px">ðŸ’¾ Save Goals</button>' +
      '</div>' +
    '</div>';
  })()}

  <div class="two-col">
    <div class="stats-card">
      <div class="stats-card-header"><span>ðŸŽ®</span><h3>Top Games</h3></div>
      <div class="stats-card-body">${topGamesHtml}</div>
    </div>
    <div class="stats-card">
      <div class="stats-card-header"><span>ðŸ“…</span><h3>Monthly Summary</h3></div>
      <div class="stats-card-body">${monthlyHtml}</div>
    </div>
  </div>

  <div class="stats-card" style="margin-bottom:24px">
    <div class="stats-card-header"><span>ðŸ“‹</span><h3>Recent Streams</h3></div>
    <div class="stats-card-body" style="padding:0 22px 18px">${streamsTableHtml}</div>
  </div>

  <div class="stats-card" style="margin-bottom:24px">
    <div class="stats-card-header"><span>ðŸ“ˆ</span><h3>Viewer Trend</h3></div>
    <div class="stats-card-body">
      <div class="chart-container"><canvas id="viewers-chart"></canvas></div>
    </div>
  </div>

  <div class="stats-card" style="margin-bottom:24px">
    <div class="stats-card-header"><span>â±ï¸</span><h3>Stream Duration</h3></div>
    <div class="stats-card-body">
      <div class="chart-container"><canvas id="duration-chart"></canvas></div>
    </div>
  </div>

  <div class="stats-card">
    <div class="stats-card-header"><span>ðŸ¤–</span><h3>Quick Insights</h3></div>
    <div class="stats-card-body">
      <div class="insight-box">${insightsHtml}</div>
    </div>
  </div>

  ${(function() {
    var csvd = currentStreamViewerData || [];
    if (csvd.length < 5) return '';
    // Downsample to max 60 points for chart
    var step = Math.max(1, Math.floor(csvd.length / 60));
    var sampled = [];
    for (var i = 0; i < csvd.length; i += step) sampled.push(csvd[i]);
    if (sampled[sampled.length - 1] !== csvd[csvd.length - 1]) sampled.push(csvd[csvd.length - 1]);
    var labels = sampled.map(function(d) { return d.time || ''; });
    var viewers = sampled.map(function(d) { return d.viewers || 0; });
    var peakV = Math.max.apply(null, viewers);
    var peakIdx = viewers.indexOf(peakV);
    var startV = viewers[0] || 0;
    var endV = viewers[viewers.length - 1] || 0;
    var avgV = Math.round(viewers.reduce(function(a, b) { return a + b; }, 0) / viewers.length);
    var durationMinutes = csvd.length > 1 ? Math.round((csvd[csvd.length - 1].timestamp - csvd[0].timestamp) / 60000) : 0;
    var durationStr = Math.floor(durationMinutes / 60) + 'h ' + (durationMinutes % 60) + 'm';
    return '<div class="stats-card" style="margin-top:24px">' +
      '<div class="stats-card-header"><span>ðŸ“¡</span><h3>Current/Last Stream â€” Live Viewer Curve</h3></div>' +
      '<div class="stats-card-body">' +
        '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:10px;margin-bottom:15px">' +
          '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Start</div><div style="font-size:18px;color:#4caf50;font-weight:bold">' + startV + '</div></div>' +
          '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Peak</div><div style="font-size:18px;color:#ffd700;font-weight:bold">' + peakV + '</div></div>' +
          '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Current/End</div><div style="font-size:18px;color:#ef5350;font-weight:bold">' + endV + '</div></div>' +
          '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Average</div><div style="font-size:18px;color:#9146ff;font-weight:bold">' + avgV + '</div></div>' +
          '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Duration</div><div style="font-size:18px;color:#2196f3;font-weight:bold">' + durationStr + '</div></div>' +
          '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Data Points</div><div style="font-size:18px;color:#ce93d8;font-weight:bold">' + csvd.length + '</div></div>' +
        '</div>' +
        '<div style="height:200px"><canvas id="live-viewer-chart"></canvas></div>' +
      '</div>' +
    '</div>' +
    '<script>' +
    'document.addEventListener("DOMContentLoaded", function() {' +
      'var lctx = document.getElementById("live-viewer-chart");' +
      'if(lctx){new Chart(lctx,{type:"line",data:{labels:' + JSON.stringify(labels) + ',datasets:[{label:"Viewers",data:' + JSON.stringify(viewers) + ',borderColor:"#9146ff",backgroundColor:"rgba(145,70,255,0.15)",fill:true,tension:0.3,pointRadius:0,borderWidth:2}]},options:{responsive:true,maintainAspectRatio:false,plugins:{legend:{display:false}},scales:{y:{beginAtZero:false,grid:{color:"rgba(255,255,255,0.05)"},ticks:{color:"#8b8fa3"}},x:{display:false}}}});}' +
    '});' +
    '</script>';
  })()}
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
const analyticsData = {
  history: ${JSON.stringify(h)},
  isLive: ${JSON.stringify(isCurrentlyLive)}
};

document.addEventListener('DOMContentLoaded', function() {
  var ctx = document.getElementById('viewers-chart');
  if (ctx && analyticsData.history.length > 0) {
    var sorted = analyticsData.history.slice().sort(function(a, b) {
      return new Date(a.startedAt || a.date) - new Date(b.startedAt || b.date);
    }).slice(-20);
    new Chart(ctx, {
      type: 'line',
      data: {
        labels: sorted.map(function(s) {
          return new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }),
        datasets: [{
          label: 'Peak Viewers',
          data: sorted.map(function(s) { return s.peakViewers || 0; }),
          borderColor: '#9146ff',
          backgroundColor: 'rgba(145, 70, 255, 0.1)',
          fill: true,
          tension: 0.4,
          pointBackgroundColor: '#9146ff',
          pointBorderColor: '#fff',
          pointBorderWidth: 2,
          pointRadius: 4
        },
        {
          label: 'Avg Viewers',
          data: sorted.map(function(s) { return s.avgViewers || s.averageViewers || 0; }),
          borderColor: '#4caf50',
          backgroundColor: 'rgba(76, 175, 80, 0.08)',
          fill: true,
          tension: 0.4,
          pointBackgroundColor: '#4caf50',
          pointBorderColor: '#fff',
          pointBorderWidth: 2,
          pointRadius: 3,
          borderDash: [5, 3]
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: true, labels: { color: '#8b8fa3', usePointStyle: true, pointStyle: 'circle' } } },
        scales: {
          y: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#8b8fa3' } },
          x: { grid: { display: false }, ticks: { color: '#8b8fa3' } }
        }
      }
    });
  }

  var dctx = document.getElementById('duration-chart');
  if (dctx && analyticsData.history.length > 0) {
    var dsorted = analyticsData.history.slice().sort(function(a, b) {
      return new Date(a.startedAt || a.date) - new Date(b.startedAt || b.date);
    }).slice(-20);
    new Chart(dctx, {
      type: 'bar',
      data: {
        labels: dsorted.map(function(s) {
          return new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }),
        datasets: [{
          label: 'Duration (min)',
          data: dsorted.map(function(s) { return s.durationMinutes || Math.round((s.duration || 0) / 60); }),
          backgroundColor: dsorted.map(function(s) {
            var m = s.durationMinutes || Math.round((s.duration || 0) / 60);
            return m >= 180 ? 'rgba(76,175,80,0.7)' : m >= 60 ? 'rgba(255,152,0,0.7)' : 'rgba(239,83,80,0.7)';
          }),
          borderColor: dsorted.map(function(s) {
            var m = s.durationMinutes || Math.round((s.duration || 0) / 60);
            return m >= 180 ? '#4caf50' : m >= 60 ? '#ff9800' : '#ef5350';
          }),
          borderWidth: 1,
          borderRadius: 4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: { callbacks: { label: function(ctx) { var v = ctx.raw; return Math.floor(v/60) + 'h ' + (v%60) + 'm'; } } }
        },
        scales: {
          y: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#8b8fa3', callback: function(v) { return Math.floor(v/60) + 'h'; } } },
          x: { grid: { display: false }, ticks: { color: '#8b8fa3' } }
        }
      }
    });
  }

  document.querySelectorAll('.filter-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      document.querySelectorAll('.filter-btn').forEach(function(b) { b.classList.remove('active'); });
      btn.classList.add('active');
    });
  });
});

function exportStats() {
  var data = analyticsData.history;
  if (!data || !data.length) { alert('No data to export'); return; }
  var headers = ['Date', 'Game', 'Peak Viewers', 'Duration (min)'];
  var rows = data.map(function(s) {
    return [
      new Date(s.startedAt || s.date).toISOString().split('T')[0],
      (s.game || s.gameName || 'Unknown').replace(/,/g, ' '),
      s.peakViewers || 0,
      s.durationMinutes || 0
    ];
  });
  var csv = [headers.join(',')].concat(rows.map(function(r) { return r.join(','); })).join('\\n');
  var blob = new Blob([csv], { type: 'text/csv' });
  var url = URL.createObjectURL(blob);
  var a = document.createElement('a');
  a.href = url;
  a.download = 'stream_stats_' + new Date().toISOString().split('T')[0] + '.csv';
  a.click();
  URL.revokeObjectURL(url);
}

function saveStreamGoals() {
  var data = {
    monthlyStreams: parseInt(document.getElementById('goalStreams').value) || 0,
    monthlyHours: parseInt(document.getElementById('goalHours').value) || 0,
    monthlyFollowers: parseInt(document.getElementById('goalFollowers').value) || 0,
    monthlyPeakViewers: parseInt(document.getElementById('goalPeak').value) || 0
  };
  fetch('/api/stream-goals', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(data) })
  .then(function(r) { return r.json(); })
  .then(function(d) { if (d.success) location.reload(); else alert(d.error || 'Error saving goals'); });
}
</script>
`;
}

// NEW: Engagement Stats Tab
function renderEngagementStatsTab() {
  const h = history || [];
  let totalEngagement = 0;
  let peakEngagement = 0;
  const engagementData = [];

  h.forEach(s => {
    const engagement = (s.peakViewers || 0) + ((s.subscribers || 0) * 10) + ((s.followers || 0) * 2);
    engagementData.push(engagement);
    totalEngagement += engagement;
    if (engagement > peakEngagement) peakEngagement = engagement;
  });

  const avgEngagement = h.length > 0 ? Math.round(totalEngagement / h.length) : 0;
  const top20Percent = h.length > 0 ? h.slice(0, Math.ceil(h.length * 0.2)) : [];
  const top20Engagement = Math.round(top20Percent.reduce((sum, s) => sum + (s.peakViewers || 0), 0) / (top20Percent.length || 1));
  const growthRate = h.length > 1 ? (((h[0].peakViewers || 0) - (h[h.length - 1].peakViewers || 0)) / (h[h.length - 1].peakViewers || 1) * 100).toFixed(1) : 0;

  // Median engagement
  const sortedEng = [...engagementData].sort((a, b) => a - b);
  const medianEngagement = sortedEng.length > 0 ? sortedEng[Math.floor(sortedEng.length / 2)] : 0;

  // Percentiles
  const p25 = sortedEng.length > 0 ? sortedEng[Math.floor(sortedEng.length * 0.25)] : 0;
  const p75 = sortedEng.length > 0 ? sortedEng[Math.floor(sortedEng.length * 0.75)] : 0;
  const p90 = sortedEng.length > 0 ? sortedEng[Math.floor(sortedEng.length * 0.90)] : 0;
  const iqr = p75 - p25;

  // Engagement consistency (standard deviation)
  const mean = avgEngagement;
  const variance = engagementData.length > 1 ? engagementData.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / engagementData.length : 0;
  const stdDev = Math.round(Math.sqrt(variance));
  const consistencyScore = mean > 0 ? Math.max(0, Math.min(100, Math.round(100 - (stdDev / mean * 100)))) : 0;

  // Streaks
  let currentStreak = 0;
  let bestStreak = 0;
  let tempStreak = 0;
  for (let i = 0; i < h.length; i++) {
    if ((h[i].peakViewers || 0) >= avgEngagement * 0.8) { tempStreak++; bestStreak = Math.max(bestStreak, tempStreak); }
    else { tempStreak = 0; }
  }
  if (h.length > 0 && (h[0].peakViewers || 0) >= avgEngagement * 0.8) {
    currentStreak = 1;
    for (let i = 1; i < h.length; i++) {
      if ((h[i].peakViewers || 0) >= avgEngagement * 0.8) currentStreak++;
      else break;
    }
  }

  // Viewer retention estimate
  const avgViewers = h.length > 0 ? Math.round(h.reduce((s, x) => s + (x.averageViewers || x.peakViewers || 0), 0) / h.length) : 0;
  const avgPeak = h.length > 0 ? Math.round(h.reduce((s, x) => s + (x.peakViewers || 0), 0) / h.length) : 0;
  const retentionRate = avgPeak > 0 ? Math.round((avgViewers / avgPeak) * 100) : 0;

  // Total followers/subs
  const totalFollowers = h.reduce((s, x) => s + (x.followers || x.newFollowers || 0), 0);
  const totalSubs = h.reduce((s, x) => s + (x.subscribers || x.newSubs || 0), 0);

  // Engagement per minute
  const totalMinutes = h.reduce((s, x) => s + (x.durationMinutes || 0), 0);
  const engPerMin = totalMinutes > 0 ? (totalEngagement / totalMinutes).toFixed(2) : '0.00';

  // Viewer per hour efficiency
  const totalHours = totalMinutes / 60;
  const viewersPerHour = totalHours > 0 ? (h.reduce((s, x) => s + (x.peakViewers || 0), 0) / totalHours).toFixed(1) : '0.0';

  // Recent vs all-time comparison
  const recent10 = h.slice(-10);
  const recent10Avg = recent10.length > 0 ? Math.round(recent10.reduce((s, x) => s + (x.peakViewers || 0), 0) / recent10.length) : 0;
  const allTimeAvg = avgPeak;
  const recentVsAllTime = allTimeAvg > 0 ? (((recent10Avg - allTimeAvg) / allTimeAvg) * 100).toFixed(1) : '0.0';

  // Week over week change
  const thisWeek = h.filter(s => (Date.now() - new Date(s.startedAt || s.date).getTime()) < 7 * 24 * 60 * 60 * 1000);
  const lastWeek = h.filter(s => { const age = Date.now() - new Date(s.startedAt || s.date).getTime(); return age >= 7 * 24 * 60 * 60 * 1000 && age < 14 * 24 * 60 * 60 * 1000; });
  const thisWeekAvg = thisWeek.length > 0 ? Math.round(thisWeek.reduce((s, x) => s + (x.peakViewers || 0), 0) / thisWeek.length) : 0;
  const lastWeekAvg = lastWeek.length > 0 ? Math.round(lastWeek.reduce((s, x) => s + (x.peakViewers || 0), 0) / lastWeek.length) : 0;
  const wowChange = lastWeekAvg > 0 ? (((thisWeekAvg - lastWeekAvg) / lastWeekAvg) * 100).toFixed(1) : '0.0';

  // Follower conversion rate
  const followerConvRate = h.length > 0 ? ((totalFollowers / Math.max(h.reduce((s, x) => s + (x.peakViewers || 0), 0), 1)) * 100).toFixed(2) : '0.00';
  const subConvRate = h.length > 0 ? ((totalSubs / Math.max(h.reduce((s, x) => s + (x.peakViewers || 0), 0), 1)) * 100).toFixed(2) : '0.00';

  // Engagement per game
  const gameEngagement = {};
  h.forEach(s => {
    const game = s.game || s.gameName || 'Unknown';
    if (!gameEngagement[game]) gameEngagement[game] = { total: 0, count: 0 };
    gameEngagement[game].total += (s.peakViewers || 0) + ((s.subscribers || 0) * 10) + ((s.followers || 0) * 2);
    gameEngagement[game].count++;
  });
  const topEngGames = Object.entries(gameEngagement).map(([g, d]) => [g, Math.round(d.total / d.count)]).sort((a, b) => b[1] - a[1]).slice(0, 5);

  // Engagement trend (improving/declining)
  const firstHalf = engagementData.slice(Math.floor(engagementData.length / 2));
  const secondHalf = engagementData.slice(0, Math.floor(engagementData.length / 2));
  const firstAvg = firstHalf.length > 0 ? firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length : 0;
  const secondAvg = secondHalf.length > 0 ? secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length : 0;
  const engTrend = secondAvg > firstAvg * 1.1 ? 'ðŸ“ˆ Improving' : secondAvg < firstAvg * 0.9 ? 'ðŸ“‰ Declining' : 'âž¡ï¸ Stable';

  // Sparkline bars for last 20 streams
  const last20 = h.slice(-20);
  const sparkMax = Math.max(...last20.map(s => s.peakViewers || 0), 1);
  let sparkBars = '';
  last20.forEach(s => {
    const pct = Math.round(((s.peakViewers || 0) / sparkMax) * 100);
    const color = pct > 70 ? '#9146ff' : pct > 40 ? '#4caf50' : '#ff9800';
    sparkBars += '<div style="flex:1;min-width:8px;background:' + color + ';height:' + Math.max(pct, 5) + '%;border-radius:2px" title="' + (s.peakViewers || 0) + ' viewers"></div>';
  });

  // Engagement per game bars
  let gameEngHtml = '';
  const topEngMax = topEngGames.length > 0 ? topEngGames[0][1] : 1;
  topEngGames.forEach(([game, avg]) => {
    const pct = Math.round((avg / topEngMax) * 100);
    gameEngHtml += '<div style="display:flex;align-items:center;gap:10px;margin-bottom:8px">' +
      '<span style="color:#b0b0b0;width:120px;font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">' + game + '</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:20px;overflow:hidden"><div style="background:linear-gradient(90deg,#9146ff,#ce93d8);height:100%;width:' + pct + '%;border-radius:3px;display:flex;align-items:center;padding-left:6px"><span style="font-size:10px;color:#fff;font-weight:bold">' + avg + '</span></div></div></div>';
  });

  // --- Last 10 vs Previous 10 Comparison ---
  const prev10 = h.length > 10 ? h.slice(-20, -10) : [];
  const recent10AvgPeak = recent10.length > 0 ? Math.round(recent10.reduce((s, x) => s + (x.peakViewers || 0), 0) / recent10.length) : 0;
  const prev10AvgPeak = prev10.length > 0 ? Math.round(prev10.reduce((s, x) => s + (x.peakViewers || 0), 0) / prev10.length) : recent10AvgPeak;
  const deltaPeak = recent10AvgPeak - prev10AvgPeak;
  const recent10Eng = recent10.map(s => (s.peakViewers || 0) + ((s.subscribers || 0) * 10) + ((s.followers || 0) * 2));
  const prev10Eng = prev10.map(s => (s.peakViewers || 0) + ((s.subscribers || 0) * 10) + ((s.followers || 0) * 2));
  const recent10AvgEng = recent10Eng.length > 0 ? Math.round(recent10Eng.reduce((a, b) => a + b, 0) / recent10Eng.length) : 0;
  const prev10AvgEng = prev10Eng.length > 0 ? Math.round(prev10Eng.reduce((a, b) => a + b, 0) / prev10Eng.length) : recent10AvgEng;
  const deltaEng = recent10AvgEng - prev10AvgEng;
  const calcRetention = (streams) => {
    if (streams.length === 0) return 0;
    return Math.round(streams.reduce((s, x) => s + ((x.averageViewers || x.peakViewers || 0) / Math.max(1, x.peakViewers || 1)), 0) / streams.length * 100);
  };
  const recent10Ret = calcRetention(recent10);
  const prev10Ret = prev10.length > 0 ? calcRetention(prev10) : recent10Ret;
  const deltaRet = recent10Ret - prev10Ret;
  const calcFollowsPerHour = (streams) => {
    const hrs = streams.reduce((s, x) => s + ((x.durationMinutes || 0) / 60), 0);
    const fols = streams.reduce((s, x) => s + (x.followers || x.newFollowers || 0), 0);
    return hrs > 0 ? (fols / hrs) : 0;
  };
  const recent10FPH = calcFollowsPerHour(recent10);
  const prev10FPH = prev10.length > 0 ? calcFollowsPerHour(prev10) : recent10FPH;
  const deltaFPH = (recent10FPH - prev10FPH).toFixed(2);

  // --- Efficiency Metrics ---
  const overallGrowthPerHour = totalHours > 0 ? (parseFloat(growthRate) / totalHours).toFixed(2) : '0.00';
  const totalViewerHours = h.reduce((s, x) => s + ((x.averageViewers || x.peakViewers || 0) * ((x.durationMinutes || 0) / 60)), 0);
  const followsPerViewerHour = totalViewerHours > 0 ? (totalFollowers / totalViewerHours).toFixed(3) : '0.000';
  const peakPerHour = totalHours > 0 ? (h.reduce((s, x) => s + (x.peakViewers || 0), 0) / totalHours).toFixed(1) : '0.0';

  return `
<div class="card">
  <h2>ðŸ‘¥ Engagement Analytics</h2>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin:20px 0">
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Avg Engagement</div>
      <div style="font-size:22px;color:#9146ff;font-weight:bold">${avgEngagement}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Peak Engagement</div>
      <div style="font-size:22px;color:#4caf50;font-weight:bold">${peakEngagement}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Median Engagement</div>
      <div style="font-size:22px;color:#ce93d8;font-weight:bold">${medianEngagement}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Growth Rate</div>
      <div style="font-size:22px;color:#ff9800;font-weight:bold">${growthRate}%</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Top 20% Avg</div>
      <div style="font-size:22px;color:#e91e63;font-weight:bold">${top20Engagement}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Consistency</div>
      <div style="font-size:22px;color:#00bcd4;font-weight:bold">${consistencyScore}%</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Viewer Retention</div>
      <div style="font-size:22px;color:#ab47bc;font-weight:bold">${retentionRate}%</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Eng / Minute</div>
      <div style="font-size:22px;color:#26c6da;font-weight:bold">${engPerMin}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Viewers / Hour</div>
      <div style="font-size:22px;color:#8bc34a;font-weight:bold">${viewersPerHour}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Recent vs All-Time</div>
      <div style="font-size:22px;color:${parseFloat(recentVsAllTime) >= 0 ? '#4caf50' : '#ef5350'};font-weight:bold">${parseFloat(recentVsAllTime) >= 0 ? '+' : ''}${recentVsAllTime}%</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Week-over-Week</div>
      <div style="font-size:22px;color:${parseFloat(wowChange) >= 0 ? '#4caf50' : '#ef5350'};font-weight:bold">${parseFloat(wowChange) >= 0 ? '+' : ''}${wowChange}%</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px">
      <div style="color:#b0b0b0;font-size:11px">Eng. Trend</div>
      <div style="font-size:18px;color:#fff;font-weight:bold;margin-top:4px">${engTrend}</div>
    </div>
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“Š Percentile Distribution</h3>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:12px;margin-top:10px">
    <div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #2196f3">
      <div style="color:#b0b0b0;font-size:10px">P25</div>
      <div style="font-size:20px;color:#2196f3;font-weight:bold">${p25}</div>
    </div>
    <div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #4caf50">
      <div style="color:#b0b0b0;font-size:10px">MEDIAN (P50)</div>
      <div style="font-size:20px;color:#4caf50;font-weight:bold">${medianEngagement}</div>
    </div>
    <div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #ff9800">
      <div style="color:#b0b0b0;font-size:10px">P75</div>
      <div style="font-size:20px;color:#ff9800;font-weight:bold">${p75}</div>
    </div>
    <div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #e91e63">
      <div style="color:#b0b0b0;font-size:10px">P90</div>
      <div style="font-size:20px;color:#e91e63;font-weight:bold">${p90}</div>
    </div>
    <div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #9c27b0">
      <div style="color:#b0b0b0;font-size:10px">IQR</div>
      <div style="font-size:20px;color:#9c27b0;font-weight:bold">${iqr}</div>
    </div>
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“ˆ Engagement Sparkline (Last 20 Streams)</h3>
  <div style="display:flex;align-items:flex-end;gap:3px;height:120px;padding:10px;background:#26262c;border-radius:6px;margin-top:10px">
    ${sparkBars || '<div style="color:#b0b0b0;margin:auto">No stream data yet</div>'}
  </div>
  <div style="display:flex;justify-content:space-between;margin-top:5px;font-size:11px;color:#666">
    <span>Oldest</span><span>Most Recent</span>
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ† Streaks & Milestones</h3>
  <div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:15px;margin-top:10px">
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">
      <div style="font-size:28px">ðŸ”¥</div>
      <div style="font-size:20px;color:#ff9800;font-weight:bold;margin:5px 0">${currentStreak}</div>
      <div style="color:#b0b0b0;font-size:11px">Current Streak</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">
      <div style="font-size:28px">â­</div>
      <div style="font-size:20px;color:#ffd700;font-weight:bold;margin:5px 0">${bestStreak}</div>
      <div style="color:#b0b0b0;font-size:11px">Best Streak</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">
      <div style="font-size:28px">ðŸ‘¥</div>
      <div style="font-size:20px;color:#4caf50;font-weight:bold;margin:5px 0">${totalFollowers}</div>
      <div style="color:#b0b0b0;font-size:11px">Total Follows</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">
      <div style="font-size:28px">ðŸ’Ž</div>
      <div style="font-size:20px;color:#9146ff;font-weight:bold;margin:5px 0">${totalSubs}</div>
      <div style="color:#b0b0b0;font-size:11px">Total Subs</div>
    </div>
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ”„ Conversion Rates</h3>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:10px">
    <div style="background:#26262c;padding:18px;border-radius:6px;text-align:center;border-left:3px solid #4caf50">
      <div style="color:#b0b0b0;font-size:11px">Follower Conversion</div>
      <div style="font-size:26px;color:#4caf50;font-weight:bold">${followerConvRate}%</div>
      <div style="color:#666;font-size:10px">viewers â†’ followers</div>
    </div>
    <div style="background:#26262c;padding:18px;border-radius:6px;text-align:center;border-left:3px solid #ffd700">
      <div style="color:#b0b0b0;font-size:11px">Subscriber Conversion</div>
      <div style="font-size:26px;color:#ffd700;font-weight:bold">${subConvRate}%</div>
      <div style="color:#666;font-size:10px">viewers â†’ subs</div>
    </div>
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸŽ® Engagement by Game</h3>
  <div style="margin-top:15px">
    ${gameEngHtml || '<div style="color:#b0b0b0;text-align:center;padding:20px">No game data</div>'}
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“Š Engagement Breakdown</h3>
  <div style="margin-top:15px">
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
      <span style="color:#b0b0b0;width:120px;font-size:13px">Viewers</span>
      <div style="flex:1;background:#1a1a2e;border-radius:4px;height:24px;overflow:hidden">
        <div style="background:linear-gradient(90deg,#9146ff,#ab47bc);height:100%;width:${Math.min(100, avgPeak > 0 ? (avgPeak / (peakEngagement || 1)) * 100 : 0)}%;border-radius:4px;transition:width 0.5s"></div>
      </div>
      <span style="color:#fff;font-weight:bold;min-width:50px;text-align:right">${avgPeak}</span>
    </div>
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
      <span style="color:#b0b0b0;width:120px;font-size:13px">Followers</span>
      <div style="flex:1;background:#1a1a2e;border-radius:4px;height:24px;overflow:hidden">
        <div style="background:linear-gradient(90deg,#4caf50,#66bb6a);height:100%;width:${Math.min(100, totalFollowers > 0 ? Math.min(100, totalFollowers / Math.max(h.length, 1) * 10) : 0)}%;border-radius:4px;transition:width 0.5s"></div>
      </div>
      <span style="color:#fff;font-weight:bold;min-width:50px;text-align:right">${totalFollowers}</span>
    </div>
    <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px">
      <span style="color:#b0b0b0;width:120px;font-size:13px">Subscribers</span>
      <div style="flex:1;background:#1a1a2e;border-radius:4px;height:24px;overflow:hidden">
        <div style="background:linear-gradient(90deg,#ff9800,#ffa726);height:100%;width:${Math.min(100, totalSubs > 0 ? Math.min(100, totalSubs / Math.max(h.length, 1) * 15) : 0)}%;border-radius:4px;transition:width 0.5s"></div>
      </div>
      <span style="color:#fff;font-weight:bold;min-width:50px;text-align:right">${totalSubs}</span>
    </div>
  </div>
  <p style="color:#666;font-size:11px;margin-top:10px">Engagement = viewers + (subs x 10) + (follows x 2) | Std Dev: ${stdDev} | Total streams: ${h.length}</p>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0"> Last 10 vs Previous 10 Streams</h3>
  <p style="color:#666;font-size:11px;margin-bottom:10px">Comparing your most recent 10 streams against the previous 10</p>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px;margin-top:10px">
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid ${deltaPeak >= 0 ? '#4caf50' : '#ef5350'}">
      <div style="color:#b0b0b0;font-size:10px">Avg Peak Î”</div>
      <div style="font-size:22px;color:${deltaPeak >= 0 ? '#4caf50' : '#ef5350'};font-weight:bold">${deltaPeak >= 0 ? '+' : ''}${deltaPeak}</div>
      <div style="color:#666;font-size:10px">${recent10AvgPeak} vs ${prev10AvgPeak}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid ${deltaEng >= 0 ? '#4caf50' : '#ef5350'}">
      <div style="color:#b0b0b0;font-size:10px">Avg Engagement Î”</div>
      <div style="font-size:22px;color:${deltaEng >= 0 ? '#4caf50' : '#ef5350'};font-weight:bold">${deltaEng >= 0 ? '+' : ''}${deltaEng}</div>
      <div style="color:#666;font-size:10px">${recent10AvgEng} vs ${prev10AvgEng}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid ${deltaRet >= 0 ? '#4caf50' : '#ef5350'}">
      <div style="color:#b0b0b0;font-size:10px">Avg Retention Î”</div>
      <div style="font-size:22px;color:${deltaRet >= 0 ? '#4caf50' : '#ef5350'};font-weight:bold">${deltaRet >= 0 ? '+' : ''}${deltaRet}%</div>
      <div style="color:#666;font-size:10px">${recent10Ret}% vs ${prev10Ret}%</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid ${parseFloat(deltaFPH) >= 0 ? '#4caf50' : '#ef5350'}">
      <div style="color:#b0b0b0;font-size:10px">Follows/Hr Î”</div>
      <div style="font-size:22px;color:${parseFloat(deltaFPH) >= 0 ? '#4caf50' : '#ef5350'};font-weight:bold">${parseFloat(deltaFPH) >= 0 ? '+' : ''}${deltaFPH}</div>
      <div style="color:#666;font-size:10px">${recent10FPH.toFixed(2)} vs ${prev10FPH.toFixed(2)}/hr</div>
    </div>
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸŽ¯ Efficiency Metrics</h3>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:12px;margin-top:10px">
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid #2196f3">
      <div style="color:#b0b0b0;font-size:10px">Growth per Hour</div>
      <div style="font-size:22px;color:#2196f3;font-weight:bold">${overallGrowthPerHour}%</div>
      <div style="color:#666;font-size:10px">Growth rate / total hours</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid #e91e63">
      <div style="color:#b0b0b0;font-size:10px">Follows per Viewer-Hour</div>
      <div style="font-size:22px;color:#e91e63;font-weight:bold">${followsPerViewerHour}</div>
      <div style="color:#666;font-size:10px">Follows / (viewers Ã— hours)</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid #ff9800">
      <div style="color:#b0b0b0;font-size:10px">Peak per Hour Streamed</div>
      <div style="font-size:22px;color:#ff9800;font-weight:bold">${peakPerHour}</div>
      <div style="color:#666;font-size:10px">Total peak viewers / hours</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid #26c6da">
      <div style="color:#b0b0b0;font-size:10px">Eng. per Minute</div>
      <div style="font-size:22px;color:#26c6da;font-weight:bold">${engPerMin}</div>
      <div style="color:#666;font-size:10px">Total engagement / minutes</div>
    </div>
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“ˆ Follower Growth Over Time</h3>
  <div style="height:220px;margin-top:10px"><canvas id="follower-growth-chart"></canvas></div>
  <div style="margin-top:8px;color:#72767d;font-size:12px">${followerHistory.length > 0 ? 'Tracking ' + followerHistory.length + ' data points since ' + new Date(followerHistory[0].timestamp).toLocaleDateString() : 'Follower tracking starts on next live stream check'}</div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“Š Engagement Trend Chart</h3>
  <div style="height:220px;margin-top:10px"><canvas id="engagement-trend-chart"></canvas></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  var engSorted = ${JSON.stringify(h.slice().sort((a, b) => new Date(a.startedAt || a.date) - new Date(b.startedAt || b.date)).slice(-20).map(s => ({
    date: new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
    engagement: (s.peakViewers || 0) + ((s.subscribers || 0) * 10) + ((s.followers || 0) * 2),
    peak: s.peakViewers || 0,
    avg: s.avgViewers || s.averageViewers || 0
  })))};
  var ectx = document.getElementById('engagement-trend-chart');
  if (ectx && engSorted.length > 0) {
    new Chart(ectx, {
      type: 'line',
      data: {
        labels: engSorted.map(function(s) { return s.date; }),
        datasets: [{
          label: 'Engagement Score',
          data: engSorted.map(function(s) { return s.engagement; }),
          borderColor: '#e91e63',
          backgroundColor: 'rgba(233,30,99,0.1)',
          fill: true,
          tension: 0.4,
          pointBackgroundColor: '#e91e63',
          pointBorderColor: '#fff',
          pointBorderWidth: 2,
          pointRadius: 4
        },
        {
          label: 'Peak Viewers',
          data: engSorted.map(function(s) { return s.peak; }),
          borderColor: '#9146ff',
          backgroundColor: 'rgba(145,70,255,0.05)',
          fill: false,
          tension: 0.4,
          pointRadius: 3,
          borderDash: [5, 3]
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: true, labels: { color: '#8b8fa3', usePointStyle: true } } },
        scales: {
          y: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#8b8fa3' } },
          x: { grid: { display: false }, ticks: { color: '#8b8fa3' } }
        }
      }
    });
  }

  // Follower Growth Chart
  var followerData = ${JSON.stringify(followerHistory.slice(-100).map(p => ({
    date: new Date(p.timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit' }),
    count: p.count
  })))};
  var fgCtx = document.getElementById('follower-growth-chart');
  if (fgCtx && followerData.length > 0) {
    new Chart(fgCtx, {
      type: 'line',
      data: {
        labels: followerData.map(function(p) { return p.date; }),
        datasets: [{
          label: 'Followers',
          data: followerData.map(function(p) { return p.count; }),
          borderColor: '#4caf50',
          backgroundColor: 'rgba(76,175,80,0.1)',
          fill: true,
          tension: 0.3,
          pointBackgroundColor: '#4caf50',
          pointBorderColor: '#fff',
          pointBorderWidth: 2,
          pointRadius: 3
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          y: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#8b8fa3' } },
          x: { grid: { display: false }, ticks: { color: '#8b8fa3', maxTicksLimit: 10 } }
        }
      }
    });
  }
});
</script>
  `;
}

// NEW: Trends Stats Tab
function renderTrendsStatsTab() {
  const h = history || [];
  const weeklyStats = {};
  const monthlyStats = {};
  const dayOfWeekStats = { 0: { label: 'Sun', streams: 0, viewers: 0, duration: 0 }, 1: { label: 'Mon', streams: 0, viewers: 0, duration: 0 }, 2: { label: 'Tue', streams: 0, viewers: 0, duration: 0 }, 3: { label: 'Wed', streams: 0, viewers: 0, duration: 0 }, 4: { label: 'Thu', streams: 0, viewers: 0, duration: 0 }, 5: { label: 'Fri', streams: 0, viewers: 0, duration: 0 }, 6: { label: 'Sat', streams: 0, viewers: 0, duration: 0 } };

  // Duration trends
  const durationBuckets = { 'Under 1h': 0, '1-2h': 0, '2-3h': 0, '3-4h': 0, '4-5h': 0, '5h+': 0 };

  h.forEach(s => {
    const date = new Date(s.startedAt || s.date);
    const week = date.getFullYear() + '-W' + Math.ceil(((date - new Date(date.getFullYear(), 0, 1)) / 86400000 + 1) / 7);
    const month = date.toLocaleString('default', { month: 'long', year: 'numeric' });
    const dow = date.getDay();

    if (!weeklyStats[week]) weeklyStats[week] = { streams: 0, avgViewers: 0, totalDuration: 0, followers: 0, subs: 0 };
    if (!monthlyStats[month]) monthlyStats[month] = { streams: 0, avgViewers: 0, totalDuration: 0, peakViewers: 0, followers: 0, subs: 0 };

    weeklyStats[week].streams++;
    weeklyStats[week].avgViewers += (s.peakViewers || 0);
    weeklyStats[week].totalDuration += (s.durationMinutes || 0);
    weeklyStats[week].followers += (s.followers || s.newFollowers || 0);
    weeklyStats[week].subs += (s.subscribers || s.newSubs || 0);
    monthlyStats[month].streams++;
    monthlyStats[month].avgViewers += (s.peakViewers || 0);
    monthlyStats[month].totalDuration += (s.durationMinutes || 0);
    monthlyStats[month].peakViewers = Math.max(monthlyStats[month].peakViewers, s.peakViewers || 0);
    monthlyStats[month].followers += (s.followers || s.newFollowers || 0);
    monthlyStats[month].subs += (s.subscribers || s.newSubs || 0);

    dayOfWeekStats[dow].streams++;
    dayOfWeekStats[dow].viewers += (s.peakViewers || 0);
    dayOfWeekStats[dow].duration += (s.durationMinutes || 0);

    const hrs = (s.durationMinutes || 0) / 60;
    if (hrs < 1) durationBuckets['Under 1h']++;
    else if (hrs < 2) durationBuckets['1-2h']++;
    else if (hrs < 3) durationBuckets['2-3h']++;
    else if (hrs < 4) durationBuckets['3-4h']++;
    else if (hrs < 5) durationBuckets['4-5h']++;
    else durationBuckets['5h+']++;
  });

  Object.keys(weeklyStats).forEach(week => {
    weeklyStats[week].avgViewers = Math.round(weeklyStats[week].avgViewers / weeklyStats[week].streams);
  });
  Object.keys(monthlyStats).forEach(month => {
    monthlyStats[month].avgViewers = Math.round(monthlyStats[month].avgViewers / monthlyStats[month].streams);
  });

  // Stream frequency analysis
  const sortedDates = h.map(s => new Date(s.startedAt || s.date)).sort((a, b) => a - b);
  const gaps = [];
  for (let i = 1; i < sortedDates.length; i++) gaps.push((sortedDates[i] - sortedDates[i - 1]) / (1000 * 60 * 60 * 24));
  const avgGap = gaps.length > 0 ? (gaps.reduce((a, b) => a + b, 0) / gaps.length).toFixed(1) : '0.0';
  const longestGap = gaps.length > 0 ? Math.round(Math.max(...gaps)) : 0;
  const shortestGap = gaps.length > 0 ? Math.round(Math.min(...gaps)) : 0;

  // Viewer volatility index
  const viewers = h.map(s => s.peakViewers || 0);
  const viewerMean = viewers.length > 0 ? viewers.reduce((a, b) => a + b, 0) / viewers.length : 0;
  const viewerStd = Math.sqrt(viewers.reduce((s, v) => s + Math.pow(v - viewerMean, 2), 0) / (viewers.length || 1));
  const volatilityIndex = viewerMean > 0 ? ((viewerStd / viewerMean) * 100).toFixed(1) : '0.0';

  // Cumulative metrics
  let cumulativeViewers = 0;
  let cumulativeHours = 0;
  const sorted = h.slice().sort((a, b) => new Date(a.startedAt || a.date) - new Date(b.startedAt || b.date));

  // Month-over-month growth rates
  const monthEntries = Object.entries(monthlyStats);
  let momGrowthHtml = '';
  if (monthEntries.length >= 2) {
    for (let i = 1; i < Math.min(monthEntries.length, 6); i++) {
      const prev = monthEntries[i - 1][1].avgViewers;
      const curr = monthEntries[i][1].avgViewers;
      const growth = prev > 0 ? (((curr - prev) / prev) * 100).toFixed(1) : '0.0';
      const color = parseFloat(growth) >= 0 ? '#4caf50' : '#ef5350';
      momGrowthHtml += '<div style="display:flex;justify-content:space-between;padding:8px 12px;background:#26262c;border-radius:4px;margin-bottom:6px">' +
        '<span style="color:#b0b0b0;font-size:12px">' + monthEntries[i - 1][0] + ' â†’ ' + monthEntries[i][0] + '</span>' +
        '<span style="color:' + color + ';font-weight:bold;font-size:13px">' + (parseFloat(growth) >= 0 ? '+' : '') + growth + '%</span></div>';
    }
  }

  // Weekend vs weekday
  const weekdayStreams = [1, 2, 3, 4, 5].reduce((s, d) => s + dayOfWeekStats[d].streams, 0);
  const weekendStreams = dayOfWeekStats[0].streams + dayOfWeekStats[6].streams;
  const weekdayAvg = weekdayStreams > 0 ? Math.round([1, 2, 3, 4, 5].reduce((s, d) => s + dayOfWeekStats[d].viewers, 0) / weekdayStreams) : 0;
  const weekendAvg = weekendStreams > 0 ? Math.round((dayOfWeekStats[0].viewers + dayOfWeekStats[6].viewers) / weekendStreams) : 0;

  // Streams per week over time
  const weekEntries = Object.entries(weeklyStats);
  const streamsPerWeekAvg = weekEntries.length > 0 ? (weekEntries.reduce((s, [, d]) => s + d.streams, 0) / weekEntries.length).toFixed(1) : '0.0';

  // Weekly HTML with progress bars
  let weeklyHtml = '';
  const weekSlice = weekEntries.slice(-6);
  const weekMax = Math.max(...weekSlice.map(([, d]) => d.avgViewers), 1);
  weekSlice.forEach(([week, data]) => {
    const pct = Math.round((data.avgViewers / weekMax) * 100);
    weeklyHtml += '<div style="padding:12px;background:#26262c;border-radius:6px;margin-bottom:8px">' +
      '<div style="display:flex;justify-content:space-between;margin-bottom:6px"><strong>' + week + '</strong><span style="color:#9146ff">' + data.avgViewers + ' avg</span></div>' +
      '<div style="background:#1a1a2e;border-radius:3px;height:8px;overflow:hidden"><div style="background:linear-gradient(90deg,#9146ff,#ab47bc);height:100%;width:' + pct + '%;border-radius:3px"></div></div>' +
      '<div style="display:flex;justify-content:space-between;margin-top:4px;font-size:11px;color:#666"><span>' + data.streams + ' streams</span><span>' + Math.round(data.totalDuration / 60) + 'h | +' + data.followers + ' follows</span></div></div>';
  });

  // Monthly HTML with more details
  let monthlyHtml = '';
  monthEntries.slice(0, 6).forEach(([month, data]) => {
    monthlyHtml += '<div style="padding:12px;background:#26262c;border-radius:6px;margin-bottom:8px">' +
      '<div style="display:flex;justify-content:space-between"><strong>' + month + '</strong><span style="color:#4caf50">' + data.streams + ' streams</span></div>' +
      '<div style="display:flex;gap:12px;margin-top:6px;font-size:12px;color:#b0b0b0;flex-wrap:wrap">' +
      '<span>Avg: <strong style="color:#fff">' + data.avgViewers + '</strong></span>' +
      '<span>Peak: <strong style="color:#ff9800">' + data.peakViewers + '</strong></span>' +
      '<span>Hours: <strong style="color:#9146ff">' + (data.totalDuration / 60).toFixed(1) + '</strong></span>' +
      '<span>Follows: <strong style="color:#4caf50">' + data.followers + '</strong></span>' +
      '<span>Subs: <strong style="color:#ffd700">' + data.subs + '</strong></span></div></div>';
  });

  // Day of week chart
  const dowMax = Math.max(...Object.values(dayOfWeekStats).map(d => d.streams > 0 ? Math.round(d.viewers / d.streams) : 0), 1);
  let dowHtml = '';
  Object.values(dayOfWeekStats).forEach(d => {
    const avg = d.streams > 0 ? Math.round(d.viewers / d.streams) : 0;
    const pct = Math.round((avg / dowMax) * 100);
    const color = pct > 70 ? '#9146ff' : pct > 40 ? '#4caf50' : '#26262c';
    const avgDur = d.streams > 0 ? (d.duration / d.streams / 60).toFixed(1) : '0.0';
    dowHtml += '<div style="text-align:center;flex:1"><div style="height:80px;display:flex;align-items:flex-end;justify-content:center"><div style="width:100%;max-width:30px;background:' + color + ';height:' + Math.max(pct, 5) + '%;border-radius:3px 3px 0 0"></div></div>' +
      '<div style="font-size:11px;color:#b0b0b0;margin-top:4px">' + d.label + '</div><div style="font-size:10px;color:#666">' + avg + ' avg</div><div style="font-size:9px;color:#555">' + d.streams + ' str</div><div style="font-size:9px;color:#555">' + avgDur + 'h</div></div>';
  });

  // Duration distribution
  const durMax = Math.max(...Object.values(durationBuckets), 1);
  let durHtml = '';
  Object.entries(durationBuckets).forEach(([label, count]) => {
    const pct = Math.round((count / durMax) * 100);
    durHtml += '<div style="display:flex;align-items:center;gap:10px;margin-bottom:8px">' +
      '<span style="color:#b0b0b0;width:70px;font-size:12px">' + label + '</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:20px;overflow:hidden"><div style="background:linear-gradient(90deg,#ff9800,#ffa726);height:100%;width:' + pct + '%;border-radius:3px;display:flex;align-items:center;padding-left:6px"><span style="font-size:10px;color:#fff;font-weight:bold">' + (count > 0 ? count : '') + '</span></div></div></div>';
  });

  // Viewer growth trendline
  let rollingAvgHtml = '';
  if (sorted.length >= 5) {
    const windowSize = Math.min(5, sorted.length);
    for (let i = windowSize - 1; i < sorted.length; i++) {
      let sum = 0;
      for (let j = i - windowSize + 1; j <= i; j++) sum += (sorted[j].peakViewers || 0);
      const avg = Math.round(sum / windowSize);
      const date = new Date(sorted[i].startedAt || sorted[i].date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      rollingAvgHtml += '<span style="font-size:11px;color:#b0b0b0;white-space:nowrap">' + date + ': <strong style="color:#9146ff">' + avg + '</strong></span> ';
    }
  }

  // Cumulative viewer chart data
  let cumulativeHtml = '';
  let cumV = 0, cumH = 0;
  const cumMax = sorted.reduce((s, x) => s + (x.peakViewers || 0), 0);
  sorted.forEach((s, i) => {
    cumV += (s.peakViewers || 0);
    cumH += ((s.durationMinutes || 0) / 60);
    if (i % Math.max(1, Math.floor(sorted.length / 10)) === 0 || i === sorted.length - 1) {
      const pct = cumMax > 0 ? Math.round((cumV / cumMax) * 100) : 0;
      const date = new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      cumulativeHtml += '<div style="display:flex;align-items:center;gap:8px;margin-bottom:4px">' +
        '<span style="color:#b0b0b0;width:60px;font-size:10px">' + date + '</span>' +
        '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:14px;overflow:hidden"><div style="background:linear-gradient(90deg,#4caf50,#81c784);height:100%;width:' + pct + '%;border-radius:3px"></div></div>' +
        '<span style="color:#fff;font-size:10px;min-width:40px;text-align:right">' + cumV + '</span></div>';
    }
  });

  return `
<div class="card">
  <h2>ðŸ“Š Trends Analysis</h2>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin:15px 0">
    <div style="background:#26262c;padding:12px;border-radius:6px;text-align:center">
      <div style="color:#b0b0b0;font-size:10px">Avg Gap (Days)</div>
      <div style="font-size:20px;color:#9146ff;font-weight:bold">${avgGap}</div>
    </div>
    <div style="background:#26262c;padding:12px;border-radius:6px;text-align:center">
      <div style="color:#b0b0b0;font-size:10px">Longest Gap</div>
      <div style="font-size:20px;color:#ef5350;font-weight:bold">${longestGap}d</div>
    </div>
    <div style="background:#26262c;padding:12px;border-radius:6px;text-align:center">
      <div style="color:#b0b0b0;font-size:10px">Shortest Gap</div>
      <div style="font-size:20px;color:#4caf50;font-weight:bold">${shortestGap}d</div>
    </div>
    <div style="background:#26262c;padding:12px;border-radius:6px;text-align:center">
      <div style="color:#b0b0b0;font-size:10px">Volatility Index</div>
      <div style="font-size:20px;color:#ff9800;font-weight:bold">${volatilityIndex}%</div>
    </div>
    <div style="background:#26262c;padding:12px;border-radius:6px;text-align:center">
      <div style="color:#b0b0b0;font-size:10px">Streams/Week Avg</div>
      <div style="font-size:20px;color:#00bcd4;font-weight:bold">${streamsPerWeekAvg}</div>
    </div>
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ”„ Weekend vs Weekday</h3>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:10px">
    <div style="background:#26262c;padding:18px;border-radius:6px;text-align:center;border-top:3px solid #2196f3">
      <div style="color:#b0b0b0;font-size:11px">Weekday Avg (Mon-Fri)</div>
      <div style="font-size:24px;color:#2196f3;font-weight:bold">${weekdayAvg}</div>
      <div style="color:#666;font-size:10px">${weekdayStreams} streams</div>
    </div>
    <div style="background:#26262c;padding:18px;border-radius:6px;text-align:center;border-top:3px solid #e91e63">
      <div style="color:#b0b0b0;font-size:11px">Weekend Avg (Sat-Sun)</div>
      <div style="font-size:24px;color:#e91e63;font-weight:bold">${weekendAvg}</div>
      <div style="color:#666;font-size:10px">${weekendStreams} streams</div>
    </div>
  </div>
</div>

<div class="card" style="margin-top:15px">
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">
    <div>
      <h3 style="margin-top:0">ðŸ“… Weekly Trends</h3>
      ${weeklyHtml || '<p style="color:#b0b0b0">No weekly data</p>'}
    </div>
    <div>
      <h3 style="margin-top:0">ðŸ“† Monthly Trends</h3>
      ${monthlyHtml || '<p style="color:#b0b0b0">No monthly data</p>'}
    </div>
  </div>
</div>

${momGrowthHtml ? '<div class="card" style="margin-top:15px"><h3 style="margin-top:0">ðŸ“ˆ Month-over-Month Growth</h3><div style="margin-top:10px">' + momGrowthHtml + '</div></div>' : ''}

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“Š Best Day to Stream</h3>
  <p style="color:#b0b0b0;font-size:12px;margin-bottom:10px">Average viewers by day of week (with stream count and avg duration)</p>
  <div style="display:flex;gap:8px;padding:10px;background:#1a1a2e;border-radius:6px">
    ${dowHtml}
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">â±ï¸ Stream Duration Distribution</h3>
  <div style="margin-top:15px">
    ${durHtml}
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“ˆ Rolling Average (5-stream window)</h3>
  <div style="padding:15px;background:#26262c;border-radius:6px;display:flex;flex-wrap:wrap;gap:10px;margin-top:10px">
    ${rollingAvgHtml || '<span style="color:#b0b0b0">Need at least 5 streams for rolling average</span>'}
  </div>
</div>

${cumulativeHtml ? '<div class="card" style="margin-top:15px"><h3 style="margin-top:0">ðŸ“Š Cumulative Viewers Over Time</h3><div style="margin-top:10px">' + cumulativeHtml + '</div></div>' : ''}

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“‰ Rolling Average & Viewer Trend</h3>
  <div style="height:220px;margin-top:10px"><canvas id="trends-rolling-chart"></canvas></div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“… Day-of-Week Performance</h3>
  <div style="height:200px;margin-top:10px"><canvas id="trends-dow-chart"></canvas></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  var trendData = ${JSON.stringify((() => {
    const s = sorted;
    const windowSize = Math.min(5, s.length);
    const rolling = [];
    for (let i = 0; i < s.length; i++) {
      if (i < windowSize - 1) { rolling.push(null); continue; }
      let sum = 0;
      for (let j = i - windowSize + 1; j <= i; j++) sum += (s[j].peakViewers || 0);
      rolling.push(Math.round(sum / windowSize));
    }
    return {
      labels: s.map(x => new Date(x.startedAt || x.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })),
      peak: s.map(x => x.peakViewers || 0),
      avg: s.map(x => x.avgViewers || x.averageViewers || 0),
      rolling: rolling,
      dow: Object.values(dayOfWeekStats).map(d => ({
        label: d.label,
        avgViewers: d.streams > 0 ? Math.round(d.viewers / d.streams) : 0,
        streams: d.streams,
        avgDuration: d.streams > 0 ? Math.round(d.duration / d.streams) : 0
      }))
    };
  })())};

  var rctx = document.getElementById('trends-rolling-chart');
  if (rctx && trendData.labels.length > 0) {
    new Chart(rctx, {
      type: 'line',
      data: {
        labels: trendData.labels,
        datasets: [{
          label: 'Peak Viewers',
          data: trendData.peak,
          borderColor: 'rgba(145,70,255,0.4)',
          backgroundColor: 'rgba(145,70,255,0.05)',
          fill: false,
          tension: 0.3,
          pointRadius: 3,
          borderWidth: 1
        },
        {
          label: 'Avg Viewers',
          data: trendData.avg,
          borderColor: 'rgba(76,175,80,0.5)',
          fill: false,
          tension: 0.3,
          pointRadius: 2,
          borderWidth: 1,
          borderDash: [3, 3]
        },
        {
          label: '5-Stream Rolling Avg',
          data: trendData.rolling,
          borderColor: '#ff9800',
          backgroundColor: 'rgba(255,152,0,0.1)',
          fill: true,
          tension: 0.4,
          pointRadius: 4,
          borderWidth: 3,
          pointBackgroundColor: '#ff9800',
          pointBorderColor: '#fff',
          pointBorderWidth: 2,
          spanGaps: true
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: true, labels: { color: '#8b8fa3', usePointStyle: true } } },
        scales: {
          y: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#8b8fa3' } },
          x: { grid: { display: false }, ticks: { color: '#8b8fa3' } }
        }
      }
    });
  }

  var dctx = document.getElementById('trends-dow-chart');
  if (dctx && trendData.dow.length > 0) {
    var dowColors = ['#ef5350', '#ff9800', '#ffd700', '#4caf50', '#2196f3', '#9146ff', '#e91e63'];
    new Chart(dctx, {
      type: 'bar',
      data: {
        labels: trendData.dow.map(function(d) { return d.label; }),
        datasets: [{
          label: 'Avg Viewers',
          data: trendData.dow.map(function(d) { return d.avgViewers; }),
          backgroundColor: dowColors.map(function(c) { return c + 'aa'; }),
          borderColor: dowColors,
          borderWidth: 1,
          borderRadius: 4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: { callbacks: { afterLabel: function(ctx) { var d = trendData.dow[ctx.dataIndex]; return d.streams + ' streams | ~' + Math.round(d.avgDuration/60) + 'h avg'; } } }
        },
        scales: {
          y: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#8b8fa3' } },
          x: { grid: { display: false }, ticks: { color: '#8b8fa3' } }
        }
      }
    });
  }
});
</script>
  `;
}

// NEW: Game Performance Tab
function renderGamePerformanceTab() {
  const h = history || [];
  const gameStats = {};

  h.forEach(s => {
    const game = s.game || s.gameName || 'Unknown';
    if (!gameStats[game]) {
      gameStats[game] = { streams: 0, totalViewers: 0, peakViewers: 0, avgViewers: 0, totalDuration: 0, dates: [], followers: 0, subs: 0, bestSingleStream: 0 };
    }
    gameStats[game].streams++;
    gameStats[game].totalViewers += (s.peakViewers || 0);
    gameStats[game].peakViewers = Math.max(gameStats[game].peakViewers, s.peakViewers || 0);
    gameStats[game].totalDuration += (s.durationMinutes || 0);
    gameStats[game].dates.push(s.startedAt || s.date);
    gameStats[game].followers += (s.followers || s.newFollowers || 0);
    gameStats[game].subs += (s.subscribers || s.newSubs || 0);
    gameStats[game].bestSingleStream = Math.max(gameStats[game].bestSingleStream, s.peakViewers || 0);
  });

  Object.keys(gameStats).forEach(game => {
    gameStats[game].avgViewers = Math.round(gameStats[game].totalViewers / gameStats[game].streams);
  });

  const sortedGames = Object.entries(gameStats).sort((a, b) => b[1].avgViewers - a[1].avgViewers).slice(0, 15);
  const totalStreams = h.length || 1;
  const topViewerMax = sortedGames.length > 0 ? sortedGames[0][1].avgViewers : 1;

  // Viewers per hour by game
  const viewersPerHourByGame = sortedGames.map(([game, data]) => {
    const hours = data.totalDuration / 60;
    return [game, hours > 0 ? (data.totalViewers / hours).toFixed(1) : '0.0'];
  });

  // Game switching frequency
  let gameSwitches = 0;
  for (let i = 1; i < h.length; i++) {
    if ((h[i].game || h[i].gameName || 'Unknown') !== (h[i-1].game || h[i-1].gameName || 'Unknown')) gameSwitches++;
  }
  const switchRate = h.length > 1 ? ((gameSwitches / (h.length - 1)) * 100).toFixed(0) : '0';

  // Rising vs declining games (compare first half vs second half of streams)
  let risingGames = [];
  let decliningGames = [];
  Object.entries(gameStats).forEach(([game, data]) => {
    if (data.dates.length >= 4) {
      const sortedDates = [...data.dates].sort((a, b) => new Date(a) - new Date(b));
      const mid = Math.floor(sortedDates.length / 2);
      const earlyStreams = h.filter(s => {
        const g = s.game || s.gameName || 'Unknown';
        return g === game && sortedDates.slice(0, mid).includes(s.startedAt || s.date);
      });
      const lateStreams = h.filter(s => {
        const g = s.game || s.gameName || 'Unknown';
        return g === game && sortedDates.slice(mid).includes(s.startedAt || s.date);
      });
      const earlyAvg = earlyStreams.length > 0 ? earlyStreams.reduce((s, x) => s + (x.peakViewers || 0), 0) / earlyStreams.length : 0;
      const lateAvg = lateStreams.length > 0 ? lateStreams.reduce((s, x) => s + (x.peakViewers || 0), 0) / lateStreams.length : 0;
      if (lateAvg > earlyAvg * 1.15) risingGames.push([game, Math.round(((lateAvg - earlyAvg) / (earlyAvg || 1)) * 100)]);
      else if (lateAvg < earlyAvg * 0.85) decliningGames.push([game, Math.round(((lateAvg - earlyAvg) / (earlyAvg || 1)) * 100)]);
    }
  });

  // Table rows
  let gamesHtml = '';
  sortedGames.forEach(([game, data], idx) => {
    const sharePercent = Math.round((data.streams / totalStreams) * 100);
    const medal = idx === 0 ? 'ðŸ¥‡' : idx === 1 ? 'ðŸ¥ˆ' : idx === 2 ? 'ðŸ¥‰' : (idx + 1).toString();
    const hours = (data.totalDuration / 60).toFixed(1);
    const vph = data.totalDuration > 0 ? (data.totalViewers / (data.totalDuration / 60)).toFixed(0) : '0';
    const lastPlayed = data.dates.length > 0 ? new Date(data.dates[data.dates.length - 1]).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : 'N/A';
    const daysSince = data.dates.length > 0 ? Math.floor((Date.now() - new Date(data.dates[data.dates.length - 1]).getTime()) / (1000 * 60 * 60 * 24)) : 0;
    gamesHtml += '<tr style="transition:background 0.2s" onmouseenter="this.style.background=\'#2a2f3a\'" onmouseleave="this.style.background=\'transparent\'">' +
      '<td style="padding:10px;border-bottom:1px solid #2a2f3a;text-align:center;font-size:16px">' + medal + '</td>' +
      '<td style="padding:10px;border-bottom:1px solid #2a2f3a;font-weight:bold">' + game + '</td>' +
      '<td style="padding:10px;border-bottom:1px solid #2a2f3a">' + data.streams + ' <span style="color:#666;font-size:11px">(' + sharePercent + '%)</span></td>' +
      '<td style="padding:10px;border-bottom:1px solid #2a2f3a;color:#ff9800;font-weight:bold">' + data.peakViewers + '</td>' +
      '<td style="padding:10px;border-bottom:1px solid #2a2f3a;color:#9146ff;font-weight:bold">' + data.avgViewers + '</td>' +
      '<td style="padding:10px;border-bottom:1px solid #2a2f3a">' + hours + 'h</td>' +
      '<td style="padding:10px;border-bottom:1px solid #2a2f3a;color:#26c6da;font-size:12px">' + vph + '/h</td>' +
      '<td style="padding:10px;border-bottom:1px solid #2a2f3a;color:#4caf50;font-size:12px">+' + data.followers + '</td>' +
      '<td style="padding:10px;border-bottom:1px solid #2a2f3a;color:#666;font-size:12px">' + lastPlayed + ' <span style="font-size:10px">(' + daysSince + 'd ago)</span></td></tr>';
  });

  // Game share visual bars
  let gameShareHtml = '';
  sortedGames.slice(0, 8).forEach(([game, data]) => {
    const pct = Math.round((data.avgViewers / topViewerMax) * 100);
    const colors = ['#9146ff', '#4caf50', '#ff9800', '#2196f3', '#e91e63', '#00bcd4', '#ff5722', '#8bc34a'];
    const color = colors[sortedGames.findIndex(([g]) => g === game) % colors.length];
    gameShareHtml += '<div style="display:flex;align-items:center;gap:10px;margin-bottom:8px">' +
      '<span style="color:#b0b0b0;width:120px;font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">' + game + '</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:22px;overflow:hidden"><div style="background:' + color + ';height:100%;width:' + pct + '%;border-radius:3px;display:flex;align-items:center;padding-left:6px"><span style="font-size:10px;color:#fff;font-weight:bold">' + data.avgViewers + ' avg</span></div></div></div>';
  });

  // Average duration per game bars
  let gameDurHtml = '';
  const durSorted = sortedGames.slice(0, 8).sort((a, b) => (b[1].totalDuration / b[1].streams) - (a[1].totalDuration / a[1].streams));
  const durMax = durSorted.length > 0 ? (durSorted[0][1].totalDuration / durSorted[0][1].streams) : 1;
  durSorted.forEach(([game, data]) => {
    const avgDur = data.totalDuration / data.streams;
    const pct = Math.round((avgDur / durMax) * 100);
    gameDurHtml += '<div style="display:flex;align-items:center;gap:10px;margin-bottom:8px">' +
      '<span style="color:#b0b0b0;width:120px;font-size:12px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">' + game + '</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:22px;overflow:hidden"><div style="background:linear-gradient(90deg,#00bcd4,#4dd0e1);height:100%;width:' + pct + '%;border-radius:3px;display:flex;align-items:center;padding-left:6px"><span style="font-size:10px;color:#fff;font-weight:bold">' + (avgDur / 60).toFixed(1) + 'h</span></div></div></div>';
  });

  // Category diversity index
  const uniqueGames = Object.keys(gameStats).length;
  const diversityRating = uniqueGames >= 10 ? 'ðŸŒˆ Highly Diverse' : uniqueGames >= 5 ? 'ðŸŽ¯ Moderately Diverse' : uniqueGames >= 2 ? 'ðŸ“Œ Focused' : 'ðŸŽ® Specialist';

  // Top game dominance
  const topGameShare = sortedGames.length > 0 ? Math.round((sortedGames[0][1].streams / totalStreams) * 100) : 0;

  return `
<div class="card">
  <h2>ðŸŽ® Game Performance</h2>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px;margin:15px 0">
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">
      <div style="color:#b0b0b0;font-size:11px">Unique Games</div>
      <div style="font-size:24px;color:#9146ff;font-weight:bold">${uniqueGames}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">
      <div style="color:#b0b0b0;font-size:11px">Top Game</div>
      <div style="font-size:14px;color:#4caf50;font-weight:bold;margin-top:4px">${sortedGames.length > 0 ? sortedGames[0][0] : 'N/A'}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">
      <div style="color:#b0b0b0;font-size:11px">Diversity</div>
      <div style="font-size:14px;color:#ff9800;font-weight:bold;margin-top:4px">${diversityRating}</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">
      <div style="color:#b0b0b0;font-size:11px">Switch Rate</div>
      <div style="font-size:24px;color:#e91e63;font-weight:bold">${switchRate}%</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">
      <div style="color:#b0b0b0;font-size:11px">Top Game Share</div>
      <div style="font-size:24px;color:#2196f3;font-weight:bold">${topGameShare}%</div>
    </div>
  </div>

  <table style="width:100%;border-collapse:collapse;margin-top:15px;font-size:13px">
    <thead>
      <tr style="background:#26262c">
        <th style="padding:10px;text-align:center;width:35px">#</th>
        <th style="padding:10px;text-align:left">Game</th>
        <th style="padding:10px;text-align:left">Streams</th>
        <th style="padding:10px;text-align:left">Peak</th>
        <th style="padding:10px;text-align:left">Avg</th>
        <th style="padding:10px;text-align:left">Hours</th>
        <th style="padding:10px;text-align:left">V/Hr</th>
        <th style="padding:10px;text-align:left">Follows</th>
        <th style="padding:10px;text-align:left">Last</th>
      </tr>
    </thead>
    <tbody>
      ${gamesHtml || '<tr><td colspan="9" style="padding:20px;text-align:center;color:#b0b0b0">No game data yet</td></tr>'}
    </tbody>
  </table>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“Š Viewer Share by Game</h3>
  <div style="margin-top:15px">
    ${gameShareHtml || '<div style="color:#b0b0b0;text-align:center;padding:20px">No data</div>'}
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">â±ï¸ Average Duration per Game</h3>
  <div style="margin-top:15px">
    ${gameDurHtml || '<div style="color:#b0b0b0;text-align:center;padding:20px">No data</div>'}
  </div>
</div>

${risingGames.length > 0 || decliningGames.length > 0 ? '<div class="card" style="margin-top:15px"><h3 style="margin-top:0">ðŸ“ˆ Game Trends</h3><div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:10px">' +
  '<div><h4 style="color:#4caf50;margin:0 0 10px">Rising Games</h4>' + (risingGames.length > 0 ? risingGames.map(function(g) { return '<div style="background:#26262c;padding:10px;border-radius:4px;margin-bottom:6px;border-left:3px solid #4caf50"><span style="color:#fff">' + g[0] + '</span> <span style="color:#4caf50;font-weight:bold">+' + g[1] + '%</span></div>'; }).join('') : '<div style="color:#666;font-size:12px">No rising games detected</div>') + '</div>' +
  '<div><h4 style="color:#ef5350;margin:0 0 10px">Declining Games</h4>' + (decliningGames.length > 0 ? decliningGames.map(function(g) { return '<div style="background:#26262c;padding:10px;border-radius:4px;margin-bottom:6px;border-left:3px solid #ef5350"><span style="color:#fff">' + g[0] + '</span> <span style="color:#ef5350;font-weight:bold">' + g[1] + '%</span></div>'; }).join('') : '<div style="color:#666;font-size:12px">No declining games detected</div>') + '</div></div></div>' : ''}

${(function() {
  // Game switching analysis from gameSegments
  var switchStreams = 0;
  var singleGameStreams = 0;
  var totalSegments = 0;
  var switchPairs = {};
  
  h.forEach(function(s) {
    var segs = s.gameSegments;
    if (segs && segs.length > 0) {
      totalSegments += segs.length;
      if (segs.length > 1) {
        switchStreams++;
        for (var i = 0; i < segs.length - 1; i++) {
          var pair = (segs[i].game || 'Unknown') + ' â†’ ' + (segs[i + 1].game || 'Unknown');
          switchPairs[pair] = (switchPairs[pair] || 0) + 1;
        }
      } else {
        singleGameStreams++;
      }
    } else {
      singleGameStreams++;
    }
  });
  
  var switchRate = h.length > 0 ? Math.round((switchStreams / h.length) * 100) : 0;
  var avgSegments = h.length > 0 ? (totalSegments / h.length).toFixed(1) : '0.0';
  
  // Compare viewers for switch vs single-game streams
  var switchViewers = h.filter(function(s) { return s.gameSegments && s.gameSegments.length > 1; });
  var singleViewers = h.filter(function(s) { return !s.gameSegments || s.gameSegments.length <= 1; });
  var switchAvg = switchViewers.length > 0 ? Math.round(switchViewers.reduce(function(sum, s) { return sum + (s.peakViewers || 0); }, 0) / switchViewers.length) : 0;
  var singleAvg = singleViewers.length > 0 ? Math.round(singleViewers.reduce(function(sum, s) { return sum + (s.peakViewers || 0); }, 0) / singleViewers.length) : 0;
  var switchImpact = switchAvg > singleAvg ? 'Game switching streams average <span style="color:#4caf50;font-weight:bold">' + switchAvg + '</span> viewers vs <span style="color:#ff9800;font-weight:bold">' + singleAvg + '</span> for single-game streams' :
    singleAvg > switchAvg ? 'Single-game streams average <span style="color:#4caf50;font-weight:bold">' + singleAvg + '</span> viewers vs <span style="color:#ff9800;font-weight:bold">' + switchAvg + '</span> for multi-game streams' :
    'No significant difference between single-game and multi-game streams';
  
  var topPairs = Object.entries(switchPairs).sort(function(a, b) { return b[1] - a[1]; }).slice(0, 5);
  var pairsHtml = '';
  topPairs.forEach(function(p) {
    pairsHtml += '<div style="display:flex;align-items:center;gap:8px;padding:8px;background:#26262c;border-radius:4px;margin-bottom:4px">' +
      '<span style="color:#ce93d8;font-size:12px;flex:1">' + p[0] + '</span>' +
      '<span style="color:#fff;font-weight:bold;font-size:13px">' + p[1] + 'x</span></div>';
  });
  
  return '<div class="card" style="margin-top:15px">' +
    '<h3 style="margin-top:0">ðŸ”€ Game Switching Analysis</h3>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px;margin:10px 0">' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #9146ff">' +
        '<div style="color:#b0b0b0;font-size:10px">Switch Rate</div>' +
        '<div style="font-size:20px;color:#9146ff;font-weight:bold">' + switchRate + '%</div>' +
        '<div style="font-size:10px;color:#666">' + switchStreams + ' of ' + h.length + ' streams</div>' +
      '</div>' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #ff9800">' +
        '<div style="color:#b0b0b0;font-size:10px">Avg Games/Stream</div>' +
        '<div style="font-size:20px;color:#ff9800;font-weight:bold">' + avgSegments + '</div>' +
      '</div>' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #4caf50">' +
        '<div style="color:#b0b0b0;font-size:10px">Single-Game</div>' +
        '<div style="font-size:20px;color:#4caf50;font-weight:bold">' + singleGameStreams + '</div>' +
      '</div>' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #2196f3">' +
        '<div style="color:#b0b0b0;font-size:10px">Multi-Game</div>' +
        '<div style="font-size:20px;color:#2196f3;font-weight:bold">' + switchStreams + '</div>' +
      '</div>' +
    '</div>' +
    '<div style="padding:10px;background:#26262c;border-radius:6px;border-left:3px solid #9146ff;margin-bottom:10px">' +
      '<div style="font-weight:bold;color:#fff">ðŸ’¡ Switching Impact</div>' +
      '<div style="color:#b0b0b0;margin-top:5px;font-size:12px">' + switchImpact + '</div>' +
    '</div>' +
    (pairsHtml ? '<div style="margin-top:10px"><div style="color:#b0b0b0;font-size:11px;margin-bottom:6px">Most Common Game Switches:</div>' + pairsHtml + '</div>' : '') +
  '</div>';
})()}

<div class="card" style="margin-top:15px">
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">
    <div>
      <h3 style="margin-top:0">ðŸ© Time Distribution by Game</h3>
      <div style="height:250px"><canvas id="game-doughnut-chart"></canvas></div>
    </div>
    <div>
      <h3 style="margin-top:0">ðŸ“Š Avg Viewers by Game</h3>
      <div style="height:250px"><canvas id="game-viewers-chart"></canvas></div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  var gameData = ${JSON.stringify(sortedGames.slice(0, 8).map(([game, data]) => ({
    game: game.length > 20 ? game.substring(0, 18) + '..' : game,
    duration: Math.round(data.totalDuration / 60 * 10) / 10,
    avgViewers: data.avgViewers,
    streams: data.streams,
    peakViewers: data.peakViewers
  })))};

  var gameColors = ['#9146ff', '#4caf50', '#ff9800', '#e91e63', '#2196f3', '#ffd700', '#00bcd4', '#ce93d8'];

  var gdc = document.getElementById('game-doughnut-chart');
  if (gdc && gameData.length > 0) {
    new Chart(gdc, {
      type: 'doughnut',
      data: {
        labels: gameData.map(function(g) { return g.game; }),
        datasets: [{
          data: gameData.map(function(g) { return g.duration; }),
          backgroundColor: gameColors.map(function(c) { return c + 'cc'; }),
          borderColor: gameColors,
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: true, position: 'right', labels: { color: '#8b8fa3', padding: 8, font: { size: 11 }, usePointStyle: true } },
          tooltip: { callbacks: { label: function(ctx) { return ctx.label + ': ' + ctx.raw + 'h (' + gameData[ctx.dataIndex].streams + ' streams)'; } } }
        }
      }
    });
  }

  var gvc = document.getElementById('game-viewers-chart');
  if (gvc && gameData.length > 0) {
    new Chart(gvc, {
      type: 'bar',
      data: {
        labels: gameData.map(function(g) { return g.game; }),
        datasets: [{
          label: 'Avg Viewers',
          data: gameData.map(function(g) { return g.avgViewers; }),
          backgroundColor: gameColors.map(function(c) { return c + 'aa'; }),
          borderColor: gameColors,
          borderWidth: 1,
          borderRadius: 4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        indexAxis: 'y',
        plugins: {
          legend: { display: false },
          tooltip: { callbacks: { afterLabel: function(ctx) { var g = gameData[ctx.dataIndex]; return 'Peak: ' + g.peakViewers + ' | ' + g.streams + ' streams'; } } }
        },
        scales: {
          x: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#8b8fa3' } },
          y: { grid: { display: false }, ticks: { color: '#8b8fa3', font: { size: 11 } } }
        }
      }
    });
  }
});
</script>
  `;
}

// NEW: Viewer Patterns Tab
function renderViewerPatternsTab() {
  const h = history || [];
  const hourStats = {};
  const dayHourStats = {};
  const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

  h.forEach(s => {
    const d = new Date(s.startedAt || s.date);
    const hour = d.getHours();
    const dow = d.getDay();
    const hourLabel = hour.toString().padStart(2, '0') + ':00';
    if (!hourStats[hour]) hourStats[hour] = { label: hourLabel, streams: 0, viewers: 0, duration: 0, followers: 0 };
    hourStats[hour].streams++;
    hourStats[hour].viewers += (s.peakViewers || 0);
    hourStats[hour].duration += (s.durationMinutes || 0);
    hourStats[hour].followers += (s.followers || s.newFollowers || 0);

    const key = dow + '-' + hour;
    if (!dayHourStats[key]) dayHourStats[key] = { streams: 0, viewers: 0 };
    dayHourStats[key].streams++;
    dayHourStats[key].viewers += (s.peakViewers || 0);
  });

  const hours = [];
  for (let i = 0; i < 24; i++) {
    const label = i.toString().padStart(2, '0') + ':00';
    hours.push({
      hour: i,
      label: label,
      streams: hourStats[i]?.streams || 0,
      avgViewers: hourStats[i] ? Math.round(hourStats[i].viewers / hourStats[i].streams) : 0,
      avgDuration: hourStats[i] ? Math.round(hourStats[i].duration / hourStats[i].streams) : 0,
      avgFollowers: hourStats[i] ? (hourStats[i].followers / hourStats[i].streams).toFixed(1) : '0.0'
    });
  }

  const maxViewers = Math.max(...hours.map(h => h.avgViewers), 1);

  // Weekend vs weekday viewer patterns
  const weekdayHours = {};
  const weekendHours = {};
  h.forEach(s => {
    const d = new Date(s.startedAt || s.date);
    const hour = d.getHours();
    const isWeekend = d.getDay() === 0 || d.getDay() === 6;
    const target = isWeekend ? weekendHours : weekdayHours;
    if (!target[hour]) target[hour] = { count: 0, viewers: 0 };
    target[hour].count++;
    target[hour].viewers += (s.peakViewers || 0);
  });

  // Viewer decay rate (avg vs peak ratio over stream length)
  const avgViewerRatio = h.length > 0 ? (h.reduce((s, x) => s + ((x.averageViewers || x.peakViewers || 0) / Math.max(x.peakViewers || 1, 1)), 0) / h.length * 100).toFixed(1) : '0.0';

  // Optimal stream length analysis
  const durationBuckets = {};
  h.forEach(s => {
    const hrs = Math.floor((s.durationMinutes || 0) / 60);
    const bucket = hrs + 'h';
    if (!durationBuckets[bucket]) durationBuckets[bucket] = { count: 0, viewers: 0, duration: 0 };
    durationBuckets[bucket].count++;
    durationBuckets[bucket].viewers += (s.peakViewers || 0);
    durationBuckets[bucket].duration += (s.durationMinutes || 0);
  });
  const optimalLength = Object.entries(durationBuckets).sort((a, b) => (b[1].viewers / b[1].count) - (a[1].viewers / a[1].count))[0];
  const optimalLengthLabel = optimalLength ? optimalLength[0] : 'N/A';
  const optimalLengthAvg = optimalLength ? Math.round(optimalLength[1].viewers / optimalLength[1].count) : 0;

  // Seasonal patterns (by month)
  const monthlyPatterns = {};
  h.forEach(s => {
    const month = new Date(s.startedAt || s.date).toLocaleString('default', { month: 'short' });
    if (!monthlyPatterns[month]) monthlyPatterns[month] = { count: 0, viewers: 0 };
    monthlyPatterns[month].count++;
    monthlyPatterns[month].viewers += (s.peakViewers || 0);
  });

  let seasonalHtml = '';
  const seasons = { 'Winter': ['Dec', 'Jan', 'Feb'], 'Spring': ['Mar', 'Apr', 'May'], 'Summer': ['Jun', 'Jul', 'Aug'], 'Fall': ['Sep', 'Oct', 'Nov'] };
  const seasonIcons = { 'Winter': 'â„ï¸', 'Spring': 'ðŸŒ¸', 'Summer': 'â˜€ï¸', 'Fall': 'ðŸ‚' };
  Object.entries(seasons).forEach(([season, months]) => {
    let totalV = 0, totalC = 0;
    months.forEach(m => { if (monthlyPatterns[m]) { totalV += monthlyPatterns[m].viewers; totalC += monthlyPatterns[m].count; } });
    const avg = totalC > 0 ? Math.round(totalV / totalC) : 0;
    seasonalHtml += '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="font-size:24px">' + seasonIcons[season] + '</div>' +
      '<div style="color:#b0b0b0;font-size:11px;margin-top:5px">' + season + '</div>' +
      '<div style="font-size:20px;color:#fff;font-weight:bold;margin-top:4px">' + avg + '</div>' +
      '<div style="color:#666;font-size:10px">' + totalC + ' streams</div></div>';
  });

  // Time-of-day heatmap
  let heatmapHtml = '';
  hours.forEach(h => {
    const percent = Math.round((h.avgViewers / maxViewers) * 100);
    const intensity = percent > 80 ? '#ef5350' : percent > 60 ? '#ff9800' : percent > 35 ? '#4caf50' : percent > 10 ? '#2e7d32' : '#26262c';
    heatmapHtml += '<div style="background:' + intensity + ';padding:6px;border-radius:4px;text-align:center">' +
      '<div style="font-size:10px;color:#ddd">' + h.label + '</div>' +
      '<div style="font-weight:bold;color:#fff;font-size:14px">' + h.avgViewers + '</div>' +
      '<div style="font-size:9px;color:#b0b0b0">' + h.streams + ' str | ' + h.avgDuration + 'm</div></div>';
  });

  // 7x24 day/hour heatmap grid
  let gridHtml = '<div style="display:grid;grid-template-columns:60px repeat(24, 1fr);gap:2px;font-size:10px">';
  gridHtml += '<div></div>';
  for (let hr = 0; hr < 24; hr++) {
    gridHtml += '<div style="text-align:center;color:#666;padding:2px">' + hr.toString().padStart(2, '0') + '</div>';
  }
  let globalMax = 1;
  for (let d = 0; d < 7; d++) {
    for (let hr = 0; hr < 24; hr++) {
      const k = d + '-' + hr;
      if (dayHourStats[k]) {
        const avg = Math.round(dayHourStats[k].viewers / dayHourStats[k].streams);
        globalMax = Math.max(globalMax, avg);
      }
    }
  }
  for (let d = 0; d < 7; d++) {
    gridHtml += '<div style="color:#b0b0b0;padding:4px;display:flex;align-items:center">' + dayNames[d] + '</div>';
    for (let hr = 0; hr < 24; hr++) {
      const k = d + '-' + hr;
      const data = dayHourStats[k];
      const avg = data ? Math.round(data.viewers / data.streams) : 0;
      const pct = Math.round((avg / globalMax) * 100);
      const opacity = pct > 0 ? Math.max(0.15, pct / 100) : 0.05;
      gridHtml += '<div style="background:rgba(145,70,255,' + opacity + ');border-radius:2px;padding:3px;text-align:center;color:' + (pct > 40 ? '#fff' : '#666') + '">' + (avg > 0 ? avg : '') + '</div>';
    }
  }
  gridHtml += '</div>';

  // Peak time identification
  const bestHour = hours.reduce((best, h) => h.avgViewers > best.avgViewers ? h : best, hours[0]);
  const worstHour = hours.filter(h => h.streams > 0).reduce((worst, h) => h.avgViewers < worst.avgViewers ? h : worst, hours.filter(h => h.streams > 0)[0] || hours[0]);
  const secondBestHour = hours.filter(h => h.hour !== bestHour.hour).reduce((best, h) => h.avgViewers > best.avgViewers ? h : best, hours[0]);

  // Time distribution: morning/afternoon/evening/night
  const timeSlots = { 'Morning (6-12)': { streams: 0, viewers: 0 }, 'Afternoon (12-18)': { streams: 0, viewers: 0 }, 'Evening (18-24)': { streams: 0, viewers: 0 }, 'Night (0-6)': { streams: 0, viewers: 0 } };
  hours.forEach(h => {
    const slot = h.hour < 6 ? 'Night (0-6)' : h.hour < 12 ? 'Morning (6-12)' : h.hour < 18 ? 'Afternoon (12-18)' : 'Evening (18-24)';
    timeSlots[slot].streams += h.streams;
    timeSlots[slot].viewers += (h.avgViewers * h.streams);
  });
  let timeSlotsHtml = '';
  const slotColors = { 'Morning (6-12)': '#ff9800', 'Afternoon (12-18)': '#fdd835', 'Evening (18-24)': '#9146ff', 'Night (0-6)': '#2196f3' };
  const slotIcons = { 'Morning (6-12)': 'ðŸŒ…', 'Afternoon (12-18)': 'â˜€ï¸', 'Evening (18-24)': 'ðŸŒ†', 'Night (0-6)': 'ðŸŒ™' };
  Object.entries(timeSlots).forEach(([slot, data]) => {
    const avg = data.streams > 0 ? Math.round(data.viewers / data.streams) : 0;
    timeSlotsHtml += '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid ' + slotColors[slot] + '">' +
      '<div style="font-size:24px">' + slotIcons[slot] + '</div>' +
      '<div style="color:#b0b0b0;font-size:11px;margin-top:5px">' + slot + '</div>' +
      '<div style="font-size:20px;color:#fff;font-weight:bold;margin-top:4px">' + avg + '</div>' +
      '<div style="color:#666;font-size:10px">' + data.streams + ' streams</div></div>';
  });

  // Viewership consistency over time (5 segments instead of 3)
  const sorted = h.slice().sort((a, b) => new Date(a.startedAt || a.date) - new Date(b.startedAt || b.date));
  let consistencyHtml = '';
  if (sorted.length >= 5) {
    const segSize = Math.ceil(sorted.length / 5);
    const labels = ['Start', 'Early', 'Mid', 'Late', 'Recent'];
    const colors = ['#666', '#ff9800', '#fdd835', '#8bc34a', '#4caf50'];
    for (let i = 0; i < 5; i++) {
      const seg = sorted.slice(i * segSize, (i + 1) * segSize);
      const avg = seg.length > 0 ? Math.round(seg.reduce((s, x) => s + (x.peakViewers || 0), 0) / seg.length) : 0;
      consistencyHtml += '<div style="flex:1;text-align:center;padding:12px;background:#26262c;border-radius:6px">' +
        '<div style="color:#b0b0b0;font-size:10px">' + labels[i] + '</div>' +
        '<div style="font-size:18px;color:' + colors[i] + ';font-weight:bold;margin-top:4px">' + avg + '</div>' +
        '<div style="font-size:9px;color:#666">' + seg.length + ' str</div></div>';
    }
  } else if (sorted.length >= 3) {
    const thirds = [sorted.slice(0, Math.ceil(sorted.length / 3)), sorted.slice(Math.ceil(sorted.length / 3), Math.ceil(sorted.length * 2 / 3)), sorted.slice(Math.ceil(sorted.length * 2 / 3))];
    const labels = ['Early', 'Mid', 'Recent'];
    thirds.forEach((third, idx) => {
      const avg = third.length > 0 ? Math.round(third.reduce((s, x) => s + (x.peakViewers || 0), 0) / third.length) : 0;
      const color = idx === 2 ? '#4caf50' : idx === 1 ? '#ff9800' : '#666';
      consistencyHtml += '<div style="flex:1;text-align:center;padding:15px;background:#26262c;border-radius:6px">' +
        '<div style="color:#b0b0b0;font-size:11px">' + labels[idx] + ' Period</div>' +
        '<div style="font-size:22px;color:' + color + ';font-weight:bold;margin-top:5px">' + avg + '</div>' +
        '<div style="font-size:10px;color:#666">' + third.length + ' streams</div></div>';
    });
  }

  return `
<div class="card">
  <h2>ðŸ‘€ Viewer Patterns</h2>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px;margin:15px 0">
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-left:3px solid #4caf50">
      <div style="color:#b0b0b0;font-size:11px">Best Time</div>
      <div style="font-size:20px;color:#4caf50;font-weight:bold">${bestHour.label}</div>
      <div style="font-size:11px;color:#666">${bestHour.avgViewers} avg viewers</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-left:3px solid #2196f3">
      <div style="color:#b0b0b0;font-size:11px">2nd Best Time</div>
      <div style="font-size:20px;color:#2196f3;font-weight:bold">${secondBestHour.label}</div>
      <div style="font-size:11px;color:#666">${secondBestHour.avgViewers} avg viewers</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-left:3px solid #ef5350">
      <div style="color:#b0b0b0;font-size:11px">Avoid Time</div>
      <div style="font-size:20px;color:#ef5350;font-weight:bold">${worstHour.label}</div>
      <div style="font-size:11px;color:#666">${worstHour.avgViewers} avg viewers</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-left:3px solid #ff9800">
      <div style="color:#b0b0b0;font-size:11px">Retention Rate</div>
      <div style="font-size:20px;color:#ff9800;font-weight:bold">${avgViewerRatio}%</div>
      <div style="font-size:11px;color:#666">avg/peak ratio</div>
    </div>
    <div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-left:3px solid #9146ff">
      <div style="color:#b0b0b0;font-size:11px">Optimal Length</div>
      <div style="font-size:20px;color:#9146ff;font-weight:bold">${optimalLengthLabel}</div>
      <div style="font-size:11px;color:#666">${optimalLengthAvg} avg viewers</div>
    </div>
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ• Hourly Heatmap</h3>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(55px,1fr));gap:4px;margin-top:10px">
    ${heatmapHtml}
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“… Day x Hour Matrix</h3>
  <p style="color:#666;font-size:11px;margin-bottom:10px">Average viewers per time slot - brighter = more viewers</p>
  ${gridHtml}
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ•°ï¸ Time of Day Performance</h3>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px;margin-top:10px">
    ${timeSlotsHtml}
  </div>
</div>

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸŒ Seasonal Performance</h3>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px;margin-top:10px">
    ${seasonalHtml}
  </div>
</div>

${consistencyHtml ? `
<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“Š Viewer Growth Over Time</h3>
  <p style="color:#666;font-size:11px;margin-bottom:10px">Comparing viewer averages across stream history segments</p>
  <div style="display:flex;gap:10px">
    ${consistencyHtml}
  </div>
</div>` : ''}

${(function() {
  var hm = activityHeatmap || {};
  var keys = Object.keys(hm);
  if (keys.length < 5) return '';
  
  // Build a calendar-style heatmap
  // Group by date, then by hour
  var dates = {};
  keys.forEach(function(k) {
    var parts = k.split('_');
    var date = parts[0];
    var hour = parseInt(parts[1]);
    if (!dates[date]) dates[date] = {};
    var values = hm[k];
    var avg = Array.isArray(values) && values.length > 0 ? Math.round(values.reduce(function(a, b) { return a + b; }, 0) / values.length) : 0;
    dates[date][hour] = avg;
  });
  
  var sortedDates = Object.keys(dates).sort();
  var allAvgs = [];
  keys.forEach(function(k) {
    var values = hm[k];
    if (Array.isArray(values) && values.length > 0) {
      allAvgs.push(Math.round(values.reduce(function(a, b) { return a + b; }, 0) / values.length));
    }
  });
  var maxAvg = Math.max.apply(null, allAvgs.concat([1]));
  
  // Build grid: rows = dates, columns = hours (only show hours with data: roughly 14-23, 0-1)
  var activeHours = [];
  for (var ah = 0; ah < 24; ah++) {
    var hasData = keys.some(function(k) { return parseInt(k.split('_')[1]) === ah; });
    if (hasData) activeHours.push(ah);
  }
  
  var gridHtml = '<div style="overflow-x:auto"><table style="border-collapse:collapse;width:100%">';
  gridHtml += '<thead><tr><th style="padding:4px 8px;font-size:10px;color:#666;text-align:left">Date</th>';
  activeHours.forEach(function(hr) {
    var label = hr > 12 ? (hr - 12) + 'p' : hr === 0 ? '12a' : hr + 'a';
    gridHtml += '<th style="padding:4px;font-size:9px;color:#666;text-align:center">' + label + '</th>';
  });
  gridHtml += '</tr></thead><tbody>';
  
  sortedDates.slice(-20).forEach(function(date) {
    var day = new Date(date + 'T12:00:00Z');
    var dayLabel = day.toLocaleDateString('en-US', { month: 'short', day: 'numeric', weekday: 'short' });
    gridHtml += '<tr><td style="padding:3px 8px;font-size:10px;color:#b0b0b0;white-space:nowrap">' + dayLabel + '</td>';
    activeHours.forEach(function(hr) {
      var val = dates[date] && dates[date][hr] !== undefined ? dates[date][hr] : -1;
      var bg, txt;
      if (val < 0) {
        bg = '#1a1a2e'; txt = '';
      } else {
        var intensity = Math.round((val / maxAvg) * 100);
        if (intensity >= 80) { bg = '#9146ff'; txt = val; }
        else if (intensity >= 60) { bg = '#7b3fd4'; txt = val; }
        else if (intensity >= 40) { bg = '#5c2fa0'; txt = val; }
        else if (intensity >= 20) { bg = '#3d1f6d'; txt = val; }
        else { bg = '#2a1540'; txt = val; }
      }
      gridHtml += '<td style="padding:2px;text-align:center;background:' + bg + ';border:1px solid #111;min-width:28px"><span style="font-size:9px;color:#fff;font-weight:bold">' + txt + '</span></td>';
    });
    gridHtml += '</tr>';
  });
  gridHtml += '</tbody></table></div>';
  
  // Summary stats
  var totalHoursTracked = keys.length;
  var trackDays = sortedDates.length;
  var peakEntry = keys.reduce(function(best, k) {
    var values = hm[k];
    var avg = Array.isArray(values) && values.length > 0 ? Math.round(values.reduce(function(a, b) { return a + b; }, 0) / values.length) : 0;
    return avg > best.avg ? { key: k, avg: avg } : best;
  }, { key: '', avg: 0 });
  var peakDate = peakEntry.key.split('_')[0] || '';
  var peakHour = parseInt(peakEntry.key.split('_')[1] || '0');
  var peakHourLabel = peakHour > 12 ? (peakHour - 12) + ':00 PM' : peakHour === 0 ? '12:00 AM' : peakHour + ':00 AM';
  
  return '<div class="card" style="margin-top:15px">' +
    '<h3 style="margin-top:0">ðŸ—“ï¸ Activity Heatmap (Real Viewer Data)</h3>' +
    '<p style="color:#666;font-size:11px;margin-bottom:10px">Average viewers per hour slot from ' + trackDays + ' streaming days (' + totalHoursTracked + ' hourly snapshots). Brighter = more viewers.</p>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px;margin-bottom:12px">' +
      '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Days Tracked</div><div style="font-size:18px;color:#9146ff;font-weight:bold">' + trackDays + '</div></div>' +
      '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Hour Snapshots</div><div style="font-size:18px;color:#2196f3;font-weight:bold">' + totalHoursTracked + '</div></div>' +
      '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Peak Hour</div><div style="font-size:14px;color:#ffd700;font-weight:bold">' + peakDate + ' ' + peakHourLabel + '</div><div style="font-size:10px;color:#666">' + peakEntry.avg + ' avg viewers</div></div>' +
    '</div>' +
    gridHtml +
    '<div style="display:flex;gap:6px;align-items:center;margin-top:8px;justify-content:flex-end">' +
      '<span style="font-size:10px;color:#666">Low</span>' +
      '<div style="width:16px;height:12px;background:#2a1540;border-radius:2px"></div>' +
      '<div style="width:16px;height:12px;background:#3d1f6d;border-radius:2px"></div>' +
      '<div style="width:16px;height:12px;background:#5c2fa0;border-radius:2px"></div>' +
      '<div style="width:16px;height:12px;background:#7b3fd4;border-radius:2px"></div>' +
      '<div style="width:16px;height:12px;background:#9146ff;border-radius:2px"></div>' +
      '<span style="font-size:10px;color:#666">High</span>' +
    '</div>' +
  '</div>';
})()}

<div class="card" style="margin-top:15px">
  <h3 style="margin-top:0">ðŸ“Š Avg Viewers by Hour & Radar</h3>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">
    <div style="height:220px"><canvas id="hourly-viewers-chart"></canvas></div>
    <div style="height:220px"><canvas id="hourly-radar-chart"></canvas></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
  var hourlyData = ${JSON.stringify(hours.filter(h => h.streams > 0).map(h => ({
    label: h.label,
    avgViewers: h.avgViewers,
    streams: h.streams,
    avgDuration: h.avgDuration
  })))};

  var hctx = document.getElementById('hourly-viewers-chart');
  if (hctx && hourlyData.length > 0) {
    new Chart(hctx, {
      type: 'bar',
      data: {
        labels: hourlyData.map(function(d) { return d.label; }),
        datasets: [{
          label: 'Avg Viewers',
          data: hourlyData.map(function(d) { return d.avgViewers; }),
          backgroundColor: hourlyData.map(function(d) {
            var ratio = d.avgViewers / Math.max.apply(null, hourlyData.map(function(x) { return x.avgViewers; }));
            return 'rgba(145, 70, 255, ' + (0.3 + ratio * 0.7) + ')';
          }),
          borderColor: '#9146ff',
          borderWidth: 1,
          borderRadius: 4
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: { callbacks: { afterLabel: function(ctx) { var d = hourlyData[ctx.dataIndex]; return d.streams + ' streams | ~' + d.avgDuration + 'min avg'; } } }
        },
        scales: {
          y: { beginAtZero: true, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#8b8fa3' } },
          x: { grid: { display: false }, ticks: { color: '#8b8fa3', font: { size: 9 } } }
        }
      }
    });
  }

  var rctx = document.getElementById('hourly-radar-chart');
  if (rctx && hourlyData.length >= 3) {
    new Chart(rctx, {
      type: 'radar',
      data: {
        labels: hourlyData.map(function(d) { return d.label; }),
        datasets: [{
          label: 'Avg Viewers',
          data: hourlyData.map(function(d) { return d.avgViewers; }),
          borderColor: '#9146ff',
          backgroundColor: 'rgba(145,70,255,0.2)',
          pointBackgroundColor: '#9146ff',
          pointBorderColor: '#fff',
          pointBorderWidth: 1,
          pointRadius: 3,
          borderWidth: 2
        },
        {
          label: 'Stream Count',
          data: hourlyData.map(function(d) { return d.streams; }),
          borderColor: '#4caf50',
          backgroundColor: 'rgba(76,175,80,0.1)',
          pointBackgroundColor: '#4caf50',
          pointBorderColor: '#fff',
          pointBorderWidth: 1,
          pointRadius: 2,
          borderWidth: 2,
          borderDash: [4, 4]
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: true, labels: { color: '#8b8fa3', usePointStyle: true, font: { size: 10 } } } },
        scales: {
          r: {
            angleLines: { color: 'rgba(255,255,255,0.1)' },
            grid: { color: 'rgba(255,255,255,0.08)' },
            pointLabels: { color: '#8b8fa3', font: { size: 9 } },
            ticks: { color: '#666', backdropColor: 'transparent' },
            beginAtZero: true
          }
        }
      }
    });
  }
});
</script>
  `;
}

// NEW: AI Insights Tab
function renderAIInsightsTab() {
  const h = history || [];
  if (h.length === 0) {
    return '<div class="card"><h2>ðŸ¤– AI Insights</h2><p style="color:#b0b0b0">Stream some content first to see AI insights!</p></div>';
  }

  const recent5 = h.slice(-Math.min(5, h.length));
  const recent5Avg = Math.round(recent5.reduce((sum, s) => sum + (s.peakViewers || 0), 0) / recent5.length);
  const older5 = h.length > 5 ? h.slice(-10, -5) : [];
  const older5Avg = older5.length > 0 ? Math.round(older5.reduce((sum, s) => sum + (s.peakViewers || 0), 0) / older5.length) : recent5Avg;

  const momentum = recent5Avg > older5Avg ? 'ðŸ“ˆ Growing' : recent5Avg < older5Avg ? 'ðŸ“‰ Declining' : 'âž¡ï¸ Stable';
  const momentumPct = older5Avg > 0 ? (((recent5Avg - older5Avg) / older5Avg) * 100).toFixed(1) : '0.0';

  // Game analysis (avg peak per game)
  const topGameData = {};
  h.forEach(s => {
    const game = s.game || s.gameName || 'Unknown';
    if (!topGameData[game]) topGameData[game] = { total: 0, count: 0, maxPeak: 0 };
    topGameData[game].total += (s.peakViewers || 0);
    topGameData[game].count++;
    topGameData[game].maxPeak = Math.max(topGameData[game].maxPeak, s.peakViewers || 0);
  });
  const bestGame = Object.entries(topGameData).map(([g, d]) => [g, Math.round(d.total / d.count), d.maxPeak]).sort((a, b) => b[1] - a[1])[0];
  const worstGame = Object.entries(topGameData).map(([g, d]) => [g, Math.round(d.total / d.count)]).sort((a, b) => a[1] - b[1])[0];

  // Best stream time analysis
  const hourBuckets = {};
  h.forEach(s => {
    const hr = new Date(s.startedAt || s.date).getHours();
    if (!hourBuckets[hr]) hourBuckets[hr] = { total: 0, count: 0 };
    hourBuckets[hr].total += (s.peakViewers || 0);
    hourBuckets[hr].count++;
  });
  const bestHourEntry = Object.entries(hourBuckets).sort((a, b) => (b[1].total / b[1].count) - (a[1].total / a[1].count))[0];
  const bestHour = bestHourEntry ? parseInt(bestHourEntry[0]) : 20;
  const bestHourAvg = bestHourEntry ? Math.round(bestHourEntry[1].total / bestHourEntry[1].count) : 0;
  const bestHourLabel = bestHour.toString().padStart(2, '0') + ':00';

  // Duration vs viewership correlation
  const withDuration = h.filter(s => s.durationMinutes > 0);
  let durationCorrelation = 'No data';
  if (withDuration.length >= 3) {
    const shortStreams = withDuration.filter(s => s.durationMinutes < 120);
    const longStreams = withDuration.filter(s => s.durationMinutes >= 120);
    const shortAvg = shortStreams.length > 0 ? Math.round(shortStreams.reduce((s, x) => s + (x.peakViewers || 0), 0) / shortStreams.length) : 0;
    const longAvg = longStreams.length > 0 ? Math.round(longStreams.reduce((s, x) => s + (x.peakViewers || 0), 0) / longStreams.length) : 0;
    durationCorrelation = longAvg > shortAvg ? 'Longer streams perform better (avg ' + longAvg + ' vs ' + shortAvg + ')' :
                          shortAvg > longAvg ? 'Shorter streams perform better (avg ' + shortAvg + ' vs ' + longAvg + ')' :
                          'Stream length has no notable impact';
  }

  // Consistency score
  const viewers = h.map(s => s.peakViewers || 0);
  const mean = viewers.reduce((a, b) => a + b, 0) / viewers.length;
  const std = Math.sqrt(viewers.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / viewers.length);
  const cv = mean > 0 ? (std / mean) : 0;
  const consistencyLabel = cv < 0.2 ? 'ðŸŸ¢ Very Consistent' : cv < 0.4 ? 'ðŸŸ¡ Moderate' : cv < 0.6 ? 'ðŸŸ  Variable' : 'ðŸ”´ Highly Variable';

  // Predicted next stream viewers (simple linear regression on last 10)
  const last10 = h.slice(-Math.min(10, h.length));
  let predictedViewers = mean;
  let predSlope = 0;
  if (last10.length >= 3) {
    const xMean = (last10.length - 1) / 2;
    const yMean = last10.reduce((s, x) => s + (x.peakViewers || 0), 0) / last10.length;
    let num = 0, den = 0;
    last10.forEach((s, i) => { num += (i - xMean) * ((s.peakViewers || 0) - yMean); den += Math.pow(i - xMean, 2); });
    predSlope = den > 0 ? num / den : 0;
    predictedViewers = Math.max(0, Math.round(yMean + predSlope * last10.length));
  }

  // Prediction confidence interval
  const predResiduals = last10.map((s, i) => {
    const yMean2 = last10.reduce((sm, x) => sm + (x.peakViewers || 0), 0) / last10.length;
    const predicted = yMean2 + predSlope * (i - (last10.length - 1) / 2);
    return Math.pow((s.peakViewers || 0) - predicted, 2);
  });
  const predStdErr = Math.sqrt(predResiduals.reduce((a, b) => a + b, 0) / Math.max(1, predResiduals.length - 2));
  const predLow = Math.max(0, Math.round(predictedViewers - 1.96 * predStdErr));
  const predHigh = Math.round(predictedViewers + 1.96 * predStdErr);

  // Day of week recommendation
  const dowStats = {};
  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  h.forEach(s => {
    const dow = new Date(s.startedAt || s.date).getDay();
    if (!dowStats[dow]) dowStats[dow] = { total: 0, count: 0 };
    dowStats[dow].total += (s.peakViewers || 0);
    dowStats[dow].count++;
  });
  const bestDow = Object.entries(dowStats).sort((a, b) => (b[1].total / b[1].count) - (a[1].total / a[1].count))[0];
  const bestDayName = bestDow ? dayNames[parseInt(bestDow[0])] : 'N/A';
  const bestDayAvg = bestDow ? Math.round(bestDow[1].total / bestDow[1].count) : 0;

  // Stream health score (weighted composite)
  const healthGrowth = parseFloat(momentumPct) > 0 ? 25 : parseFloat(momentumPct) > -10 ? 15 : 5;
  const healthConsistency = cv < 0.3 ? 25 : cv < 0.5 ? 15 : 5;
  const healthActivity = h.length >= 20 ? 25 : h.length >= 10 ? 15 : 5;
  const healthEngagement = mean > 50 ? 25 : mean > 20 ? 15 : 5;
  const healthScore = healthGrowth + healthConsistency + healthActivity + healthEngagement;
  const healthLabel = healthScore >= 80 ? 'ðŸŒŸ Excellent' : healthScore >= 60 ? 'âœ… Good' : healthScore >= 40 ? 'âš ï¸ Fair' : 'ðŸ”» Needs Work';
  const healthColor = healthScore >= 80 ? '#4caf50' : healthScore >= 60 ? '#8bc34a' : healthScore >= 40 ? '#ff9800' : '#ef5350';

  // --- NEW: Burnout Risk Assessment ---
  const gaps = [];
  for (let i = 0; i < h.length - 1; i++) {
    const d1 = new Date(h[i].startedAt || h[i].date).getTime();
    const d2 = new Date(h[i + 1].startedAt || h[i + 1].date).getTime();
    gaps.push(Math.abs(d1 - d2) / (1000 * 60 * 60 * 24));
  }
  const avgGap = gaps.length > 0 ? gaps.reduce((a, b) => a + b, 0) / gaps.length : 0;
  const recentGaps = gaps.slice(-Math.min(3, gaps.length));
  const recentAvgGap = recentGaps.length > 0 ? recentGaps.reduce((a, b) => a + b, 0) / recentGaps.length : 0;
  const recentDurations = h.slice(-Math.min(5, h.length)).map(s => s.durationMinutes || 0);
  const recentAvgDur = recentDurations.length > 0 ? recentDurations.reduce((a, b) => a + b, 0) / recentDurations.length : 0;
  const olderDurations = h.length > 5 ? h.slice(-10, -5).map(s => s.durationMinutes || 0) : [];
  const olderAvgDur = olderDurations.length > 0 ? olderDurations.reduce((a, b) => a + b, 0) / olderDurations.length : recentAvgDur;
  let burnoutScore = 0;
  if (recentAvgGap > avgGap * 1.5 && avgGap > 0) burnoutScore += 30; // streaming less frequently
  if (recentAvgDur < olderAvgDur * 0.8 && olderAvgDur > 0) burnoutScore += 25; // shorter streams
  if (parseFloat(momentumPct) < -15) burnoutScore += 25; // declining viewers
  if (recentAvgGap > 7) burnoutScore += 20; // big gaps
  burnoutScore = Math.min(100, burnoutScore);
  const burnoutLabel = burnoutScore >= 70 ? 'ðŸ”´ High Risk' : burnoutScore >= 40 ? 'ðŸŸ  Moderate' : burnoutScore >= 15 ? 'ðŸŸ¡ Low' : 'ðŸŸ¢ Healthy';
  const burnoutColor = burnoutScore >= 70 ? '#ef5350' : burnoutScore >= 40 ? '#ff9800' : burnoutScore >= 15 ? '#ffd700' : '#4caf50';

  // --- NEW: Schedule Adherence Score ---
  const streamDows = h.map(s => new Date(s.startedAt || s.date).getDay());
  const dowFreq = {};
  streamDows.forEach(d => { dowFreq[d] = (dowFreq[d] || 0) + 1; });
  const maxDowCount = Math.max(...Object.values(dowFreq), 1);
  const scheduleDays = Object.keys(dowFreq).filter(d => dowFreq[d] >= maxDowCount * 0.5).length;
  const scheduleAdherence = h.length >= 4 ? Math.min(100, Math.round((scheduleDays <= 3 ? 80 : 50) + (gaps.length > 0 ? Math.max(0, 20 - (Math.sqrt(gaps.reduce((s, g) => s + Math.pow(g - avgGap, 2), 0) / Math.max(1, gaps.length)) * 3)) : 0))) : 0;
  const scheduleLabel = scheduleAdherence >= 80 ? 'ðŸŸ¢ Very Regular' : scheduleAdherence >= 60 ? 'ðŸŸ¡ Somewhat Regular' : scheduleAdherence >= 40 ? 'ðŸŸ  Irregular' : 'ðŸ”´ No Pattern';

  // --- NEW: Content Freshness Score ---
  const gamesByRecency = {};
  h.forEach((s, i) => {
    const game = s.game || s.gameName || 'Unknown';
    if (!(game in gamesByRecency)) gamesByRecency[game] = i;
  });
  const uniqueGameCount = Object.keys(gamesByRecency).length;
  const recentGames = Object.values(gamesByRecency).filter(i => i < 10).length;
  const freshnessScore = Math.min(100, Math.round((uniqueGameCount / Math.max(1, h.length)) * 200 + recentGames * 10));
  const freshnessLabel = freshnessScore >= 80 ? 'ðŸŒˆ Very Fresh' : freshnessScore >= 50 ? 'ðŸŽ¨ Moderate' : freshnessScore >= 25 ? 'ðŸ”„ Getting Stale' : 'âš ï¸ Repetitive';

  // --- NEW: Audience Loyalty Estimate ---
  const avgViewersList = h.map(s => s.averageViewers || s.peakViewers || 0);
  const peakViewersList = h.map(s => s.peakViewers || 0);
  const avgRetention = peakViewersList.reduce((s, p, i) => s + (p > 0 ? (avgViewersList[i] / p) : 0), 0) / Math.max(1, h.length);
  const loyaltyScore = Math.min(100, Math.round(avgRetention * 100));
  const loyaltyLabel = loyaltyScore >= 80 ? 'ðŸ’Ž Die-hard Fans' : loyaltyScore >= 60 ? 'â¤ï¸ Loyal' : loyaltyScore >= 40 ? 'ðŸ‘‹ Casual' : 'ðŸš¶ Low Retention';

  // --- NEW: Milestone Projections ---
  const totalViewersSoFar = h.reduce((s, x) => s + (x.peakViewers || 0), 0);
  const avgViewersPerStream = totalViewersSoFar / Math.max(1, h.length);
  const milestonesArr = [100, 500, 1000, 5000, 10000, 50000].filter(m => m > totalViewersSoFar);
  let milestonesHtml = '';
  milestonesArr.slice(0, 4).forEach(m => {
    const streamsNeeded = Math.ceil((m - totalViewersSoFar) / Math.max(1, avgViewersPerStream));
    const daysNeeded = Math.ceil(streamsNeeded * Math.max(1, avgGap));
    milestonesHtml += '<div style="display:flex;justify-content:space-between;align-items:center;padding:10px 15px;background:#26262c;border-radius:6px;margin-bottom:8px">' +
      '<span style="color:#fff;font-weight:bold">' + m.toLocaleString() + ' total peak viewers</span>' +
      '<span style="color:#b0b0b0;font-size:12px">~' + streamsNeeded + ' streams (~' + daysNeeded + ' days)</span></div>';
  });

  // --- NEW: Anomaly Detection ---
  const anomalies = [];
  const upperThresh = mean + 2 * std;
  const lowerThresh = Math.max(0, mean - 2 * std);
  h.forEach(s => {
    const v = s.peakViewers || 0;
    const date = new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const game = s.game || s.gameName || 'Unknown';
    if (v > upperThresh) anomalies.push({ type: 'spike', date: date, game: game, viewers: v, deviation: ((v - mean) / Math.max(1, std)).toFixed(1) });
    else if (v < lowerThresh && std > 0) anomalies.push({ type: 'dip', date: date, game: game, viewers: v, deviation: ((mean - v) / Math.max(1, std)).toFixed(1) });
  });
  let anomalyHtml = '';
  anomalies.slice(0, 6).forEach(a => {
    const color = a.type === 'spike' ? '#4caf50' : '#ef5350';
    const icon = a.type === 'spike' ? 'ðŸ“ˆ' : 'ðŸ“‰';
    anomalyHtml += '<div style="display:flex;justify-content:space-between;align-items:center;padding:10px 15px;background:#26262c;border-radius:6px;margin-bottom:8px;border-left:3px solid ' + color + '">' +
      '<div><span style="font-size:14px">' + icon + '</span> <span style="color:#fff">' + a.date + '</span> <span style="color:#b0b0b0;font-size:12px">(' + a.game + ')</span></div>' +
      '<div><span style="color:' + color + ';font-weight:bold">' + a.viewers + '</span> <span style="color:#666;font-size:11px">' + a.deviation + ' sigma</span></div></div>';
  });

  // --- NEW: Fatigue Analysis ---
  const durBuckets = { short: [], medium: [], long: [], veryLong: [] };
  withDuration.forEach(s => {
    const dur = s.durationMinutes || 0;
    const ratio = (s.averageViewers || s.peakViewers || 0) / Math.max(1, s.peakViewers || 1);
    if (dur < 60) durBuckets.short.push(ratio);
    else if (dur < 180) durBuckets.medium.push(ratio);
    else if (dur < 300) durBuckets.long.push(ratio);
    else durBuckets.veryLong.push(ratio);
  });
  const fatigueData = {};
  Object.entries(durBuckets).forEach(([k, arr]) => {
    fatigueData[k] = arr.length > 0 ? (arr.reduce((a, b) => a + b, 0) / arr.length * 100).toFixed(0) : null;
  });
  const fatiguLabels = { short: 'Under 1h', medium: '1-3h', long: '3-5h', veryLong: '5h+' };
  let fatigueHtml = '';
  Object.entries(fatigueData).forEach(([k, v]) => {
    if (v !== null) {
      const barColor = parseInt(v) >= 70 ? '#4caf50' : parseInt(v) >= 50 ? '#ff9800' : '#ef5350';
      fatigueHtml += '<div style="display:flex;align-items:center;gap:10px;margin-bottom:8px">' +
        '<span style="color:#b0b0b0;width:80px;font-size:12px">' + fatiguLabels[k] + '</span>' +
        '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:18px;overflow:hidden"><div style="background:' + barColor + ';height:100%;width:' + v + '%;border-radius:3px"></div></div>' +
        '<span style="color:#fff;font-size:12px;min-width:40px;text-align:right">' + v + '%</span></div>';
    }
  });

  // --- NEW: Stream DNA Profile ---
  const totalHours = h.reduce((s, x) => s + ((x.durationMinutes || 0) / 60), 0);
  const avgDurMins = h.length > 0 ? h.reduce((s, x) => s + (x.durationMinutes || 0), 0) / h.length : 0;
  const dnaVariety = uniqueGameCount >= 5 ? 'Explorer' : uniqueGameCount >= 3 ? 'Versatile' : 'Specialist';
  const dnaSchedule = scheduleAdherence >= 70 ? 'Clockwork' : scheduleAdherence >= 40 ? 'Flexible' : 'Spontaneous';
  const dnaLength = avgDurMins >= 240 ? 'Marathon' : avgDurMins >= 120 ? 'Standard' : 'Sprint';
  const dnaGrowth = parseFloat(momentumPct) > 10 ? 'Rising Star' : parseFloat(momentumPct) > 0 ? 'Steady Climber' : parseFloat(momentumPct) > -10 ? 'Plateau' : 'Rebuilding';

  // --- NEW: Comparative Percentile Analysis ---
  const sortedViewers = [...viewers].sort((a, b) => a - b);
  const p10 = sortedViewers[Math.floor(sortedViewers.length * 0.1)] || 0;
  const p25 = sortedViewers[Math.floor(sortedViewers.length * 0.25)] || 0;
  const p50 = sortedViewers[Math.floor(sortedViewers.length * 0.5)] || 0;
  const p75 = sortedViewers[Math.floor(sortedViewers.length * 0.75)] || 0;
  const p90 = sortedViewers[Math.floor(sortedViewers.length * 0.9)] || 0;

  // --- NEW: Week-over-week trend for last 4 weeks ---
  const now = Date.now();
  const weekData = [0, 1, 2, 3].map(w => {
    const weekStart = now - (w + 1) * 7 * 24 * 60 * 60 * 1000;
    const weekEnd = now - w * 7 * 24 * 60 * 60 * 1000;
    const weekStreams = h.filter(s => {
      const t = new Date(s.startedAt || s.date).getTime();
      return t >= weekStart && t < weekEnd;
    });
    return {
      streams: weekStreams.length,
      avgViewers: weekStreams.length > 0 ? Math.round(weekStreams.reduce((s, x) => s + (x.peakViewers || 0), 0) / weekStreams.length) : 0,
      totalHours: weekStreams.reduce((s, x) => s + ((x.durationMinutes || 0) / 60), 0).toFixed(1)
    };
  });
  let weekTrendHtml = '';
  const weekLabels = ['This Week', '1 Week Ago', '2 Weeks Ago', '3 Weeks Ago'];
  weekData.forEach((w, i) => {
    const prevW = weekData[Math.min(i + 1, weekData.length - 1)];
    const changeIcon = w.avgViewers > prevW.avgViewers ? 'ðŸŸ¢' : w.avgViewers < prevW.avgViewers ? 'ðŸ”´' : 'âšª';
    weekTrendHtml += '<tr style="transition:background 0.2s" onmouseenter="this.style.background=\'#2a2f3a\'" onmouseleave="this.style.background=\'transparent\'">' +
      '<td style="padding:8px 12px;border-bottom:1px solid #2a2f3a;color:#b0b0b0;font-size:12px">' + weekLabels[i] + '</td>' +
      '<td style="padding:8px 12px;border-bottom:1px solid #2a2f3a;color:#fff;text-align:center">' + w.streams + '</td>' +
      '<td style="padding:8px 12px;border-bottom:1px solid #2a2f3a;color:#9146ff;font-weight:bold;text-align:center">' + w.avgViewers + '</td>' +
      '<td style="padding:8px 12px;border-bottom:1px solid #2a2f3a;color:#b0b0b0;text-align:center">' + w.totalHours + 'h</td>' +
      '<td style="padding:8px 12px;border-bottom:1px solid #2a2f3a;text-align:center">' + changeIcon + '</td></tr>';
  });

  // Build dynamic suggestions
  const aiSuggestions = [];
  if (parseFloat(momentumPct) < 0) aiSuggestions.push('Your viewership is declining. Try experimenting with new content or streaming times.');
  if (cv > 0.5) aiSuggestions.push('Your viewer count varies a lot. Consistent scheduling can stabilize your audience.');
  if (bestGame && worstGame && bestGame[0] !== worstGame[0]) aiSuggestions.push('Focus more on <strong>' + bestGame[0] + '</strong> â€” it outperforms other games by ' + Math.round(((bestGame[1] - worstGame[1]) / (worstGame[1] || 1)) * 100) + '%.');
  if (withDuration.length > 0) aiSuggestions.push(durationCorrelation + '.');
  aiSuggestions.push('Your best streaming time is <strong>' + bestHourLabel + '</strong> on <strong>' + bestDayName + '</strong>.');
  if (h.length < 10) aiSuggestions.push('Stream more to unlock better insights! You have only ' + h.length + ' sessions recorded.');
  if (burnoutScore >= 40) aiSuggestions.push('Burnout risk detected! Consider taking a planned break or doing shorter, more fun streams.');
  if (freshnessScore < 30) aiSuggestions.push('Your content is getting repetitive. Mixing in a new game could re-engage viewers.');
  if (loyaltyScore < 50) aiSuggestions.push('Audience retention is low. Engage with chat more and create moments that keep viewers watching.');
  if (scheduleAdherence < 40) aiSuggestions.push('No clear schedule pattern detected. Setting a regular schedule helps viewers know when to tune in.');

  let suggestionsHtml = '';
  const sugIcons = ['ðŸ’¡', 'ðŸŽ¯', 'ðŸ“Š', 'â°', 'ðŸ”‘', 'ðŸš€', 'ðŸ”¥', 'ðŸŽ¨', 'ðŸ’¬', 'ðŸ“…'];
  const sugColors = ['#9146ff', '#4caf50', '#ff9800', '#2196f3', '#e91e63', '#00bcd4', '#ff5722', '#8bc34a', '#ab47bc', '#009688'];
  aiSuggestions.forEach((s, i) => {
    suggestionsHtml += '<div style="background:#26262c;padding:15px;border-radius:6px;border-left:3px solid ' + sugColors[i % sugColors.length] + '">' +
      '<div style="color:#fff;font-size:13px">' + sugIcons[i % sugIcons.length] + ' ' + s + '</div></div>';
  });

  // --- NEW: Effort / Outcome / ROI Scores ---
  const aiTotalHours = h.reduce((s, x) => s + ((x.durationMinutes || 0) / 60), 0);
  const aiAvgDuration = h.length > 0 ? h.reduce((s, x) => s + (x.durationMinutes || 0), 0) / h.length : 0;
  const consistencyPenalty = 1 + (cv * 0.5); // higher variance = higher effort cost
  const effortScore = Math.min(100, Math.round((aiAvgDuration / 60) * 15 * consistencyPenalty));
  const peakWeight = 0.4, followWeight = 0.3, retentionWeight = 0.3;
  const normPeak = Math.min(100, Math.round((mean / Math.max(1, Math.max(...viewers))) * 100));
  const avgFollows = h.length > 0 ? h.reduce((s, x) => s + (x.followers || x.newFollowers || 0), 0) / h.length : 0;
  const normFollows = Math.min(100, Math.round(avgFollows * 10));
  const normRetention = loyaltyScore;
  const outcomeScore = Math.round(normPeak * peakWeight + normFollows * followWeight + normRetention * retentionWeight);
  const roiRaw = effortScore > 0 ? (outcomeScore / effortScore) : 0;
  const roiRating = roiRaw >= 1.5 ? 'ðŸŒŸ Excellent' : roiRaw >= 1.0 ? 'âœ… Good' : roiRaw >= 0.7 ? 'âš ï¸ Average' : 'ðŸ”» Low';
  const roiColor = roiRaw >= 1.5 ? '#4caf50' : roiRaw >= 1.0 ? '#8bc34a' : roiRaw >= 0.7 ? '#ff9800' : '#ef5350';

  // --- NEW: Stream Warnings ---
  const streamWarnings = [];
  // Viewer Drop After X Minutes
  const vgh = viewerGraphHistory || [];
  vgh.slice(-5).forEach(function(stream) {
    if (!stream.data || stream.data.length < 20) return;
    var pts = stream.data;
    var peak = 0, peakIdx = 0;
    pts.forEach(function(p, i) { if ((p.viewers || 0) > peak) { peak = p.viewers; peakIdx = i; } });
    if (peakIdx < pts.length - 5) {
      var afterPeak = pts.slice(peakIdx, Math.min(peakIdx + 20, pts.length));
      var dropPct = afterPeak.length > 1 ? ((peak - (afterPeak[afterPeak.length - 1].viewers || 0)) / Math.max(1, peak) * 100) : 0;
      if (dropPct > 30) {
        var minMark = Math.round((peakIdx / pts.length) * ((stream.durationMinutes || 0) || pts.length));
        streamWarnings.push({ icon: 'ðŸ“‰', label: 'Viewer Drop', detail: Math.round(dropPct) + '% drop after ~' + minMark + ' min (peak: ' + peak + ')', color: '#ef5350' });
      }
    }
  });
  // Underperforming Game Warning
  const overallAvgPeak = mean;
  Object.entries(topGameData).forEach(function(entry) {
    var g = entry[0], d = entry[1];
    var gAvg = d.total / d.count;
    if (gAvg < overallAvgPeak * 0.7 && d.count >= 2) {
      streamWarnings.push({ icon: 'ðŸŽ®', label: 'Underperforming Game', detail: g + ' averages ' + Math.round(gAvg) + ' viewers (' + Math.round((1 - gAvg / overallAvgPeak) * 100) + '% below average)', color: '#ff9800' });
    }
  });
  // Late-Night Performance Penalty
  const lateStreams = h.filter(function(s) { var hr = new Date(s.startedAt || s.date).getHours(); return hr >= 23 || hr < 5; });
  const otherStreams = h.filter(function(s) { var hr = new Date(s.startedAt || s.date).getHours(); return hr >= 5 && hr < 23; });
  if (lateStreams.length >= 2 && otherStreams.length >= 2) {
    var lateAvg = Math.round(lateStreams.reduce(function(s, x) { return s + (x.peakViewers || 0); }, 0) / lateStreams.length);
    var otherAvg = Math.round(otherStreams.reduce(function(s, x) { return s + (x.peakViewers || 0); }, 0) / otherStreams.length);
    if (lateAvg < otherAvg * 0.8) {
      streamWarnings.push({ icon: 'ðŸ˜´', label: 'Late-Night Penalty', detail: 'Late streams avg ' + lateAvg + ' vs ' + otherAvg + ' peak viewers (-' + Math.round((1 - lateAvg / otherAvg) * 100) + '%)', color: '#ab47bc' });
    }
  }
  // Repeated Title Word Fatigue
  const titleWordViewers = {};
  h.forEach(function(s) {
    if (!s.title) return;
    var words = s.title.split(/[\s|,!.?]+/).map(function(w) { return w.toLowerCase().trim(); }).filter(function(w) { return w.length > 3; });
    words.forEach(function(w) {
      if (!titleWordViewers[w]) titleWordViewers[w] = [];
      titleWordViewers[w].push(s.peakViewers || 0);
    });
  });
  Object.entries(titleWordViewers).forEach(function(entry) {
    var w = entry[0], arr = entry[1];
    if (arr.length >= 4) {
      var firstHalf = arr.slice(0, Math.floor(arr.length / 2));
      var secondHalf = arr.slice(Math.floor(arr.length / 2));
      var firstAvg = firstHalf.reduce(function(a, b) { return a + b; }, 0) / firstHalf.length;
      var secondAvg2 = secondHalf.reduce(function(a, b) { return a + b; }, 0) / secondHalf.length;
      if (secondAvg2 < firstAvg * 0.75 && firstAvg > 0) {
        streamWarnings.push({ icon: 'ðŸ”', label: 'Title Word Fatigue', detail: '"' + w + '" used ' + arr.length + 'x â€” viewers declining (' + Math.round(firstAvg) + ' â†’ ' + Math.round(secondAvg2) + ')', color: '#ff5722' });
      }
    }
  });
  var warningsHtml = '';
  streamWarnings.slice(0, 6).forEach(function(w) {
    warningsHtml += '<div style="display:flex;align-items:center;gap:12px;padding:12px 15px;background:#26262c;border-radius:6px;margin-bottom:8px;border-left:3px solid ' + w.color + '">' +
      '<span style="font-size:18px">' + w.icon + '</span>' +
      '<div><div style="color:#fff;font-weight:bold;font-size:13px">' + w.label + '</div>' +
      '<div style="color:#b0b0b0;font-size:12px;margin-top:2px">' + w.detail + '</div></div></div>';
  });

  // --- NEW: Stream Type Badges ---
  const classifyStream = function(s, idx, arr) {
    var peak = s.peakViewers || 0;
    var avg = s.averageViewers || s.peakViewers || 0;
    var dur = s.durationMinutes || 0;
    var game = s.game || s.gameName || 'Unknown';
    var prevStreams = arr.slice(Math.max(0, idx - 3), idx);
    var prevAvgPeak = prevStreams.length > 0 ? prevStreams.reduce(function(sm, x) { return sm + (x.peakViewers || 0); }, 0) / prevStreams.length : peak;
    // Breakout: peak significantly above overall average
    if (peak > overallAvgPeak * 1.5) return { badge: 'ðŸš€', label: 'Breakout', color: '#4caf50' };
    // Momentum: 3+ consecutive improvements
    if (prevStreams.length >= 2 && prevStreams.every(function(p) { return (p.peakViewers || 0) < peak; })) return { badge: 'ðŸ”¥', label: 'Momentum', color: '#ff9800' };
    // Stable Builder: close to average, good retention
    var retention = peak > 0 ? avg / peak : 0;
    if (Math.abs(peak - overallAvgPeak) < overallAvgPeak * 0.2 && retention > 0.6) return { badge: 'ðŸ§±', label: 'Stable Builder', color: '#2196f3' };
    // Experimental: game played fewer than 3 times
    var gameCount = topGameData[game] ? topGameData[game].count : 0;
    if (gameCount <= 2) return { badge: 'ðŸ§ª', label: 'Experimental', color: '#ab47bc' };
    // Low Energy: below average peak AND short duration
    if (peak < overallAvgPeak * 0.7 && dur < aiAvgDuration * 0.7) return { badge: 'ðŸ’¤', label: 'Low Energy', color: '#ef5350' };
    return { badge: 'ðŸ“Š', label: 'Standard', color: '#666' };
  };
  var streamBadges = h.slice(-10).map(function(s, i, arr) {
    var badge = classifyStream(s, i, h.slice(-10));
    return {
      date: new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
      game: (s.game || s.gameName || 'Unknown').substring(0, 20),
      peak: s.peakViewers || 0,
      badge: badge.badge,
      label: badge.label,
      color: badge.color
    };
  });
  var badgesHtml = '';
  streamBadges.reverse().forEach(function(b) {
    badgesHtml += '<tr style="transition:background 0.2s" onmouseenter="this.style.background=\'#2a2f3a\'" onmouseleave="this.style.background=\'transparent\'">' +
      '<td style="padding:8px 12px;border-bottom:1px solid #2a2f3a;color:#b0b0b0;font-size:12px">' + b.date + '</td>' +
      '<td style="padding:8px 12px;border-bottom:1px solid #2a2f3a;color:#fff;font-size:12px">' + b.game + '</td>' +
      '<td style="padding:8px 12px;border-bottom:1px solid #2a2f3a;color:#9146ff;font-weight:bold;text-align:center">' + b.peak + '</td>' +
      '<td style="padding:8px 12px;border-bottom:1px solid #2a2f3a;text-align:center"><span style="background:' + b.color + '22;color:' + b.color + ';padding:3px 10px;border-radius:12px;font-size:11px;font-weight:bold">' + b.badge + ' ' + b.label + '</span></td>' +
    '</tr>';
  });

  return '<div class="card">' +
  '<h2>ðŸ¤– AI-Powered Insights</h2>' +
  '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:15px;margin:15px 0">' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center">' +
      '<div style="font-size:32px;margin-bottom:5px">ðŸ¥</div>' +
      '<div style="color:#b0b0b0;font-size:11px">Stream Health</div>' +
      '<div style="font-size:28px;color:' + healthColor + ';font-weight:bold">' + healthScore + '</div>' +
      '<div style="font-size:12px;color:' + healthColor + '">' + healthLabel + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center">' +
      '<div style="font-size:32px;margin-bottom:5px">ðŸ“Š</div>' +
      '<div style="color:#b0b0b0;font-size:11px">Growth Momentum</div>' +
      '<div style="font-size:22px;color:' + (parseFloat(momentumPct) >= 0 ? '#4caf50' : '#ef5350') + ';font-weight:bold">' + (parseFloat(momentumPct) >= 0 ? '+' : '') + momentumPct + '%</div>' +
      '<div style="font-size:12px;color:#b0b0b0">' + momentum + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center">' +
      '<div style="font-size:32px;margin-bottom:5px">ðŸ”®</div>' +
      '<div style="color:#b0b0b0;font-size:11px">Predicted Next Stream</div>' +
      '<div style="font-size:28px;color:#9146ff;font-weight:bold">' + predictedViewers + '</div>' +
      '<div style="font-size:11px;color:#666">' + predLow + ' - ' + predHigh + ' range</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center">' +
      '<div style="font-size:32px;margin-bottom:5px">ðŸ“</div>' +
      '<div style="color:#b0b0b0;font-size:11px">Consistency</div>' +
      '<div style="font-size:16px;color:#fff;font-weight:bold;margin-top:5px">' + consistencyLabel + '</div>' +
      '<div style="font-size:11px;color:#666">CV: ' + (cv * 100).toFixed(0) + '%</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center">' +
      '<div style="font-size:32px;margin-bottom:5px">ðŸ”¥</div>' +
      '<div style="color:#b0b0b0;font-size:11px">Burnout Risk</div>' +
      '<div style="font-size:22px;color:' + burnoutColor + ';font-weight:bold">' + burnoutScore + '%</div>' +
      '<div style="font-size:12px;color:' + burnoutColor + '">' + burnoutLabel + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center">' +
      '<div style="font-size:32px;margin-bottom:5px">ðŸ“…</div>' +
      '<div style="color:#b0b0b0;font-size:11px">Schedule Score</div>' +
      '<div style="font-size:22px;color:#2196f3;font-weight:bold">' + scheduleAdherence + '%</div>' +
      '<div style="font-size:12px;color:#b0b0b0">' + scheduleLabel + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center">' +
      '<div style="font-size:32px;margin-bottom:5px">ðŸŽ¨</div>' +
      '<div style="color:#b0b0b0;font-size:11px">Content Freshness</div>' +
      '<div style="font-size:22px;color:#ab47bc;font-weight:bold">' + freshnessScore + '%</div>' +
      '<div style="font-size:12px;color:#b0b0b0">' + freshnessLabel + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center">' +
      '<div style="font-size:32px;margin-bottom:5px">ðŸ’Ž</div>' +
      '<div style="color:#b0b0b0;font-size:11px">Audience Loyalty</div>' +
      '<div style="font-size:22px;color:#ffd700;font-weight:bold">' + loyaltyScore + '%</div>' +
      '<div style="font-size:12px;color:#b0b0b0">' + loyaltyLabel + '</div>' +
    '</div>' +
  '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ§¬ Stream DNA Profile</h3>' +
  '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;margin-top:15px">' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center;border-top:3px solid #9146ff">' +
      '<div style="color:#b0b0b0;font-size:11px;margin-bottom:5px">Content Style</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + dnaVariety + '</div>' +
      '<div style="color:#666;font-size:11px">' + uniqueGameCount + ' unique games</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center;border-top:3px solid #4caf50">' +
      '<div style="color:#b0b0b0;font-size:11px;margin-bottom:5px">Schedule Type</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + dnaSchedule + '</div>' +
      '<div style="color:#666;font-size:11px">' + scheduleAdherence + '% adherence</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center;border-top:3px solid #ff9800">' +
      '<div style="color:#b0b0b0;font-size:11px;margin-bottom:5px">Stream Length</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + dnaLength + '</div>' +
      '<div style="color:#666;font-size:11px">avg ' + Math.round(avgDurMins) + ' min</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center;border-top:3px solid #2196f3">' +
      '<div style="color:#b0b0b0;font-size:11px;margin-bottom:5px">Growth Phase</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + dnaGrowth + '</div>' +
      '<div style="color:#666;font-size:11px">' + momentumPct + '% momentum</div>' +
    '</div>' +
  '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ“Š Viewer Distribution (Percentiles)</h3>' +
  '<div style="display:grid;grid-template-columns:repeat(5,1fr);gap:10px;margin-top:15px">' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center">' +
      '<div style="color:#ef5350;font-size:11px">P10</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + p10 + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center">' +
      '<div style="color:#ff9800;font-size:11px">P25</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + p25 + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center">' +
      '<div style="color:#ffd700;font-size:11px">P50 (Median)</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + p50 + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center">' +
      '<div style="color:#8bc34a;font-size:11px">P75</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + p75 + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center">' +
      '<div style="color:#4caf50;font-size:11px">P90</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + p90 + '</div>' +
    '</div>' +
  '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ“… Week-over-Week Trend</h3>' +
  '<table style="width:100%;border-collapse:collapse;margin-top:10px">' +
    '<thead><tr style="background:#26262c">' +
      '<th style="padding:8px 12px;text-align:left;font-size:12px">Period</th>' +
      '<th style="padding:8px 12px;text-align:center;font-size:12px">Streams</th>' +
      '<th style="padding:8px 12px;text-align:center;font-size:12px">Avg Peak</th>' +
      '<th style="padding:8px 12px;text-align:center;font-size:12px">Hours</th>' +
      '<th style="padding:8px 12px;text-align:center;font-size:12px">Trend</th>' +
    '</tr></thead>' +
    '<tbody>' + weekTrendHtml + '</tbody>' +
  '</table>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ† Key Findings</h3>' +
  '<div style="display:grid;gap:12px;margin-top:10px">' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;border-left:3px solid #4caf50">' +
      '<div style="font-weight:bold;color:#fff">ðŸŽ® Best Performing Game</div>' +
      '<div style="color:#b0b0b0;margin-top:5px">' + (bestGame ? bestGame[0] + ' â€” <strong style="color:#4caf50">' + bestGame[1] + '</strong> avg peak viewers (best: ' + bestGame[2] + ')' : 'N/A') + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;border-left:3px solid #ff9800">' +
      '<div style="font-weight:bold;color:#fff">â° Optimal Stream Time</div>' +
      '<div style="color:#b0b0b0;margin-top:5px"><strong style="color:#ff9800">' + bestDayName + '</strong> at <strong style="color:#ff9800">' + bestHourLabel + '</strong> â€” avg ' + bestDayAvg + ' viewers on best day, ' + bestHourAvg + ' at best hour</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;border-left:3px solid #2196f3">' +
      '<div style="font-weight:bold;color:#fff">â±ï¸ Duration Impact</div>' +
      '<div style="color:#b0b0b0;margin-top:5px">' + durationCorrelation + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;border-left:3px solid #e91e63">' +
      '<div style="font-weight:bold;color:#fff">ðŸ”¥ Burnout Assessment</div>' +
      '<div style="color:#b0b0b0;margin-top:5px">Risk level: <strong style="color:' + burnoutColor + '">' + burnoutLabel + '</strong> (' + burnoutScore + '%). ' + (burnoutScore >= 40 ? 'Consider varying your content or taking short breaks.' : 'You seem to be in a sustainable rhythm!') + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;border-left:3px solid #9146ff">' +
      '<div style="font-weight:bold;color:#fff">ðŸ’Ž Loyalty Analysis</div>' +
      '<div style="color:#b0b0b0;margin-top:5px">Audience retention: <strong style="color:#ffd700">' + loyaltyScore + '%</strong> â€” ' + loyaltyLabel + '. ' + (loyaltyScore >= 60 ? 'Your viewers stick around!' : 'Try more engagement strategies to retain viewers.') + '</div>' +
    '</div>' +
  '</div>' +
'</div>' +

(anomalyHtml ? '<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ” Anomaly Detection</h3>' +
  '<p style="color:#b0b0b0;font-size:12px;margin-bottom:10px">Streams that deviated significantly from your average (' + Math.round(mean) + ' viewers, +/- 2 sigma)</p>' +
  anomalyHtml +
'</div>' : '') +

(fatigueHtml ? '<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ˜´ Viewer Fatigue Analysis</h3>' +
  '<p style="color:#b0b0b0;font-size:12px;margin-bottom:10px">Average viewer retention (avg/peak ratio) by stream duration</p>' +
  fatigueHtml +
'</div>' : '') +

(milestonesHtml ? '<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸŽ¯ Milestone Projections</h3>' +
  '<p style="color:#b0b0b0;font-size:12px;margin-bottom:10px">Estimated time to reach viewer milestones at current pace (' + Math.round(avgViewersPerStream) + ' avg peak/stream)</p>' +
  milestonesHtml +
'</div>' : '') +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ’¡ Smart Suggestions</h3>' +
  '<div style="display:grid;gap:10px;margin-top:10px">' +
    suggestionsHtml +
  '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ“ˆ Health Score Breakdown</h3>' +
  '<div style="margin-top:15px">' +
    '<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">' +
      '<span style="color:#b0b0b0;width:110px;font-size:12px">Growth</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:20px;overflow:hidden"><div style="background:#4caf50;height:100%;width:' + (healthGrowth * 4) + '%;border-radius:3px"></div></div>' +
      '<span style="color:#fff;font-size:12px;min-width:35px;text-align:right">' + healthGrowth + '/25</span>' +
    '</div>' +
    '<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">' +
      '<span style="color:#b0b0b0;width:110px;font-size:12px">Consistency</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:20px;overflow:hidden"><div style="background:#9146ff;height:100%;width:' + (healthConsistency * 4) + '%;border-radius:3px"></div></div>' +
      '<span style="color:#fff;font-size:12px;min-width:35px;text-align:right">' + healthConsistency + '/25</span>' +
    '</div>' +
    '<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">' +
      '<span style="color:#b0b0b0;width:110px;font-size:12px">Activity</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:20px;overflow:hidden"><div style="background:#ff9800;height:100%;width:' + (healthActivity * 4) + '%;border-radius:3px"></div></div>' +
      '<span style="color:#fff;font-size:12px;min-width:35px;text-align:right">' + healthActivity + '/25</span>' +
    '</div>' +
    '<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">' +
      '<span style="color:#b0b0b0;width:110px;font-size:12px">Engagement</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:20px;overflow:hidden"><div style="background:#2196f3;height:100%;width:' + (healthEngagement * 4) + '%;border-radius:3px"></div></div>' +
      '<span style="color:#fff;font-size:12px;min-width:35px;text-align:right">' + healthEngagement + '/25</span>' +
    '</div>' +
    '<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">' +
      '<span style="color:#b0b0b0;width:110px;font-size:12px">Freshness</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:20px;overflow:hidden"><div style="background:#ab47bc;height:100%;width:' + Math.min(100, freshnessScore) + '%;border-radius:3px"></div></div>' +
      '<span style="color:#fff;font-size:12px;min-width:35px;text-align:right">' + freshnessScore + '/100</span>' +
    '</div>' +
    '<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">' +
      '<span style="color:#b0b0b0;width:110px;font-size:12px">Loyalty</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:20px;overflow:hidden"><div style="background:#ffd700;height:100%;width:' + Math.min(100, loyaltyScore) + '%;border-radius:3px"></div></div>' +
      '<span style="color:#fff;font-size:12px;min-width:35px;text-align:right">' + loyaltyScore + '/100</span>' +
    '</div>' +
    '<div style="display:flex;align-items:center;gap:10px;margin-bottom:10px">' +
      '<span style="color:#b0b0b0;width:110px;font-size:12px">Schedule</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:20px;overflow:hidden"><div style="background:#00bcd4;height:100%;width:' + Math.min(100, scheduleAdherence) + '%;border-radius:3px"></div></div>' +
      '<span style="color:#fff;font-size:12px;min-width:35px;text-align:right">' + scheduleAdherence + '/100</span>' +
    '</div>' +
  '</div>' +
'</div>' +

// Effort / Outcome / ROI card
'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">âš–ï¸ Effort / Outcome / ROI</h3>' +
  '<p style="color:#666;font-size:11px;margin-bottom:10px">Effort = Duration Ã— Consistency penalty | Outcome = Peak + Follows + Retention weighted | ROI = Outcome / Effort</p>' +
  '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:15px;margin-top:10px">' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center;border-top:3px solid #ff9800">' +
      '<div style="font-size:28px;margin-bottom:5px">ðŸ§®</div>' +
      '<div style="color:#b0b0b0;font-size:11px">Effort Score</div>' +
      '<div style="font-size:28px;color:#ff9800;font-weight:bold">' + effortScore + '</div>' +
      '<div style="font-size:10px;color:#666">avg ' + Math.round(aiAvgDuration) + 'min Ã— ' + consistencyPenalty.toFixed(2) + ' penalty</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center;border-top:3px solid #4caf50">' +
      '<div style="font-size:28px;margin-bottom:5px">ðŸ“Š</div>' +
      '<div style="color:#b0b0b0;font-size:11px">Outcome Score</div>' +
      '<div style="font-size:28px;color:#4caf50;font-weight:bold">' + outcomeScore + '</div>' +
      '<div style="font-size:10px;color:#666">peak ' + normPeak + ' + follows ' + normFollows + ' + retention ' + normRetention + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:20px;border-radius:8px;text-align:center;border-top:3px solid ' + roiColor + '">' +
      '<div style="font-size:28px;margin-bottom:5px">âš–ï¸</div>' +
      '<div style="color:#b0b0b0;font-size:11px">ROI Rating</div>' +
      '<div style="font-size:28px;color:' + roiColor + ';font-weight:bold">' + roiRaw.toFixed(2) + '</div>' +
      '<div style="font-size:12px;color:' + roiColor + '">' + roiRating + '</div>' +
    '</div>' +
  '</div>' +
'</div>' +

// Stream Warnings card
(warningsHtml ? '<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">âš ï¸ Stream Warnings</h3>' +
  '<p style="color:#666;font-size:11px;margin-bottom:10px">Issues detected from your recent stream data that may impact growth</p>' +
  warningsHtml +
'</div>' : '') +

// Stream Type Badges card
'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ·ï¸ Stream Type Classification</h3>' +
  '<p style="color:#666;font-size:11px;margin-bottom:10px">Each recent stream classified by its performance pattern</p>' +
  '<div style="display:flex;flex-wrap:wrap;gap:8px;margin-bottom:15px">' +
    '<span style="background:#4caf5022;color:#4caf50;padding:4px 10px;border-radius:12px;font-size:11px">ðŸš€ Breakout = Peak &gt; 150% avg</span>' +
    '<span style="background:#ff980022;color:#ff9800;padding:4px 10px;border-radius:12px;font-size:11px">ðŸ”¥ Momentum = Consecutive growth</span>' +
    '<span style="background:#2196f322;color:#2196f3;padding:4px 10px;border-radius:12px;font-size:11px">ðŸ§± Stable Builder = Consistent</span>' +
    '<span style="background:#ab47bc22;color:#ab47bc;padding:4px 10px;border-radius:12px;font-size:11px">ðŸ§ª Experimental = New game</span>' +
    '<span style="background:#ef535022;color:#ef5350;padding:4px 10px;border-radius:12px;font-size:11px">ðŸ’¤ Low Energy = Below avg</span>' +
  '</div>' +
  '<table style="width:100%;border-collapse:collapse">' +
    '<thead><tr style="background:#26262c">' +
      '<th style="padding:8px 12px;text-align:left;font-size:12px;color:#b0b0b0">Date</th>' +
      '<th style="padding:8px 12px;text-align:left;font-size:12px;color:#b0b0b0">Game</th>' +
      '<th style="padding:8px 12px;text-align:center;font-size:12px;color:#b0b0b0">Peak</th>' +
      '<th style="padding:8px 12px;text-align:center;font-size:12px;color:#b0b0b0">Type</th>' +
    '</tr></thead>' +
    '<tbody>' + badgesHtml + '</tbody>' +
  '</table>' +
'</div>' +

// Viewer timeline deep analysis from viewerGraphHistory
(function() {
  var vgh = viewerGraphHistory || [];
  if (vgh.length < 2) return '';
  
  // Analyze viewer curves across all streams
  var firstHalfAvgs = [];
  var secondHalfAvgs = [];
  var startViewers = [];
  var endViewers = [];
  var peakPositions = [];
  var maxDataPoints = 0;
  
  vgh.forEach(function(stream) {
    if (!stream.data || stream.data.length < 10) return;
    maxDataPoints = Math.max(maxDataPoints, stream.data.length);
    var mid = Math.floor(stream.data.length / 2);
    var first = stream.data.slice(0, mid);
    var second = stream.data.slice(mid);
    var firstAvg = first.reduce(function(s, d) { return s + (d.viewers || 0); }, 0) / first.length;
    var secondAvg = second.reduce(function(s, d) { return s + (d.viewers || 0); }, 0) / second.length;
    firstHalfAvgs.push(firstAvg);
    secondHalfAvgs.push(secondAvg);
    startViewers.push(stream.data[0].viewers || 0);
    endViewers.push(stream.data[stream.data.length - 1].viewers || 0);
    
    // Find peak position
    var peak = 0;
    var peakIdx = 0;
    stream.data.forEach(function(dp, idx) {
      if ((dp.viewers || 0) > peak) { peak = dp.viewers; peakIdx = idx; }
    });
    peakPositions.push(Math.round((peakIdx / stream.data.length) * 100));
  });
  
  if (firstHalfAvgs.length === 0) return '';
  
  var avgFirst = Math.round(firstHalfAvgs.reduce(function(a, b) { return a + b; }, 0) / firstHalfAvgs.length);
  var avgSecond = Math.round(secondHalfAvgs.reduce(function(a, b) { return a + b; }, 0) / secondHalfAvgs.length);
  var avgStart = Math.round(startViewers.reduce(function(a, b) { return a + b; }, 0) / startViewers.length);
  var avgEnd = Math.round(endViewers.reduce(function(a, b) { return a + b; }, 0) / endViewers.length);
  var avgPeakPos = Math.round(peakPositions.reduce(function(a, b) { return a + b; }, 0) / peakPositions.length);
  
  var halfTrend = avgSecond >= avgFirst ? 'ðŸ“ˆ Viewers increase as streams go on (+' + Math.round(((avgSecond - avgFirst) / Math.max(avgFirst, 1)) * 100) + '%)' :
    'ðŸ“‰ Viewers decline in 2nd half (-' + Math.round(((avgFirst - avgSecond) / Math.max(avgFirst, 1)) * 100) + '%)';
  
  var retPct = avgStart > 0 ? Math.round((avgEnd / avgStart) * 100) : 0;
  var retLabel = retPct >= 80 ? 'ðŸŸ¢ Excellent' : retPct >= 60 ? 'ðŸŸ¡ Good' : retPct >= 40 ? 'ðŸŸ  Average' : 'ðŸ”´ Low';
  
  var peakLabel = avgPeakPos <= 25 ? 'Early (first quarter)' : avgPeakPos <= 50 ? 'Mid-early' : avgPeakPos <= 75 ? 'Mid-late' : 'Late (last quarter)';
  
  return '<div class="card" style="margin-top:15px">' +
    '<h3 style="margin-top:0">ðŸ“¡ In-Stream Viewer Flow Analysis</h3>' +
    '<p style="color:#b0b0b0;font-size:12px;margin-bottom:10px">Deep analysis of minute-by-minute viewer data across ' + vgh.length + ' streams (up to ' + maxDataPoints + ' data points per stream)</p>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin-top:10px">' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #4caf50">' +
        '<div style="color:#b0b0b0;font-size:10px">Avg Start Viewers</div>' +
        '<div style="font-size:20px;color:#4caf50;font-weight:bold">' + avgStart + '</div>' +
      '</div>' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #2196f3">' +
        '<div style="color:#b0b0b0;font-size:10px">1st Half Avg</div>' +
        '<div style="font-size:20px;color:#2196f3;font-weight:bold">' + avgFirst + '</div>' +
      '</div>' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #9146ff">' +
        '<div style="color:#b0b0b0;font-size:10px">2nd Half Avg</div>' +
        '<div style="font-size:20px;color:#9146ff;font-weight:bold">' + avgSecond + '</div>' +
      '</div>' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #ef5350">' +
        '<div style="color:#b0b0b0;font-size:10px">Avg End Viewers</div>' +
        '<div style="font-size:20px;color:#ef5350;font-weight:bold">' + avgEnd + '</div>' +
      '</div>' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #ff9800">' +
        '<div style="color:#b0b0b0;font-size:10px">Startâ†’End Retention</div>' +
        '<div style="font-size:20px;color:#ff9800;font-weight:bold">' + retPct + '%</div>' +
        '<div style="font-size:10px;color:#666">' + retLabel + '</div>' +
      '</div>' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid #ffd700">' +
        '<div style="color:#b0b0b0;font-size:10px">Peak Position</div>' +
        '<div style="font-size:20px;color:#ffd700;font-weight:bold">' + avgPeakPos + '%</div>' +
        '<div style="font-size:10px;color:#666">' + peakLabel + '</div>' +
      '</div>' +
    '</div>' +
    '<div style="margin-top:12px;padding:10px;background:#26262c;border-radius:6px;border-left:3px solid #9146ff">' +
      '<div style="font-weight:bold;color:#fff">ðŸ“Š Stream Flow Pattern</div>' +
      '<div style="color:#b0b0b0;margin-top:5px">' + halfTrend + '</div>' +
    '</div>' +
  '</div>';
})() +

// Multi-stream viewer overlay chart
(function() {
  var vgh = viewerGraphHistory || [];
  var usable = vgh.filter(function(s) { return s.data && s.data.length >= 20; });
  if (usable.length < 2) return '';
  
  // Take last 5 streams, normalize to % of stream duration
  var streams = usable.slice(-5);
  var chartColors = ['#9146ff', '#4caf50', '#ff9800', '#e91e63', '#2196f3'];
  var normalizedStreams = [];
  
  streams.forEach(function(stream, idx) {
    var pts = stream.data;
    // Downsample to 50 points normalized across stream length
    var step = Math.max(1, Math.floor(pts.length / 50));
    var sampled = [];
    for (var i = 0; i < pts.length; i += step) sampled.push(pts[i].viewers || 0);
    normalizedStreams.push({
      label: new Date(stream.startedAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
      data: sampled,
      peak: stream.peakViewers || Math.max.apply(null, sampled),
      color: chartColors[idx % chartColors.length]
    });
  });
  
  // Generate percentage labels (0% to 100% of stream time)
  var maxLen = Math.max.apply(null, normalizedStreams.map(function(s) { return s.data.length; }));
  var labels = [];
  for (var i = 0; i < maxLen; i++) labels.push(Math.round((i / (maxLen - 1)) * 100) + '%');
  
  // Pad shorter streams with null
  normalizedStreams.forEach(function(s) {
    while (s.data.length < maxLen) s.data.push(null);
  });
  
  var datasets = normalizedStreams.map(function(s) {
    return {
      label: s.label + ' (peak: ' + s.peak + ')',
      data: s.data,
      borderColor: s.color,
      backgroundColor: 'transparent',
      fill: false,
      tension: 0.3,
      pointRadius: 0,
      borderWidth: 2,
      spanGaps: true
    };
  });
  
  return '<div class="card" style="margin-top:15px">' +
    '<h3 style="margin-top:0">ðŸ”„ Multi-Stream Viewer Overlay (Last ' + streams.length + ' Streams)</h3>' +
    '<p style="color:#666;font-size:11px;margin-bottom:10px">Viewer curves normalized by stream progress (0% = start, 100% = end). Compare viewer behavior patterns across streams.</p>' +
    '<div style="height:250px"><canvas id="multi-stream-overlay"></canvas></div>' +
  '</div>' +
  '<script src="https://cdn.jsdelivr.net/npm/chart.js"><\/script>' +
  '<script>' +
  'document.addEventListener("DOMContentLoaded", function() {' +
    'var msCtx = document.getElementById("multi-stream-overlay");' +
    'if (msCtx) {' +
      'new Chart(msCtx, {' +
        'type: "line",' +
        'data: {' +
          'labels: ' + JSON.stringify(labels) + ',' +
          'datasets: ' + JSON.stringify(datasets) +
        '},' +
        'options: {' +
          'responsive: true,' +
          'maintainAspectRatio: false,' +
          'interaction: { mode: "index", intersect: false },' +
          'plugins: { legend: { display: true, labels: { color: "#8b8fa3", usePointStyle: true, font: { size: 10 } } } },' +
          'scales: {' +
            'y: { beginAtZero: true, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#8b8fa3" }, title: { display: true, text: "Viewers", color: "#666" } },' +
            'x: { grid: { display: false }, ticks: { color: "#8b8fa3", maxTicksLimit: 10 }, title: { display: true, text: "Stream Progress", color: "#666" } }' +
          '}' +
        '}' +
      '});' +
    '}' +
  '});' +
  '<\/script>';
})() +

// Stream health/retention analysis chart
(function() {
  var vgh = viewerGraphHistory || [];
  var usable = vgh.filter(function(s) { return s.data && s.data.length >= 20; });
  if (usable.length < 3) return '';
  
  var healthData = usable.slice(-10).map(function(stream) {
    var pts = stream.data;
    var viewers = pts.map(function(p) { return p.viewers || 0; });
    var peak = Math.max.apply(null, viewers);
    var peakIdx = viewers.indexOf(peak);
    var startV = viewers[0] || 1;
    var endV = viewers[viewers.length - 1] || 0;
    
    // Ramp-up score: how quickly viewers reach peak (earlier = better)
    var rampPct = Math.round((1 - peakIdx / viewers.length) * 100);
    
    // Retention score: end viewers / peak viewers
    var retention = peak > 0 ? Math.round((endV / peak) * 100) : 0;
    
    // Stability score: low coefficient of variation = more stable
    var avg = viewers.reduce(function(a, b) { return a + b; }, 0) / viewers.length;
    var variance = viewers.reduce(function(s, v) { return s + Math.pow(v - avg, 2); }, 0) / viewers.length;
    var cv = avg > 0 ? Math.sqrt(variance) / avg : 0;
    var stability = Math.round(Math.max(0, 100 - cv * 100));
    
    // Growth score: end vs start
    var growth = startV > 0 ? Math.round(((endV - startV) / startV) * 100) : 0;
    
    // Overall health = weighted average
    var health = Math.round(rampPct * 0.2 + retention * 0.3 + stability * 0.3 + Math.min(100, Math.max(0, growth + 50)) * 0.2);
    
    return {
      date: new Date(stream.startedAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
      ramp: rampPct,
      retention: retention,
      stability: stability,
      health: health,
      peak: peak
    };
  });
  
  return '<div class="card" style="margin-top:15px">' +
    '<h3 style="margin-top:0">â¤ï¸ Stream Health Analysis</h3>' +
    '<p style="color:#666;font-size:11px;margin-bottom:10px">Stream quality metrics derived from minute-by-minute viewer data. Higher = better.</p>' +
    '<div style="height:250px"><canvas id="stream-health-chart"></canvas></div>' +
  '</div>' +
  '<script>' +
  'document.addEventListener("DOMContentLoaded", function() {' +
    'var healthData = ' + JSON.stringify(healthData) + ';' +
    'var shCtx = document.getElementById("stream-health-chart");' +
    'if (shCtx && healthData.length > 0) {' +
      'new Chart(shCtx, {' +
        'type: "bar",' +
        'data: {' +
          'labels: healthData.map(function(d) { return d.date; }),' +
          'datasets: [{' +
            'label: "Health Score",' +
            'data: healthData.map(function(d) { return d.health; }),' +
            'backgroundColor: healthData.map(function(d) { return d.health >= 70 ? "#4caf50aa" : d.health >= 40 ? "#ff9800aa" : "#ef5350aa"; }),' +
            'borderColor: healthData.map(function(d) { return d.health >= 70 ? "#4caf50" : d.health >= 40 ? "#ff9800" : "#ef5350"; }),' +
            'borderWidth: 1,' +
            'borderRadius: 4,' +
            'order: 2' +
          '}, {' +
            'label: "Retention %",' +
            'data: healthData.map(function(d) { return d.retention; }),' +
            'type: "line",' +
            'borderColor: "#9146ff",' +
            'backgroundColor: "transparent",' +
            'borderWidth: 2,' +
            'pointRadius: 3,' +
            'pointBackgroundColor: "#9146ff",' +
            'tension: 0.3,' +
            'order: 1' +
          '}, {' +
            'label: "Stability %",' +
            'data: healthData.map(function(d) { return d.stability; }),' +
            'type: "line",' +
            'borderColor: "#2196f3",' +
            'backgroundColor: "transparent",' +
            'borderWidth: 2,' +
            'pointRadius: 3,' +
            'pointBackgroundColor: "#2196f3",' +
            'borderDash: [4, 4],' +
            'tension: 0.3,' +
            'order: 1' +
          '}]' +
        '},' +
        'options: {' +
          'responsive: true,' +
          'maintainAspectRatio: false,' +
          'plugins: {' +
            'legend: { display: true, labels: { color: "#8b8fa3", usePointStyle: true, font: { size: 10 } } },' +
            'tooltip: { callbacks: { afterBody: function(ctx) { var d = healthData[ctx[0].dataIndex]; return "Ramp-up: " + d.ramp + "% | Retention: " + d.retention + "% | Stability: " + d.stability + "% | Peak: " + d.peak; } } }' +
          '},' +
          'scales: {' +
            'y: { beginAtZero: true, max: 100, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#8b8fa3", callback: function(v) { return v + "%"; } } },' +
            'x: { grid: { display: false }, ticks: { color: "#8b8fa3" } }' +
          '}' +
        '}' +
      '});' +
    '}' +
  '});' +
  '<\/script>';
})() +

// Title analysis
(function() {
  var titleLengths = [];
  var titleWords = {};
  h.forEach(function(s) {
    if (s.title) {
      titleLengths.push(s.title.length);
      s.title.split(/[\s|,!.?]+/).forEach(function(w) {
        var word = w.toLowerCase().trim();
        if (word.length > 2 && word !== 'the' && word !== 'and' && word !== 'for' && word !== 'with') {
          titleWords[word] = (titleWords[word] || 0) + 1;
        }
      });
    }
  });
  if (titleLengths.length < 3) return '';
  
  var avgLen = Math.round(titleLengths.reduce(function(a, b) { return a + b; }, 0) / titleLengths.length);
  var shortTitles = h.filter(function(s) { return s.title && s.title.length < avgLen; });
  var longTitles = h.filter(function(s) { return s.title && s.title.length >= avgLen; });
  var shortAvg = shortTitles.length > 0 ? Math.round(shortTitles.reduce(function(s, x) { return s + (x.peakViewers || 0); }, 0) / shortTitles.length) : 0;
  var longAvg = longTitles.length > 0 ? Math.round(longTitles.reduce(function(s, x) { return s + (x.peakViewers || 0); }, 0) / longTitles.length) : 0;
  var titleAdvice = longAvg > shortAvg ? 'Longer titles (' + avgLen + '+ chars) correlate with ' + (longAvg - shortAvg) + ' more peak viewers' :
    shortAvg > longAvg ? 'Shorter titles (<' + avgLen + ' chars) correlate with ' + (shortAvg - longAvg) + ' more peak viewers' :
    'Title length has no significant impact on viewership';
  
  var topWords = Object.entries(titleWords).sort(function(a, b) { return b[1] - a[1]; }).slice(0, 8);
  var topWordsHtml = '';
  topWords.forEach(function(w) {
    topWordsHtml += '<span style="background:#2a1f3d;padding:4px 10px;border-radius:12px;font-size:11px;color:#ce93d8;margin:3px;display:inline-block">' + w[0] + ' <strong style="color:#fff">' + w[1] + 'x</strong></span>';
  });
  
  return '<div class="card" style="margin-top:15px">' +
    '<h3 style="margin-top:0">ðŸ“ Title Analysis</h3>' +
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:10px">' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Avg Title Length</div><div style="font-size:20px;color:#ce93d8;font-weight:bold">' + avgLen + ' chars</div></div>' +
      '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Title Impact</div><div style="font-size:14px;color:#fff;font-weight:bold;margin-top:4px">' + titleAdvice + '</div></div>' +
    '</div>' +
    (topWordsHtml ? '<div style="margin-top:10px"><div style="color:#b0b0b0;font-size:11px;margin-bottom:6px">Most used words in titles:</div><div>' + topWordsHtml + '</div></div>' : '') +
  '</div>';
})();
}

// NEW: Reports Tab
function renderReportsTab() {
  const h = history || [];
  const totalStreams = h.length;
  const totalHours = h.reduce((sum, s) => sum + ((s.durationMinutes || 0) / 60), 0);
  const peakViewersAll = Math.max(...h.map(s => s.peakViewers || 0), 0);
  const avgViewers = totalStreams > 0 ? Math.round(h.reduce((s, x) => s + (x.peakViewers || 0), 0) / totalStreams) : 0;
  const totalFollowers = h.reduce((s, x) => s + (x.followers || x.newFollowers || 0), 0);
  const totalSubs = h.reduce((s, x) => s + (x.subscribers || x.newSubs || 0), 0);
  const uniqueGamesArr = [...new Set(h.map(s => s.game || s.gameName || 'Unknown'))];
  const uniqueGames = uniqueGamesArr.length;
  const avgDuration = totalStreams > 0 ? (totalHours / totalStreams).toFixed(1) : '0.0';
  const medianViewers = (() => { const sorted = h.map(s => s.peakViewers || 0).sort((a, b) => a - b); return sorted.length > 0 ? sorted[Math.floor(sorted.length / 2)] : 0; })();
  const totalViewerHours = h.reduce((s, x) => s + ((x.averageViewers || x.peakViewers || 0) * ((x.durationMinutes || 0) / 60)), 0);

  // Longest stream
  const longestStream = h.reduce((best, s) => (s.durationMinutes || 0) > (best.durationMinutes || 0) ? s : best, h[0] || {});
  const longestGame = longestStream.game || longestStream.gameName || 'Unknown';
  const longestHrs = ((longestStream.durationMinutes || 0) / 60).toFixed(1);
  const longestDate = longestStream.startedAt || longestStream.date ? new Date(longestStream.startedAt || longestStream.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : 'N/A';

  // Most viewed stream
  const bestStream = h.reduce((best, s) => (s.peakViewers || 0) > (best.peakViewers || 0) ? s : best, h[0] || {});
  const bestStreamGame = bestStream.game || bestStream.gameName || 'Unknown';
  const bestStreamDate = bestStream.startedAt || bestStream.date ? new Date(bestStream.startedAt || bestStream.date).toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' }) : 'N/A';

  // Most followers in one stream
  const bestFollowStream = h.reduce((best, s) => ((s.followers || s.newFollowers || 0) > (best.followers || best.newFollowers || 0)) ? s : best, h[0] || {});
  const bestFollows = bestFollowStream.followers || bestFollowStream.newFollowers || 0;
  const bestFollowGame = bestFollowStream.game || bestFollowStream.gameName || 'Unknown';

  // Most subs in one stream
  const bestSubStream = h.reduce((best, s) => ((s.subscribers || s.newSubs || 0) > (best.subscribers || best.newSubs || 0)) ? s : best, h[0] || {});
  const bestSubsCount = bestSubStream.subscribers || bestSubStream.newSubs || 0;
  const bestSubGame = bestSubStream.game || bestSubStream.gameName || 'Unknown';

  // Shortest stream
  const withDur = h.filter(s => (s.durationMinutes || 0) > 0);
  const shortestStream = withDur.length > 0 ? withDur.reduce((best, s) => (s.durationMinutes || Infinity) < (best.durationMinutes || Infinity) ? s : best, withDur[0]) : {};
  const shortestHrs = ((shortestStream.durationMinutes || 0) / 60).toFixed(1);
  const shortestGame = shortestStream.game || shortestStream.gameName || 'Unknown';

  // Streaker data - hot/cold streaks
  let currentStreak = 0, bestStreak = 0, worstStreak = 0, currentCold = 0, worstCold = 0;
  h.forEach(s => {
    if ((s.peakViewers || 0) >= avgViewers) {
      currentStreak++;
      currentCold = 0;
      if (currentStreak > bestStreak) bestStreak = currentStreak;
    } else {
      currentCold++;
      currentStreak = 0;
      if (currentCold > worstCold) worstCold = currentCold;
    }
  });

  // Streamer Level (gamification)
  const xpTotal = totalStreams * 100 + Math.round(totalHours * 50) + totalFollowers * 10 + totalSubs * 25 + peakViewersAll * 5;
  const levelThresholds = [0, 500, 1500, 3500, 7000, 12000, 20000, 35000, 55000, 80000, 120000];
  let streamerLevel = 1;
  for (let i = levelThresholds.length - 1; i >= 0; i--) { if (xpTotal >= levelThresholds[i]) { streamerLevel = i + 1; break; } }
  const nextLevelXP = levelThresholds[Math.min(streamerLevel, levelThresholds.length - 1)] || xpTotal + 1000;
  const xpProgress = streamerLevel <= levelThresholds.length ? Math.min(100, Math.round(((xpTotal - (levelThresholds[streamerLevel - 1] || 0)) / Math.max(1, (nextLevelXP - (levelThresholds[streamerLevel - 1] || 0)))) * 100)) : 100;
  const levelTitles = ['Newbie', 'Beginner', 'Regular', 'Enthusiast', 'Dedicated', 'Veteran', 'Expert', 'Master', 'Legend', 'Champion', 'Mythic'];
  const levelTitle = levelTitles[Math.min(streamerLevel - 1, levelTitles.length - 1)];

  // Monthly breakdown for report
  const monthlyData = {};
  h.forEach(s => {
    const d = new Date(s.startedAt || s.date);
    const key = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0');
    if (!monthlyData[key]) monthlyData[key] = { streams: 0, viewers: 0, hours: 0, follows: 0, subs: 0, peak: 0 };
    monthlyData[key].streams++;
    monthlyData[key].viewers += (s.peakViewers || 0);
    monthlyData[key].hours += (s.durationMinutes || 0) / 60;
    monthlyData[key].follows += (s.followers || s.newFollowers || 0);
    monthlyData[key].subs += (s.subscribers || s.newSubs || 0);
    if ((s.peakViewers || 0) > monthlyData[key].peak) monthlyData[key].peak = s.peakViewers;
  });
  let monthlyTableHtml = '';
  const sortedMonths = Object.keys(monthlyData).sort().reverse();
  sortedMonths.forEach(m => {
    const d = monthlyData[m];
    const avgV = d.streams > 0 ? Math.round(d.viewers / d.streams) : 0;
    monthlyTableHtml += '<tr style="transition:background 0.2s" onmouseenter="this.style.background=\'#2a2f3a\'" onmouseleave="this.style.background=\'transparent\'">' +
      '<td style="padding:8px 10px;border-bottom:1px solid #2a2f3a;color:#b0b0b0;font-size:12px">' + m + '</td>' +
      '<td style="padding:8px 10px;border-bottom:1px solid #2a2f3a;color:#fff;text-align:center">' + d.streams + '</td>' +
      '<td style="padding:8px 10px;border-bottom:1px solid #2a2f3a;color:#9146ff;font-weight:bold;text-align:center">' + avgV + '</td>' +
      '<td style="padding:8px 10px;border-bottom:1px solid #2a2f3a;color:#ff9800;text-align:center">' + d.peak + '</td>' +
      '<td style="padding:8px 10px;border-bottom:1px solid #2a2f3a;color:#4caf50;text-align:center">' + d.hours.toFixed(1) + 'h</td>' +
      '<td style="padding:8px 10px;border-bottom:1px solid #2a2f3a;color:#e91e63;text-align:center">' + d.follows + '</td>' +
      '<td style="padding:8px 10px;border-bottom:1px solid #2a2f3a;color:#ffd700;text-align:center">' + d.subs + '</td></tr>';
  });

  // Date range
  const firstStreamDate = h.length > 0 ? new Date(h[h.length - 1].startedAt || h[h.length - 1].date).toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' }) : 'N/A';
  const lastStreamDate = h.length > 0 ? new Date(h[0].startedAt || h[0].date).toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' }) : 'N/A';
  const daySpan = h.length >= 2 ? Math.ceil((new Date(h[0].startedAt || h[0].date).getTime() - new Date(h[h.length - 1].startedAt || h[h.length - 1].date).getTime()) / (1000 * 60 * 60 * 24)) : 0;

  // Achievements/Milestones
  const achievements = [];
  if (totalStreams >= 1) achievements.push({ icon: 'ðŸŽ¬', label: 'First Stream', desc: 'Completed your first stream!' });
  if (totalStreams >= 10) achievements.push({ icon: 'ðŸ”Ÿ', label: '10 Streams', desc: 'Reached 10 total streams' });
  if (totalStreams >= 25) achievements.push({ icon: 'ðŸŽ¯', label: '25 Streams', desc: 'Quarter century of streams!' });
  if (totalStreams >= 50) achievements.push({ icon: 'ðŸ…', label: '50 Streams', desc: 'Half a hundred!' });
  if (totalStreams >= 100) achievements.push({ icon: 'ðŸ’¯', label: 'Centurion', desc: '100 streams completed' });
  if (totalHours >= 10) achievements.push({ icon: 'â°', label: '10 Hours', desc: '10 hours of total streaming' });
  if (totalHours >= 50) achievements.push({ icon: 'âŒ›', label: '50 Hours', desc: '50 hours streamed' });
  if (totalHours >= 100) achievements.push({ icon: 'ðŸ•', label: '100 Hours', desc: 'Triple digit hours!' });
  if (peakViewersAll >= 50) achievements.push({ icon: 'ðŸ‘€', label: '50 Peak', desc: 'Reached 50 peak viewers' });
  if (peakViewersAll >= 100) achievements.push({ icon: 'ðŸ”¥', label: '100 Peak', desc: 'Hit 100 peak viewers' });
  if (peakViewersAll >= 500) achievements.push({ icon: 'ðŸŒŸ', label: '500 Peak', desc: '500 viewer milestone!' });
  if (uniqueGames >= 5) achievements.push({ icon: 'ðŸŽ®', label: 'Variety Pro', desc: 'Played 5+ different games' });
  if (uniqueGames >= 10) achievements.push({ icon: 'ðŸŒˆ', label: 'Game Explorer', desc: 'Streamed 10+ unique games' });
  if (bestStreak >= 5) achievements.push({ icon: 'ðŸ”¥', label: 'Hot Streak', desc: '5+ above-avg streams in a row' });
  if (totalFollowers >= 100) achievements.push({ icon: 'â¤ï¸', label: '100 Follows', desc: 'Earned 100 followers' });
  if (totalSubs >= 50) achievements.push({ icon: 'â­', label: '50 Subs', desc: 'Gained 50 subscribers' });
  let achievementsHtml = '';
  achievements.forEach(a => {
    achievementsHtml += '<div style="background:#26262c;padding:12px 15px;border-radius:6px;display:flex;align-items:center;gap:12px">' +
      '<span style="font-size:24px">' + a.icon + '</span>' +
      '<div><div style="color:#fff;font-weight:bold;font-size:13px">' + a.label + '</div>' +
      '<div style="color:#666;font-size:11px">' + a.desc + '</div></div></div>';
  });

  // Stream history table (last 30 now with more columns)
  const last30 = h.slice(-30).reverse();
  let historyTableHtml = '';
  last30.forEach((s, idx) => {
    const date = new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: '2-digit' });
    const game = s.game || s.gameName || 'Unknown';
    const dur = ((s.durationMinutes || 0) / 60).toFixed(1);
    const peak = s.peakViewers || 0;
    const avg = s.averageViewers || peak;
    const fol = s.followers || s.newFollowers || 0;
    const sub = s.subscribers || s.newSubs || 0;
    const viewerColor = peak >= avgViewers ? '#4caf50' : '#ef5350';
    const dayName = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][new Date(s.startedAt || s.date).getDay()];
    historyTableHtml += '<tr style="transition:background 0.2s" onmouseenter="this.style.background=\'#2a2f3a\'" onmouseleave="this.style.background=\'transparent\'">' +
      '<td style="padding:8px 6px;border-bottom:1px solid #2a2f3a;color:#b0b0b0;font-size:11px">' + date + '</td>' +
      '<td style="padding:8px 6px;border-bottom:1px solid #2a2f3a;color:#666;font-size:11px">' + dayName + '</td>' +
      '<td style="padding:8px 6px;border-bottom:1px solid #2a2f3a;font-size:12px">' + game + '</td>' +
      '<td style="padding:8px 6px;border-bottom:1px solid #2a2f3a;color:' + viewerColor + ';font-weight:bold;text-align:center;font-size:12px">' + peak + '</td>' +
      '<td style="padding:8px 6px;border-bottom:1px solid #2a2f3a;color:#b0b0b0;text-align:center;font-size:12px">' + avg + '</td>' +
      '<td style="padding:8px 6px;border-bottom:1px solid #2a2f3a;color:#b0b0b0;text-align:center;font-size:12px">' + dur + 'h</td>' +
      '<td style="padding:8px 6px;border-bottom:1px solid #2a2f3a;color:#e91e63;text-align:center;font-size:12px">' + fol + '</td>' +
      '<td style="padding:8px 6px;border-bottom:1px solid #2a2f3a;color:#ffd700;text-align:center;font-size:12px">' + sub + '</td></tr>';
  });

  // Game summary for report
  const gameStats = {};
  h.forEach(s => {
    const g = s.game || s.gameName || 'Unknown';
    if (!gameStats[g]) gameStats[g] = { streams: 0, totalViewers: 0, hours: 0 };
    gameStats[g].streams++;
    gameStats[g].totalViewers += (s.peakViewers || 0);
    gameStats[g].hours += (s.durationMinutes || 0) / 60;
  });
  const topGamesArr = Object.entries(gameStats).sort((a, b) => (b[1].totalViewers / b[1].streams) - (a[1].totalViewers / a[1].streams)).slice(0, 5);
  let topGamesHtml = '';
  topGamesArr.forEach((g, i) => {
    const pct = totalStreams > 0 ? Math.round((g[1].streams / totalStreams) * 100) : 0;
    topGamesHtml += '<div style="display:flex;align-items:center;gap:10px;margin-bottom:8px">' +
      '<span style="color:#ffd700;font-weight:bold;width:20px">#' + (i + 1) + '</span>' +
      '<span style="color:#fff;flex:1">' + g[0] + '</span>' +
      '<span style="color:#9146ff;font-size:12px">' + g[1].streams + ' streams</span>' +
      '<span style="color:#b0b0b0;font-size:12px">' + pct + '%</span></div>';
  });

  return '<div class="card">' +
  '<h2>ðŸ“‹ Reports & Export</h2>' +
  '<div style="display:flex;gap:10px;flex-wrap:wrap;margin:15px 0">' +
    '<button class="small" style="background:#4caf50;color:#fff;border:none;cursor:pointer;padding:10px 20px;border-radius:6px;font-weight:bold" onclick="exportAsJSON()">ðŸ“¥ Export JSON</button>' +
    '<button class="small" style="background:#2196f3;color:#fff;border:none;cursor:pointer;padding:10px 20px;border-radius:6px;font-weight:bold" onclick="exportAsCSV()">ðŸ“¥ Export CSV</button>' +
  '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ† Streamer Level</h3>' +
  '<div style="display:flex;align-items:center;gap:20px;margin-top:15px">' +
    '<div style="text-align:center">' +
      '<div style="font-size:48px">ðŸŽ®</div>' +
      '<div style="color:#ffd700;font-weight:bold;font-size:28px">Lv.' + streamerLevel + '</div>' +
      '<div style="color:#b0b0b0;font-size:12px">' + levelTitle + '</div>' +
    '</div>' +
    '<div style="flex:1">' +
      '<div style="display:flex;justify-content:space-between;margin-bottom:5px">' +
        '<span style="color:#b0b0b0;font-size:12px">XP: ' + xpTotal.toLocaleString() + '</span>' +
        '<span style="color:#b0b0b0;font-size:12px">Next: ' + nextLevelXP.toLocaleString() + '</span>' +
      '</div>' +
      '<div style="background:#1a1a2e;border-radius:6px;height:24px;overflow:hidden">' +
        '<div style="background:linear-gradient(90deg,#9146ff,#ffd700);height:100%;width:' + xpProgress + '%;border-radius:6px;transition:width 0.5s"></div>' +
      '</div>' +
      '<div style="color:#666;font-size:11px;margin-top:5px">Streams x100 + Hours x50 + Follows x10 + Subs x25 + Peak x5</div>' +
    '</div>' +
  '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ“Š Channel Summary</h3>' +
  '<div style="color:#b0b0b0;font-size:12px;margin-bottom:10px">' + firstStreamDate + ' to ' + lastStreamDate + ' (' + daySpan + ' days)</div>' +
  '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px;margin-top:10px">' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:11px">Total Streams</div>' +
      '<div style="font-size:24px;color:#9146ff;font-weight:bold">' + totalStreams + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:11px">Total Hours</div>' +
      '<div style="font-size:24px;color:#4caf50;font-weight:bold">' + totalHours.toFixed(1) + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:11px">All-Time Peak</div>' +
      '<div style="font-size:24px;color:#ff9800;font-weight:bold">' + peakViewersAll + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:11px">Avg Peak</div>' +
      '<div style="font-size:24px;color:#2196f3;font-weight:bold">' + avgViewers + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:11px">Median Peak</div>' +
      '<div style="font-size:24px;color:#00bcd4;font-weight:bold">' + medianViewers + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:11px">Avg Duration</div>' +
      '<div style="font-size:24px;color:#ab47bc;font-weight:bold">' + avgDuration + 'h</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:11px">Unique Games</div>' +
      '<div style="font-size:24px;color:#795548;font-weight:bold">' + uniqueGames + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:11px">Viewer-Hours</div>' +
      '<div style="font-size:24px;color:#009688;font-weight:bold">' + Math.round(totalViewerHours).toLocaleString() + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:11px">Total Follows</div>' +
      '<div style="font-size:24px;color:#e91e63;font-weight:bold">' + totalFollowers + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:11px">Total Subs</div>' +
      '<div style="font-size:24px;color:#ffd700;font-weight:bold">' + totalSubs + '</div>' +
    '</div>' +
  '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ… Personal Records</h3>' +
  '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:15px;margin-top:10px">' +
    '<div style="background:#26262c;padding:18px;border-radius:6px;border-left:3px solid #ffd700">' +
      '<div style="font-size:18px;margin-bottom:5px">ðŸ‘‘ Most Viewed</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + (bestStream.peakViewers || 0) + ' viewers</div>' +
      '<div style="color:#b0b0b0;font-size:12px;margin-top:4px">' + bestStreamGame + ' â€” ' + bestStreamDate + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:18px;border-radius:6px;border-left:3px solid #9146ff">' +
      '<div style="font-size:18px;margin-bottom:5px">â±ï¸ Longest Stream</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + longestHrs + ' hours</div>' +
      '<div style="color:#b0b0b0;font-size:12px;margin-top:4px">' + longestGame + ' â€” ' + longestDate + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:18px;border-radius:6px;border-left:3px solid #4caf50">' +
      '<div style="font-size:18px;margin-bottom:5px">âš¡ Shortest Stream</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + shortestHrs + ' hours</div>' +
      '<div style="color:#b0b0b0;font-size:12px;margin-top:4px">' + shortestGame + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:18px;border-radius:6px;border-left:3px solid #e91e63">' +
      '<div style="font-size:18px;margin-bottom:5px">â¤ï¸ Most Follows</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + bestFollows + ' in one stream</div>' +
      '<div style="color:#b0b0b0;font-size:12px;margin-top:4px">' + bestFollowGame + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:18px;border-radius:6px;border-left:3px solid #ff9800">' +
      '<div style="font-size:18px;margin-bottom:5px">â­ Most Subs</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + bestSubsCount + ' in one stream</div>' +
      '<div style="color:#b0b0b0;font-size:12px;margin-top:4px">' + bestSubGame + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:18px;border-radius:6px;border-left:3px solid #2196f3">' +
      '<div style="font-size:18px;margin-bottom:5px">ðŸ”¥ Best Hot Streak</div>' +
      '<div style="color:#fff;font-weight:bold;font-size:18px">' + bestStreak + ' streams above avg</div>' +
      '<div style="color:#b0b0b0;font-size:12px;margin-top:4px">Cold streak record: ' + worstCold + ' below avg</div>' +
    '</div>' +
  '</div>' +
'</div>' +

(achievementsHtml ? '<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸŽ–ï¸ Achievements Unlocked (' + achievements.length + ')</h3>' +
  '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px;margin-top:10px">' +
    achievementsHtml +
  '</div>' +
'</div>' : '') +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸŽ® Top Games Summary</h3>' +
  '<div style="margin-top:10px">' + topGamesHtml + '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ“… Monthly Breakdown</h3>' +
  '<div style="overflow-x:auto">' +
  '<table style="width:100%;border-collapse:collapse;margin-top:10px">' +
    '<thead><tr style="background:#26262c">' +
      '<th style="padding:8px 10px;text-align:left;font-size:12px">Month</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Streams</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Avg Peak</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Best</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Hours</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Follows</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Subs</th>' +
    '</tr></thead>' +
    '<tbody>' + (monthlyTableHtml || '<tr><td colspan="7" style="padding:20px;text-align:center;color:#b0b0b0">No data</td></tr>') + '</tbody>' +
  '</table></div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ“œ Stream History (Last 30)</h3>' +
  '<div style="overflow-x:auto">' +
  '<table style="width:100%;border-collapse:collapse;margin-top:10px">' +
    '<thead><tr style="background:#26262c">' +
      '<th style="padding:8px 6px;text-align:left;font-size:11px">Date</th>' +
      '<th style="padding:8px 6px;text-align:left;font-size:11px">Day</th>' +
      '<th style="padding:8px 6px;text-align:left;font-size:11px">Game</th>' +
      '<th style="padding:8px 6px;text-align:center;font-size:11px">Peak</th>' +
      '<th style="padding:8px 6px;text-align:center;font-size:11px">Avg</th>' +
      '<th style="padding:8px 6px;text-align:center;font-size:11px">Dur</th>' +
      '<th style="padding:8px 6px;text-align:center;font-size:11px">Fol</th>' +
      '<th style="padding:8px 6px;text-align:center;font-size:11px">Sub</th>' +
    '</tr></thead>' +
    '<tbody>' + (historyTableHtml || '<tr><td colspan="8" style="padding:20px;text-align:center;color:#b0b0b0">No stream history</td></tr>') + '</tbody>' +
  '</table></div>' +
'</div>' +

(function() {
  var titledStreams = h.filter(function(s) { return s.title && s.title.length > 0; });
  if (titledStreams.length < 2) return '';
  
  var recent15 = titledStreams.slice(-15).reverse();
  var titleTableHtml = '';
  recent15.forEach(function(s, i) {
    var date = new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    var game = s.game || s.gameName || 'Unknown';
    var peak = s.peakViewers || 0;
    var titleLen = s.title.length;
    var rowBg = i % 2 === 0 ? '#26262c' : '#1e1e24';
    titleTableHtml += '<tr style="background:' + rowBg + '">' +
      '<td style="padding:6px 8px;font-size:11px;color:#b0b0b0">' + date + '</td>' +
      '<td style="padding:6px 8px;font-size:11px;color:#fff;max-width:300px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="' + s.title.replace(/"/g, '&quot;') + '">' + s.title.substring(0, 80) + (s.title.length > 80 ? '...' : '') + '</td>' +
      '<td style="padding:6px 8px;font-size:11px;color:#ce93d8;text-align:center">' + game + '</td>' +
      '<td style="padding:6px 8px;font-size:12px;color:#ffd700;text-align:center;font-weight:bold">' + peak + '</td>' +
      '<td style="padding:6px 8px;font-size:11px;color:#666;text-align:center">' + titleLen + '</td>' +
    '</tr>';
  });
  
  var uniqueTitles = new Set(titledStreams.map(function(s) { return s.title; }));
  var reuseRate = titledStreams.length > 0 ? Math.round(((titledStreams.length - uniqueTitles.size) / titledStreams.length) * 100) : 0;
  
  return '<div class="card" style="margin-top:15px">' +
    '<h3 style="margin-top:0">ðŸ“ Stream Title History</h3>' +
    '<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin:10px 0">' +
      '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Total Titled</div><div style="font-size:18px;color:#9146ff;font-weight:bold">' + titledStreams.length + '</div></div>' +
      '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Unique Titles</div><div style="font-size:18px;color:#4caf50;font-weight:bold">' + uniqueTitles.size + '</div></div>' +
      '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Reuse Rate</div><div style="font-size:18px;color:#ff9800;font-weight:bold">' + reuseRate + '%</div></div>' +
    '</div>' +
    '<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;margin-top:8px">' +
      '<thead><tr style="background:#26262c">' +
        '<th style="padding:6px 8px;text-align:left;font-size:11px">Date</th>' +
        '<th style="padding:6px 8px;text-align:left;font-size:11px">Title</th>' +
        '<th style="padding:6px 8px;text-align:center;font-size:11px">Game</th>' +
        '<th style="padding:6px 8px;text-align:center;font-size:11px">Peak</th>' +
        '<th style="padding:6px 8px;text-align:center;font-size:11px">Len</th>' +
      '</tr></thead>' +
      '<tbody>' + titleTableHtml + '</tbody>' +
    '</table></div>' +
  '</div>';
})() +

(function() {
  var sugs = suggestions || [];
  if (sugs.length < 1) return '';
  var totalSugs = sugs.length;
  var statusCounts = {};
  sugs.forEach(function(s) { var st = s.status || 'Pending'; statusCounts[st] = (statusCounts[st] || 0) + 1; });
  var totalUpvotes = sugs.reduce(function(s, x) { return s + (x.upvotes || 0); }, 0);
  var topSug = sugs.slice().sort(function(a, b) { return (b.upvotes || 0) - (a.upvotes || 0); })[0];
  var uniqueSuggesters = new Set(sugs.map(function(s) { return s.user || s.userId; })).size;
  
  var statusHtml = '';
  var statusColors = { 'Pending': '#ff9800', 'In Progress': '#2196f3', 'Completed': '#4caf50', 'Rejected': '#ef5350' };
  Object.entries(statusCounts).forEach(function(e) {
    var color = statusColors[e[0]] || '#666';
    statusHtml += '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center;border-top:3px solid ' + color + '">' +
      '<div style="color:#b0b0b0;font-size:10px">' + e[0] + '</div>' +
      '<div style="font-size:20px;color:' + color + ';font-weight:bold">' + e[1] + '</div></div>';
  });
  
  return '<div class="card" style="margin-top:15px">' +
    '<h3 style="margin-top:0">ðŸ’¡ Suggestion Analytics</h3>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:10px;margin:10px 0">' +
      '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Total</div><div style="font-size:18px;color:#9146ff;font-weight:bold">' + totalSugs + '</div></div>' +
      '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Upvotes</div><div style="font-size:18px;color:#ffd700;font-weight:bold">' + totalUpvotes + '</div></div>' +
      '<div style="background:#26262c;padding:10px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Suggesters</div><div style="font-size:18px;color:#4caf50;font-weight:bold">' + uniqueSuggesters + '</div></div>' +
      statusHtml +
    '</div>' +
    (topSug ? '<div style="padding:10px;background:#26262c;border-radius:6px;border-left:3px solid #ffd700;margin-top:8px">' +
      '<div style="font-size:12px;color:#ffd700;font-weight:bold">Top Suggestion (' + (topSug.upvotes || 0) + ' upvotes)</div>' +
      '<div style="color:#fff;font-size:12px;margin-top:4px">"' + (topSug.suggestion || '').substring(0, 120) + '"</div>' +
      '<div style="color:#666;font-size:10px;margin-top:3px">by ' + (topSug.user || 'Unknown') + ' | ' + (topSug.status || 'Pending') + '</div>' +
    '</div>' : '') +
  '</div>';
})() +

'<div style="text-align:center;margin-top:15px;padding:10px;color:#666;font-size:11px">' +
  'Report generated: ' + new Date().toLocaleString() + ' | Data spans ' + totalStreams + ' streams over ' + daySpan + ' days | Streamer Level ' + streamerLevel + ' (' + levelTitle + ')' +
'</div>' +

'<script>' +
'function exportAsJSON() {' +
  'var data = JSON.stringify((window.analyticsData || { history: history }), null, 2);' +
  'var blob = new Blob([data], { type: "application/json" });' +
  'var url = URL.createObjectURL(blob);' +
  'var a = document.createElement("a");' +
  'a.href = url;' +
  'a.download = "stream_analytics_" + new Date().toISOString().split("T")[0] + ".json";' +
  'a.click();' +
  'URL.revokeObjectURL(url);' +
'}' +
'function exportAsCSV() {' +
  'var h = (window.analyticsData || { history: history }).history;' +
  'if (!h || !h.length) { alert("No data to export"); return; }' +
  'var headers = ["Date","Game","Peak Viewers","Avg Viewers","Duration (min)","Followers","Subscribers"];' +
  'var rows = h.map(function(s) { return [' +
    'new Date(s.startedAt || s.date).toISOString().split("T")[0],' +
    '(s.game || s.gameName || "Unknown").replace(/,/g, " "),' +
    's.peakViewers || 0,' +
    's.averageViewers || s.peakViewers || 0,' +
    's.durationMinutes || 0,' +
    's.followers || s.newFollowers || 0,' +
    's.subscribers || s.newSubs || 0' +
  ']; });' +
  'var csv = [headers.join(",")].concat(rows.map(function(r) { return r.join(","); })).join("\\n");' +
  'var blob = new Blob([csv], { type: "text/csv" });' +
  'var url = URL.createObjectURL(blob);' +
  'var a = document.createElement("a");' +
  'a.href = url;' +
  'a.download = "stream_stats_" + new Date().toISOString().split("T")[0] + ".csv";' +
  'a.click();' +
  'URL.revokeObjectURL(url);' +
'}' +
'</script>';
}

function renderCommunityStatsTab() {
  // ===== LEVELING DATA =====
  const levelEntries = Object.entries(leveling || {});
  const totalMembers = levelEntries.length;
  const totalXP = levelEntries.reduce(function(s, e) { return s + (e[1].xp || 0); }, 0);
  const avgXP = totalMembers > 0 ? Math.round(totalXP / totalMembers) : 0;
  const avgLevel = totalMembers > 0 ? (levelEntries.reduce(function(s, e) { return s + (e[1].level || 0); }, 0) / totalMembers).toFixed(1) : '0.0';
  const maxLevel = levelEntries.reduce(function(best, e) { return (e[1].level || 0) > (best[1].level || 0) ? e : best; }, ['', {level: 0, xp: 0}]);
  const topByXP = levelEntries.map(function(e) { return { id: e[0], xp: e[1].xp || 0, level: e[1].level || 0, lastMsg: e[1].lastMsg || 0 }; }).sort(function(a, b) { return b.xp - a.xp; });
  const top10 = topByXP.slice(0, 10);

  // Level distribution buckets
  var lvlDist = { '0': 0, '1-5': 0, '6-10': 0, '11-15': 0, '16-20': 0, '21-25': 0, '26-30': 0, '31+': 0 };
  levelEntries.forEach(function(e) {
    var lv = e[1].level || 0;
    if (lv === 0) lvlDist['0']++;
    else if (lv <= 5) lvlDist['1-5']++;
    else if (lv <= 10) lvlDist['6-10']++;
    else if (lv <= 15) lvlDist['11-15']++;
    else if (lv <= 20) lvlDist['16-20']++;
    else if (lv <= 25) lvlDist['21-25']++;
    else if (lv <= 30) lvlDist['26-30']++;
    else lvlDist['31+']++;
  });
  var lvlDistMax = Math.max.apply(null, Object.values(lvlDist).concat([1]));
  var lvlDistHtml = '';
  Object.entries(lvlDist).forEach(function(entry) {
    var pct = Math.round((entry[1] / lvlDistMax) * 100);
    lvlDistHtml += '<div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">' +
      '<span style="color:#b0b0b0;width:50px;font-size:12px;text-align:right">Lv ' + entry[0] + '</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:22px;overflow:hidden"><div style="background:linear-gradient(90deg,#9146ff,#ce93d8);height:100%;width:' + pct + '%;border-radius:3px;display:flex;align-items:center;padding-left:6px"><span style="font-size:10px;color:#fff;font-weight:bold">' + (entry[1] > 0 ? entry[1] : '') + '</span></div></div></div>';
  });

  // Active members (messaged in last 7 days)
  var sevenDaysAgo = Date.now() - 7 * 24 * 60 * 60 * 1000;
  var thirtyDaysAgo = Date.now() - 30 * 24 * 60 * 60 * 1000;
  var activeWeek = levelEntries.filter(function(e) { return (e[1].lastMsg || 0) > sevenDaysAgo; }).length;
  var activeMonth = levelEntries.filter(function(e) { return (e[1].lastMsg || 0) > thirtyDaysAgo; }).length;
  var dormant = totalMembers - activeMonth;
  var activityRate = totalMembers > 0 ? Math.round((activeWeek / totalMembers) * 100) : 0;

  // Top 10 table
  var top10Html = '';
  top10.forEach(function(u, i) {
    var rankIcon = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : i === 2 ? 'ðŸ¥‰' : '#' + (i + 1);
    var lastActive = u.lastMsg > 0 ? new Date(u.lastMsg).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : 'N/A';
    var rowBg = i % 2 === 0 ? '#26262c' : '#1e1e24';
    top10Html += '<tr style="background:' + rowBg + '">' +
      '<td style="padding:8px 10px;font-size:13px">' + rankIcon + '</td>' +
      '<td style="padding:8px 10px;font-size:12px;color:#b0b0b0">' + u.id + '</td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:13px;color:#9146ff;font-weight:bold">' + u.level + '</td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:13px;color:#ffd700;font-weight:bold">' + u.xp.toLocaleString() + '</td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:11px;color:#666">' + lastActive + '</td>' +
    '</tr>';
  });

  // ===== COMMAND USAGE DATA =====
  var cmdUsage = commandUsage || {};
  var cmdEntries = Object.entries(cmdUsage);
  var totalCmdUses = cmdEntries.reduce(function(s, e) { return s + (e[1].total || 0); }, 0);
  var uniqueCmdUsers = new Set();
  cmdEntries.forEach(function(e) {
    if (e[1].userCounts) Object.keys(e[1].userCounts).forEach(function(uid) { uniqueCmdUsers.add(uid); });
  });
  var cmdsSorted = cmdEntries.map(function(e) {
    var userCount = e[1].userCounts ? Object.keys(e[1].userCounts).length : 0;
    var lastUsedStr = e[1].lastUsed ? new Date(e[1].lastUsed).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : 'Never';
    return { name: e[0], total: e[1].total || 0, users: userCount, lastUsed: lastUsedStr };
  }).sort(function(a, b) { return b.total - a.total; });
  var cmdMaxUse = cmdsSorted.length > 0 ? cmdsSorted[0].total : 1;

  var cmdTableHtml = '';
  cmdsSorted.forEach(function(c, i) {
    var pct = Math.round((c.total / cmdMaxUse) * 100);
    var rowBg = i % 2 === 0 ? '#26262c' : '#1e1e24';
    cmdTableHtml += '<tr style="background:' + rowBg + '">' +
      '<td style="padding:8px 10px;font-size:13px;color:#ce93d8;font-weight:bold">/' + c.name + '</td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:13px;color:#fff;font-weight:bold">' + c.total + '</td>' +
      '<td style="padding:8px 10px"><div style="background:#1a1a2e;border-radius:3px;height:16px;overflow:hidden"><div style="background:#9146ff;height:100%;width:' + pct + '%;border-radius:3px"></div></div></td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:12px;color:#b0b0b0">' + c.users + '</td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:11px;color:#666">' + c.lastUsed + '</td>' +
    '</tr>';
  });

  // Top command users across all commands
  var userCmdTotals = {};
  cmdEntries.forEach(function(e) {
    if (e[1].userCounts) {
      Object.entries(e[1].userCounts).forEach(function(uc) {
        if (!userCmdTotals[uc[0]]) userCmdTotals[uc[0]] = { username: uc[1].username || uc[0], total: 0 };
        userCmdTotals[uc[0]].total += uc[1].count || 0;
      });
    }
  });
  var topCmdUsers = Object.entries(userCmdTotals).map(function(e) { return { id: e[0], username: e[1].username, total: e[1].total }; }).sort(function(a, b) { return b.total - a.total; }).slice(0, 5);
  var topCmdUsersHtml = '';
  topCmdUsers.forEach(function(u, i) {
    var icon = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : i === 2 ? 'ðŸ¥‰' : 'ðŸ…';
    topCmdUsersHtml += '<div style="display:flex;align-items:center;gap:10px;padding:10px;background:#26262c;border-radius:6px;margin-bottom:6px">' +
      '<span style="font-size:18px">' + icon + '</span>' +
      '<span style="color:#fff;font-weight:bold;flex:1">' + u.username + '</span>' +
      '<span style="color:#9146ff;font-weight:bold">' + u.total + ' uses</span></div>';
  });

  // Command usage over time (by day of week)
  var cmdByDay = { Sun: 0, Mon: 0, Tue: 0, Wed: 0, Thu: 0, Fri: 0, Sat: 0 };
  var dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  cmdEntries.forEach(function(e) {
    if (e[1].history) {
      e[1].history.forEach(function(h) {
        if (h.timestamp) {
          var day = new Date(h.timestamp).getDay();
          cmdByDay[dayNames[day]]++;
        }
      });
    }
  });
  var cmdDayMax = Math.max.apply(null, Object.values(cmdByDay).concat([1]));
  var cmdDayHtml = '';
  dayNames.forEach(function(day) {
    var pct = Math.round((cmdByDay[day] / cmdDayMax) * 100);
    var color = cmdByDay[day] === cmdDayMax ? '#9146ff' : '#555';
    cmdDayHtml += '<div style="flex:1;text-align:center">' +
      '<div style="height:80px;display:flex;flex-direction:column;justify-content:flex-end;align-items:center">' +
        '<div style="width:24px;background:' + color + ';height:' + Math.max(pct, 5) + '%;border-radius:3px 3px 0 0"></div>' +
      '</div>' +
      '<div style="font-size:10px;color:#b0b0b0;margin-top:4px">' + day + '</div>' +
      '<div style="font-size:10px;color:#666">' + cmdByDay[day] + '</div></div>';
  });

  // ===== CUSTOM COMMANDS =====
  var custCmds = (customCommands || []).slice().sort(function(a, b) { return (b.uses || 0) - (a.uses || 0); });
  var totalCustUses = custCmds.reduce(function(s, c) { return s + (c.uses || 0); }, 0);
  var custMax = custCmds.length > 0 ? (custCmds[0].uses || 1) : 1;
  var custCmdsHtml = '';
  custCmds.forEach(function(c, i) {
    var pct = Math.round(((c.uses || 0) / custMax) * 100);
    var rankColor = i === 0 ? '#ffd700' : i === 1 ? '#c0c0c0' : i === 2 ? '#cd7f32' : '#666';
    custCmdsHtml += '<div style="display:flex;align-items:center;gap:10px;margin-bottom:8px">' +
      '<span style="color:' + rankColor + ';font-weight:bold;width:20px;text-align:center;font-size:13px">' + (i + 1) + '</span>' +
      '<span style="color:#ce93d8;font-weight:bold;width:120px;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">!' + (c.name || c.command || '???') + '</span>' +
      '<div style="flex:1;background:#1a1a2e;border-radius:3px;height:20px;overflow:hidden"><div style="background:linear-gradient(90deg,#ff9800,#ffb74d);height:100%;width:' + pct + '%;border-radius:3px;display:flex;align-items:center;padding-left:6px"><span style="font-size:10px;color:#fff;font-weight:bold">' + (c.uses || 0) + '</span></div></div></div>';
  });

  // ===== GIVEAWAYS =====
  var ga = giveaways || [];
  var totalGiveaways = ga.length;
  var totalGAEntries = ga.reduce(function(s, g) { return s + (g.entryCount || (g._entriesCache ? g._entriesCache.entries.length : 0) || 0); }, 0);
  var avgGAEntries = totalGiveaways > 0 ? (totalGAEntries / totalGiveaways).toFixed(1) : '0';
  var gaHtml = '';
  ga.forEach(function(g, i) {
    var entryCount = g.entryCount || (g._entriesCache ? g._entriesCache.entries.length : 0) || 0;
    var winnerCount = g.winners ? g.winners.length : 0;
    var endDate = g.endTime ? new Date(g.endTime).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) : 'Unknown';
    var status = g.active ? 'ðŸŸ¢ Active' : 'ðŸ”´ Ended';
    var rowBg = i % 2 === 0 ? '#26262c' : '#1e1e24';
    gaHtml += '<tr style="background:' + rowBg + '">' +
      '<td style="padding:8px 10px;font-size:13px;color:#fff">' + (g.prize || 'Unknown') + '</td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:12px">' + status + '</td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:13px;color:#ffd700;font-weight:bold">' + entryCount + '</td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:13px;color:#4caf50;font-weight:bold">' + winnerCount + '</td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:11px;color:#b0b0b0">' + endDate + '</td>' +
      '<td style="padding:8px 10px;text-align:center;font-size:11px;color:#666">' + (g.createdBy || 'Unknown') + '</td>' +
    '</tr>';
  });

  // ===== POLLS =====
  var pl = polls || [];
  var totalPolls = pl.length;
  var totalPollVotes = pl.reduce(function(s, p) { return s + (p.results ? p.results.reduce(function(vs, r) { return vs + (r.votes || 0); }, 0) : 0); }, 0);
  var pollsHtml = '';
  pl.forEach(function(p) {
    var totalV = p.results ? p.results.reduce(function(s, r) { return s + (r.votes || 0); }, 0) : 0;
    pollsHtml += '<div style="background:#26262c;padding:15px;border-radius:8px;margin-bottom:12px">' +
      '<div style="font-weight:bold;color:#fff;font-size:14px;margin-bottom:10px">ðŸ“Š ' + (p.question || 'Unknown Poll') + '</div>' +
      '<div style="color:#666;font-size:11px;margin-bottom:10px">' + (p.active ? 'ðŸŸ¢ Active' : 'ðŸ”´ Ended') + ' | ' + totalV + ' total votes</div>';
    if (p.results) {
      p.results.forEach(function(r) {
        var pct = totalV > 0 ? Math.round((r.votes / totalV) * 100) : 0;
        var isWinner = r.votes === Math.max.apply(null, p.results.map(function(x) { return x.votes || 0; })) && r.votes > 0;
        pollsHtml += '<div style="margin-bottom:6px">' +
          '<div style="display:flex;justify-content:space-between;margin-bottom:3px">' +
            '<span style="color:#b0b0b0;font-size:12px">' + (isWinner ? 'ðŸ‘‘ ' : '') + r.option + '</span>' +
            '<span style="color:#fff;font-size:12px;font-weight:bold">' + r.votes + ' (' + pct + '%)</span>' +
          '</div>' +
          '<div style="background:#1a1a2e;border-radius:3px;height:18px;overflow:hidden"><div style="background:' + (isWinner ? 'linear-gradient(90deg,#ffd700,#ffb74d)' : 'linear-gradient(90deg,#9146ff,#ce93d8)') + ';height:100%;width:' + pct + '%;border-radius:3px"></div></div>' +
        '</div>';
      });
    }
    pollsHtml += '</div>';
  });

  // ===== NOTIFICATION HISTORY =====
  var nh = notificationHistory || [];
  var totalNotifs = nh.length;
  var notifTypes = {};
  nh.forEach(function(n) {
    var t = n.type || 'unknown';
    notifTypes[t] = (notifTypes[t] || 0) + 1;
  });
  var notifTypesHtml = '';
  var notifColors = { live: '#4caf50', offline: '#ef5350', follow: '#e91e63', game: '#9146ff', title: '#ff9800', viewer: '#2196f3', raid: '#ffd700', clip: '#00bcd4' };
  Object.entries(notifTypes).sort(function(a, b) { return b[1] - a[1]; }).forEach(function(nt) {
    var color = notifColors[nt[0]] || '#666';
    notifTypesHtml += '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center;border-top:3px solid ' + color + '">' +
      '<div style="color:#b0b0b0;font-size:10px;text-transform:uppercase">' + nt[0] + '</div>' +
      '<div style="font-size:20px;color:' + color + ';font-weight:bold;margin-top:4px">' + nt[1] + '</div></div>';
  });

  // ===== SCHEDULE OVERVIEW =====
  var sched = schedule || {};
  var weekly = sched.weekly || {};
  var schedHtml = '';
  var schedDays = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
  var schedLabels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
  schedDays.forEach(function(day, i) {
    var s = weekly[day];
    if (s) {
      var hour = s.hour || 0;
      var min = s.minute || 0;
      var ampm = hour >= 12 ? 'PM' : 'AM';
      var h12 = hour > 12 ? hour - 12 : (hour === 0 ? 12 : hour);
      var timeStr = h12 + ':' + (min < 10 ? '0' : '') + min + ' ' + ampm;
      var isWeekend = i >= 5;
      var bg = isWeekend ? '#2a1f3d' : '#26262c';
      schedHtml += '<div style="background:' + bg + ';padding:12px;border-radius:6px;text-align:center;border-left:3px solid ' + (isWeekend ? '#e91e63' : '#9146ff') + '">' +
        '<div style="color:#b0b0b0;font-size:11px;font-weight:bold">' + schedLabels[i] + '</div>' +
        '<div style="font-size:16px;color:#fff;font-weight:bold;margin-top:4px">' + timeStr + '</div></div>';
    }
  });

  // ===== VIEWER GRAPH HISTORY =====
  var vgh = viewerGraphHistory || [];
  var avgRampUp = 0;
  var avgPeakTime = 0;
  var avgViewerDrop = 0;
  if (vgh.length > 0) {
    var rampUps = [];
    var peakTimes = [];
    var drops = [];
    vgh.forEach(function(stream) {
      if (stream.data && stream.data.length > 10) {
        var peak = 0;
        var peakIdx = 0;
        stream.data.forEach(function(dp, idx) {
          if ((dp.viewers || 0) > peak) { peak = dp.viewers; peakIdx = idx; }
        });
        if (peakIdx > 0 && stream.data[0].timestamp) {
          var rampMinutes = Math.round((stream.data[peakIdx].timestamp - stream.data[0].timestamp) / 60000);
          rampUps.push(rampMinutes);
          var pctOfStream = Math.round((peakIdx / stream.data.length) * 100);
          peakTimes.push(pctOfStream);
        }
        var lastViewers = stream.data[stream.data.length - 1].viewers || 0;
        if (peak > 0) drops.push(Math.round(((peak - lastViewers) / peak) * 100));
      }
    });
    avgRampUp = rampUps.length > 0 ? Math.round(rampUps.reduce(function(a, b) { return a + b; }, 0) / rampUps.length) : 0;
    avgPeakTime = peakTimes.length > 0 ? Math.round(peakTimes.reduce(function(a, b) { return a + b; }, 0) / peakTimes.length) : 0;
    avgViewerDrop = drops.length > 0 ? Math.round(drops.reduce(function(a, b) { return a + b; }, 0) / drops.length) : 0;
  }

  // Viewer stability score (how much do viewers fluctuate within streams)
  var stabilityScores = [];
  vgh.forEach(function(stream) {
    if (stream.data && stream.data.length > 5) {
      var viewers = stream.data.map(function(dp) { return dp.viewers || 0; });
      var avg = viewers.reduce(function(a, b) { return a + b; }, 0) / viewers.length;
      var variance = viewers.reduce(function(s, v) { return s + Math.pow(v - avg, 2); }, 0) / viewers.length;
      var cv = avg > 0 ? Math.round((Math.sqrt(variance) / avg) * 100) : 0;
      stabilityScores.push(Math.max(0, 100 - cv));
    }
  });
  var avgStability = stabilityScores.length > 0 ? Math.round(stabilityScores.reduce(function(a, b) { return a + b; }, 0) / stabilityScores.length) : 0;

  // ===== COMMUNITY ENGAGEMENT SCORE =====
  var communityScore = 0;
  if (totalMembers > 0) communityScore += Math.min(25, Math.round((totalMembers / 100) * 25));
  if (totalCmdUses > 0) communityScore += Math.min(25, Math.round((totalCmdUses / 50) * 25));
  if (activeWeek > 0) communityScore += Math.min(25, Math.round((activityRate / 50) * 25));
  if (totalGiveaways + totalPolls > 0) communityScore += Math.min(25, (totalGiveaways + totalPolls) * 5);
  communityScore = Math.min(100, communityScore);
  var scoreColor = communityScore >= 75 ? '#4caf50' : communityScore >= 50 ? '#ff9800' : communityScore >= 25 ? '#ffd700' : '#ef5350';
  var scoreLabel = communityScore >= 75 ? 'Thriving' : communityScore >= 50 ? 'Active' : communityScore >= 25 ? 'Growing' : 'Starting';

  return '<div class="card">' +
  '<h2>ðŸ¤ Community & Bot Analytics</h2>' +
  '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin:20px 0">' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid ' + scoreColor + '">' +
      '<div style="color:#b0b0b0;font-size:10px">Community Score</div>' +
      '<div style="font-size:26px;color:' + scoreColor + ';font-weight:bold">' + communityScore + '</div>' +
      '<div style="font-size:10px;color:#666">' + scoreLabel + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Total Members</div>' +
      '<div style="font-size:22px;color:#9146ff;font-weight:bold">' + totalMembers + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Active (7d)</div>' +
      '<div style="font-size:22px;color:#4caf50;font-weight:bold">' + activeWeek + '</div>' +
      '<div style="font-size:10px;color:#666">' + activityRate + '% rate</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Active (30d)</div>' +
      '<div style="font-size:22px;color:#2196f3;font-weight:bold">' + activeMonth + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Dormant</div>' +
      '<div style="font-size:22px;color:#ef5350;font-weight:bold">' + dormant + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Total XP Earned</div>' +
      '<div style="font-size:22px;color:#ffd700;font-weight:bold">' + totalXP.toLocaleString() + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Avg XP / Member</div>' +
      '<div style="font-size:22px;color:#ff9800;font-weight:bold">' + avgXP.toLocaleString() + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Avg Level</div>' +
      '<div style="font-size:22px;color:#ce93d8;font-weight:bold">' + avgLevel + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Highest Level</div>' +
      '<div style="font-size:22px;color:#e91e63;font-weight:bold">' + (maxLevel[1].level || 0) + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Bot Commands Used</div>' +
      '<div style="font-size:22px;color:#00bcd4;font-weight:bold">' + totalCmdUses + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Unique Bot Users</div>' +
      '<div style="font-size:22px;color:#ab47bc;font-weight:bold">' + uniqueCmdUsers.size + '</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center">' +
      '<div style="color:#b0b0b0;font-size:10px">Custom Commands</div>' +
      '<div style="font-size:22px;color:#8bc34a;font-weight:bold">' + custCmds.length + '</div>' +
    '</div>' +
  '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ“Š Level Distribution</h3>' +
  '<div style="margin-top:10px">' + (lvlDistHtml || '<div style="color:#b0b0b0;text-align:center;padding:20px">No leveling data</div>') + '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ† Top Community Members (by XP)</h3>' +
  '<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;margin-top:10px">' +
    '<thead><tr style="background:#26262c">' +
      '<th style="padding:8px 10px;text-align:left;font-size:12px">Rank</th>' +
      '<th style="padding:8px 10px;text-align:left;font-size:12px">User ID</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Level</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">XP</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Last Active</th>' +
    '</tr></thead>' +
    '<tbody>' + (top10Html || '<tr><td colspan="5" style="padding:20px;text-align:center;color:#b0b0b0">No members</td></tr>') + '</tbody>' +
  '</table></div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ¤– Bot Command Usage</h3>' +
  '<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;margin-top:10px">' +
    '<thead><tr style="background:#26262c">' +
      '<th style="padding:8px 10px;text-align:left;font-size:12px">Command</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Uses</th>' +
      '<th style="padding:8px 10px;font-size:12px">Popularity</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Users</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Last Used</th>' +
    '</tr></thead>' +
    '<tbody>' + (cmdTableHtml || '<tr><td colspan="5" style="padding:20px;text-align:center;color:#b0b0b0">No command usage data</td></tr>') + '</tbody>' +
  '</table></div>' +
'</div>' +

'<div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:15px">' +
  '<div class="card">' +
    '<h3 style="margin-top:0">ðŸ‘‘ Top Bot Users</h3>' +
    '<div style="margin-top:10px">' + (topCmdUsersHtml || '<div style="color:#b0b0b0;text-align:center;padding:15px">No data</div>') + '</div>' +
  '</div>' +
  '<div class="card">' +
    '<h3 style="margin-top:0">ðŸ“… Command Activity by Day</h3>' +
    '<div style="display:flex;gap:4px;padding:10px;background:#1a1a2e;border-radius:6px;margin-top:10px;height:120px">' +
      cmdDayHtml +
    '</div>' +
  '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">â­ Custom Commands Popularity</h3>' +
  '<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:10px;margin-top:10px">' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Total Commands</div><div style="font-size:20px;color:#ff9800;font-weight:bold">' + custCmds.length + '</div></div>' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Total Uses</div><div style="font-size:20px;color:#ffd700;font-weight:bold">' + totalCustUses + '</div></div>' +
  '</div>' +
  '<div style="margin-top:10px">' + (custCmdsHtml || '<div style="color:#b0b0b0;text-align:center;padding:20px">No custom commands</div>') + '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ“¡ Viewer Timeline Analysis</h3>' +
  '<p style="color:#b0b0b0;font-size:12px;margin-bottom:10px">Analyzed from ' + vgh.length + ' streams with detailed viewer data</p>' +
  '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px">' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid #4caf50">' +
      '<div style="color:#b0b0b0;font-size:10px">Avg Ramp-Up</div>' +
      '<div style="font-size:22px;color:#4caf50;font-weight:bold">' + avgRampUp + ' min</div>' +
      '<div style="font-size:10px;color:#666">Time to peak viewers</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid #ff9800">' +
      '<div style="color:#b0b0b0;font-size:10px">Peak Position</div>' +
      '<div style="font-size:22px;color:#ff9800;font-weight:bold">' + avgPeakTime + '%</div>' +
      '<div style="font-size:10px;color:#666">Through the stream</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid #ef5350">' +
      '<div style="color:#b0b0b0;font-size:10px">Avg Viewer Drop</div>' +
      '<div style="font-size:22px;color:#ef5350;font-weight:bold">' + avgViewerDrop + '%</div>' +
      '<div style="font-size:10px;color:#666">Peak â†’ End</div>' +
    '</div>' +
    '<div style="background:#26262c;padding:15px;border-radius:6px;text-align:center;border-top:3px solid #2196f3">' +
      '<div style="color:#b0b0b0;font-size:10px">Viewer Stability</div>' +
      '<div style="font-size:22px;color:#2196f3;font-weight:bold">' + avgStability + '%</div>' +
      '<div style="font-size:10px;color:#666">In-stream consistency</div>' +
    '</div>' +
  '</div>' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸŽ‰ Giveaways</h3>' +
  '<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin:10px 0">' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Total Giveaways</div><div style="font-size:20px;color:#ffd700;font-weight:bold">' + totalGiveaways + '</div></div>' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Total Entries</div><div style="font-size:20px;color:#4caf50;font-weight:bold">' + totalGAEntries + '</div></div>' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Avg Entries</div><div style="font-size:20px;color:#2196f3;font-weight:bold">' + avgGAEntries + '</div></div>' +
  '</div>' +
  (gaHtml ? '<div style="overflow-x:auto"><table style="width:100%;border-collapse:collapse;margin-top:10px">' +
    '<thead><tr style="background:#26262c">' +
      '<th style="padding:8px 10px;text-align:left;font-size:12px">Prize</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Status</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Entries</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Winners</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">End Date</th>' +
      '<th style="padding:8px 10px;text-align:center;font-size:12px">Created By</th>' +
    '</tr></thead>' +
    '<tbody>' + gaHtml + '</tbody>' +
  '</table></div>' : '<div style="color:#b0b0b0;text-align:center;padding:15px">No giveaways yet</div>') +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ“Š Polls</h3>' +
  '<div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin:10px 0">' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Total Polls</div><div style="font-size:20px;color:#9146ff;font-weight:bold">' + totalPolls + '</div></div>' +
    '<div style="background:#26262c;padding:12px;border-radius:6px;text-align:center"><div style="color:#b0b0b0;font-size:10px">Total Votes</div><div style="font-size:20px;color:#ce93d8;font-weight:bold">' + totalPollVotes + '</div></div>' +
  '</div>' +
  (pollsHtml || '<div style="color:#b0b0b0;text-align:center;padding:15px">No polls yet</div>') +
'</div>' +

(totalNotifs > 0 ? '<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ”” Notification Analytics</h3>' +
  '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(100px,1fr));gap:10px;margin:10px 0">' +
    notifTypesHtml +
  '</div>' +
  '<div style="color:#666;font-size:11px;margin-top:8px">Total notifications sent: ' + totalNotifs + '</div>' +
  '<div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:15px">' +
  '<div style="background:#1a1a2e;padding:15px;border-radius:8px"><h4 style="margin:0 0 10px 0;color:#e0e0e0;font-size:13px">ðŸ“Š Notifications by Day</h4><div style="height:180px"><canvas id="notif-timeline-chart"></canvas></div></div>' +
  '<div style="background:#1a1a2e;padding:15px;border-radius:8px"><h4 style="margin:0 0 10px 0;color:#e0e0e0;font-size:13px">ðŸŽ¯ Type Breakdown</h4><div style="height:180px"><canvas id="notif-type-chart"></canvas></div></div>' +
  '</div>' +
'</div>' : '') +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ“… Stream Schedule</h3>' +
  '<div style="display:grid;grid-template-columns:repeat(7,1fr);gap:8px;margin-top:10px">' +
    schedHtml +
  '</div>' +
  (sched.nextStreamAt ? '<div style="margin-top:10px;padding:10px;background:#26262c;border-radius:6px;text-align:center"><span style="color:#b0b0b0;font-size:12px">Next scheduled stream: </span><span style="color:#4caf50;font-weight:bold;font-size:13px">' + new Date(sched.nextStreamAt).toLocaleString() + '</span></div>' : '') +
'</div>' +

'<div style="text-align:center;margin-top:15px;padding:10px;color:#666;font-size:11px">' +
  'Community data as of ' + new Date().toLocaleString() + ' | ' + totalMembers + ' tracked members | ' + totalCmdUses + ' bot command uses | ' + vgh.length + ' detailed viewer timelines' +
'</div>' +

'<div class="card" style="margin-top:15px">' +
  '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">' +
    '<div><h3 style="margin-top:0">ðŸ“Š Level Distribution</h3><div style="height:220px"><canvas id="level-dist-chart"></canvas></div></div>' +
    '<div><h3 style="margin-top:0">ðŸ¤– Top Commands</h3><div style="height:220px"><canvas id="cmd-usage-chart"></canvas></div></div>' +
  '</div>' +
'</div>' +

'<script src="https://cdn.jsdelivr.net/npm/chart.js"><\/script>' +
'<script>' +
'document.addEventListener("DOMContentLoaded", function() {' +
  'var lvlData = ' + JSON.stringify(Object.entries(lvlDist).map(function(e) { return { label: 'Lv ' + e[0], count: e[1] }; })) + ';' +
  'var cmdData = ' + JSON.stringify(cmdsSorted.slice(0, 10).map(function(c) { return { name: c.name, total: c.total, users: c.users }; })) + ';' +
  'var lvlCtx = document.getElementById("level-dist-chart");' +
  'if (lvlCtx && lvlData.length > 0) {' +
    'new Chart(lvlCtx, {' +
      'type: "bar",' +
      'data: {' +
        'labels: lvlData.map(function(d) { return d.label; }),' +
        'datasets: [{' +
          'label: "Members",' +
          'data: lvlData.map(function(d) { return d.count; }),' +
          'backgroundColor: ["#ef5350aa","#ff9800aa","#ffd700aa","#4caf50aa","#2196f3aa","#9146ffaa","#e91e63aa","#ce93d8aa"],' +
          'borderColor: ["#ef5350","#ff9800","#ffd700","#4caf50","#2196f3","#9146ff","#e91e63","#ce93d8"],' +
          'borderWidth: 1,' +
          'borderRadius: 4' +
        '}]' +
      '},' +
      'options: {' +
        'responsive: true,' +
        'maintainAspectRatio: false,' +
        'plugins: { legend: { display: false } },' +
        'scales: {' +
          'y: { beginAtZero: true, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#8b8fa3", stepSize: 1 } },' +
          'x: { grid: { display: false }, ticks: { color: "#8b8fa3", font: { size: 10 } } }' +
        '}' +
      '}' +
    '});' +
  '}' +
  'var cmdCtx = document.getElementById("cmd-usage-chart");' +
  'if (cmdCtx && cmdData.length > 0) {' +
    'new Chart(cmdCtx, {' +
      'type: "doughnut",' +
      'data: {' +
        'labels: cmdData.map(function(d) { return "/" + d.name; }),' +
        'datasets: [{' +
          'data: cmdData.map(function(d) { return d.total; }),' +
          'backgroundColor: ["#9146ffcc","#4caf50cc","#ff9800cc","#e91e63cc","#2196f3cc","#ffd700cc","#00bcd4cc","#ce93d8cc","#ef5350cc","#8bc34acc"],' +
          'borderColor: ["#9146ff","#4caf50","#ff9800","#e91e63","#2196f3","#ffd700","#00bcd4","#ce93d8","#ef5350","#8bc34a"],' +
          'borderWidth: 2' +
        '}]' +
      '},' +
      'options: {' +
        'responsive: true,' +
        'maintainAspectRatio: false,' +
        'plugins: {' +
          'legend: { display: true, position: "right", labels: { color: "#8b8fa3", padding: 6, font: { size: 10 }, usePointStyle: true } },' +
          'tooltip: { callbacks: { label: function(ctx) { return ctx.label + ": " + ctx.raw + " uses (" + cmdData[ctx.dataIndex].users + " users)"; } } }' +
        '}' +
      '}' +
    '});' +
  '}' +
'});' +
'<\/script>' +

'<div class="card" style="margin-top:15px">' +
  '<h3 style="margin-top:0">ðŸ† Weekly XP vs All-Time XP (Top 10)</h3>' +
  '<div style="height:260px"><canvas id="weekly-xp-chart"></canvas></div>' +
'</div>' +

'<script>' +
'document.addEventListener("DOMContentLoaded", function() {' +
  'var weeklyXPData = ' + JSON.stringify((function() {
    var wk = Object.entries(weeklyLeveling || {});
    var lv = Object.entries(leveling || {});
    // Get top 10 by weekly XP
    var topWeekly = wk.map(function(e) { return { id: e[0], weeklyXp: e[1].xp || 0 }; }).sort(function(a, b) { return b.weeklyXp - a.weeklyXp; }).slice(0, 10);
    // Match with all-time data
    return topWeekly.map(function(u) {
      var allTime = lv.find(function(e) { return e[0] === u.id; });
      var totalXp = allTime ? (allTime[1].xp || 0) : 0;
      var level = allTime ? (allTime[1].level || 0) : 0;
      return { id: u.id.substring(0, 8) + '..', weeklyXp: u.weeklyXp, totalXp: totalXp, level: level };
    });
  })()) + ';' +
  'var wxCtx = document.getElementById("weekly-xp-chart");' +
  'if (wxCtx && weeklyXPData.length > 0) {' +
    'new Chart(wxCtx, {' +
      'type: "bar",' +
      'data: {' +
        'labels: weeklyXPData.map(function(d) { return "Lv" + d.level + " " + d.id; }),' +
        'datasets: [{' +
          'label: "Weekly XP",' +
          'data: weeklyXPData.map(function(d) { return d.weeklyXp; }),' +
          'backgroundColor: "#e91e63aa",' +
          'borderColor: "#e91e63",' +
          'borderWidth: 1,' +
          'borderRadius: 4,' +
          'yAxisID: "y"' +
        '}, {' +
          'label: "All-Time XP",' +
          'data: weeklyXPData.map(function(d) { return d.totalXp; }),' +
          'backgroundColor: "#9146ff44",' +
          'borderColor: "#9146ff",' +
          'borderWidth: 1,' +
          'borderRadius: 4,' +
          'yAxisID: "y1"' +
        '}]' +
      '},' +
      'options: {' +
        'responsive: true,' +
        'maintainAspectRatio: false,' +
        'plugins: { legend: { display: true, labels: { color: "#8b8fa3", usePointStyle: true } } },' +
        'scales: {' +
          'y: { type: "linear", position: "left", beginAtZero: true, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#e91e63" }, title: { display: true, text: "Weekly XP", color: "#e91e63" } },' +
          'y1: { type: "linear", position: "right", beginAtZero: true, grid: { drawOnChartArea: false }, ticks: { color: "#9146ff" }, title: { display: true, text: "All-Time XP", color: "#9146ff" } },' +
          'x: { grid: { display: false }, ticks: { color: "#8b8fa3", font: { size: 9 } } }' +
        '}' +
      '}' +
    '});' +
  '}' +
'});' +
// Notification charts  
'var nhData = ' + JSON.stringify((() => {
  const dailyCounts = {};
  (notificationHistory || []).forEach(n => {
    const day = new Date(n.timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    dailyCounts[day] = (dailyCounts[day] || 0) + 1;
  });
  return Object.entries(dailyCounts).slice(-14);
})()) + ';' +
'var ntCtx = document.getElementById("notif-timeline-chart");' +
'if (ntCtx && nhData.length > 0) {' +
  'new Chart(ntCtx, {' +
    'type: "bar",' +
    'data: { labels: nhData.map(function(d){return d[0]}), datasets: [{ label: "Notifications", data: nhData.map(function(d){return d[1]}), backgroundColor: "#5b5bff88", borderColor: "#5b5bff", borderWidth: 1, borderRadius: 3 }] },' +
    'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#8b8fa3", stepSize: 1 } }, x: { grid: { display: false }, ticks: { color: "#8b8fa3", font: { size: 9 } } } } }' +
  '});' +
'}' +
'var ntypeData = ' + JSON.stringify(Object.entries(notifTypes)) + ';' +
'var ntypeColors = ' + JSON.stringify(Object.entries(notifTypes).map(([t]) => ({ live: '#4caf50', offline: '#ef5350', follow: '#e91e63', game: '#9146ff', title: '#ff9800', viewer: '#2196f3', raid: '#ffd700', clip: '#00bcd4' })[t] || '#666')) + ';' +
'var ntpCtx = document.getElementById("notif-type-chart");' +
'if (ntpCtx && ntypeData.length > 0) {' +
  'new Chart(ntpCtx, {' +
    'type: "doughnut",' +
    'data: { labels: ntypeData.map(function(d){return d[0]}), datasets: [{ data: ntypeData.map(function(d){return d[1]}), backgroundColor: ntypeColors, borderWidth: 0 }] },' +
    'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: "right", labels: { color: "#8b8fa3", font: { size: 11 }, padding: 8, usePointStyle: true } } } }' +
  '});' +
'}' +
'<\/script>';
}

// RPG Economy Tab
function renderRPGEconomyTab() {
  const playersPath = path.join(process.cwd(), 'data', 'players.json');
  const craftingPath = path.join(process.cwd(), 'data', 'crafting.json');
  const guildsPath = path.join(process.cwd(), 'data', 'guilds.json');
  let players = [];
  let craftingData = { materials: [], recipes: [] };
  let guilds = [];
  try {
    if (fs.existsSync(playersPath)) {
      const raw = cachedReadJSON(playersPath);
      players = Object.values(raw).filter(p => p && p.userId);
    }
  } catch(e) {}
  try {
    if (fs.existsSync(craftingPath)) craftingData = cachedReadJSON(craftingPath);
  } catch(e) {}
  try {
    if (fs.existsSync(guildsPath)) {
      const raw = cachedReadJSON(guildsPath);
      const serverId = Object.keys(raw)[0];
      if (serverId) guilds = Object.values(raw[serverId]).filter(g => g && g.id);
    }
  } catch(e) {}

  // === GOLD ECONOMY ===
  const totalGold = players.reduce((s,p) => s + (p.gold || 0), 0);
  const totalGoldEarned = players.reduce((s,p) => s + ((p.progressStats||{}).goldEarned||0), 0);
  const totalGoldSpent = players.reduce((s,p) => s + (p.goldSpentTotal || 0), 0);
  const avgGold = players.length > 0 ? Math.round(totalGold / players.length) : 0;
  const maxGold = players.reduce((m,p) => Math.max(m, p.gold || 0), 0);
  const spendingBreakdown = { shop: 0, crafting: 0, gambling: 0, guild: 0, upgrades: 0, marketplace: 0, other: 0 };
  players.forEach(p => {
    const b = p.goldSpentBreakdown || {};
    Object.keys(spendingBreakdown).forEach(k => { spendingBreakdown[k] += (b[k] || 0); });
  });

  // Gold distribution buckets
  const goldBuckets = { '0-999': 0, '1K-10K': 0, '10K-100K': 0, '100K-1M': 0, '1M+': 0 };
  players.forEach(p => {
    const g = p.gold || 0;
    if (g < 1000) goldBuckets['0-999']++;
    else if (g < 10000) goldBuckets['1K-10K']++;
    else if (g < 100000) goldBuckets['10K-100K']++;
    else if (g < 1000000) goldBuckets['100K-1M']++;
    else goldBuckets['1M+']++;
  });

  // === AUTO-SELL STATS ===
  const totalAutoSold = players.reduce((s,p) => s + ((p.autoSellSettings||{}).itemsSold||0), 0);
  const totalAutoGold = players.reduce((s,p) => s + ((p.autoSellSettings||{}).totalGoldEarned||0), 0);

  // === GATHERING STATS ===
  const gatheringAggs = { mining: [], chopping: [], gathering: [] };
  players.forEach(p => {
    const gl = p.gatheringLevels || {};
    if (gl.mining) gatheringAggs.mining.push({ name: p.username, level: gl.mining });
    if (gl.chopping) gatheringAggs.chopping.push({ name: p.username, level: gl.chopping });
    if (gl.gathering) gatheringAggs.gathering.push({ name: p.username, level: gl.gathering });
  });
  Object.keys(gatheringAggs).forEach(k => gatheringAggs[k].sort((a,b) => b.level - a.level));

  // === PROFESSION STATS ===
  const professionAgg = {};
  players.forEach(p => {
    const pl = p.professionLevels || {};
    Object.entries(pl).forEach(([prof, lvl]) => {
      if (!professionAgg[prof]) professionAgg[prof] = { totalLevel: 0, count: 0, maxLevel: 0, topPlayer: '' };
      professionAgg[prof].totalLevel += lvl;
      professionAgg[prof].count++;
      if (lvl > professionAgg[prof].maxLevel) { professionAgg[prof].maxLevel = lvl; professionAgg[prof].topPlayer = p.username || 'Unknown'; }
    });
  });

  // === EQUIPMENT ANALYTICS ===
  const slotCounts = {};
  const itemPopularity = {};
  players.forEach(p => {
    const eq = p.equippedItems || {};
    Object.entries(eq).forEach(([slot, itemId]) => {
      if (itemId) {
        slotCounts[slot] = (slotCounts[slot] || 0) + 1;
        itemPopularity[itemId] = (itemPopularity[itemId] || 0) + 1;
      }
    });
  });
  const totalSlots = players.length * 10;
  const filledSlots = Object.values(slotCounts).reduce((s,v) => s + v, 0);
  const fillRate = totalSlots > 0 ? ((filledSlots / totalSlots) * 100).toFixed(1) : '0';

  // === INVENTORY STATS ===
  const avgInvSize = players.length > 0 ? (players.reduce((s,p) => s + (Array.isArray(p.inventory) ? p.inventory.length : 0), 0) / players.length).toFixed(1) : '0';
  const maxInvSize = players.reduce((m,p) => Math.max(m, Array.isArray(p.inventory) ? p.inventory.length : 0), 0);

  // === CRAFTING RECIPES ===
  const recipes = Array.isArray(craftingData.recipes) ? craftingData.recipes : [];
  const materials = Array.isArray(craftingData.materials) ? craftingData.materials : [];
  const totalCrafts = players.reduce((s,p) => s + ((p.progressStats||{}).craftsCompleted||0), 0);
  const totalGatheringActions = players.reduce((s,p) => s + ((p.progressStats||{}).gatheringActions||0), 0);

  // === TRADE ACTIVITY ===
  const allTrades = [];
  players.forEach(p => { (p.tradeHistory || []).forEach(t => allTrades.push({ ...t, player: p.username })); });
  allTrades.sort((a,b) => (b.timestamp||0) - (a.timestamp||0));

  // Top gold holders
  const topGold = [...players].sort((a,b) => (b.gold||0) - (a.gold||0)).slice(0, 10);

  // === GUILD TREASURY ===
  const guildTreasury = guilds.map(g => ({ name: g.name || 'Unknown', gold: g.gold || 0, bankItems: (g.bank?.items || []).length, bankMaterials: Object.keys(g.bank?.materials || {}).length }));

  // Spending breakdown labels/data for chart
  const spendLabels = Object.keys(spendingBreakdown).map(k => k.charAt(0).toUpperCase() + k.slice(1));
  const spendData = Object.values(spendingBreakdown);
  const spendColors = ['#e91e63','#ff9800','#f44336','#9c27b0','#2196f3','#4caf50','#607d8b'];

  // Format number helper
  const fmtG = (n) => n >= 1e6 ? (n/1e6).toFixed(1)+'M' : n >= 1e3 ? (n/1e3).toFixed(1)+'K' : String(n);

  return '<div class="card"><h2 style="margin-bottom:25px">ðŸ’° RPG Economy</h2>' +
    // Gold overview cards
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:14px;margin-bottom:30px">' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(76,175,80,0.3)"><div style="font-size:26px;font-weight:700;color:#4caf50">' + fmtG(totalGold) + '</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Gold in Circulation</div></div>' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(255,152,0,0.3)"><div style="font-size:26px;font-weight:700;color:#ff9800">' + fmtG(totalGoldEarned) + '</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Total Gold Earned</div></div>' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(233,30,99,0.3)"><div style="font-size:26px;font-weight:700;color:#e91e63">' + fmtG(totalGoldSpent) + '</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Total Gold Spent</div></div>' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(91,91,255,0.3)"><div style="font-size:26px;font-weight:700;color:#5b5bff">' + fmtG(avgGold) + '</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Avg Gold/Player</div></div>' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(0,188,212,0.3)"><div style="font-size:26px;font-weight:700;color:#00bcd4">' + fmtG(maxGold) + '</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Richest Player</div></div>' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(156,39,176,0.3)"><div style="font-size:26px;font-weight:700;color:#9c27b0">' + fillRate + '%</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Equip Slot Fill Rate</div></div>' +
    '</div>' +
    // Activity stats row
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px;margin-bottom:30px">' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#4db6ac">ðŸ”¨ ' + totalCrafts.toLocaleString() + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Items Crafted</div></div>' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#81c784">ðŸŒ¿ ' + totalGatheringActions.toLocaleString() + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Gathering Actions</div></div>' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#ff8a65">ðŸª ' + totalAutoSold.toLocaleString() + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Items Auto-Sold</div></div>' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#ffb74d">ðŸ’° ' + fmtG(totalAutoGold) + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Auto-Sell Revenue</div></div>' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#90caf9">ðŸ“¦ ' + avgInvSize + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Avg Inventory Size</div></div>' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#ce93d8">ðŸ”„ ' + allTrades.length + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Market Trades</div></div>' +
    '</div>' +
    // Charts row: Gold Distribution + Spending Breakdown
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px">' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ’° Gold Distribution</h3><div style="height:250px"><canvas id="goldDistChart"></canvas></div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ“Š Gold Spending Breakdown</h3><div style="height:250px"><canvas id="goldSpendChart"></canvas></div></div>' +
    '</div>' +
    // Top Gold Holders + Gathering Leaderboard
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px">' +
    // Top Gold Holders
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ† Top Gold Holders</h3>' +
    '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:8px;color:#8b8fa3">Player</th><th style="text-align:right;padding:8px;color:#8b8fa3">Gold</th><th style="text-align:right;padding:8px;color:#8b8fa3">Earned</th><th style="text-align:right;padding:8px;color:#8b8fa3">Spent</th></tr></thead><tbody>' +
    topGold.map(function(p, i) {
      var medal = i < 3 ? ['ðŸ¥‡','ðŸ¥ˆ','ðŸ¥‰'][i] : '' + (i+1);
      return '<tr style="border-bottom:1px solid #222"><td style="padding:8px;color:#fff">' + medal + ' ' + (p.username||'Unknown') + '</td><td style="text-align:right;padding:8px;color:#4caf50;font-weight:700">' + (p.gold||0).toLocaleString() + '</td><td style="text-align:right;padding:8px;color:#ff9800">' + ((p.progressStats||{}).goldEarned||0).toLocaleString() + '</td><td style="text-align:right;padding:8px;color:#e91e63">' + (p.goldSpentTotal||0).toLocaleString() + '</td></tr>';
    }).join('') +
    '</tbody></table></div>' +
    // Gathering Leaderboard
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">â›ï¸ Gathering Leaderboard</h3>' +
    '<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px">' +
    // Mining
    '<div><h4 style="color:#ff6b6b;font-size:12px;margin:0 0 8px 0">â›ï¸ Mining</h4>' +
    gatheringAggs.mining.slice(0, 5).map(function(g, i) {
      return '<div style="font-size:12px;padding:4px 0;border-bottom:1px solid #222"><span style="color:#8b8fa3">' + (i+1) + '.</span> <span style="color:#fff">' + g.name + '</span> <span style="color:#ff6b6b;font-weight:600">Lv' + g.level + '</span></div>';
    }).join('') +
    '</div>' +
    // Chopping
    '<div><h4 style="color:#81c784;font-size:12px;margin:0 0 8px 0">ðŸª“ Chopping</h4>' +
    gatheringAggs.chopping.slice(0, 5).map(function(g, i) {
      return '<div style="font-size:12px;padding:4px 0;border-bottom:1px solid #222"><span style="color:#8b8fa3">' + (i+1) + '.</span> <span style="color:#fff">' + g.name + '</span> <span style="color:#81c784;font-weight:600">Lv' + g.level + '</span></div>';
    }).join('') +
    '</div>' +
    // Gathering
    '<div><h4 style="color:#4db6ac;font-size:12px;margin:0 0 8px 0">ðŸŒ¿ Gathering</h4>' +
    gatheringAggs.gathering.slice(0, 5).map(function(g, i) {
      return '<div style="font-size:12px;padding:4px 0;border-bottom:1px solid #222"><span style="color:#8b8fa3">' + (i+1) + '.</span> <span style="color:#fff">' + g.name + '</span> <span style="color:#4db6ac;font-weight:600">Lv' + g.level + '</span></div>';
    }).join('') +
    '</div>' +
    '</div></div>' +
    '</div>' +
    // Profession Levels
    (Object.keys(professionAgg).length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ› ï¸ Profession Analytics</h3>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px">' +
    Object.entries(professionAgg).map(function(entry) {
      var prof = entry[0];
      var data = entry[1];
      var avgLvl = data.count > 0 ? (data.totalLevel / data.count).toFixed(1) : '0';
      return '<div style="background:#2a2e35;padding:14px;border-radius:8px"><div style="color:#fff;font-weight:600;margin-bottom:6px">' + prof.charAt(0).toUpperCase() + prof.slice(1) + '</div>' +
        '<div style="font-size:12px;color:#8b8fa3">Players: <span style="color:#5b5bff">' + data.count + '</span></div>' +
        '<div style="font-size:12px;color:#8b8fa3">Avg Level: <span style="color:#ff9800">' + avgLvl + '</span></div>' +
        '<div style="font-size:12px;color:#8b8fa3">Highest: <span style="color:#4caf50">Lv' + data.maxLevel + '</span> (' + data.topPlayer + ')</div></div>';
    }).join('') +
    '</div></div>' : '') +
    // Crafting Recipes Available
    (recipes.length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ“œ Crafting Recipes (' + recipes.length + ' total)</h3>' +
    '<div style="max-height:250px;overflow-y:auto"><table style="width:100%;border-collapse:collapse;font-size:12px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:6px;color:#8b8fa3">Recipe</th><th style="text-align:left;padding:6px;color:#8b8fa3">Profession</th><th style="text-align:right;padding:6px;color:#8b8fa3">Level</th><th style="text-align:left;padding:6px;color:#8b8fa3">Output</th><th style="text-align:left;padding:6px;color:#8b8fa3">Class</th></tr></thead><tbody>' +
    recipes.slice(0, 30).map(function(r) {
      return '<tr style="border-bottom:1px solid #222"><td style="padding:6px;color:#fff">' + (r.name||r.id) + '</td><td style="padding:6px;color:#4db6ac">' + (r.profession||'-') + '</td><td style="text-align:right;padding:6px;color:#ff9800">' + (r.level||1) + '</td><td style="padding:6px;color:#81c784">' + ((r.output||{}).item || '-') + '</td><td style="padding:6px;color:#e91e63">' + (r.classRestriction||'Any') + '</td></tr>';
    }).join('') +
    '</tbody></table></div></div>' : '') +
    // Materials Available
    (materials.length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">âš’ï¸ Materials Database (' + materials.length + ' types)</h3>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px">' +
    materials.slice(0, 20).map(function(m) {
      var rarityColors = { common: '#9e9e9e', uncommon: '#4caf50', rare: '#2196f3', epic: '#9c27b0', legendary: '#ff9800' };
      var c = rarityColors[m.rarity] || '#9e9e9e';
      return '<div style="background:#2a2e35;padding:10px;border-radius:6px;border-left:3px solid ' + c + '"><div style="color:' + c + ';font-weight:600;font-size:12px">' + (m.name||m.id) + '</div><div style="font-size:11px;color:#72767d">' + (m.rarity||'common') + ' â€¢ ' + (m.gatheringType||'?') + ' â€¢ ' + (m.value||0) + 'g</div></div>';
    }).join('') +
    '</div></div>' : '') +
    // Guild Treasury
    (guildTreasury.length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ° Guild Treasuries</h3>' +
    '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:8px;color:#8b8fa3">Guild</th><th style="text-align:right;padding:8px;color:#8b8fa3">Treasury Gold</th><th style="text-align:right;padding:8px;color:#8b8fa3">Bank Items</th><th style="text-align:right;padding:8px;color:#8b8fa3">Bank Materials</th></tr></thead><tbody>' +
    guildTreasury.map(function(g) {
      return '<tr style="border-bottom:1px solid #222"><td style="padding:8px;color:#fff;font-weight:600">' + g.name + '</td><td style="text-align:right;padding:8px;color:#4caf50;font-weight:700">' + g.gold.toLocaleString() + '</td><td style="text-align:right;padding:8px;color:#5b5bff">' + g.bankItems + '</td><td style="text-align:right;padding:8px;color:#ff9800">' + g.bankMaterials + '</td></tr>';
    }).join('') +
    '</tbody></table></div>' : '') +
    // Recent Market Trades
    (allTrades.length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:20px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ”„ Recent Market Activity</h3>' +
    '<div style="max-height:200px;overflow-y:auto">' +
    allTrades.slice(0, 20).map(function(t) {
      var icon = t.type === 'buy' ? 'ðŸ›’' : t.type === 'sell' ? 'ðŸ’°' : 'ðŸ“‹';
      var color = t.type === 'buy' ? '#e91e63' : '#4caf50';
      return '<div style="padding:6px 10px;border-bottom:1px solid #222;font-size:12px"><span style="color:#8b8fa3">' + new Date(t.timestamp||0).toLocaleString() + '</span> ' + icon + ' <strong style="color:#fff">' + (t.player||'') + '</strong> <span style="color:' + color + '">' + t.type + '</span> <span style="color:#b5bac1">' + (t.item||'?') + '</span> for <span style="color:#ff9800">' + (t.price||0) + 'g</span></div>';
    }).join('') +
    '</div></div>' : '') +
    '</div>' +
    // Charts
    '<script>' +
    'document.addEventListener("DOMContentLoaded", function() {' +
    // Gold Distribution Chart
    'var gdCtx = document.getElementById("goldDistChart");' +
    'if (gdCtx) { new Chart(gdCtx, {' +
      'type: "bar",' +
      'data: { labels: ' + JSON.stringify(Object.keys(goldBuckets)) + ', datasets: [{ label: "Players", data: ' + JSON.stringify(Object.values(goldBuckets)) + ', backgroundColor: ["#4caf5088","#ff980088","#5b5bff88","#e91e6388","#00bcd488"], borderColor: ["#4caf50","#ff9800","#5b5bff","#e91e63","#00bcd4"], borderWidth: 1, borderRadius: 4 }] },' +
      'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#8b8fa3", stepSize: 1 } }, x: { grid: { display: false }, ticks: { color: "#8b8fa3" } } } }' +
    '}); }' +
    // Gold Spending Breakdown Chart
    'var gsCtx = document.getElementById("goldSpendChart");' +
    'if (gsCtx) { new Chart(gsCtx, {' +
      'type: "doughnut",' +
      'data: { labels: ' + JSON.stringify(spendLabels) + ', datasets: [{ data: ' + JSON.stringify(spendData) + ', backgroundColor: ' + JSON.stringify(spendColors) + ', borderWidth: 0 }] },' +
      'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: "right", labels: { color: "#8b8fa3", font: { size: 11 }, padding: 10, usePointStyle: true } } } }' +
    '}); }' +
    '});' +
    '<\/script>';
}

// RPG Quests & Combat Tab
function renderRPGQuestsCombatTab() {
  const playersPath = path.join(process.cwd(), 'data', 'players.json');
  const bountiesPath = path.join(process.cwd(), 'data', 'bounties.json');
  const guildQuestsPath = path.join(process.cwd(), 'data', 'guild-quests.json');
  const defenseQuestsPath = path.join(process.cwd(), 'data', 'defense-quests.json');
  const guildsPath = path.join(process.cwd(), 'data', 'guilds.json');
  let players = [];
  let bountyData = { player: [], npc: [], limited: [] };
  let guildQuests = { daily: [], weekly: [], limited: [] };
  let defenseQuests = [];
  let guilds = [];
  try {
    if (fs.existsSync(playersPath)) {
      const raw = cachedReadJSON(playersPath);
      players = Object.values(raw).filter(p => p && p.userId);
    }
  } catch(e) {}
  try { if (fs.existsSync(bountiesPath)) bountyData = cachedReadJSON(bountiesPath); } catch(e) {}
  try { if (fs.existsSync(guildQuestsPath)) guildQuests = cachedReadJSON(guildQuestsPath); } catch(e) {}
  try { if (fs.existsSync(defenseQuestsPath)) defenseQuests = cachedReadJSON(defenseQuestsPath); } catch(e) {}
  try {
    if (fs.existsSync(guildsPath)) {
      const raw = cachedReadJSON(guildsPath);
      const serverId = Object.keys(raw)[0];
      if (serverId) guilds = Object.values(raw[serverId]).filter(g => g && g.id);
    }
  } catch(e) {}
  if (!Array.isArray(defenseQuests)) defenseQuests = [];

  // === COMBAT STATS ===
  var totalWins = 0, totalLosses = 0, totalForfeits = 0;
  var combatByType = { normal: {w:0,l:0}, boss: {w:0,l:0}, worldBoss: {w:0,l:0}, dungeon: {w:0,l:0}, arena: {w:0,l:0}, guildBoss: {w:0,l:0}, raid: {w:0,l:0} };
  var enemyStats = {};
  players.forEach(function(p) {
    var cr = p.combatRecord || {};
    totalWins += cr.totalWins || 0;
    totalLosses += cr.totalLosses || 0;
    totalForfeits += cr.totalForfeits || 0;
    var bt = cr.byType || {};
    Object.keys(combatByType).forEach(function(t) {
      combatByType[t].w += (bt[t]||{}).wins || 0;
      combatByType[t].l += (bt[t]||{}).losses || 0;
    });
    var be = cr.byEnemy || {};
    Object.entries(be).forEach(function(entry) {
      var name = entry[0]; var d = entry[1];
      if (!enemyStats[name]) enemyStats[name] = { wins: 0, losses: 0 };
      enemyStats[name].wins += d.wins || 0;
      enemyStats[name].losses += d.losses || 0;
    });
  });
  var totalCombats = totalWins + totalLosses;
  var overallWinRate = totalCombats > 0 ? ((totalWins / totalCombats) * 100).toFixed(1) : '0';

  // Top enemies by encounters
  var topEnemies = Object.entries(enemyStats).map(function(e) {
    var total = e[1].wins + e[1].losses;
    var wr = total > 0 ? ((e[1].wins / total) * 100).toFixed(1) : '0';
    return { name: e[0], wins: e[1].wins, losses: e[1].losses, total: total, winRate: wr };
  }).sort(function(a,b) { return b.total - a.total; }).slice(0, 15);

  // === DEATH LOG ===
  var allDeaths = [];
  players.forEach(function(p) {
    (p.deathLog || []).forEach(function(d) { allDeaths.push({ player: p.username, enemy: d.enemy, enemyLevel: d.enemyLevel, playerLevel: d.playerLevel, timestamp: d.timestamp, type: d.type }); });
  });
  allDeaths.sort(function(a,b) { return (b.timestamp||0) - (a.timestamp||0); });

  // === SKILL USAGE ===
  var skillAgg = {};
  players.forEach(function(p) {
    var su = p.skillUsageStats || {};
    Object.entries(su).forEach(function(entry) {
      var name = entry[0]; var d = entry[1];
      if (!skillAgg[name]) skillAgg[name] = { timesUsed: 0, totalDamage: 0 };
      skillAgg[name].timesUsed += d.timesUsed || 0;
      skillAgg[name].totalDamage += d.totalDamage || 0;
    });
  });
  var topSkills = Object.entries(skillAgg).map(function(e) {
    return { name: e[0], used: e[1].timesUsed, damage: e[1].totalDamage, avgDmg: e[1].timesUsed > 0 ? Math.round(e[1].totalDamage / e[1].timesUsed) : 0 };
  }).sort(function(a,b) { return b.used - a.used; }).slice(0, 15);

  // === QUEST STATS ===
  var totalDailyCompleted = players.reduce(function(s,p) { return s + (Array.isArray(p.dailyQuestsCompleted) ? p.dailyQuestsCompleted.length : 0); }, 0);
  var totalWeeklyCompleted = players.reduce(function(s,p) { return s + (Array.isArray(p.weeklyQuestsCompleted) ? p.weeklyQuestsCompleted.length : 0); }, 0);
  var totalBountiesCompleted = players.reduce(function(s,p) { return s + (Array.isArray(p.completedBounties) ? p.completedBounties.length : 0); }, 0);
  var totalBountiesActive = players.reduce(function(s,p) { return s + (Array.isArray(p.activeBounties) ? p.activeBounties.length : 0); }, 0);

  // Guild rank distribution
  var rankCounts = {};
  players.forEach(function(p) {
    var r = p.guildRank || 'F';
    rankCounts[r] = (rankCounts[r] || 0) + 1;
  });

  // === ROGUELIKE DEEP STATS ===
  var totalRuns = players.reduce(function(s,p) { return s + ((p.roguelikeStats||{}).totalRunsCompleted||0); }, 0);
  var highestFloor = players.reduce(function(m,p) { return Math.max(m, (p.roguelikeStats||{}).highestFloorReached||0); }, 0);
  var totalRogueDeaths = players.reduce(function(s,p) { return s + ((p.roguelikeStats||{}).deathCount||0); }, 0);
  var totalRogueBosses = players.reduce(function(s,p) { return s + ((p.roguelikeStats||{}).bossesDefeated||0); }, 0);
  var totalVoluntaryExits = players.reduce(function(s,p) { return s + ((p.roguelikeStats||{}).voluntaryExits||0); }, 0);
  var totalCurrencyA = players.reduce(function(s,p) { return s + ((p.roguelikeStats||{}).totalCurrencyEarned||{}).A||0; }, 0);
  var totalCurrencyB = players.reduce(function(s,p) { return s + ((p.roguelikeStats||{}).totalCurrencyEarned||{}).B||0; }, 0);
  var totalCurrencyC = players.reduce(function(s,p) { return s + ((p.roguelikeStats||{}).totalCurrencyEarned||{}).C||0; }, 0);

  // World bosses defeated
  var worldBossAgg = {};
  players.forEach(function(p) {
    (p.worldBossesDefeated || []).forEach(function(b) {
      worldBossAgg[b] = (worldBossAgg[b] || 0) + 1;
    });
  });

  // Guild boss history
  var guildBossHistory = [];
  guilds.forEach(function(g) {
    (g.bossHistory || []).forEach(function(bh) {
      guildBossHistory.push({ guild: g.name, boss: bh.bossName || 'Unknown', tier: bh.tier || 1, damage: bh.totalDamage || 0, participants: Object.keys(bh.participants || {}).length, timestamp: bh.defeatedAt || bh.timestamp || 0 });
    });
  });
  guildBossHistory.sort(function(a,b) { return (b.timestamp||0) - (a.timestamp||0); });

  // Bounty data
  var activeBounties = (bountyData.player || []).filter(function(b) { return !b.completed; });
  var completedBounties = (bountyData.player || []).filter(function(b) { return b.completed; });

  // Combat type labels/data for chart
  var ctLabels = Object.keys(combatByType).map(function(k) { return k.charAt(0).toUpperCase() + k.slice(1); });
  var ctWins = Object.values(combatByType).map(function(v) { return v.w; });
  var ctLosses = Object.values(combatByType).map(function(v) { return v.l; });

  return '<div class="card"><h2 style="margin-bottom:25px">ðŸ“œ RPG Quests & Combat</h2>' +
    // Combat overview cards
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:14px;margin-bottom:30px">' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(76,175,80,0.3)"><div style="font-size:26px;font-weight:700;color:#4caf50">' + totalWins.toLocaleString() + '</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Total Victories</div></div>' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(244,67,54,0.3)"><div style="font-size:26px;font-weight:700;color:#f44336">' + totalLosses.toLocaleString() + '</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Total Defeats</div></div>' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(91,91,255,0.3)"><div style="font-size:26px;font-weight:700;color:#5b5bff">' + overallWinRate + '%</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Win Rate</div></div>' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(233,30,99,0.3)"><div style="font-size:26px;font-weight:700;color:#e91e63">' + allDeaths.length + '</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Deaths Logged</div></div>' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(255,152,0,0.3)"><div style="font-size:26px;font-weight:700;color:#ff9800">' + totalBountiesCompleted + '</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Bounties Done</div></div>' +
    '<div style="background:#1a1a2e;padding:18px;border-radius:10px;text-align:center;border:1px solid rgba(156,39,176,0.3)"><div style="font-size:26px;font-weight:700;color:#9c27b0">' + (totalDailyCompleted + totalWeeklyCompleted) + '</div><div style="color:#8b8fa3;font-size:11px;margin-top:4px">Quests Completed</div></div>' +
    '</div>' +
    // Charts row: Combat by Type + Skill Usage
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px">' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">âš”ï¸ Combat by Type</h3><div style="height:280px"><canvas id="combatTypeChart"></canvas></div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ… Guild Rank Distribution</h3><div style="height:280px"><canvas id="guildRankChart"></canvas></div></div>' +
    '</div>' +
    // Enemy Encounters Table + Skill Usage Table
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px">' +
    // Enemy Encounters
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ‘¾ Top Enemy Encounters</h3>' +
    (topEnemies.length > 0 ?
    '<div style="max-height:350px;overflow-y:auto"><table style="width:100%;border-collapse:collapse;font-size:12px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:6px;color:#8b8fa3">Enemy</th><th style="text-align:right;padding:6px;color:#8b8fa3">Wins</th><th style="text-align:right;padding:6px;color:#8b8fa3">Losses</th><th style="text-align:right;padding:6px;color:#8b8fa3">Win%</th></tr></thead><tbody>' +
    topEnemies.map(function(e) {
      var wrColor = parseFloat(e.winRate) >= 70 ? '#4caf50' : parseFloat(e.winRate) >= 40 ? '#ff9800' : '#f44336';
      return '<tr style="border-bottom:1px solid #222"><td style="padding:6px;color:#fff">' + e.name + '</td><td style="text-align:right;padding:6px;color:#4caf50">' + e.wins + '</td><td style="text-align:right;padding:6px;color:#f44336">' + e.losses + '</td><td style="text-align:right;padding:6px;color:' + wrColor + ';font-weight:700">' + e.winRate + '%</td></tr>';
    }).join('') +
    '</tbody></table></div>' : '<div style="color:#72767d;text-align:center;padding:20px">No combat data yet â€” tracking begins now!</div>') +
    '</div>' +
    // Skill Usage
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">âš¡ Most Used Skills</h3>' +
    (topSkills.length > 0 ?
    '<div style="max-height:350px;overflow-y:auto"><table style="width:100%;border-collapse:collapse;font-size:12px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:6px;color:#8b8fa3">Skill</th><th style="text-align:right;padding:6px;color:#8b8fa3">Uses</th><th style="text-align:right;padding:6px;color:#8b8fa3">Total Dmg</th><th style="text-align:right;padding:6px;color:#8b8fa3">Avg Dmg</th></tr></thead><tbody>' +
    topSkills.map(function(s) {
      return '<tr style="border-bottom:1px solid #222"><td style="padding:6px;color:#fff">âš¡ ' + s.name + '</td><td style="text-align:right;padding:6px;color:#5b5bff;font-weight:600">' + s.used + '</td><td style="text-align:right;padding:6px;color:#ff9800">' + s.damage.toLocaleString() + '</td><td style="text-align:right;padding:6px;color:#4caf50">' + s.avgDmg + '</td></tr>';
    }).join('') +
    '</tbody></table></div>' : '<div style="color:#72767d;text-align:center;padding:20px">No skill usage data yet â€” tracking begins now!</div>') +
    '</div>' +
    '</div>' +
    // Roguelike Deep Stats
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ—¼ Roguelike Deep Stats</h3>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:10px">' +
    '<div style="background:#2a2e35;padding:12px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#ba68c8">' + totalRuns + '</div><div style="color:#72767d;font-size:10px;margin-top:3px">Total Runs</div></div>' +
    '<div style="background:#2a2e35;padding:12px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#5b5bff">F' + highestFloor + '</div><div style="color:#72767d;font-size:10px;margin-top:3px">Highest Floor</div></div>' +
    '<div style="background:#2a2e35;padding:12px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#f44336">' + totalRogueDeaths + '</div><div style="color:#72767d;font-size:10px;margin-top:3px">Deaths</div></div>' +
    '<div style="background:#2a2e35;padding:12px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#4caf50">' + totalRogueBosses + '</div><div style="color:#72767d;font-size:10px;margin-top:3px">Bosses Killed</div></div>' +
    '<div style="background:#2a2e35;padding:12px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#ff9800">' + totalVoluntaryExits + '</div><div style="color:#72767d;font-size:10px;margin-top:3px">Voluntary Exits</div></div>' +
    '<div style="background:#2a2e35;padding:12px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#e91e63">' + totalCurrencyA + '</div><div style="color:#72767d;font-size:10px;margin-top:3px">Currency A</div></div>' +
    '<div style="background:#2a2e35;padding:12px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#00bcd4">' + totalCurrencyB + '</div><div style="color:#72767d;font-size:10px;margin-top:3px">Currency B</div></div>' +
    '<div style="background:#2a2e35;padding:12px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#9c27b0">' + totalCurrencyC + '</div><div style="color:#72767d;font-size:10px;margin-top:3px">Currency C</div></div>' +
    '</div></div>' +
    // Active Bounties + Guild Quests
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px">' +
    // Active Bounties
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸŽ¯ Active Bounties (' + activeBounties.length + ')</h3>' +
    (activeBounties.length > 0 ?
    activeBounties.map(function(b) {
      var timeLeft = b.expiresAt ? Math.max(0, Math.round((b.expiresAt - Date.now()) / 3600000)) + 'h left' : 'No expiry';
      return '<div style="background:#2a2e35;padding:12px;border-radius:8px;margin-bottom:8px;border-left:3px solid #ff9800"><div style="color:#fff;font-weight:600">' + (b.title||'Bounty') + '</div><div style="color:#72767d;font-size:11px">' + (b.description||'') + '</div><div style="display:flex;justify-content:space-between;margin-top:6px;font-size:11px"><span style="color:#ff9800">ðŸ’° ' + ((b.rewards||{}).gold||0) + 'g</span><span style="color:#8b8fa3">' + timeLeft + '</span></div></div>';
    }).join('') : '<div style="color:#72767d;text-align:center;padding:20px">No active bounties</div>') +
    '</div>' +
    // Guild Quests Available
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ“‹ Guild Quests Available</h3>' +
    '<h4 style="color:#4caf50;font-size:12px;margin:10px 0 6px 0">Daily (' + (guildQuests.daily||[]).length + ')</h4>' +
    (guildQuests.daily||[]).map(function(q) {
      return '<div style="font-size:12px;padding:4px 8px;border-bottom:1px solid #222"><span style="color:#fff">' + (q.title||q.id) + '</span> <span style="color:#72767d">â€” ' + (q.description||'') + '</span> <span style="color:#ff9800">+' + ((q.rewards||{}).gold||0) + 'g</span></div>';
    }).join('') +
    '<h4 style="color:#5b5bff;font-size:12px;margin:10px 0 6px 0">Weekly (' + (guildQuests.weekly||[]).length + ')</h4>' +
    (guildQuests.weekly||[]).map(function(q) {
      return '<div style="font-size:12px;padding:4px 8px;border-bottom:1px solid #222"><span style="color:#fff">' + (q.title||q.id) + '</span> <span style="color:#72767d">â€” ' + (q.description||'') + '</span> <span style="color:#ff9800">+' + ((q.rewards||{}).gold||0) + 'g</span></div>';
    }).join('') +
    '<h4 style="color:#e91e63;font-size:12px;margin:10px 0 6px 0">Limited (' + (guildQuests.limited||[]).length + ')</h4>' +
    (guildQuests.limited||[]).map(function(q) {
      return '<div style="font-size:12px;padding:4px 8px;border-bottom:1px solid #222"><span style="color:#fff">' + (q.title||q.id) + '</span> <span style="color:#72767d">â€” ' + (q.description||'') + '</span></div>';
    }).join('') +
    '</div>' +
    '</div>' +
    // Defense Quests
    (defenseQuests.length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ›¡ï¸ Defense Quests</h3>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:12px">' +
    defenseQuests.map(function(q) {
      var enemy = q.enemy || {};
      return '<div style="background:#2a2e35;padding:14px;border-radius:8px;border-left:3px solid #e91e63"><div style="color:#fff;font-weight:600;margin-bottom:4px">' + (q.name||q.id) + '</div><div style="color:#72767d;font-size:11px;margin-bottom:6px">' + (q.description||'') + '</div><div style="font-size:11px"><span style="color:#8b8fa3">Min Level: </span><span style="color:#ff9800">' + (q.minLevel||1) + '</span> â€¢ <span style="color:#8b8fa3">Enemy: </span><span style="color:#f44336">' + (enemy.name||'?') + ' Lv' + (enemy.level||'?') + '</span></div><div style="font-size:11px;margin-top:4px"><span style="color:#8b8fa3">Rewards: </span><span style="color:#4caf50">' + ((q.reward||{}).xp||0) + ' XP, ' + ((q.reward||{}).gold||0) + 'g</span>' + ((q.reward||{}).unlockClass ? ' <span style="color:#9c27b0">Unlocks: ' + q.reward.unlockClass + '</span>' : '') + '</div></div>';
    }).join('') +
    '</div></div>' : '') +
    // World Bosses Defeated
    (Object.keys(worldBossAgg).length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ‰ World Bosses Defeated</h3>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px">' +
    Object.entries(worldBossAgg).map(function(entry) {
      return '<div style="background:#2a2e35;padding:12px;border-radius:8px;text-align:center"><div style="font-size:24px">ðŸ‰</div><div style="color:#fff;font-weight:600;font-size:13px">' + entry[0] + '</div><div style="color:#ff9800;font-size:12px">' + entry[1] + ' player' + (entry[1] > 1 ? 's' : '') + '</div></div>';
    }).join('') +
    '</div></div>' : '') +
    // Guild Boss History
    (guildBossHistory.length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ‘‘ Guild Boss History</h3>' +
    '<div style="max-height:250px;overflow-y:auto"><table style="width:100%;border-collapse:collapse;font-size:12px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:6px;color:#8b8fa3">Guild</th><th style="text-align:left;padding:6px;color:#8b8fa3">Boss</th><th style="text-align:right;padding:6px;color:#8b8fa3">Tier</th><th style="text-align:right;padding:6px;color:#8b8fa3">Damage</th><th style="text-align:right;padding:6px;color:#8b8fa3">Players</th><th style="text-align:left;padding:6px;color:#8b8fa3">Date</th></tr></thead><tbody>' +
    guildBossHistory.map(function(bh) {
      return '<tr style="border-bottom:1px solid #222"><td style="padding:6px;color:#fff">' + bh.guild + '</td><td style="padding:6px;color:#e91e63">' + bh.boss + '</td><td style="text-align:right;padding:6px;color:#ff9800">T' + bh.tier + '</td><td style="text-align:right;padding:6px;color:#f44336;font-weight:600">' + bh.damage.toLocaleString() + '</td><td style="text-align:right;padding:6px;color:#5b5bff">' + bh.participants + '</td><td style="padding:6px;color:#8b8fa3">' + (bh.timestamp ? new Date(bh.timestamp).toLocaleDateString() : 'N/A') + '</td></tr>';
    }).join('') +
    '</tbody></table></div></div>' : '') +
    // Recent Deaths
    (allDeaths.length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:20px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ’€ Recent Deaths</h3>' +
    '<div style="max-height:200px;overflow-y:auto">' +
    allDeaths.slice(0, 25).map(function(d) {
      return '<div style="padding:6px 10px;border-bottom:1px solid #222;font-size:12px"><span style="color:#8b8fa3">' + new Date(d.timestamp||0).toLocaleString() + '</span> ðŸ’€ <strong style="color:#fff">' + (d.player||'?') + '</strong> <span style="color:#72767d">(Lv' + d.playerLevel + ')</span> killed by <span style="color:#f44336">' + (d.enemy||'?') + '</span> <span style="color:#72767d">(Lv' + d.enemyLevel + ') [' + (d.type||'combat') + ']</span></div>';
    }).join('') +
    '</div></div>' : '') +
    '</div>' +
    // Charts
    '<script>' +
    'document.addEventListener("DOMContentLoaded", function() {' +
    // Combat by Type grouped bar chart
    'var ctCtx = document.getElementById("combatTypeChart");' +
    'if (ctCtx) { new Chart(ctCtx, {' +
      'type: "bar",' +
      'data: { labels: ' + JSON.stringify(ctLabels) + ', datasets: [' +
      '{ label: "Wins", data: ' + JSON.stringify(ctWins) + ', backgroundColor: "#4caf5088", borderColor: "#4caf50", borderWidth: 1, borderRadius: 4 },' +
      '{ label: "Losses", data: ' + JSON.stringify(ctLosses) + ', backgroundColor: "#f4433688", borderColor: "#f44336", borderWidth: 1, borderRadius: 4 }' +
      '] },' +
      'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: "#8b8fa3", usePointStyle: true } } }, scales: { y: { beginAtZero: true, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#8b8fa3" } }, x: { grid: { display: false }, ticks: { color: "#8b8fa3" } } } }' +
    '}); }' +
    // Guild Rank Distribution
    'var grCtx = document.getElementById("guildRankChart");' +
    'if (grCtx) { new Chart(grCtx, {' +
      'type: "doughnut",' +
      'data: { labels: ' + JSON.stringify(Object.keys(rankCounts)) + ', datasets: [{ data: ' + JSON.stringify(Object.values(rankCounts)) + ', backgroundColor: ["#9e9e9e","#4caf50","#2196f3","#ff9800","#e91e63","#9c27b0","#ffd700"], borderWidth: 0 }] },' +
      'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: "right", labels: { color: "#8b8fa3", font: { size: 12 }, padding: 10, usePointStyle: true } } } }' +
    '}); }' +
    '});' +
    '<\/script>';
}

// Stream Comparison tab
function renderStreamCompareTab() {
  const h = history || [];
  const sortedStreams = h.slice().sort((a, b) => new Date(b.startedAt || b.date) - new Date(a.startedAt || a.date));

  // Build dropdown options
  const streamOptions = sortedStreams.map((s, i) => {
    const date = new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    const game = s.game || 'Unknown';
    const peak = s.peakViewers || 0;
    return '<option value="' + i + '"' + (i === 0 ? ' selected' : '') + '>' + date + ' - ' + game + ' (' + peak + ' peak)</option>';
  }).join('');

  const streamOptions2 = sortedStreams.map((s, i) => {
    const date = new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    const game = s.game || 'Unknown';
    const peak = s.peakViewers || 0;
    return '<option value="' + i + '"' + (i === 1 ? ' selected' : '') + '>' + date + ' - ' + game + ' (' + peak + ' peak)</option>';
  }).join('');

  // Pre-generate all stream data for JS
  const streamData = JSON.stringify(sortedStreams.map(s => ({
    date: new Date(s.startedAt || s.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }),
    game: s.game || 'Unknown',
    title: s.title || 'No title',
    peakViewers: s.peakViewers || 0,
    avgViewers: s.avgViewers || s.averageViewers || 0,
    duration: s.durationMinutes || 0,
    followers: s.followers || s.newFollowers || 0,
    subs: s.subscribers || s.newSubs || 0,
    engagement: (s.peakViewers || 0) + ((s.subscribers || 0) * 10) + ((s.followers || 0) * 2)
  })));

  return '<div class="card"><h2 style="margin-bottom:25px">ðŸ†š Stream Comparison</h2>' +
    '<p style="color:#72767d;font-size:13px;margin:0 0 20px 0">Compare any two streams side by side to spot differences in performance.</p>' +
    // Stream selectors
    '<div style="display:grid;grid-template-columns:1fr auto 1fr;gap:16px;align-items:end;margin-bottom:30px">' +
    '<div>' +
    '<label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:6px">Stream A</label>' +
    '<select id="streamA" onchange="compareStreams()" style="width:100%;padding:10px;background:#2a2e35;border:1px solid #5b5bff44;border-radius:6px;color:#fff;font-size:13px">' + streamOptions + '</select>' +
    '</div>' +
    '<div style="text-align:center;padding-bottom:3px"><span style="font-size:24px;color:#5b5bff;font-weight:700">VS</span></div>' +
    '<div>' +
    '<label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:6px">Stream B</label>' +
    '<select id="streamB" onchange="compareStreams()" style="width:100%;padding:10px;background:#2a2e35;border:1px solid #e91e6344;border-radius:6px;color:#fff;font-size:13px">' + streamOptions2 + '</select>' +
    '</div>' +
    '</div>' +
    // Comparison display
    '<div id="compare-result"></div>' +
    // Comparison chart
    '<div style="margin-top:20px;background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ“Š Visual Comparison</h3>' +
    '<div style="height:280px"><canvas id="compare-chart"></canvas></div>' +
    '</div>' +
    '</div>' +
    '<script>' +
    'var allStreams = ' + streamData + ';' +
    'var compareChart = null;' +
    'function compareStreams() {' +
    '  var ai = parseInt(document.getElementById("streamA").value);' +
    '  var bi = parseInt(document.getElementById("streamB").value);' +
    '  var a = allStreams[ai]; var b = allStreams[bi];' +
    '  if (!a || !b) return;' +
    '  function diff(va, vb) { var d = va - vb; var pct = vb > 0 ? ((d/vb)*100).toFixed(0) : "n/a"; return "<span style=\\"color:" + (d > 0 ? "#4caf50" : d < 0 ? "#ef5350" : "#8b8fa3") + ";font-weight:700\\">" + (d > 0 ? "+" : "") + d + (pct !== "n/a" ? " (" + (d > 0 ? "+" : "") + pct + "%)" : "") + "</span>"; }' +
    '  var metrics = [' +
    '    { label: "ðŸ“Š Peak Viewers", a: a.peakViewers, b: b.peakViewers },' +
    '    { label: "ðŸ‘¥ Avg Viewers", a: a.avgViewers, b: b.avgViewers },' +
    '    { label: "â±ï¸ Duration (min)", a: a.duration, b: b.duration },' +
    '    { label: "â¤ï¸ Followers", a: a.followers, b: b.followers },' +
    '    { label: "â­ Subs", a: a.subs, b: b.subs },' +
    '    { label: "ðŸ”¥ Engagement", a: a.engagement, b: b.engagement }' +
    '  ];' +
    '  var html = "<div style=\\"display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:10px\\">"' +
    '    + "<div style=\\"background:#5b5bff11;border:1px solid #5b5bff33;border-radius:10px;padding:16px\\"><div style=\\"font-size:14px;font-weight:700;color:#5b5bff;margin-bottom:6px\\">ðŸ…°ï¸ " + a.date + "</div><div style=\\"color:#b5bac1;font-size:12px\\">" + a.game + "</div><div style=\\"color:#72767d;font-size:11px;margin-top:4px\\">" + a.title + "</div></div>"' +
    '    + "<div style=\\"background:#e91e6311;border:1px solid #e91e6333;border-radius:10px;padding:16px\\"><div style=\\"font-size:14px;font-weight:700;color:#e91e63;margin-bottom:6px\\">ðŸ…±ï¸ " + b.date + "</div><div style=\\"color:#b5bac1;font-size:12px\\">" + b.game + "</div><div style=\\"color:#72767d;font-size:11px;margin-top:4px\\">" + b.title + "</div></div>"' +
    '    + "</div>";' +
    '  html += "<table style=\\"width:100%;border-collapse:collapse;font-size:13px\\"><thead><tr style=\\"border-bottom:2px solid #333\\"><th style=\\"text-align:left;padding:10px;color:#8b8fa3\\">Metric</th><th style=\\"text-align:right;padding:10px;color:#5b5bff\\">Stream A</th><th style=\\"text-align:right;padding:10px;color:#e91e63\\">Stream B</th><th style=\\"text-align:right;padding:10px;color:#8b8fa3\\">Difference</th></tr></thead><tbody>";' +
    '  metrics.forEach(function(m) {' +
    '    html += "<tr style=\\"border-bottom:1px solid #222\\"><td style=\\"padding:10px;color:#e0e0e0\\">" + m.label + "</td><td style=\\"text-align:right;padding:10px;color:#5b5bff;font-weight:600\\">" + m.a + "</td><td style=\\"text-align:right;padding:10px;color:#e91e63;font-weight:600\\">" + m.b + "</td><td style=\\"text-align:right;padding:10px\\">" + diff(m.a, m.b) + "</td></tr>";' +
    '  });' +
    '  html += "</tbody></table>";' +
    '  // Winner banner' +
    '  var aWins = metrics.filter(function(m){return m.a > m.b}).length;' +
    '  var bWins = metrics.filter(function(m){return m.b > m.a}).length;' +
    '  if (aWins !== bWins) {' +
    '    var winner = aWins > bWins ? "A" : "B";' +
    '    var wColor = winner === "A" ? "#5b5bff" : "#e91e63";' +
    '    html += "<div style=\\"text-align:center;margin-top:15px;padding:12px;background:" + wColor + "11;border:1px solid " + wColor + "33;border-radius:8px\\"><span style=\\"font-size:16px;font-weight:700;color:" + wColor + "\\">ðŸ† Stream " + winner + " wins " + Math.max(aWins,bWins) + "/" + metrics.length + " metrics</span></div>";' +
    '  }' +
    '  document.getElementById("compare-result").innerHTML = html;' +
    '  // Update chart' +
    '  if (compareChart) compareChart.destroy();' +
    '  var ctx = document.getElementById("compare-chart");' +
    '  if (ctx) {' +
    '    compareChart = new Chart(ctx, {' +
    '      type: "bar",' +
    '      data: {' +
    '        labels: ["Peak", "Avg Viewers", "Duration", "Followers", "Subs", "Engagement"],' +
    '        datasets: [{' +
    '          label: "Stream A (" + a.date + ")",' +
    '          data: [a.peakViewers, a.avgViewers, a.duration, a.followers, a.subs, a.engagement],' +
    '          backgroundColor: "#5b5bff88",' +
    '          borderColor: "#5b5bff",' +
    '          borderWidth: 1,' +
    '          borderRadius: 4' +
    '        }, {' +
    '          label: "Stream B (" + b.date + ")",' +
    '          data: [b.peakViewers, b.avgViewers, b.duration, b.followers, b.subs, b.engagement],' +
    '          backgroundColor: "#e91e6388",' +
    '          borderColor: "#e91e63",' +
    '          borderWidth: 1,' +
    '          borderRadius: 4' +
    '        }]' +
    '      },' +
    '      options: {' +
    '        responsive: true,' +
    '        maintainAspectRatio: false,' +
    '        plugins: { legend: { display: true, labels: { color: "#8b8fa3", usePointStyle: true } } },' +
    '        scales: {' +
    '          y: { beginAtZero: true, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#8b8fa3" } },' +
    '          x: { grid: { display: false }, ticks: { color: "#8b8fa3" } }' +
    '        }' +
    '      }' +
    '    });' +
    '  }' +
    '}' +
    'document.addEventListener("DOMContentLoaded", function() { if (allStreams.length >= 2) compareStreams(); });' +
    '<\/script>';
}

// RPG Analytics tab
function renderRPGAnalyticsTab() {
  const playersPath = path.join(process.cwd(), 'data', 'players.json');
  const guildsPath = path.join(process.cwd(), 'data', 'guilds.json');
  let players = [];
  let guilds = [];
  try {
    if (fs.existsSync(playersPath)) {
      const raw = cachedReadJSON(playersPath);
      players = Object.values(raw).filter(p => p && p.userId);
    }
  } catch(e) {}
  try {
    if (fs.existsSync(guildsPath)) {
      const raw = cachedReadJSON(guildsPath);
      const serverId = Object.keys(raw)[0];
      if (serverId) guilds = Object.values(raw[serverId]).filter(g => g && g.id);
    }
  } catch(e) {}

  // Aggregate stats
  const totalPlayers = players.length;
  const totalGold = players.reduce((s,p) => s + (p.gold || 0), 0);
  const avgLevel = totalPlayers > 0 ? (players.reduce((s,p) => s + (p.level || 1), 0) / totalPlayers).toFixed(1) : '0';
  const maxLevel = players.reduce((m,p) => Math.max(m, p.level || 1), 0);
  const totalArenaWins = players.reduce((s,p) => s + (p.arenaWins || 0), 0);
  const totalArenaLosses = players.reduce((s,p) => s + (p.arenaLosses || 0), 0);
  const arenaWinRate = (totalArenaWins + totalArenaLosses) > 0 ? ((totalArenaWins / (totalArenaWins + totalArenaLosses)) * 100).toFixed(1) : '0';

  // Class distribution
  const classCounts = {};
  players.forEach(p => { const c = p.class || 'Unknown'; classCounts[c] = (classCounts[c] || 0) + 1; });
  const classLabels = Object.keys(classCounts);
  const classData = Object.values(classCounts);
  const classColors = ['#e91e63','#5b5bff','#4caf50','#ff9800','#00bcd4','#9c27b0','#ffeb3b','#795548'];

  // Level distribution buckets
  const levelBuckets = {'1-10':0,'11-25':0,'26-50':0,'51-75':0,'76-100':0,'101-150':0};
  players.forEach(p => {
    const l = p.level || 1;
    if (l <= 10) levelBuckets['1-10']++;
    else if (l <= 25) levelBuckets['11-25']++;
    else if (l <= 50) levelBuckets['26-50']++;
    else if (l <= 75) levelBuckets['51-75']++;
    else if (l <= 100) levelBuckets['76-100']++;
    else levelBuckets['101-150']++;
  });

  // Profession distribution
  const profCounts = {};
  players.forEach(p => { (p.professions || []).forEach(pr => { profCounts[pr] = (profCounts[pr] || 0) + 1; }); });

  // Progress stats aggregated
  const totalMonsters = players.reduce((s,p) => s + ((p.progressStats||{}).monstersDefeated||0), 0);
  const totalCrafts = players.reduce((s,p) => s + ((p.progressStats||{}).craftsCompleted||0), 0);
  const totalGathering = players.reduce((s,p) => s + ((p.progressStats||{}).gatheringActions||0), 0);
  const totalGoldEarned = players.reduce((s,p) => s + ((p.progressStats||{}).goldEarned||0), 0);
  const totalDungeons = players.reduce((s,p) => s + ((p.progressStats||{}).dungeonsCleared||0), 0);
  const totalCritHits = players.reduce((s,p) => s + ((p.progressStats||{}).criticalHits||0), 0);

  // Roguelike stats
  const totalRuns = players.reduce((s,p) => s + ((p.roguelikeStats||{}).totalRunsCompleted||0), 0);
  const highestFloor = players.reduce((m,p) => Math.max(m, (p.roguelikeStats||{}).highestFloorReached||0), 0);
  const totalRogueDeaths = players.reduce((s,p) => s + ((p.roguelikeStats||{}).deathCount||0), 0);
  const totalRogueBosses = players.reduce((s,p) => s + ((p.roguelikeStats||{}).bossesDefeated||0), 0);

  // Top players by level
  const topByLevel = [...players].sort((a,b) => (b.level||0) - (a.level||0)).slice(0, 10);
  // Top by gold
  const topByGold = [...players].sort((a,b) => (b.gold||0) - (a.gold||0)).slice(0, 10);
  // Top arena
  const topByArena = [...players].filter(p => (p.arenaWins||0) > 0).sort((a,b) => (b.arenaWins||0) - (a.arenaWins||0)).slice(0, 10);

  // ============================================
  // CREATIVE ANALYTICS DATA COMPUTATION
  // ============================================

  // --- 1. SUPERLATIVE AWARDS ---
  const activePlayers = players.filter(p => (p.level||1) > 1 || (p.gold||0) > 0);
  const superlatives = [];
  
  // Goblin Slayer - most monsters defeated
  const topMonsterSlayer = [...players].sort((a,b) => ((b.progressStats||{}).monstersDefeated||0) - ((a.progressStats||{}).monstersDefeated||0))[0];
  if (topMonsterSlayer && (topMonsterSlayer.progressStats||{}).monstersDefeated > 0)
    superlatives.push({ award: 'The Goblin Slayer', emoji: 'âš”ï¸', player: topMonsterSlayer.username, value: (topMonsterSlayer.progressStats.monstersDefeated||0).toLocaleString() + ' kills', color: '#ff6b6b' });
  
  // Dungeon Rat - most dungeons cleared
  const topDungeoneer = [...players].sort((a,b) => ((b.progressStats||{}).dungeonsCleared||0) - ((a.progressStats||{}).dungeonsCleared||0))[0];
  if (topDungeoneer && (topDungeoneer.progressStats||{}).dungeonsCleared > 0)
    superlatives.push({ award: 'Dungeon Rat', emoji: 'ðŸ°', player: topDungeoneer.username, value: (topDungeoneer.progressStats.dungeonsCleared||0) + ' cleared', color: '#ffb74d' });
  
  // Golden Hands - most crafts
  const topCrafter = [...players].sort((a,b) => ((b.progressStats||{}).craftsCompleted||0) - ((a.progressStats||{}).craftsCompleted||0))[0];
  if (topCrafter && (topCrafter.progressStats||{}).craftsCompleted > 0)
    superlatives.push({ award: 'Golden Hands', emoji: 'ðŸ”¨', player: topCrafter.username, value: (topCrafter.progressStats.craftsCompleted||0) + ' crafts', color: '#4db6ac' });
  
  // Harvest Moon - most gathering actions
  const topGatherer = [...players].sort((a,b) => ((b.progressStats||{}).gatheringActions||0) - ((a.progressStats||{}).gatheringActions||0))[0];
  if (topGatherer && (topGatherer.progressStats||{}).gatheringActions > 0)
    superlatives.push({ award: 'Harvest Moon', emoji: 'ðŸŒ¿', player: topGatherer.username, value: (topGatherer.progressStats.gatheringActions||0).toLocaleString() + ' gathers', color: '#81c784' });
  
  // Scrooge McDuck - richest
  const richest = topByGold[0];
  if (richest && (richest.gold||0) > 0)
    superlatives.push({ award: 'Scrooge McDuck', emoji: 'ðŸ’°', player: richest.username, value: (richest.gold||0).toLocaleString() + ' gold', color: '#ffd700' });
  
  // The Hoarder - most inventory items
  const topHoarder = [...players].sort((a,b) => ((b.inventory||[]).reduce((s,i) => s+(i.quantity||1),0)) - ((a.inventory||[]).reduce((s,i) => s+(i.quantity||1),0)))[0];
  if (topHoarder) {
    const hoardCount = (topHoarder.inventory||[]).reduce((s,i) => s+(i.quantity||1),0);
    if (hoardCount > 0) superlatives.push({ award: 'The Hoarder', emoji: 'ðŸŽ’', player: topHoarder.username, value: hoardCount.toLocaleString() + ' items', color: '#ce93d8' });
  }
  
  // Arena Champion - best arena win rate (min 5 fights)
  const arenaChamp = [...players].filter(p => ((p.arenaWins||0)+(p.arenaLosses||0)) >= 5)
    .sort((a,b) => ((b.arenaWins||0)/((b.arenaWins||0)+(b.arenaLosses||1))) - ((a.arenaWins||0)/((a.arenaWins||0)+(a.arenaLosses||1))))[0];
  if (arenaChamp)
    superlatives.push({ award: 'Arena Champion', emoji: 'ðŸ†', player: arenaChamp.username, value: ((arenaChamp.arenaWins||0)/((arenaChamp.arenaWins||0)+(arenaChamp.arenaLosses||1))*100).toFixed(0) + '% win rate', color: '#00bcd4' });
  
  // Rogue Runner - highest roguelike floor
  const topRogue = [...players].sort((a,b) => ((b.roguelikeStats||{}).highestFloorReached||0) - ((a.roguelikeStats||{}).highestFloorReached||0))[0];
  if (topRogue && (topRogue.roguelikeStats||{}).highestFloorReached > 0)
    superlatives.push({ award: 'Rogue Runner', emoji: 'ðŸ—¼', player: topRogue.username, value: 'Floor ' + (topRogue.roguelikeStats.highestFloorReached||0), color: '#ba68c8' });
  
  // World Explorer - most worlds unlocked
  const topExplorer = [...players].sort((a,b) => ((b.worldsUnlocked||[]).length) - ((a.worldsUnlocked||[]).length))[0];
  if (topExplorer && (topExplorer.worldsUnlocked||[]).length > 0)
    superlatives.push({ award: 'World Explorer', emoji: 'ðŸ—ºï¸', player: topExplorer.username, value: (topExplorer.worldsUnlocked||[]).length + ' worlds', color: '#64b5f6' });
  
  // Boss Slayer - most world bosses defeated
  const topBossSlayer = [...players].sort((a,b) => ((b.worldBossesDefeated||[]).length) - ((a.worldBossesDefeated||[]).length))[0];
  if (topBossSlayer && (topBossSlayer.worldBossesDefeated||[]).length > 0)
    superlatives.push({ award: 'Boss Slayer', emoji: 'ðŸ‰', player: topBossSlayer.username, value: (topBossSlayer.worldBossesDefeated||[]).length + ' bosses', color: '#ef5350' });
  
  // Skill Master - most skills learned
  const topSkillMaster = [...players].sort((a,b) => ((b.skills||[]).length) - ((a.skills||[]).length))[0];
  if (topSkillMaster && (topSkillMaster.skills||[]).length > 0)
    superlatives.push({ award: 'Skill Master', emoji: 'ðŸ“š', player: topSkillMaster.username, value: (topSkillMaster.skills||[]).length + ' skills', color: '#7986cb' });
  
  // Critical Machine - most critical hits  
  const topCrit = [...players].sort((a,b) => ((b.progressStats||{}).criticalHits||0) - ((a.progressStats||{}).criticalHits||0))[0];
  if (topCrit && (topCrit.progressStats||{}).criticalHits > 0)
    superlatives.push({ award: 'Critical Machine', emoji: 'ðŸ’¥', player: topCrit.username, value: (topCrit.progressStats.criticalHits||0).toLocaleString() + ' crits', color: '#e57373' });
  
  // Glass Cannon - highest offense stats with lowest defense
  const glassCannonCandidates = players.filter(p => (p.strength||0) > 0 && (p.defense||0) > 0);
  if (glassCannonCandidates.length > 0) {
    const glassCannon = [...glassCannonCandidates].sort((a,b) => {
      const ratioA = ((a.strength||0)+(a.intelligence||0)) / Math.max(1,(a.defense||0)+(a.vitality||0));
      const ratioB = ((b.strength||0)+(b.intelligence||0)) / Math.max(1,(b.defense||0)+(b.vitality||0));
      return ratioB - ratioA;
    })[0];
    if (glassCannon) superlatives.push({ award: 'Glass Cannon', emoji: 'ðŸ”®', player: glassCannon.username, value: 'ATK:' + ((glassCannon.strength||0)+(glassCannon.intelligence||0)) + ' DEF:' + ((glassCannon.defense||0)+(glassCannon.vitality||0)), color: '#ff8a65' });
  }
  
  // The Tank - highest defense+vitality
  const topTank = [...players].sort((a,b) => ((b.defense||0)+(b.vitality||0)+(b.maxHp||0)) - ((a.defense||0)+(a.vitality||0)+(a.maxHp||0)))[0];
  if (topTank && ((topTank.defense||0)+(topTank.vitality||0)) > 0)
    superlatives.push({ award: 'The Tank', emoji: 'ðŸ›¡ï¸', player: topTank.username, value: (topTank.maxHp||0).toLocaleString() + ' HP', color: '#4fc3f7' });
  
  // Marathon Gatherer - highest auto-gather count
  const topAutoGather = [...players].sort((a,b) => (b.autoGatherCount||0) - (a.autoGatherCount||0))[0];
  if (topAutoGather && (topAutoGather.autoGatherCount||0) > 0)
    superlatives.push({ award: 'Marathon Gatherer', emoji: 'â›ï¸', player: topAutoGather.username, value: (topAutoGather.autoGatherCount||0).toLocaleString() + ' auto-gathers', color: '#a1887f' });

  const superlativeAwardsHtml = superlatives.map(s =>
    '<div style="background:linear-gradient(135deg,' + s.color + '11,' + s.color + '05);border:1px solid ' + s.color + '44;border-radius:12px;padding:16px;text-align:center;min-width:180px">' +
    '<div style="font-size:32px;margin-bottom:6px">' + s.emoji + '</div>' +
    '<div style="font-size:11px;color:' + s.color + ';font-weight:700;text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">' + s.award + '</div>' +
    '<div style="font-size:15px;color:#fff;font-weight:600;margin-bottom:4px">' + (s.player||'Unknown') + '</div>' +
    '<div style="font-size:12px;color:#8b8fa3">' + s.value + '</div></div>'
  ).join('');

  // --- 2. ECONOMY HEALTH INDEX ---
  const goldValues = players.map(p => p.gold || 0).sort((a,b) => a-b);
  const medianGold = goldValues.length > 0 ? goldValues[Math.floor(goldValues.length / 2)] : 0;
  const avgGoldVal = totalPlayers > 0 ? Math.round(totalGold / totalPlayers) : 0;
  
  // Gini coefficient calculation
  let giniCoeff = 0;
  if (goldValues.length > 1) {
    const n = goldValues.length;
    const sumOfDiffs = goldValues.reduce((sum, gi, i) => {
      return sum + goldValues.reduce((s2, gj) => s2 + Math.abs(gi - gj), 0);
    }, 0);
    const meanGold = totalGold / n;
    giniCoeff = meanGold > 0 ? (sumOfDiffs / (2 * n * n * meanGold)) : 0;
  }
  
  // Top 10% wealth share
  const top10Pct = Math.max(1, Math.ceil(goldValues.length * 0.1));
  const top10Gold = goldValues.slice(-top10Pct).reduce((s,g) => s+g, 0);
  const top10Share = totalGold > 0 ? ((top10Gold / totalGold) * 100).toFixed(1) : '0';
  
  // Economy health grade
  let econGrade = 'A';
  let econColor = '#4caf50';
  if (giniCoeff > 0.8) { econGrade = 'F'; econColor = '#ff1744'; }
  else if (giniCoeff > 0.65) { econGrade = 'D'; econColor = '#ff6b6b'; }
  else if (giniCoeff > 0.5) { econGrade = 'C'; econColor = '#ff9800'; }
  else if (giniCoeff > 0.35) { econGrade = 'B'; econColor = '#ffeb3b'; }
  
  // Gold earned vs current gold (spending indicator)
  const totalEverEarned = players.reduce((s,p) => s + ((p.progressStats||{}).goldEarned||0), 0);
  const goldSpentPct = totalEverEarned > 0 ? (((totalEverEarned - totalGold) / totalEverEarned) * 100).toFixed(1) : '0';
  
  // Richest vs poorest ratio
  const richestGold = goldValues.length > 0 ? goldValues[goldValues.length-1] : 0;
  const poorestGold = goldValues.length > 0 ? goldValues[0] : 0;
  const wealthRatio = poorestGold > 0 ? Math.round(richestGold / poorestGold) : richestGold > 0 ? 'âˆž' : '0';
  
  // Lorenz curve data points (10 percentile buckets)
  const lorenzData = [];
  if (goldValues.length > 0) {
    for (let pct = 0; pct <= 100; pct += 10) {
      const idx = Math.min(Math.floor(goldValues.length * pct / 100), goldValues.length);
      const cumGold = goldValues.slice(0, idx).reduce((s,g) => s+g, 0);
      lorenzData.push({ pct, cumGold: totalGold > 0 ? ((cumGold / totalGold) * 100).toFixed(1) : 0 });
    }
  }

  // --- 3. PLAYER PERSONALITY RADAR (AI Tendencies) ---
  const playersWithAI = players.filter(p => p.aiTendencies && typeof p.aiTendencies === 'object');
  const aiLabels = ['Aggression', 'Risk Taking', 'Skill Usage', 'Resource Conservation', 'Defensive Priority', 'Finisher Usage'];
  const aiKeys = ['aggression', 'riskTaking', 'skillUsage', 'resourceConservation', 'defensivePriority', 'finisherUsage'];
  
  // Server averages
  const aiAvgs = aiKeys.map(k => {
    if (playersWithAI.length === 0) return 0;
    return +(playersWithAI.reduce((s,p) => s + (p.aiTendencies[k]||0), 0) / playersWithAI.length).toFixed(2);
  });
  
  // Find extremes
  const mostAggressive = [...playersWithAI].sort((a,b) => (b.aiTendencies.aggression||0) - (a.aiTendencies.aggression||0))[0];
  const mostCautious = [...playersWithAI].sort((a,b) => (b.aiTendencies.defensivePriority||0) - (a.aiTendencies.defensivePriority||0))[0];
  const biggestRiskTaker = [...playersWithAI].sort((a,b) => (b.aiTendencies.riskTaking||0) - (a.aiTendencies.riskTaking||0))[0];
  
  // Top 3 players for individual radar display
  const radarPlayers = playersWithAI.slice(0, 3).map(p => ({
    name: p.username,
    data: aiKeys.map(k => +(p.aiTendencies[k]||0).toFixed(2))
  }));

  // --- 4. THE GRAVEYARD (Death Analytics) ---
  const totalArenaDeaths = players.reduce((s,p) => s + (p.arenaLosses||0), 0);
  const totalDeathsAll = totalRogueDeaths + totalArenaDeaths;
  const deathsByType = {
    'Arena': totalArenaDeaths,
    'Roguelike': totalRogueDeaths
  };
  
  // Players with most combined deaths  
  const topDeathPlayers = [...players].sort((a,b) => {
    const deathsA = (a.arenaLosses||0) + ((a.roguelikeStats||{}).deathCount||0);
    const deathsB = (b.arenaLosses||0) + ((b.roguelikeStats||{}).deathCount||0);
    return deathsB - deathsA;
  }).slice(0, 5);
  
  // Last enemy data (what killed people last)
  const lastEnemyCounts = {};
  players.forEach(p => {
    if (p.lastEnemy && p.lastEnemy.name) {
      lastEnemyCounts[p.lastEnemy.name] = (lastEnemyCounts[p.lastEnemy.name]||0) + 1;
    }
  });
  const topEnemies = Object.entries(lastEnemyCounts).sort((a,b) => b[1]-a[1]).slice(0, 5);
  
  // "Overconfidence index" â€” players fighting enemies way above their level
  let overconfidentBattles = 0;
  let totalBattleRecords = 0;
  players.forEach(p => {
    if (p.lastEnemy && p.lastEnemy.level) {
      totalBattleRecords++;
      if ((p.lastEnemy.level||0) > (p.level||1) + 10) overconfidentBattles++;
    }
  });
  const overconfidenceRate = totalBattleRecords > 0 ? ((overconfidentBattles / totalBattleRecords) * 100).toFixed(0) : '0';

  // --- 5. RISK & LUCK METERS ---
  // Roguelike risk profiles
  const roguelikePlayers = players.filter(p => (p.roguelikeStats||{}).totalRunsCompleted > 0);
  const chickenScoreAvg = roguelikePlayers.length > 0 
    ? (roguelikePlayers.reduce((s,p) => s + ((p.roguelikeStats.voluntaryExits||0) / Math.max(1, p.roguelikeStats.totalRunsCompleted)), 0) / roguelikePlayers.length * 100).toFixed(0)
    : '0';
  const yoloScoreAvg = roguelikePlayers.length > 0
    ? (roguelikePlayers.reduce((s,p) => s + ((p.roguelikeStats.deathCount||0) / Math.max(1, p.roguelikeStats.totalRunsCompleted)), 0) / roguelikePlayers.length * 100).toFixed(0)
    : '0';
  const rogueBossEfficiency = roguelikePlayers.length > 0
    ? (roguelikePlayers.reduce((s,p) => s + ((p.roguelikeStats.bossesDefeated||0) / Math.max(1, p.roguelikeStats.totalRunsCompleted)), 0) / roguelikePlayers.length).toFixed(1)
    : '0';
  
  // Arena risk   
  const arenaParticipants = players.filter(p => ((p.arenaWins||0)+(p.arenaLosses||0)) > 0);
  const avgArenaWinRate = arenaParticipants.length > 0
    ? (arenaParticipants.reduce((s,p) => s + ((p.arenaWins||0) / Math.max(1, (p.arenaWins||0)+(p.arenaLosses||0))), 0) / arenaParticipants.length * 100).toFixed(0)
    : '0';
  
  // Biggest gambler (most arena fights)
  const biggestGambler = [...players].sort((a,b) => ((b.arenaWins||0)+(b.arenaLosses||0)) - ((a.arenaWins||0)+(a.arenaLosses||0)))[0];
  
  // Risk profile: efficient roguelike runner vs reckless
  const riskProfiles = roguelikePlayers.map(p => ({
    name: p.username,
    chicken: p.roguelikeStats.totalRunsCompleted > 0 ? ((p.roguelikeStats.voluntaryExits||0) / p.roguelikeStats.totalRunsCompleted * 100).toFixed(0) : '0',
    yolo: p.roguelikeStats.totalRunsCompleted > 0 ? ((p.roguelikeStats.deathCount||0) / p.roguelikeStats.totalRunsCompleted * 100).toFixed(0) : '0',
    floor: p.roguelikeStats.highestFloorReached||0,
    bosses: p.roguelikeStats.bossesDefeated||0,
    runs: p.roguelikeStats.totalRunsCompleted||0
  })).sort((a,b) => b.floor - a.floor).slice(0, 8);

  // --- 6. PLAYER ARCHETYPE CLASSIFICATION ---
  const archetypeData = players.filter(p => (p.level||1) > 1).map(p => {
    const combat = ((p.progressStats||{}).monstersDefeated||0) + ((p.progressStats||{}).criticalHits||0);
    const crafting = ((p.progressStats||{}).craftsCompleted||0) * 5;
    const gathering = ((p.progressStats||{}).gatheringActions||0);
    const exploration = ((p.worldsUnlocked||[]).length * 100) + ((p.worldBossesDefeated||[]).length * 50);
    const social = (p.arenaWins||0) * 3 + (p.arenaLosses||0) + (p.guildXP||0);
    const dungeoneering = ((p.progressStats||{}).dungeonsCleared||0) * 10 + ((p.roguelikeStats||{}).totalRunsCompleted||0) * 5;
    
    const scores = { combat, crafting, gathering, exploration, social, dungeoneering };
    const maxKey = Object.entries(scores).sort((a,b) => b[1]-a[1])[0];
    
    const archetypeMap = {
      combat: { name: 'Warrior', emoji: 'âš”ï¸', color: '#ff6b6b' },
      crafting: { name: 'Artisan', emoji: 'ðŸ”¨', color: '#4db6ac' },
      gathering: { name: 'Farmer', emoji: 'ðŸŒ¾', color: '#81c784' },
      exploration: { name: 'Explorer', emoji: 'ðŸ—ºï¸', color: '#64b5f6' },
      social: { name: 'Gladiator', emoji: 'ðŸŸï¸', color: '#ffb74d' },
      dungeoneering: { name: 'Delver', emoji: 'ðŸ°', color: '#ba68c8' }
    };
    
    // Check if well-rounded (no single category > 40% of total)
    const totalScore = Object.values(scores).reduce((s,v) => s+v, 0);
    const maxPct = totalScore > 0 ? (maxKey[1] / totalScore) : 0;
    
    let archetype;
    if (totalScore === 0) {
      archetype = { name: 'Newcomer', emoji: 'ðŸŒŸ', color: '#8b8fa3' };
    } else if (maxPct < 0.35) {
      archetype = { name: 'Completionist', emoji: 'ðŸ‘‘', color: '#ffd700' };
    } else {
      archetype = archetypeMap[maxKey[0]];
    }
    
    return { username: p.username, level: p.level||1, archetype, scores, totalScore };
  });
  
  // Archetype distribution
  const archetypeCounts = {};
  archetypeData.forEach(p => {
    const n = p.archetype.name;
    archetypeCounts[n] = (archetypeCounts[n]||0) + 1;
  });
  const archetypeLabels = Object.keys(archetypeCounts);
  const archetypeValues = Object.values(archetypeCounts);
  const archetypeColors = archetypeLabels.map(n => {
    const colorMap = { Warrior:'#ff6b6b', Artisan:'#4db6ac', Farmer:'#81c784', Explorer:'#64b5f6', Gladiator:'#ffb74d', Delver:'#ba68c8', Completionist:'#ffd700', Newcomer:'#8b8fa3' };
    return colorMap[n] || '#5b5bff';
  });
  
  // Top archetyped players for display
  const archetypeShowcase = archetypeData.filter(p => p.totalScore > 0).sort((a,b) => b.totalScore - a.totalScore).slice(0, 12);

  // Guild stats
  const guildRows = guilds.map(g => {
    const memberCount = Object.keys(g.members || {}).length;
    return '<tr><td style="color:#fff;font-weight:600">' + (g.name||'Unknown') + '</td><td>' + memberCount + '</td><td>' + (g.level||1) + '</td><td>' + (g.gold||0).toLocaleString() + '</td><td>' + (g.xp||0).toLocaleString() + '</td><td>' + (g.bossHistory||[]).length + '</td></tr>';
  }).join('');

  // Active events summary
  const activeEvts = rpgEvents.activeEvents || [];
  const activeEventsHtml = activeEvts.length > 0 
    ? activeEvts.map(e => '<div style="display:inline-block;padding:6px 14px;background:#5b5bff22;border:1px solid #5b5bff;border-radius:20px;margin:4px;font-size:13px">' + (e.emoji||'ðŸŽ®') + ' ' + (e.name||'Event') + ' <span style="color:#8b8fa3">(' + Math.max(0, Math.round(((e.endsAt||0) - Date.now()) / 60000)) + 'min left)</span></div>').join('')
    : '<span style="color:#72767d">No active events</span>';

  return '<div class="card"><h2 style="margin-bottom:25px">ðŸŽ® RPG Analytics</h2>' +
    // Active events banner
    '<div style="margin-bottom:20px;padding:15px;background:#1a1a2e;border-radius:10px;border:1px solid #5b5bff33">' +
    '<h3 style="margin:0 0 10px 0;font-size:14px;color:#8b8fa3">âš¡ Active Events</h3>' + activeEventsHtml + '</div>' +
    // Summary cards row
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:16px;margin-bottom:30px">' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(91,91,255,0.2)"><div style="font-size:28px;font-weight:700;color:#5b5bff">' + totalPlayers + '</div><div style="color:#8b8fa3;font-size:12px;margin-top:4px">Total Players</div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(233,30,99,0.2)"><div style="font-size:28px;font-weight:700;color:#e91e63">' + avgLevel + '</div><div style="color:#8b8fa3;font-size:12px;margin-top:4px">Avg Level</div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(255,152,0,0.2)"><div style="font-size:28px;font-weight:700;color:#ff9800">Lv.' + maxLevel + '</div><div style="color:#8b8fa3;font-size:12px;margin-top:4px">Highest Level</div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(76,175,80,0.2)"><div style="font-size:28px;font-weight:700;color:#4caf50">' + (totalGold >= 1e6 ? (totalGold/1e6).toFixed(1)+'M' : totalGold.toLocaleString()) + '</div><div style="color:#8b8fa3;font-size:12px;margin-top:4px">Total Gold</div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(0,188,212,0.2)"><div style="font-size:28px;font-weight:700;color:#00bcd4">' + arenaWinRate + '%</div><div style="color:#8b8fa3;font-size:12px;margin-top:4px">Arena Win Rate</div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(156,39,176,0.2)"><div style="font-size:28px;font-weight:700;color:#9c27b0">' + guilds.length + '</div><div style="color:#8b8fa3;font-size:12px;margin-top:4px">Guilds</div></div>' +
    '</div>' +
    // Progress stats cards
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(130px,1fr));gap:12px;margin-bottom:30px">' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#ff6b6b">âš”ï¸ ' + totalMonsters.toLocaleString() + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Monsters Killed</div></div>' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#4db6ac">ðŸ”¨ ' + totalCrafts.toLocaleString() + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Items Crafted</div></div>' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#81c784">ðŸŒ¿ ' + totalGathering.toLocaleString() + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Gathering Actions</div></div>' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#ffb74d">ðŸ° ' + totalDungeons.toLocaleString() + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Dungeons Cleared</div></div>' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#e57373">ðŸ’¥ ' + totalCritHits.toLocaleString() + '</div><div style="color:#72767d;font-size:11px;margin-top:4px">Critical Hits</div></div>' +
    '<div style="background:#2a2e35;padding:14px;border-radius:8px;text-align:center"><div style="font-size:20px;font-weight:700;color:#ba68c8">ðŸ—¼ ' + totalRuns + ' runs</div><div style="color:#72767d;font-size:11px;margin-top:4px">Roguelike (Floor ' + highestFloor + ')</div></div>' +
    '</div>' +
    // Charts row
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px">' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸŽ­ Class Distribution</h3><div style="height:250px"><canvas id="classDistChart"></canvas></div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ“Š Level Distribution</h3><div style="height:250px"><canvas id="levelDistChart"></canvas></div></div>' +
    '</div>' +
    // Profession chart
    (Object.keys(profCounts).length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ› ï¸ Profession Popularity</h3><div style="height:200px"><canvas id="profChart"></canvas></div></div>' : '') +
    // Leaderboards
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:30px">' +
    // Top by level
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ† Top Players by Level</h3>' +
    '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:8px;color:#8b8fa3">Player</th><th style="text-align:left;padding:8px;color:#8b8fa3">Class</th><th style="text-align:right;padding:8px;color:#8b8fa3">Level</th></tr></thead><tbody>' +
    topByLevel.map((p,i) => '<tr style="border-bottom:1px solid #222"><td style="padding:8px;color:#fff">' + (i<3?['ðŸ¥‡','ðŸ¥ˆ','ðŸ¥‰'][i]:''+(i+1)) + ' ' + (p.username||'Unknown') + '</td><td style="padding:8px;color:#b5bac1">' + (p.class||'-') + '</td><td style="text-align:right;padding:8px;color:#5b5bff;font-weight:700">' + (p.level||1) + '</td></tr>').join('') +
    '</tbody></table></div>' +
    // Top by gold
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ’° Top Players by Gold</h3>' +
    '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:8px;color:#8b8fa3">Player</th><th style="text-align:right;padding:8px;color:#8b8fa3">Gold</th></tr></thead><tbody>' +
    topByGold.map((p,i) => '<tr style="border-bottom:1px solid #222"><td style="padding:8px;color:#fff">' + (i<3?['ðŸ¥‡','ðŸ¥ˆ','ðŸ¥‰'][i]:''+(i+1)) + ' ' + (p.username||'Unknown') + '</td><td style="text-align:right;padding:8px;color:#ff9800;font-weight:700">' + (p.gold||0).toLocaleString() + '</td></tr>').join('') +
    '</tbody></table></div>' +
    '</div>' +
    // Arena leaderboard
    (topByArena.length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">âš”ï¸ Arena Leaderboard</h3>' +
    '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:8px;color:#8b8fa3">Player</th><th style="text-align:right;padding:8px;color:#8b8fa3">Wins</th><th style="text-align:right;padding:8px;color:#8b8fa3">Losses</th><th style="text-align:right;padding:8px;color:#8b8fa3">Win Rate</th></tr></thead><tbody>' +
    topByArena.map((p,i) => {
      const w = p.arenaWins||0, l = p.arenaLosses||0;
      const wr = (w+l) > 0 ? ((w/(w+l))*100).toFixed(1) : '0';
      return '<tr style="border-bottom:1px solid #222"><td style="padding:8px;color:#fff">' + (i<3?['ðŸ¥‡','ðŸ¥ˆ','ðŸ¥‰'][i]:''+(i+1)) + ' ' + (p.username||'Unknown') + '</td><td style="text-align:right;padding:8px;color:#4caf50;font-weight:700">' + w + '</td><td style="text-align:right;padding:8px;color:#ff6b6b">' + l + '</td><td style="text-align:right;padding:8px;color:#00bcd4;font-weight:700">' + wr + '%</td></tr>';
    }).join('') +
    '</tbody></table></div>' : '') +
    // Guilds table
    (guilds.length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:30px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ° Guilds Overview</h3>' +
    '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:8px;color:#8b8fa3">Guild</th><th style="text-align:right;padding:8px;color:#8b8fa3">Members</th><th style="text-align:right;padding:8px;color:#8b8fa3">Level</th><th style="text-align:right;padding:8px;color:#8b8fa3">Gold</th><th style="text-align:right;padding:8px;color:#8b8fa3">XP</th><th style="text-align:right;padding:8px;color:#8b8fa3">Bosses</th></tr></thead><tbody>' +
    guildRows +
    '</tbody></table></div>' : '') +
    // Event history summary
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;margin-bottom:20px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ“œ Recent RPG Events</h3>' +
    ((rpgEvents.eventHistory||[]).length > 0 ?
      '<div style="max-height:200px;overflow-y:auto">' +
      (rpgEvents.eventHistory||[]).slice(-15).reverse().map(e => '<div style="padding:8px 12px;border-bottom:1px solid #222;font-size:13px"><span style="color:#8b8fa3">' + new Date(e.triggeredAt||0).toLocaleString() + '</span> ' + (e.emoji||'ðŸŽ®') + ' <strong style="color:#fff">' + (e.name||'Event') + '</strong> <span style="color:#72767d">@ ' + (e.viewerCount||0) + ' viewers</span></div>').join('')
      + '</div>'
      : '<span style="color:#72767d">No events triggered yet. Events activate when viewer milestones are reached during streams!</span>') +
    '</div>' +
    '</div>' +
    
    // ============================================
    // SECTION: SUPERLATIVE AWARDS WALL
    // ============================================
    '<div class="card" style="margin-top:30px"><h2 style="margin-bottom:20px">ðŸ… Superlative Awards Wall</h2>' +
    '<p style="color:#72767d;font-size:13px;margin:0 0 20px 0">Automatically computed titles awarded to the most outstanding players in each category.</p>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(190px,1fr));gap:14px">' +
    superlativeAwardsHtml +
    '</div></div>' +
    
    // ============================================
    // SECTION: ECONOMY HEALTH INDEX
    // ============================================
    '<div class="card" style="margin-top:30px"><h2 style="margin-bottom:20px">ðŸ“Š Economy Health Index</h2>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:16px;margin-bottom:25px">' +
    // Econ Grade
    '<div style="background:linear-gradient(135deg,' + econColor + '15,' + econColor + '05);padding:24px;border-radius:12px;text-align:center;border:2px solid ' + econColor + '66">' +
    '<div style="font-size:48px;font-weight:900;color:' + econColor + '">' + econGrade + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Economy Health</div>' +
    '<div style="color:#72767d;font-size:10px;margin-top:2px">Gini: ' + giniCoeff.toFixed(3) + '</div></div>' +
    // Median Gold
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(255,215,0,0.2)">' +
    '<div style="font-size:24px;font-weight:700;color:#ffd700">' + (medianGold >= 1e6 ? (medianGold/1e6).toFixed(1)+'M' : medianGold.toLocaleString()) + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Median Gold</div></div>' +
    // Avg Gold
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(255,152,0,0.2)">' +
    '<div style="font-size:24px;font-weight:700;color:#ff9800">' + (avgGoldVal >= 1e6 ? (avgGoldVal/1e6).toFixed(1)+'M' : avgGoldVal.toLocaleString()) + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Average Gold</div></div>' +
    // Total Circulation
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(76,175,80,0.2)">' +
    '<div style="font-size:24px;font-weight:700;color:#4caf50">' + (totalGold >= 1e9 ? (totalGold/1e9).toFixed(2)+'B' : totalGold >= 1e6 ? (totalGold/1e6).toFixed(1)+'M' : totalGold.toLocaleString()) + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">In Circulation</div></div>' +
    // Gold Spent %
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(233,30,99,0.2)">' +
    '<div style="font-size:24px;font-weight:700;color:#e91e63">' + goldSpentPct + '%</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Gold Spent (of earned)</div></div>' +
    // Top 10% Share
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(156,39,176,0.2)">' +
    '<div style="font-size:24px;font-weight:700;color:#9c27b0">' + top10Share + '%</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Held by Top 10%</div></div>' +
    // Wealth Ratio
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(0,188,212,0.2)">' +
    '<div style="font-size:24px;font-weight:700;color:#00bcd4">' + wealthRatio + 'x</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Rich/Poor Ratio</div></div>' +
    '</div>' +
    // Lorenz Curve
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ“ˆ Wealth Distribution (Lorenz Curve)</h3><div style="height:250px"><canvas id="lorenzChart"></canvas></div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ’¡ Economy Insights</h3>' +
    '<div style="space-y:10px">' +
    '<div style="padding:12px;background:#2a2e35;border-radius:8px;margin-bottom:8px"><span style="color:#ffd700">ðŸ’°</span> <span style="color:#e0e0e0">Total gold ever earned:</span> <strong style="color:#4caf50">' + (totalEverEarned >= 1e6 ? (totalEverEarned/1e6).toFixed(1)+'M' : totalEverEarned.toLocaleString()) + '</strong></div>' +
    '<div style="padding:12px;background:#2a2e35;border-radius:8px;margin-bottom:8px"><span style="color:#e91e63">ðŸ”¥</span> <span style="color:#e0e0e0">Gold removed from economy:</span> <strong style="color:#e91e63">' + ((totalEverEarned-totalGold) >= 1e6 ? ((totalEverEarned-totalGold)/1e6).toFixed(1)+'M' : Math.max(0,totalEverEarned-totalGold).toLocaleString()) + '</strong></div>' +
    '<div style="padding:12px;background:#2a2e35;border-radius:8px;margin-bottom:8px"><span style="color:#ff9800">ðŸ“Š</span> <span style="color:#e0e0e0">Median/Average ratio:</span> <strong style="color:#ff9800">' + (avgGoldVal > 0 ? (medianGold/avgGoldVal).toFixed(2) : '0') + '</strong> <span style="color:#72767d;font-size:11px">(closer to 1 = healthier)</span></div>' +
    '<div style="padding:12px;background:#2a2e35;border-radius:8px;margin-bottom:8px"><span style="color:#9c27b0">ðŸ¦</span> <span style="color:#e0e0e0">Economy classification:</span> <strong style="color:' + econColor + '">' + (giniCoeff < 0.3 ? 'Egalitarian' : giniCoeff < 0.5 ? 'Moderate' : giniCoeff < 0.7 ? 'Unequal' : 'Oligarchic') + '</strong></div>' +
    '</div></div></div></div>' +
    
    // ============================================
    // SECTION: PLAYER PERSONALITY RADAR
    // ============================================
    (playersWithAI.length > 0 ?
    '<div class="card" style="margin-top:30px"><h2 style="margin-bottom:20px">ðŸ§  Combat Personality Radar</h2>' +
    '<p style="color:#72767d;font-size:13px;margin:0 0 20px 0">Each player\'s AI combat DNA mapped across 6 personality axes. Based on how the AI adapts to each player\'s combat style.</p>' +
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:25px">' +
    // Server Average Radar
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸŒ Server Average Personality</h3><div style="height:300px"><canvas id="serverRadarChart"></canvas></div></div>' +
    // Player Comparison Radar
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ‘¥ Top Players Comparison</h3><div style="height:300px"><canvas id="playerRadarChart"></canvas></div></div>' +
    '</div>' +
    // Personality extremes
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:14px">' +
    (mostAggressive ? '<div style="background:linear-gradient(135deg,#ff6b6b15,#ff6b6b05);border:1px solid #ff6b6b44;border-radius:10px;padding:16px;text-align:center">' +
    '<div style="font-size:24px">ðŸ”¥</div><div style="color:#ff6b6b;font-weight:700;font-size:12px;text-transform:uppercase;margin:6px 0">Most Aggressive</div>' +
    '<div style="color:#fff;font-weight:600">' + (mostAggressive.username||'Unknown') + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px">' + ((mostAggressive.aiTendencies.aggression||0)*100).toFixed(0) + '% aggression</div></div>' : '') +
    (mostCautious ? '<div style="background:linear-gradient(135deg,#4fc3f715,#4fc3f705);border:1px solid #4fc3f744;border-radius:10px;padding:16px;text-align:center">' +
    '<div style="font-size:24px">ðŸ›¡ï¸</div><div style="color:#4fc3f7;font-weight:700;font-size:12px;text-transform:uppercase;margin:6px 0">Most Defensive</div>' +
    '<div style="color:#fff;font-weight:600">' + (mostCautious.username||'Unknown') + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px">' + ((mostCautious.aiTendencies.defensivePriority||0)*100).toFixed(0) + '% defensive</div></div>' : '') +
    (biggestRiskTaker ? '<div style="background:linear-gradient(135deg,#ff980015,#ff980005);border:1px solid #ff980044;border-radius:10px;padding:16px;text-align:center">' +
    '<div style="font-size:24px">ðŸŽ²</div><div style="color:#ff9800;font-weight:700;font-size:12px;text-transform:uppercase;margin:6px 0">Biggest Risk Taker</div>' +
    '<div style="color:#fff;font-weight:600">' + (biggestRiskTaker.username||'Unknown') + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px">' + ((biggestRiskTaker.aiTendencies.riskTaking||0)*100).toFixed(0) + '% risk</div></div>' : '') +
    '</div></div>' : '') +
    
    // ============================================
    // SECTION: THE GRAVEYARD
    // ============================================
    '<div class="card" style="margin-top:30px"><h2 style="margin-bottom:20px">ðŸ’€ The Graveyard</h2>' +
    '<p style="color:#72767d;font-size:13px;margin:0 0 20px 0">Death analytics and the most dangerous aspects of the RPG world.</p>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:16px;margin-bottom:25px">' +
    '<div style="background:linear-gradient(135deg,#ff174415,#ff174405);padding:20px;border-radius:10px;text-align:center;border:1px solid #ff174444">' +
    '<div style="font-size:28px;font-weight:700;color:#ff1744">' + totalDeathsAll + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Total Deaths</div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(255,107,107,0.2)">' +
    '<div style="font-size:28px;font-weight:700;color:#ff6b6b">' + totalArenaDeaths + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Arena Defeats</div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(186,104,200,0.2)">' +
    '<div style="font-size:28px;font-weight:700;color:#ba68c8">' + totalRogueDeaths + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Roguelike Deaths</div></div>' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(255,152,0,0.2)">' +
    '<div style="font-size:28px;font-weight:700;color:#ff9800">' + overconfidenceRate + '%</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Overconfidence Rate</div>' +
    '<div style="color:#72767d;font-size:10px">fighting 10+ levels above</div></div>' +
    '</div>' +
    // Most dangerous enemies
    (topEnemies.length > 0 ?
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px">' +
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">â˜ ï¸ Most Encountered Enemies</h3>' +
    '<div>' + topEnemies.map((e,i) => 
      '<div style="display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #222">' +
      '<span style="color:#fff;font-size:13px">' + (i===0?'ðŸ’€ ':i===1?'â˜ ï¸ ':'âš°ï¸ ') + e[0] + '</span>' +
      '<span style="color:#ff6b6b;font-weight:600;font-size:13px">' + e[1] + ' encounters</span></div>'
    ).join('') + '</div></div>' : '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:20px"><div></div>') +
    // Death leaderboard
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸª¦ Death Leaderboard (Phoenix Down Award)</h3>' +
    '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:8px;color:#8b8fa3">Player</th><th style="text-align:right;padding:8px;color:#8b8fa3">Arena</th><th style="text-align:right;padding:8px;color:#8b8fa3">Roguelike</th><th style="text-align:right;padding:8px;color:#8b8fa3">Total</th></tr></thead><tbody>' +
    topDeathPlayers.map((p,i) => {
      const aDeaths = p.arenaLosses||0;
      const rDeaths = (p.roguelikeStats||{}).deathCount||0;
      return '<tr style="border-bottom:1px solid #222"><td style="padding:8px;color:#fff">' + (i===0?'ðŸ’€ ':i===1?'â˜ ï¸ ':'ðŸ’” ') + (p.username||'Unknown') + '</td><td style="text-align:right;padding:8px;color:#ff6b6b">' + aDeaths + '</td><td style="text-align:right;padding:8px;color:#ba68c8">' + rDeaths + '</td><td style="text-align:right;padding:8px;color:#ff1744;font-weight:700">' + (aDeaths+rDeaths) + '</td></tr>';
    }).join('') +
    '</tbody></table></div></div></div>' +
    
    // ============================================
    // SECTION: RISK & LUCK METERS
    // ============================================
    '<div class="card" style="margin-top:30px"><h2 style="margin-bottom:20px">ðŸŽ² Risk & Luck Meters</h2>' +
    '<p style="color:#72767d;font-size:13px;margin:0 0 20px 0">How cautious or reckless are your players? Risk profiles from roguelike and arena data.</p>' +
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:16px;margin-bottom:25px">' +
    // Chicken Score (server avg)
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(255,235,59,0.2)">' +
    '<div style="font-size:32px;margin-bottom:4px">ðŸ”</div>' +
    '<div style="font-size:28px;font-weight:700;color:#ffeb3b">' + chickenScoreAvg + '%</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Chicken Score (Avg)</div>' +
    '<div style="color:#72767d;font-size:10px">voluntary exits / runs</div></div>' +
    // Yolo Score (server avg)
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(255,23,68,0.2)">' +
    '<div style="font-size:32px;margin-bottom:4px">ðŸ’€</div>' +
    '<div style="font-size:28px;font-weight:700;color:#ff1744">' + yoloScoreAvg + '%</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">YOLO Score (Avg)</div>' +
    '<div style="color:#72767d;font-size:10px">deaths / runs</div></div>' +
    // Boss Efficiency
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(76,175,80,0.2)">' +
    '<div style="font-size:32px;margin-bottom:4px">ðŸ‰</div>' +
    '<div style="font-size:28px;font-weight:700;color:#4caf50">' + rogueBossEfficiency + '</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Bosses/Run (Avg)</div>' +
    '<div style="color:#72767d;font-size:10px">roguelike boss efficiency</div></div>' +
    // Arena Win Rate
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px;text-align:center;border:1px solid rgba(0,188,212,0.2)">' +
    '<div style="font-size:32px;margin-bottom:4px">âš”ï¸</div>' +
    '<div style="font-size:28px;font-weight:700;color:#00bcd4">' + avgArenaWinRate + '%</div>' +
    '<div style="color:#8b8fa3;font-size:12px;margin-top:4px">Arena Win Rate (Avg)</div>' +
    '<div style="color:#72767d;font-size:10px">' + arenaParticipants.length + ' participants</div></div>' +
    '</div>' +
    // Biggest gambler
    (biggestGambler && ((biggestGambler.arenaWins||0)+(biggestGambler.arenaLosses||0)) > 0 ?
    '<div style="background:linear-gradient(135deg,#ff980015,#ff980005);border:1px solid #ff980044;border-radius:10px;padding:16px;margin-bottom:20px;display:flex;align-items:center;gap:16px">' +
    '<div style="font-size:40px">ðŸŽ°</div>' +
    '<div><div style="color:#ff9800;font-size:12px;font-weight:700;text-transform:uppercase;letter-spacing:1px">Biggest Arena Gambler</div>' +
    '<div style="color:#fff;font-size:18px;font-weight:600">' + (biggestGambler.username||'Unknown') + '</div>' +
    '<div style="color:#8b8fa3;font-size:13px">' + ((biggestGambler.arenaWins||0)+(biggestGambler.arenaLosses||0)) + ' total fights (' + (biggestGambler.arenaWins||0) + 'W / ' + (biggestGambler.arenaLosses||0) + 'L)</div></div></div>' : '') +
    // Risk profiles table
    (riskProfiles.length > 0 ?
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ“‹ Roguelike Risk Profiles</h3>' +
    '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:8px;color:#8b8fa3">Player</th><th style="text-align:center;padding:8px;color:#8b8fa3">Runs</th><th style="text-align:center;padding:8px;color:#8b8fa3">Best Floor</th><th style="text-align:center;padding:8px;color:#8b8fa3">Bosses</th><th style="text-align:center;padding:8px;color:#ffeb3b">ðŸ” Chicken</th><th style="text-align:center;padding:8px;color:#ff1744">ðŸ’€ YOLO</th></tr></thead><tbody>' +
    riskProfiles.map(p => '<tr style="border-bottom:1px solid #222"><td style="padding:8px;color:#fff">' + p.name + '</td><td style="text-align:center;padding:8px;color:#8b8fa3">' + p.runs + '</td><td style="text-align:center;padding:8px;color:#ba68c8;font-weight:600">' + p.floor + '</td><td style="text-align:center;padding:8px;color:#4caf50">' + p.bosses + '</td><td style="text-align:center;padding:8px;color:#ffeb3b;font-weight:600">' + p.chicken + '%</td><td style="text-align:center;padding:8px;color:#ff1744;font-weight:600">' + p.yolo + '%</td></tr>').join('') +
    '</tbody></table></div>' : '') +
    '</div>' +
    
    // ============================================
    // SECTION: PLAYER ARCHETYPE CLASSIFICATION
    // ============================================
    '<div class="card" style="margin-top:30px"><h2 style="margin-bottom:20px">ðŸŽ­ Player Archetype Classification</h2>' +
    '<p style="color:#72767d;font-size:13px;margin:0 0 20px 0">Players are classified into archetypes based on their dominant activity: combat, crafting, gathering, exploration, PvP, or dungeoneering. Well-rounded players earn the Completionist title.</p>' +
    '<div style="display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-bottom:25px">' +
    // Archetype distribution chart
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸŽ­ Archetype Distribution</h3><div style="height:280px"><canvas id="archetypeChart"></canvas></div></div>' +
    // Archetype legend
    '<div style="background:#1a1a2e;padding:20px;border-radius:10px"><h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:14px">ðŸ“– Archetype Guide</h3>' +
    '<div style="display:grid;gap:8px">' +
    '<div style="padding:10px;background:#2a2e35;border-radius:8px;border-left:3px solid #ff6b6b"><span style="font-size:16px">âš”ï¸</span> <strong style="color:#ff6b6b">Warrior</strong> <span style="color:#8b8fa3;font-size:12px">â€” Focuses on monster hunting & combat</span></div>' +
    '<div style="padding:10px;background:#2a2e35;border-radius:8px;border-left:3px solid #4db6ac"><span style="font-size:16px">ðŸ”¨</span> <strong style="color:#4db6ac">Artisan</strong> <span style="color:#8b8fa3;font-size:12px">â€” Master of crafting professions</span></div>' +
    '<div style="padding:10px;background:#2a2e35;border-radius:8px;border-left:3px solid #81c784"><span style="font-size:16px">ðŸŒ¾</span> <strong style="color:#81c784">Farmer</strong> <span style="color:#8b8fa3;font-size:12px">â€” Dedicated to gathering resources</span></div>' +
    '<div style="padding:10px;background:#2a2e35;border-radius:8px;border-left:3px solid #64b5f6"><span style="font-size:16px">ðŸ—ºï¸</span> <strong style="color:#64b5f6">Explorer</strong> <span style="color:#8b8fa3;font-size:12px">â€” Unlocks worlds & defeats world bosses</span></div>' +
    '<div style="padding:10px;background:#2a2e35;border-radius:8px;border-left:3px solid #ffb74d"><span style="font-size:16px">ðŸŸï¸</span> <strong style="color:#ffb74d">Gladiator</strong> <span style="color:#8b8fa3;font-size:12px">â€” Lives for PvP & guild activities</span></div>' +
    '<div style="padding:10px;background:#2a2e35;border-radius:8px;border-left:3px solid #ba68c8"><span style="font-size:16px">ðŸ°</span> <strong style="color:#ba68c8">Delver</strong> <span style="color:#8b8fa3;font-size:12px">â€” Dungeon & roguelike specialist</span></div>' +
    '<div style="padding:10px;background:#2a2e35;border-radius:8px;border-left:3px solid #ffd700"><span style="font-size:16px">ðŸ‘‘</span> <strong style="color:#ffd700">Completionist</strong> <span style="color:#8b8fa3;font-size:12px">â€” Well-rounded across all activities</span></div>' +
    '</div></div></div>' +
    // Player archetype showcase
    (archetypeShowcase.length > 0 ?
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px">' +
    archetypeShowcase.map(p => 
      '<div style="background:linear-gradient(135deg,' + p.archetype.color + '12,' + p.archetype.color + '04);border:1px solid ' + p.archetype.color + '44;border-radius:10px;padding:14px;display:flex;align-items:center;gap:12px">' +
      '<div style="font-size:28px;min-width:36px;text-align:center">' + p.archetype.emoji + '</div>' +
      '<div><div style="color:#fff;font-weight:600;font-size:14px">' + p.username + '</div>' +
      '<div style="color:' + p.archetype.color + ';font-size:11px;font-weight:700;text-transform:uppercase;letter-spacing:0.5px">' + p.archetype.name + '</div>' +
      '<div style="color:#72767d;font-size:11px">Lv.' + p.level + '</div></div></div>'
    ).join('') +
    '</div>' : '') +
    '</div>' +
    
    // Chart.js scripts
    '<script>' +
    'document.addEventListener("DOMContentLoaded", function() {' +
    // Class distribution chart
    'const classCtx = document.getElementById("classDistChart");' +
    'if (classCtx) { new Chart(classCtx, {' +
      'type: "doughnut",' +
      'data: { labels: ' + JSON.stringify(classLabels) + ', datasets: [{ data: ' + JSON.stringify(classData) + ', backgroundColor: ' + JSON.stringify(classColors.slice(0, classLabels.length)) + ', borderWidth: 0 }] },' +
      'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: "right", labels: { color: "#8b8fa3", font: { size: 12 }, padding: 12, usePointStyle: true } } } }' +
    '}); }' +
    // Level distribution chart
    'const levelCtx = document.getElementById("levelDistChart");' +
    'if (levelCtx) { new Chart(levelCtx, {' +
      'type: "bar",' +
      'data: { labels: ' + JSON.stringify(Object.keys(levelBuckets)) + ', datasets: [{ label: "Players", data: ' + JSON.stringify(Object.values(levelBuckets)) + ', backgroundColor: ["#5b5bff88","#e91e6388","#4caf5088","#ff980088","#00bcd488","#9c27b088"], borderColor: ["#5b5bff","#e91e63","#4caf50","#ff9800","#00bcd4","#9c27b0"], borderWidth: 1, borderRadius: 4 }] },' +
      'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { y: { beginAtZero: true, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#8b8fa3", stepSize: 1 } }, x: { grid: { display: false }, ticks: { color: "#8b8fa3" } } } }' +
    '}); }' +
    // Profession chart
    (Object.keys(profCounts).length > 0 ?
    'const profCtx = document.getElementById("profChart");' +
    'if (profCtx) { new Chart(profCtx, {' +
      'type: "bar",' +
      'data: { labels: ' + JSON.stringify(Object.keys(profCounts).map(k=>k.charAt(0).toUpperCase()+k.slice(1))) + ', datasets: [{ label: "Players", data: ' + JSON.stringify(Object.values(profCounts)) + ', backgroundColor: "#4db6ac88", borderColor: "#4db6ac", borderWidth: 1, borderRadius: 4 }] },' +
      'options: { indexAxis: "y", responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } }, scales: { x: { beginAtZero: true, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#8b8fa3", stepSize: 1 } }, y: { grid: { display: false }, ticks: { color: "#8b8fa3" } } } }' +
    '}); }' : '') +
    
    // Lorenz Curve chart
    'const lorenzCtx = document.getElementById("lorenzChart");' +
    'if (lorenzCtx) { new Chart(lorenzCtx, {' +
      'type: "line",' +
      'data: { labels: ' + JSON.stringify(lorenzData.map(d => d.pct + '%')) + ', datasets: [' +
        '{ label: "Perfect Equality", data: ' + JSON.stringify(lorenzData.map(d => parseFloat(d.pct))) + ', borderColor: "#ffffff44", borderDash: [5,5], borderWidth: 1, pointRadius: 0, fill: false },' +
        '{ label: "Actual Distribution", data: ' + JSON.stringify(lorenzData.map(d => parseFloat(d.cumGold))) + ', borderColor: "#e91e63", backgroundColor: "#e91e6322", borderWidth: 2, pointRadius: 3, pointBackgroundColor: "#e91e63", fill: true }' +
      '] },' +
      'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: "#8b8fa3", font: { size: 11 } } } }, scales: { y: { beginAtZero: true, max: 100, grid: { color: "rgba(255,255,255,0.05)" }, ticks: { color: "#8b8fa3", callback: function(v) { return v + "%"; } }, title: { display: true, text: "% of Total Gold", color: "#8b8fa3" } }, x: { grid: { display: false }, ticks: { color: "#8b8fa3" }, title: { display: true, text: "% of Players", color: "#8b8fa3" } } } }' +
    '}); }' +
    
    // Server Personality Radar chart
    (playersWithAI.length > 0 ?
    'const serverRadarCtx = document.getElementById("serverRadarChart");' +
    'if (serverRadarCtx) { new Chart(serverRadarCtx, {' +
      'type: "radar",' +
      'data: { labels: ' + JSON.stringify(aiLabels) + ', datasets: [{ label: "Server Average", data: ' + JSON.stringify(aiAvgs) + ', borderColor: "#5b5bff", backgroundColor: "#5b5bff33", borderWidth: 2, pointBackgroundColor: "#5b5bff", pointRadius: 4 }] },' +
      'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: "#8b8fa3" } } }, scales: { r: { beginAtZero: true, max: 1, grid: { color: "rgba(255,255,255,0.1)" }, angleLines: { color: "rgba(255,255,255,0.1)" }, pointLabels: { color: "#8b8fa3", font: { size: 11 } }, ticks: { color: "#8b8fa3", backdropColor: "transparent", stepSize: 0.2 } } } }' +
    '}); }' +
    // Player Comparison Radar chart
    'const playerRadarCtx = document.getElementById("playerRadarChart");' +
    'if (playerRadarCtx) {' +
      'const radarColors = ["#e91e63","#4caf50","#ff9800"];' +
      'new Chart(playerRadarCtx, {' +
      'type: "radar",' +
      'data: { labels: ' + JSON.stringify(aiLabels) + ', datasets: ' + JSON.stringify(radarPlayers.map((p,i) => ({
        label: p.name,
        data: p.data,
        borderColor: ['#e91e63','#4caf50','#ff9800'][i] || '#5b5bff',
        backgroundColor: ['#e91e6322','#4caf5022','#ff980022'][i] || '#5b5bff22',
        borderWidth: 2,
        pointRadius: 3
      }))) + ' },' +
      'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { labels: { color: "#8b8fa3", font: { size: 11 } } } }, scales: { r: { beginAtZero: true, max: 1, grid: { color: "rgba(255,255,255,0.1)" }, angleLines: { color: "rgba(255,255,255,0.1)" }, pointLabels: { color: "#8b8fa3", font: { size: 10 } }, ticks: { color: "#8b8fa3", backdropColor: "transparent", stepSize: 0.2 } } } }' +
    '}); }' : '') +
    
    // Archetype Distribution chart
    'const archetypeCtx = document.getElementById("archetypeChart");' +
    'if (archetypeCtx) { new Chart(archetypeCtx, {' +
      'type: "doughnut",' +
      'data: { labels: ' + JSON.stringify(archetypeLabels) + ', datasets: [{ data: ' + JSON.stringify(archetypeValues) + ', backgroundColor: ' + JSON.stringify(archetypeColors.map(c => c + '88')) + ', borderColor: ' + JSON.stringify(archetypeColors) + ', borderWidth: 2 }] },' +
      'options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: "right", labels: { color: "#8b8fa3", font: { size: 12 }, padding: 10, usePointStyle: true } } } }' +
    '}); }' +
    
    '});' +
    '<\/script>';
}

// RPG Events Management tab
function renderRPGEventsTab() {
  const milestones = rpgEvents.milestoneEvents || [];
  const active = rpgEvents.activeEvents || [];
  const historyEvts = rpgEvents.eventHistory || [];

  // Current viewer count
  const currentViewers = isLive ? (stats.currentViewers || 0) : 0;

  // Active events display
  const activeHtml = active.length > 0
    ? active.map(e => {
        const minsLeft = Math.max(0, Math.round(((e.endsAt||0) - Date.now()) / 60000));
        const pct = e.duration > 0 ? Math.min(100, ((e.duration - minsLeft) / e.duration * 100)).toFixed(0) : 100;
        return '<div style="background:#5b5bff11;border:1px solid #5b5bff44;border-radius:10px;padding:16px;margin-bottom:10px">' +
          '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">' +
          '<span style="font-size:18px;font-weight:700;color:#fff">' + (e.emoji||'ðŸŽ®') + ' ' + (e.name||'Event') + '</span>' +
          '<span style="color:#4caf50;font-weight:600">' + minsLeft + ' min remaining</span></div>' +
          '<div style="background:#222;border-radius:4px;height:6px;overflow:hidden"><div style="background:linear-gradient(90deg,#5b5bff,#e91e63);height:100%;width:' + pct + '%;transition:width 1s"></div></div>' +
          '<div style="color:#72767d;font-size:12px;margin-top:6px">' + (e.description||'') + '</div></div>';
      }).join('')
    : '<div style="text-align:center;padding:30px;color:#72767d">No active events right now. Events trigger automatically when viewer milestones are reached!</div>';

  // Milestone config rows
  const milestoneRows = milestones.map((m, i) => {
    const isActive = active.some(a => a.id === m.id);
    const wasTriggered = (rpgEvents.triggeredThisStream || {})[m.id];
    let statusBadge = '<span style="padding:3px 10px;border-radius:12px;font-size:11px;background:#33333388;color:#72767d">Waiting</span>';
    if (isActive) statusBadge = '<span style="padding:3px 10px;border-radius:12px;font-size:11px;background:#4caf5022;color:#4caf50;border:1px solid #4caf5044">ðŸ”´ LIVE</span>';
    else if (wasTriggered) statusBadge = '<span style="padding:3px 10px;border-radius:12px;font-size:11px;background:#ff980022;color:#ff9800;border:1px solid #ff980044">âœ“ Triggered</span>';
    
    return '<tr style="border-bottom:1px solid #222">' +
      '<td style="padding:12px;text-align:center;font-size:20px">' + (m.emoji||'ðŸŽ®') + '</td>' +
      '<td style="padding:12px"><div style="color:#fff;font-weight:600">' + (m.name||'Event') + '</div><div style="color:#72767d;font-size:12px">' + (m.description||'') + '</div></td>' +
      '<td style="padding:12px;text-align:center"><span style="color:#5b5bff;font-weight:700;font-size:18px">' + (m.viewerThreshold||0) + '</span><div style="color:#72767d;font-size:11px">viewers</div></td>' +
      '<td style="padding:12px;text-align:center;color:#8b8fa3">' + (m.type||'').replace(/_/g,' ') + '</td>' +
      '<td style="padding:12px;text-align:center;color:#8b8fa3">' + (m.duration||0) + ' min</td>' +
      '<td style="padding:12px;text-align:center">' + statusBadge + '</td>' +
      '<td style="padding:12px;text-align:center">' +
      '<label style="position:relative;display:inline-block;width:40px;height:22px;cursor:pointer">' +
      '<input type="checkbox" ' + (m.enabled ? 'checked' : '') + ' onchange="toggleMilestoneEvent(' + i + ', this.checked)" style="opacity:0;width:0;height:0">' +
      '<span style="position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background:' + (m.enabled ? '#4caf50' : '#555') + ';border-radius:22px;transition:.3s"></span>' +
      '<span style="position:absolute;height:16px;width:16px;left:' + (m.enabled ? '20px' : '3px') + ';bottom:3px;background:#fff;border-radius:50%;transition:.3s"></span>' +
      '</label></td>' +
      '</tr>';
  }).join('');

  // Event history
  const historyRows = historyEvts.slice(-20).reverse().map(e => {
    return '<tr style="border-bottom:1px solid #222">' +
      '<td style="padding:8px;color:#8b8fa3;font-size:12px">' + new Date(e.triggeredAt||0).toLocaleString() + '</td>' +
      '<td style="padding:8px">' + (e.emoji||'ðŸŽ®') + ' <span style="color:#fff">' + (e.name||'Event') + '</span></td>' +
      '<td style="padding:8px;text-align:center;color:#5b5bff">' + (e.viewerCount||0) + '</td>' +
      '<td style="padding:8px;text-align:center;color:#' + (e.completed ? '4caf50' : 'ff9800') + '">' + (e.completed ? 'âœ“ Completed' : 'â± Expired') + '</td>' +
      '</tr>';
  }).join('');

  return '<div class="card"><h2 style="margin-bottom:25px">âš¡ RPG Events Manager</h2>' +
    // Current stream status bar
    '<div style="display:flex;gap:16px;margin-bottom:25px;flex-wrap:wrap">' +
    '<div style="flex:1;min-width:200px;background:' + (isLive ? 'linear-gradient(135deg,#4caf5022,#4caf5011)' : '#2a2e35') + ';padding:18px;border-radius:10px;border:1px solid ' + (isLive ? '#4caf5044' : '#33333388') + ';text-align:center">' +
    '<div style="font-size:12px;color:#8b8fa3;margin-bottom:6px">Stream Status</div>' +
    '<div style="font-size:24px;font-weight:700;color:' + (isLive ? '#4caf50' : '#ff6b6b') + '">' + (isLive ? 'ðŸŸ¢ LIVE' : 'ðŸ”´ OFFLINE') + '</div></div>' +
    '<div style="flex:1;min-width:200px;background:#1a1a2e;padding:18px;border-radius:10px;border:1px solid #5b5bff33;text-align:center">' +
    '<div style="font-size:12px;color:#8b8fa3;margin-bottom:6px">Current Viewers</div>' +
    '<div style="font-size:24px;font-weight:700;color:#5b5bff">' + currentViewers + '</div></div>' +
    '<div style="flex:1;min-width:200px;background:#1a1a2e;padding:18px;border-radius:10px;border:1px solid #e91e6333;text-align:center">' +
    '<div style="font-size:12px;color:#8b8fa3;margin-bottom:6px">Active Events</div>' +
    '<div style="font-size:24px;font-weight:700;color:#e91e63">' + active.length + '</div></div>' +
    '<div style="flex:1;min-width:200px;background:#1a1a2e;padding:18px;border-radius:10px;border:1px solid #ff980033;text-align:center">' +
    '<div style="font-size:12px;color:#8b8fa3;margin-bottom:6px">Events This Stream</div>' +
    '<div style="font-size:24px;font-weight:700;color:#ff9800">' + Object.keys(rpgEvents.triggeredThisStream||{}).length + '</div></div>' +
    '</div>' +
    // Active events
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:16px">ðŸ”´ Active Events</h3>' + activeHtml +
    // Milestone config table
    '<div style="margin-top:30px;background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:16px">ðŸŽ¯ Viewer Milestone Events</h3>' +
    '<p style="color:#72767d;font-size:13px;margin:0 0 15px 0">Configure RPG events that automatically trigger when viewer milestones are reached during a stream. Each event triggers once per stream.</p>' +
    '<table style="width:100%;border-collapse:collapse"><thead><tr style="border-bottom:2px solid #333">' +
    '<th style="padding:10px;color:#8b8fa3;font-size:12px;width:40px"></th>' +
    '<th style="padding:10px;text-align:left;color:#8b8fa3;font-size:12px">Event</th>' +
    '<th style="padding:10px;text-align:center;color:#8b8fa3;font-size:12px">Threshold</th>' +
    '<th style="padding:10px;text-align:center;color:#8b8fa3;font-size:12px">Type</th>' +
    '<th style="padding:10px;text-align:center;color:#8b8fa3;font-size:12px">Duration</th>' +
    '<th style="padding:10px;text-align:center;color:#8b8fa3;font-size:12px">Status</th>' +
    '<th style="padding:10px;text-align:center;color:#8b8fa3;font-size:12px">Enabled</th>' +
    '</tr></thead><tbody>' + milestoneRows + '</tbody></table></div>' +
    // Add custom event section
    '<div style="margin-top:20px;background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:16px">âž• Add Custom Milestone Event</h3>' +
    '<div style="display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:12px;margin-bottom:15px">' +
    '<div><label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:6px">Event Name</label><input type="text" id="newEventName" placeholder="e.g. XP Party" style="width:100%;padding:10px;background:#2a2e35;border:1px solid #444;border-radius:6px;color:#fff;font-size:13px" onclick="this.focus()" onkeydown="event.stopPropagation()" onkeypress="event.stopPropagation()" onkeyup="event.stopPropagation()"></div>' +
    '<div><label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:6px">Viewer Threshold</label><input type="number" id="newEventThreshold" placeholder="e.g. 75" min="1" style="width:100%;padding:10px;background:#2a2e35;border:1px solid #444;border-radius:6px;color:#fff;font-size:13px" onclick="this.focus()" onkeydown="event.stopPropagation()" onkeypress="event.stopPropagation()" onkeyup="event.stopPropagation()"></div>' +
    '<div><label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:6px">Type</label><select id="newEventType" style="width:100%;padding:10px;background:#2a2e35;border:1px solid #444;border-radius:6px;color:#fff;font-size:13px"><option value="xp_boost">âš¡ XP Boost</option><option value="gold_rain">ðŸ’° Gold Rain</option><option value="loot_boost">ðŸŽ Loot Boost</option><option value="secret_dungeon">ðŸ° Secret Dungeon</option><option value="boss_spawn">ðŸ‰ Boss Spawn</option></select></div>' +
    '<div><label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:6px">Duration (min)</label><input type="number" id="newEventDuration" placeholder="e.g. 30" min="1" max="180" style="width:100%;padding:10px;background:#2a2e35;border:1px solid #444;border-radius:6px;color:#fff;font-size:13px" onclick="this.focus()" onkeydown="event.stopPropagation()" onkeypress="event.stopPropagation()" onkeyup="event.stopPropagation()"></div>' +
    '</div>' +
    '<div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-bottom:15px">' +
    '<div><label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:6px">Description</label><input type="text" id="newEventDesc" placeholder="e.g. Double XP for all players!" style="width:100%;padding:10px;background:#2a2e35;border:1px solid #444;border-radius:6px;color:#fff;font-size:13px" onclick="this.focus()" onkeydown="event.stopPropagation()" onkeypress="event.stopPropagation()" onkeyup="event.stopPropagation()"></div>' +
    '<div><label style="display:block;color:#8b8fa3;font-size:12px;margin-bottom:6px">Emoji</label><input type="text" id="newEventEmoji" placeholder="e.g. âš¡" maxlength="2" style="width:100%;padding:10px;background:#2a2e35;border:1px solid #444;border-radius:6px;color:#fff;font-size:13px" onclick="this.focus()" onkeydown="event.stopPropagation()" onkeypress="event.stopPropagation()" onkeyup="event.stopPropagation()"></div>' +
    '<div style="display:flex;align-items:flex-end"><button onclick="addMilestoneEvent()" style="width:100%;padding:10px 20px;background:#5b5bff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;font-size:14px">Add Event</button></div>' +
    '</div></div>' +
    // Manual trigger
    '<div style="margin-top:20px;background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:16px">ðŸŽ® Manual Trigger</h3>' +
    '<p style="color:#72767d;font-size:13px;margin:0 0 15px 0">Manually trigger an RPG event right now (bypasses viewer threshold).</p>' +
    '<div style="display:flex;gap:12px;flex-wrap:wrap">' +
    milestones.filter(m=>m.enabled).map(m => 
      '<button onclick="manualTriggerEvent(\'' + m.id + '\')" style="padding:10px 20px;background:#2a2e35;border:1px solid #5b5bff44;border-radius:8px;color:#fff;cursor:pointer;font-size:13px;transition:all .2s" onmouseover="this.style.background=\'#5b5bff33\'" onmouseout="this.style.background=\'#2a2e35\'">' + (m.emoji||'ðŸŽ®') + ' ' + (m.name||'Event') + '</button>'
    ).join('') +
    '</div></div>' +
    // Event history
    '<div style="margin-top:30px;background:#1a1a2e;padding:20px;border-radius:10px">' +
    '<h3 style="margin:0 0 15px 0;color:#e0e0e0;font-size:16px">ðŸ“œ Event History</h3>' +
    (historyRows.length > 0 ?
      '<table style="width:100%;border-collapse:collapse;font-size:13px"><thead><tr style="border-bottom:1px solid #333"><th style="text-align:left;padding:8px;color:#8b8fa3">When</th><th style="text-align:left;padding:8px;color:#8b8fa3">Event</th><th style="text-align:center;padding:8px;color:#8b8fa3">Viewers</th><th style="text-align:center;padding:8px;color:#8b8fa3">Status</th></tr></thead><tbody>' + historyRows + '</tbody></table>'
      : '<div style="text-align:center;padding:20px;color:#72767d">No events in history yet</div>') +
    '</div>' +
    '</div>' +
    '<script>' +
    'function toggleMilestoneEvent(index, enabled) {' +
    '  fetch("/api/rpg-events/toggle", { method: "POST", headers: {"Content-Type":"application/json"}, body: JSON.stringify({index, enabled}) })' +
    '  .then(r => r.json()).then(d => { if(d.success) location.reload(); });' +
    '}' +
    'function addMilestoneEvent() {' +
    '  const name = document.getElementById("newEventName").value;' +
    '  const threshold = parseInt(document.getElementById("newEventThreshold").value);' +
    '  const type = document.getElementById("newEventType").value;' +
    '  const duration = parseInt(document.getElementById("newEventDuration").value);' +
    '  const description = document.getElementById("newEventDesc").value;' +
    '  const emoji = document.getElementById("newEventEmoji").value || "ðŸŽ®";' +
    '  if (!name || !threshold || !duration) return alert("Please fill in all required fields");' +
    '  fetch("/api/rpg-events/add", { method: "POST", headers: {"Content-Type":"application/json"}, body: JSON.stringify({name,threshold,type,duration,description,emoji}) })' +
    '  .then(r => r.json()).then(d => { if(d.success) location.reload(); else alert(d.error||"Error"); });' +
    '}' +
    'function manualTriggerEvent(eventId) {' +
    '  if (!confirm("Manually trigger this event now?")) return;' +
    '  fetch("/api/rpg-events/trigger", { method: "POST", headers: {"Content-Type":"application/json"}, body: JSON.stringify({eventId}) })' +
    '  .then(r => r.json()).then(d => { if(d.success) { alert("Event triggered!"); location.reload(); } else alert(d.error||"Error"); });' +
    '}' +
    '<\/script>';
}

// NEW: Suggestions tab
function renderSuggestionsTab() {
  const uniqueUsers = [...new Set(suggestions.map(s => s.user))];
  const statuses = ['Pending', 'In Progress', 'Completed', 'Rejected'];
  const cooldownMinutes = dashboardSettings.suggestionCooldownMinutes || 60;
  
  return `
<div class="card">
  <h2 style="margin-bottom:25px">ðŸ’¡ Community Suggestions</h2>
  
  <div style="margin-bottom:25px;background:#2a2e2e;padding:20px;border-radius:8px">
    <label style="display:block;margin-bottom:12px;color:#fff;font-weight:600">â±ï¸ Suggestion Cooldown</label>
    <div style="display:flex;gap:12px;align-items:center">
      <input type="number" id="suggestionCooldown" value="${cooldownMinutes}" min="0" max="1440" inputmode="numeric" autocomplete="off" spellcheck="false" style="flex:1 1 220px;min-width:0;width:auto;padding:10px;background:#3a3a42;color:#fff;border:1px solid #5b5bff;border-radius:6px;font-size:14px;pointer-events:auto;cursor:text;position:relative;z-index:1" onclick="this.focus()" onkeydown="event.stopPropagation();" onkeypress="event.stopPropagation();" onkeyup="event.stopPropagation();">
      <span style="color:#b5bac1;white-space:nowrap">minutes</span>
      <button onclick="saveSuggestionCooldown()" style="padding:10px 20px;background:#5b5bff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600">Save</button>
    </div>
    <div style="margin-top:10px;color:#72767d;font-size:13px">Users must wait this long between suggestions. Set to 0 for no cooldown.</div>
  </div>
  
  <div style="margin-bottom:20px">
    <input type="text" id="suggestionSearch" placeholder="ðŸ” Search suggestions..." style="width:100%;padding:12px;background:#2a2a2e;color:#fff;border:1px solid #3a3a42;border-radius:6px;font-size:14px">
  </div>

  <div style="margin-bottom:20px;display:flex;gap:10px;flex-wrap:wrap">
    <button onclick="filterSuggestions('')" style="padding:10px 16px;background:#5b5bff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600">All (${suggestions.length})</button>
    ${uniqueUsers.map(user => `
      <button onclick="filterSuggestions('${user}')" style="padding:10px 16px;background:#4a4a5e;color:#fff;border:none;border-radius:6px;cursor:pointer">${user} (${suggestions.filter(s => s.user === user).length})</button>
    `).join('')}
  </div>

  <div style="margin-bottom:20px;display:flex;gap:10px">
    <button onclick="sortSuggestions('newest')" style="padding:10px 16px;background:#5b5bff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600">ðŸ“… Newest</button>
    <button onclick="sortSuggestions('oldest')" style="padding:10px 16px;background:#4a4a5e;color:#fff;border:none;border-radius:6px;cursor:pointer">ðŸ“… Oldest</button>
    <button onclick="sortSuggestions('upvotes')" style="padding:10px 16px;background:#4a4a5e;color:#fff;border:none;border-radius:6px;cursor:pointer">ðŸ‘ Most Upvoted</button>
    <button onclick="exportSuggestions()" style="padding:10px 16px;background:#5b5b5e;color:#fff;border:none;border-radius:6px;cursor:pointer;margin-left:auto">â¬‡ï¸ Export</button>
  </div>

  ${suggestions.length === 0 ? '<p style="padding:40px;text-align:center;color:#72767d">No suggestions yet</p>' : `
  <div id="suggestionsContainer">
    ${suggestions.map((s, idx) => `
    <div class="suggestion-item" data-user="${s.user}" data-id="${idx}" data-upvotes="${s.upvotes || 0}" data-date="${s.timestamp}" style="background:#2a2e2e;padding:20px;margin-bottom:16px;border-radius:8px;border-left:4px solid ${s.status === 'Completed' ? '#3ba55c' : s.status === 'In Progress' ? '#faa61a' : s.status === 'Rejected' ? '#ed4245' : '#5b5bff'}">
      <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:16px">
        <div style="flex:1">
          <div style="font-weight:bold;color:#fff;font-size:15px;margin-bottom:8px">${s.user}</div>
          <div style="color:#b5bac1;margin:10px 0;font-size:14px;line-height:1.6">${s.suggestion}</div>
          <div style="color:#72767d;font-size:12px;margin-top:8px">${new Date(s.timestamp).toLocaleString()}</div>
        </div>
        <select onchange="updateStatus(${idx}, this.value)" style="padding:8px 12px;background:#3a3a42;color:#fff;border:1px solid #5b5bff;border-radius:6px;cursor:pointer;font-size:13px">
          ${statuses.map(st => `<option value="${st}" ${(s.status || 'Pending') === st ? 'selected' : ''}>${st}</option>`).join('')}
        </select>
      </div>
      
      <div style="display:flex;gap:12px;align-items:center">
        <div style="display:flex;align-items:center;gap:8px;background:#1e2124;padding:8px 14px;border-radius:6px">
          <span style="font-size:18px">ðŸ‘</span>
          <span style="color:#fff;font-weight:bold" id="upvotes-${idx}">${s.upvotes || 0}</span>
        </div>
        <button onclick="deleteSuggestion(${idx})" style="padding:8px 14px;background:#ed4245;color:#fff;border:none;border-radius:6px;cursor:pointer;font-size:13px">ðŸ—‘ï¸ Delete</button>
      </div>
    </div>
    `).join('')}
  </div>
  `}
</div>

<script>
let currentFilter = '';
let currentSort = 'newest';

function filterSuggestions(user) {
  currentFilter = user;
  applyFilters();
}

function sortSuggestions(method) {
  currentSort = method;
  applyFilters();
}

function applyFilters() {
  const items = document.querySelectorAll('.suggestion-item');
  let itemsArray = Array.from(items);
  
  if (currentFilter) {
    itemsArray.forEach(item => {
      item.style.display = item.dataset.user === currentFilter ? 'block' : 'none';
    });
  } else {
    itemsArray.forEach(item => item.style.display = 'block');
  }
  
  const container = document.getElementById('suggestionsContainer');
  if (!container) return;
  
  itemsArray = itemsArray.filter(item => item.style.display !== 'none');
  
  if (currentSort === 'newest') {
    itemsArray.sort((a, b) => new Date(b.dataset.date) - new Date(a.dataset.date));
  } else if (currentSort === 'oldest') {
    itemsArray.sort((a, b) => new Date(a.dataset.date) - new Date(b.dataset.date));
  } else if (currentSort === 'upvotes') {
    itemsArray.sort((a, b) => parseInt(b.dataset.upvotes) - parseInt(a.dataset.upvotes));
  }
  
  itemsArray.forEach(item => container.appendChild(item));
}

document.getElementById('suggestionSearch')?.addEventListener('input', function(e) {
  const query = e.target.value.toLowerCase();
  document.querySelectorAll('.suggestion-item').forEach(item => {
    const text = item.textContent.toLowerCase();
    item.style.display = text.includes(query) ? 'block' : 'none';
  });
});

function updateStatus(idx, status) {
  fetch('/update-suggestion', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ index: idx, status })
  }).then(r => r.json()).then(d => {
    if (d.success) showToast('Status updated!', 'success');
  });
}

function deleteSuggestion(idx) {
  if (!confirm('Delete this suggestion?')) return;
  fetch('/delete-suggestion', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ index: idx })
  }).then(r => r.json()).then(d => {
    if (d.success) location.reload();
  });
}

function exportSuggestions() {
  const suggestions = ${JSON.stringify(suggestions)};
  const csv = 'User,Suggestion,Status,Upvotes,Date\\n' + suggestions.map(s => 
    '"' + s.user + '","' + s.suggestion.replace(/"/g, '""') + '","' + (s.status || 'Pending') + '",' + (s.upvotes || 0) + ',' + new Date(s.timestamp).toISOString()
  ).join('\\n');
  
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'suggestions.csv';
  a.click();
}

function saveSuggestionCooldown() {
  const cooldown = document.getElementById('suggestionCooldown').value;
  fetch('/save-suggestion-cooldown', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ cooldown: parseInt(cooldown) || 0 })
  }).then(r => r.json()).then(d => {
    if (d.success) showToast('Cooldown saved!', 'success');
  });
}
</script>
`;
}

// NEW: Commands and Config merged tab
function renderCommandsAndConfigTab(tab) {
  const subTab = tab === 'commands' ? 'config-commands' : tab;
  const isCommands = subTab === 'commands-config';
  const isConfig = subTab === 'config-commands';
  
  return isCommands ? renderCommandsContent() : renderConfigContent();
}

function renderCommandsContent() {
  return renderCommandsTab();
}

function renderConfigContent() {
  return renderConfigTab();
}

// NEW: Commands tab
function renderCommandsTab() {
  const commands = [
    { key: 'help', name: '/help', desc: 'Discover every available command quickly.', category: 'Utility', syntax: '/help', options: [], permissions: 'Everyone', examples: ['/help'], preview: { type: 'text', content: 'Shows the full command list.' }, addedAt: 1 },
    { key: 'streamstatus', name: '/streamstatus', desc: 'Check whether the stream is live right now.', category: 'Info', syntax: '/streamstatus', options: [], permissions: 'Everyone', examples: ['/streamstatus'], preview: { type: 'text', content: 'ðŸ”´ LIVE | 124 viewers' }, addedAt: 2 },
    { key: 'lastlive', name: '/lastlive', desc: 'See the last stream title and timestamp.', category: 'Info', syntax: '/lastlive', options: [], permissions: 'Everyone', examples: ['/lastlive'], preview: { type: 'text', content: 'Last stream: "Fortnite" at 1/28/2026 8:00 PM' }, addedAt: 3 },
    { key: 'topgame', name: '/topgame', desc: 'Find the most played game on the channel.', category: 'Info', syntax: '/topgame', options: [], permissions: 'Everyone', examples: ['/topgame'], preview: { type: 'text', content: 'Top Game: Fortnite (42 streams)' }, addedAt: 4 },
    { key: 'stats', name: '/stats', desc: 'View stream stats and performance trends.', category: 'Info', syntax: '/stats', options: [], permissions: 'Everyone', examples: ['/stats'], preview: { type: 'text', content: 'Shows totals, peak viewers, and averages.' }, addedAt: 5 },
    { key: 'uptime', name: '/uptime', desc: 'Check the bot uptime in real time.', category: 'Utility', syntax: '/uptime', options: [], permissions: 'Everyone', examples: ['/uptime'], preview: { type: 'text', content: 'Bot uptime: 2d 4h 12m' }, addedAt: 6 },
    { key: 'rank', name: '/rank', desc: 'Check your level & XP rank instantly.', category: 'Utility', syntax: '/rank [@user]', options: [{ name: 'user', type: 'user', required: false }], permissions: 'Everyone', examples: ['/rank', '/rank @Antho'], preview: { type: 'text', content: 'Antho is Level 12 with 3,420 XP.' }, addedAt: 7 },
    { key: 'leaderboard', name: '/leaderboard', desc: 'Compare XP rankings across the server.', category: 'Utility', syntax: '/leaderboard', options: [], permissions: 'Everyone', examples: ['/leaderboard'], preview: { type: 'text', content: 'Shows the top XP earners.' }, addedAt: 8 },
    { key: 'cmd', name: '/cmd', desc: 'Run a custom command by name.', category: 'Utility', syntax: '/cmd name: <command>', options: [{ name: 'name', type: 'string', required: true }], permissions: 'Everyone', examples: ['/cmd name: rules'], preview: { type: 'text', content: 'Runs the selected custom command.' }, addedAt: 9 },
    { key: 'commands', name: '/commands', desc: 'List all custom commands.', category: 'Utility', syntax: '/commands', options: [], permissions: 'Everyone', examples: ['/commands'], preview: { type: 'text', content: 'Lists all custom commands.' }, addedAt: 10 },
    { key: 'suggest', name: '/suggest', desc: 'Send a suggestion to staff.', category: 'Community', syntax: '/suggest suggestion: <text>', options: [{ name: 'suggestion', type: 'string', required: true }], permissions: 'Everyone', examples: ['/suggest suggestion: Add more emotes'], preview: { type: 'text', content: 'Suggestion submitted âœ…' }, addedAt: 11 },
    { key: 'warnings', name: '/warnings', desc: 'Review warnings for a user.', category: 'Moderation', syntax: '/warnings user: <@user>', options: [{ name: 'user', type: 'user', required: true }], permissions: 'Moderator', examples: ['/warnings @User'], preview: { type: 'text', content: 'Shows warning list for the user.' }, addedAt: 12 },
    { key: 'warn', name: '/warn', desc: 'Issue a warning with an optional reason.', category: 'Moderation', syntax: '/warn user: <@user> [reason]', options: [{ name: 'user', type: 'user', required: true }, { name: 'reason', type: 'string', required: false }], permissions: 'Administrator', examples: ['/warn @User Spamming'], preview: { type: 'text', content: 'âš ï¸ User warned for: Spamming' }, addedAt: 13 },
    { key: 'alertson', name: '/alertson', desc: 'Enable stream alerts for today.', category: 'Admin', syntax: '/alertson', options: [], permissions: 'Administrator', examples: ['/alertson'], preview: { type: 'text', content: 'Alerts enabled âœ…' }, addedAt: 14 },
    { key: 'alertsoff', name: '/alertsoff', desc: 'Disable stream alerts for today.', category: 'Admin', syntax: '/alertsoff', options: [], permissions: 'Administrator', examples: ['/alertsoff'], preview: { type: 'text', content: 'Alerts disabled âœ…' }, addedAt: 15 },
    { key: 'setschedule', name: '/setschedule', desc: 'Set weekly stream schedule blocks.', category: 'Admin', syntax: '/setschedule time1: <HH:MM> days1: <days> [time2] [days2] channel: <#channel>', options: [{ name: 'time1', type: 'string', required: true }, { name: 'days1', type: 'string', required: true }, { name: 'channel', type: 'channel', required: true }, { name: 'time2', type: 'string', required: false }, { name: 'days2', type: 'string', required: false }], permissions: 'Administrator', examples: ['/setschedule time1: 16:00 days1: mon,tue,wed channel: #announcements'], preview: { type: 'text', content: 'Weekly schedule updated.' }, addedAt: 16 },
    { key: 'cancelstream', name: '/cancelstream', desc: 'Cancel todayâ€™s scheduled stream.', category: 'Admin', syntax: '/cancelstream', options: [], permissions: 'Administrator', examples: ['/cancelstream'], preview: { type: 'text', content: 'Todayâ€™s stream cancelled.' }, addedAt: 17 },
    { key: 'setlivemessage', name: '/setlivemessage', desc: 'Update the live announcement template.', category: 'Admin', syntax: '/setlivemessage message: <text>', options: [{ name: 'message', type: 'string', required: true }], permissions: 'Administrator', examples: ['/setlivemessage We are LIVE!'], preview: { type: 'text', content: 'Live message saved.' }, addedAt: 18 },
    { key: 'setmilestones', name: '/setmilestones', desc: 'Configure viewer milestone alerts.', category: 'Admin', syntax: '/setmilestones milestones: <list>', options: [{ name: 'milestones', type: 'string', required: true }], permissions: 'Administrator', examples: ['/setmilestones 100,250,500'], preview: { type: 'text', content: 'Milestones updated.' }, addedAt: 19 },
    { key: 'setofflinethreshold', name: '/setofflinethreshold', desc: 'Adjust offline detection delay.', category: 'Admin', syntax: '/setofflinethreshold seconds: <number>', options: [{ name: 'seconds', type: 'integer', required: true }], permissions: 'Administrator', examples: ['/setofflinethreshold 120'], preview: { type: 'text', content: 'Offline threshold updated.' }, addedAt: 20 },
    { key: 'setalertroles', name: '/setalertroles', desc: 'Assign roles for alert types.', category: 'Admin', syntax: '/setalertroles role_type: <type> role: <@role>', options: [{ name: 'role_type', type: 'string', required: true }, { name: 'role', type: 'role', required: true }], permissions: 'Administrator', examples: ['/setalertroles liveAlert @StreamPing'], preview: { type: 'text', content: 'Alert role updated.' }, addedAt: 21 },
    { key: 'forcelive', name: '/forcelive', desc: 'Force the stream state to LIVE.', category: 'Admin', syntax: '/forcelive', options: [], permissions: 'Administrator', examples: ['/forcelive'], preview: { type: 'text', content: 'Stream forced live.' }, addedAt: 22 },
    { key: 'forceoffline', name: '/forceoffline', desc: 'Force the stream state to OFFLINE.', category: 'Admin', syntax: '/forceoffline', options: [], permissions: 'Administrator', examples: ['/forceoffline'], preview: { type: 'text', content: 'Stream forced offline.' }, addedAt: 23 },
    { key: 'testdelay', name: '/testdelay', desc: 'Trigger a delayed notification test.', category: 'Admin', syntax: '/testdelay', options: [], permissions: 'Administrator', examples: ['/testdelay'], preview: { type: 'text', content: 'Delayed notification sent.' }, addedAt: 24 },
    { key: 'streamhealth', name: '/streamhealth', desc: 'Inspect stream health diagnostics.', category: 'Admin', syntax: '/streamhealth', options: [], permissions: 'Administrator', examples: ['/streamhealth'], preview: { type: 'text', content: 'Shows stream health details.' }, addedAt: 25 },
    { key: 'addcommand', name: '/addcommand', desc: 'Create a new custom command.', category: 'Admin', syntax: '/addcommand name: <text> response: <text>', options: [{ name: 'name', type: 'string', required: true }, { name: 'response', type: 'string', required: true }], permissions: 'Administrator', examples: ['/addcommand name: rules response: Be nice!'], preview: { type: 'text', content: 'Custom command created.' }, addedAt: 26 },
    { key: 'editcommand', name: '/editcommand', desc: 'Update an existing custom command.', category: 'Admin', syntax: '/editcommand name: <text> response: <text>', options: [{ name: 'name', type: 'string', required: true }, { name: 'response', type: 'string', required: true }], permissions: 'Administrator', examples: ['/editcommand name: rules response: Be nice!'], preview: { type: 'text', content: 'Custom command updated.' }, addedAt: 27 },
    { key: 'removecommand', name: '/removecommand', desc: 'Delete a custom command.', category: 'Admin', syntax: '/removecommand name: <text>', options: [{ name: 'name', type: 'string', required: true }], permissions: 'Administrator', examples: ['/removecommand name: rules'], preview: { type: 'text', content: 'Custom command removed.' }, addedAt: 28 },
    { key: 'addfilter', name: '/addfilter', desc: 'Suppress notifications with a keyword.', category: 'Admin', syntax: '/addfilter keyword: <text> type: <type>', options: [{ name: 'keyword', type: 'string', required: true }, { name: 'type', type: 'string', required: true }], permissions: 'Administrator', examples: ['/addfilter keyword: test type: title'], preview: { type: 'text', content: 'Filter added.' }, addedAt: 29 },
    { key: 'removefilter', name: '/removefilter', desc: 'Remove a notification filter.', category: 'Admin', syntax: '/removefilter filter_id: <id>', options: [{ name: 'filter_id', type: 'string', required: true }], permissions: 'Administrator', examples: ['/removefilter filter_123'], preview: { type: 'text', content: 'Filter removed.' }, addedAt: 30 }
  ];

  const categories = ['All', 'Info', 'Utility', 'Community', 'Moderation', 'Admin', 'Fun', 'Economy', 'Giveaways'];

  const now = Date.now();
  const withinMs = (ts, ms) => ts && now - ts <= ms;
  const formatUptime = (ms) => {
    const d = Math.floor(ms / (1000 * 60 * 60 * 24));
    const h = Math.floor((ms % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const m = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
    return `${d}d ${h}h ${m}m`;
  };

  const commandsWithStats = commands.map(cmd => {
    const usage = commandUsage[cmd.key] || { total: 0, lastUsed: null, history: [], userCounts: {} };
    const history = Array.isArray(usage.history) ? usage.history : [];
    const weekUses = history.filter(h => withinMs(new Date(h.timestamp).getTime(), 7 * 24 * 60 * 60 * 1000)).length;
    const monthUses = history.filter(h => withinMs(new Date(h.timestamp).getTime(), 30 * 24 * 60 * 60 * 1000)).length;
    const dayUses = history.filter(h => withinMs(new Date(h.timestamp).getTime(), 24 * 60 * 60 * 1000)).length;
    const lastUsed = usage.lastUsed ? new Date(usage.lastUsed).toLocaleString() : 'Never';

    const userCounts = usage.userCounts || {};
    const topUserEntry = Object.entries(userCounts).sort((a, b) => (b[1].count || 0) - (a[1].count || 0))[0];
    const topUser = topUserEntry ? `@${topUserEntry[1].username} (${topUserEntry[1].count})` : 'â€”';

    const cooldownMs = Number(config.commandCooldowns?.[cmd.key] || 0);
    const cooldownSec = cooldownMs ? Math.round(cooldownMs / 1000) : 0;
    const pinned = !!config.commandPinned?.[cmd.key];
    const disabled = !!config.commandDisabled?.[cmd.key];
    const requiresArgs = (cmd.options || []).some(o => o.required);
    const status = disabled ? 'disabled' : (cooldownSec > 0 ? 'cooldown' : 'enabled');

    const requiredOpts = (cmd.options || []).filter(o => o.required).map(o => `${o.name} (${o.type})`);
    const optionalOpts = (cmd.options || []).filter(o => !o.required).map(o => `${o.name} (${o.type})`);

    const optionText = requiredOpts.length || optionalOpts.length
      ? `${requiredOpts.length ? 'Required: ' + requiredOpts.join(', ') : ''}${requiredOpts.length && optionalOpts.length ? ' â€¢ ' : ''}${optionalOpts.length ? 'Optional: ' + optionalOpts.join(', ') : ''}`
      : 'No options';

    return {
      ...cmd,
      usesTotal: usage.total || 0,
      usesWeek: weekUses,
      usesMonth: monthUses,
      usesToday: dayUses,
      lastUsed,
      topUser,
      cooldownSec,
      pinned,
      disabled,
      status,
      requiresArgs,
      optionText
    };
  });

  const totalUses = commandsWithStats.reduce((sum, c) => sum + (c.usesTotal || 0), 0);
  const usesToday = commandsWithStats.reduce((sum, c) => sum + (c.usesToday || 0), 0);
  const activeServers = client?.guilds?.cache?.size ?? 0;
  const botUptime = formatUptime(Date.now() - startTime);

  const categoryCounts = {};
  categories.forEach(c => categoryCounts[c] = 0);
  commandsWithStats.forEach(cmd => {
    categoryCounts[cmd.category] = (categoryCounts[cmd.category] || 0) + 1;
    categoryCounts.All = (categoryCounts.All || 0) + 1;
  });

  const exampleData = {};
  commandsWithStats.forEach(cmd => {
    exampleData[cmd.key] = {
      name: cmd.name,
      examples: cmd.examples || [],
      preview: cmd.preview || { type: 'text', content: '' }
    };
  });
  const exampleJson = JSON.stringify(exampleData).replace(/</g, '\\u003c');

  let html = `
<div class="card">
  <h2>ðŸ“– Command Center</h2>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-top:12px">
    <div style="padding:12px;background:#26262c;border-radius:8px">Bot uptime: <b>${botUptime}</b></div>
    <div style="padding:12px;background:#26262c;border-radius:8px">Commands today: <b>${usesToday}</b></div>
    <div style="padding:12px;background:#26262c;border-radius:8px">Active servers: <b>${activeServers}</b></div>
    <div style="padding:12px;background:#26262c;border-radius:8px">Commands used: <b>${totalUses}</b></div>
  </div>

  <div style="margin:16px 0">
    <input type="text" id="commandSearch" oninput="applyCommandFilters()" placeholder="ðŸ” Search commands..." style="width:100%;padding:10px;background:#2a2a2e;color:#fff;border:1px solid #3a3a42;border-radius:4px;font-size:14px">
  </div>

  <div class="command-filters">
    ${categories.map(cat => `
      <button onclick="setCommandCategory('${cat}')" class="filter-btn" data-category="${cat}" style="padding:5px 10px;background:${cat === 'All' ? '#9146ff' : '#4a4a5e'};color:#fff;border:none;border-radius:3px;cursor:pointer;font-size:13px">${cat} (${categoryCounts[cat] || 0})</button>
    `).join('')}
  </div>

  <div style="display:flex;gap:10px;align-items:center;margin-bottom:18px;flex-wrap:wrap">
    <label style="font-size:13px;color:#b0b0b0">Sort by:</label>
    <select id="commandSort" onchange="applyCommandFilters()" style="width:200px">
      <option value="alphabetical">Alphabetical</option>
      <option value="popularity">Popularity</option>
      <option value="newest">Newest</option>
      <option value="cooldown">Cooldown</option>
      <option value="requiresArgs">Requires Args</option>
      <option value="pinned">Pinned</option>
    </select>
  </div>
</div>

<div class="cmd-grid" id="commandsGrid">
  ${commandsWithStats.map(cmd => {
    const statusDot = cmd.status === 'disabled' ? 'status-dot status-disabled' : cmd.status === 'cooldown' ? 'status-dot status-cooldown' : 'status-dot status-enabled';
    const badge = cmd.category === 'Admin' ? 'admin' : cmd.category === 'Community' ? 'community' : 'info';
    return `
    <div class="cmd-card" data-name="${cmd.name.toLowerCase()}" data-desc="${cmd.desc.toLowerCase()}" data-category="${cmd.category}" data-uses="${cmd.usesTotal}" data-added="${cmd.addedAt}" data-cooldown="${cmd.cooldownSec}" data-requires="${cmd.requiresArgs ? 1 : 0}" data-pinned="${cmd.pinned ? 1 : 0}" data-status="${cmd.status}">
      <div class="cmd-header">
        <div class="cmd-title">
          <span class="${statusDot}"></span>
          <span class="cmd-name" onclick="copyCommandName('${cmd.name}')" title="Click to copy">${cmd.name}</span>
        </div>
        <div class="cmd-actions">
          <button class="small" onclick="toggleCommandPinned('${cmd.key}')" title="Pin command" style="background:${cmd.pinned ? '#f7b731' : '#3a3a42'}">${cmd.pinned ? 'â˜…' : 'â˜†'}</button>
          <button class="small" onclick="toggleCommandDisabled('${cmd.key}')" style="background:${cmd.disabled ? '#c43c3c' : '#3a3a42'}">${cmd.disabled ? 'Disabled' : 'Enabled'}</button>
          <button class="small" onclick="showCommandExample('${cmd.key}')">Examples</button>
        </div>
      </div>

      <div style="margin-top:6px">
        <span class="badge ${badge}">${cmd.category}</span>
      </div>

      <div class="desc" style="margin-top:6px">${cmd.desc}</div>
      <div class="usage" style="margin-top:8px">${cmd.syntax}</div>

      <div style="margin-top:8px;font-size:12px;color:#b0b0b0">${cmd.optionText}</div>
      <div style="margin-top:6px;font-size:12px;color:#b0b0b0">Permissions: <b>${cmd.permissions}</b></div>

      <div style="margin-top:10px;display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:12px;color:#c9c9c9">
        <div>Uses: <b>${cmd.usesTotal}</b></div>
        <div>Last used: <b>${cmd.lastUsed}</b></div>
        <div>Week: <b>${cmd.usesWeek}</b> â€¢ Month: <b>${cmd.usesMonth}</b></div>
        <div>Top user: <b>${cmd.topUser}</b></div>
      </div>

      <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
        <input type="number" id="cooldown-${cmd.key}" min="0" placeholder="Cooldown (sec)" value="${cmd.cooldownSec || ''}" style="width:140px">
        <button class="small" onclick="saveCommandCooldown('${cmd.key}')">Save</button>
      </div>
    </div>`;
  }).join('')}
</div>

<script>
window.commandExampleData = ${exampleJson};
window.commandCategoryOrder = ${JSON.stringify(categories)};

let activeCategory = 'All';

function setCommandCategory(category) {
  activeCategory = category;
  const buttons = document.querySelectorAll('.filter-btn');
  buttons.forEach(btn => {
    if (btn.dataset.category === category) {
      btn.style.background = '#9146ff';
    } else {
      btn.style.background = '#4a4a5e';
    }
  });
  applyCommandFilters();
}

function applyCommandFilters() {
  const searchTerm = (document.getElementById('commandSearch')?.value || '').toLowerCase();
  const sortBy = document.getElementById('commandSort')?.value || 'alphabetical';
  const cards = Array.from(document.querySelectorAll('.cmd-card'));

  let visible = cards.filter(card => {
    const name = card.dataset.name || '';
    const desc = card.dataset.desc || '';
    const category = card.dataset.category || '';
    const matchesSearch = name.includes(searchTerm) || desc.includes(searchTerm) || category.toLowerCase().includes(searchTerm);
    const matchesCategory = activeCategory === 'All' || category === activeCategory;
    return matchesSearch && matchesCategory;
  });

  visible.sort((a, b) => {
    const pinnedA = parseInt(a.dataset.pinned || '0', 10);
    const pinnedB = parseInt(b.dataset.pinned || '0', 10);
    if (sortBy === 'pinned' && pinnedA !== pinnedB) return pinnedB - pinnedA;

    if (sortBy === 'popularity') return parseInt(b.dataset.uses || '0', 10) - parseInt(a.dataset.uses || '0', 10);
    if (sortBy === 'newest') return parseInt(b.dataset.added || '0', 10) - parseInt(a.dataset.added || '0', 10);
    if (sortBy === 'cooldown') return parseInt(b.dataset.cooldown || '0', 10) - parseInt(a.dataset.cooldown || '0', 10);
    if (sortBy === 'requiresArgs') return parseInt(b.dataset.requires || '0', 10) - parseInt(a.dataset.requires || '0', 10);
    return (a.dataset.name || '').localeCompare(b.dataset.name || '');
  });

  const container = document.getElementById('commandsGrid');
  container.innerHTML = '';
  container.classList.toggle('cmd-sections', activeCategory === 'All');
  container.classList.toggle('cmd-grid', activeCategory !== 'All');

  if (activeCategory === 'All') {
    const categoryOrder = (window.commandCategoryOrder || []).filter(c => c !== 'All');
    const grouped = new Map();
    visible.forEach(card => {
      const cat = card.dataset.category || 'Other';
      if (!grouped.has(cat)) grouped.set(cat, []);
      grouped.get(cat).push(card);
    });

    categoryOrder.forEach(cat => {
      const group = grouped.get(cat);
      if (!group || group.length === 0) return;
      const section = document.createElement('div');
      section.className = 'cmd-section';
      const header = document.createElement('div');
      header.className = 'cmd-section-title';
      header.textContent = cat;
      const grid = document.createElement('div');
      grid.className = 'cmd-section-grid';
      group.forEach(card => grid.appendChild(card));
      section.appendChild(header);
      section.appendChild(grid);
      container.appendChild(section);
      grouped.delete(cat);
    });

    grouped.forEach((group, cat) => {
      const section = document.createElement('div');
      section.className = 'cmd-section';
      const header = document.createElement('div');
      header.className = 'cmd-section-title';
      header.textContent = cat;
      const grid = document.createElement('div');
      grid.className = 'cmd-section-grid';
      group.forEach(card => grid.appendChild(card));
      section.appendChild(header);
      section.appendChild(grid);
      container.appendChild(section);
    });
  } else {
    visible.forEach(card => container.appendChild(card));
  }
}

function saveCommandCooldown(commandKey) {
  const input = document.getElementById('cooldown-' + commandKey);
  const cooldownSeconds = input ? input.value : '';
  fetch('/commands/cooldown', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ command: commandKey, cooldownSeconds })
  }).then(r => r.json()).then(data => {
    if (data.success) {
      const card = document.querySelector('.cmd-card[data-name="/' + commandKey + '"]') || document.querySelector('.cmd-card[data-name="/' + commandKey.toLowerCase() + '"]');
      if (card) {
        const sec = parseInt(cooldownSeconds || '0', 10) || 0;
        card.dataset.cooldown = String(sec);
        card.dataset.status = sec > 0 ? 'cooldown' : 'enabled';
        const dot = card.querySelector('.status-dot');
        if (dot) {
          dot.classList.remove('status-enabled', 'status-cooldown', 'status-disabled');
          dot.classList.add(sec > 0 ? 'status-cooldown' : 'status-enabled');
        }
      }
      applyCommandFilters();
    } else {
      alert(data.error || 'Failed to update cooldown');
    }
  });
}

function toggleCommandPinned(commandKey) {
  const card = document.querySelector('.cmd-card[data-name="/' + commandKey + '"]') || document.querySelector('.cmd-card[data-name="/' + commandKey.toLowerCase() + '"]');
  const isPinned = card ? card.dataset.pinned === '1' : false;
  fetch('/commands/pin', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ command: commandKey, pinned: !isPinned })
  }).then(r => r.json()).then(data => {
    if (data.success && card) {
      card.dataset.pinned = !isPinned ? '1' : '0';
      applyCommandFilters();
      location.reload();
    }
  });
}

function toggleCommandDisabled(commandKey) {
  const card = document.querySelector('.cmd-card[data-name="/' + commandKey + '"]') || document.querySelector('.cmd-card[data-name="/' + commandKey.toLowerCase() + '"]');
  const isDisabled = card ? card.dataset.status === 'disabled' : false;
  fetch('/commands/disable', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ command: commandKey, disabled: !isDisabled })
  }).then(r => r.json()).then(data => {
    if (data.success) location.reload();
  });
}

function showCommandExample(commandKey) {
  const data = window.commandExampleData?.[commandKey];
  if (!data) return;
  let examplesHtml = '';
  if (Array.isArray(data.examples) && data.examples.length) {
    examplesHtml = '<div style="margin-top:10px;color:#b0b0b0;font-size:12px">' + data.examples.map(e => '<div>â€¢ ' + String(e) + '</div>').join('') + '</div>';
  }

  let previewHtml = '';
  if (data.preview?.type === 'embed') {
    previewHtml =
      '<div style="margin-top:12px;background:#2a2f3a;border-left:4px solid #9146ff;padding:12px;border-radius:6px">' +
        '<div style="font-weight:600;color:#fff">' + (data.preview.title || 'Example Embed') + '</div>' +
        '<div style="margin-top:6px;color:#d0d0d0;white-space:pre-wrap">' + (data.preview.description || '') + '</div>' +
      '</div>';
  } else {
    previewHtml =
      '<div style="margin-top:12px;background:#2a2f3a;padding:10px;border-radius:6px;color:#d0d0d0;white-space:pre-wrap">' +
        (data.preview?.content || '') +
      '</div>';
  }

  const html =
    '<div>' +
      '<h3 style="margin:0 0 6px 0;font-size:18px">' + data.name + ' Examples</h3>' +
      examplesHtml +
      previewHtml +
      '<div style="display:flex;justify-content:flex-end;margin-top:12px">' +
        '<button onclick="closeModal()" class="small" style="background:#3a3a42">Close</button>' +
      '</div>' +
    '</div>';
  showCustomModal(html);
}

function copyCommandName(text) {
  if (navigator.clipboard) {
    navigator.clipboard.writeText(text);
  }
}

applyCommandFilters();
</script>`;

  return html;
}

// NEW: Settings tab
function renderNotificationRoleInputs() {
  const notifTypes = [
    { key: 'liveAlert', label: 'ðŸ”´ Stream Goes Live' },
    { key: 'scheduleAlert', label: 'â° Schedule Alert' },
    { key: 'titleChange', label: 'ðŸ“ Title Changed' },
    { key: 'gameChange', label: 'ðŸŽ® Game Changed' },
    { key: 'vodNotification', label: 'ðŸ“¹ VOD Available' },
    { key: 'raidNotification', label: 'âš”ï¸ Raid Received' },
    { key: 'clipNotification', label: 'ðŸŽ¬ Clip Created' },
    { key: 'followerMilestone', label: 'ðŸ‘¥ Follower Milestone' },
    { key: 'viewerMilestone', label: 'ðŸ‘€ Viewer Milestone' }
  ];
  
  return notifTypes.map(t => {
    const isEnabled = config.notificationEnabled[t.key] !== false; // default true
    const pingEnabled = config.notificationPing[t.key] !== false; // default true
    
    return `
    <div style="margin-bottom:16px;padding:12px;background:#26262c;border-radius:10px">
      <label style="display:block;margin-bottom:8px"><b>${t.label}</b></label>
      <div style="display:grid;grid-template-columns:0.6fr 300px 72px;gap:10px;align-items:center;margin-bottom:10px">
        <input type="text" id="notif-${t.key}" value="${config.notificationRoles[t.key] || ''}" placeholder="Role ID (optional)" style="width:100%;padding:14px 16px;border:1px solid #3a3a42;border-radius:10px;background:#1d2028;color:#ffffff;font-size:14px;caret-color:#ffffff;">
        <span id="notif-display-${t.key}" style="padding:8px;background:#3a3a42;border-radius:8px;min-height:28px;display:flex;align-items:center;font-size:12px;justify-content:center"></span>
        <button onclick="saveNotificationRole('${t.key}')" style="padding:4px 6px;font-size:10px;line-height:1;white-space:nowrap;height:28px;border-radius:8px;">Save</button>
      </div>
      <div style="display:grid;grid-template-columns:0.6fr 300px 72px;gap:10px;align-items:center;margin-bottom:10px">
        <input type="text" id="channel-${t.key}" value="${config.notificationChannels[t.key] || ''}" placeholder="Channel ID (optional)" style="width:100%;padding:14px 16px;border:1px solid #3a3a42;border-radius:10px;background:#1d2028;color:#ffffff;font-size:14px;caret-color:#ffffff;">
        <span id="channel-display-${t.key}" style="padding:8px;background:#3a3a42;border-radius:8px;min-height:28px;display:flex;align-items:center;font-size:12px;justify-content:center"></span>
        <button onclick="saveNotificationChannel('${t.key}')" style="padding:4px 6px;font-size:10px;line-height:1;white-space:nowrap;height:28px;border-radius:8px;">Save</button>
      </div>
      <div style="display:flex;gap:20px;font-size:13px">
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
          <input type="checkbox" id="enable-${t.key}" ${isEnabled ? 'checked' : ''} onchange="toggleNotificationEnabled('${t.key}')" style="width:16px;height:16px;cursor:pointer">
          <span>Enable Notification</span>
        </label>
        <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
          <input type="checkbox" id="ping-${t.key}" ${pingEnabled ? 'checked' : ''} onchange="toggleNotificationPing('${t.key}')" style="width:16px;height:16px;cursor:pointer">
          <span>Enable Ping</span>
        </label>
      </div>
    </div>
  `;
  }).join('');
}

function renderConfigTab() {
  return `
<div class="card" style="margin-bottom:20px">
  <div style="display:flex;gap:8px;flex-wrap:wrap;border-bottom:2px solid #3a3a42;padding-bottom:10px">
    <button class="small" style="width:auto;background:#9146ff;color:white" onclick="document.querySelectorAll('[data-config-section]').forEach(el=>el.style.display='none');document.getElementById('section-general').style.display='block'">âš™ï¸ General</button>
    <button class="small" style="width:auto;background:#2a2f3a;color:white" onclick="document.querySelectorAll('[data-config-section]').forEach(el=>el.style.display='none');document.getElementById('section-notifications').style.display='block'">ðŸ”” Notifications</button>
    <button class="small" style="width:auto;background:#2a2f3a;color:white" onclick="document.querySelectorAll('[data-config-section]').forEach(el=>el.style.display='none');document.getElementById('section-commands').style.display='block'">ðŸ“– Commands</button>
  </div>
</div>

<div id="section-general" data-config-section>
  <div class="card">
    <h2>âš™ï¸ General Settings</h2>
    <label>Primary Notification Role:</label>
    <div style="display:grid;grid-template-columns:0.6fr 300px 72px;gap:40px;margin-bottom:18px;align-items:center">
      <input type="text" id="role" value="${config.ROLE_ID || ''}" placeholder="Role ID" style="width:100%;padding:14px 16px;border:1px solid #3a3a42;border-radius:10px;background:#1d2028;color:#ffffff;font-size:14px;caret-color:#ffffff;">
      <span id="roleDisplay" style="padding:10px 12px;background:#26262c;border-radius:8px;display:flex;align-items:center;font-size:13px;min-height:34px;justify-content:center;line-height:1.2;min-width:300px"></span>
      <button onclick="saveRole()" style="padding:4px 6px;font-size:10px;line-height:1;white-space:nowrap;height:28px;border-radius:8px;">Save</button>
    </div>
    
    <label style="margin-top:18px">Custom Notification Channel:</label>
    <div style="display:grid;grid-template-columns:0.6fr 300px 72px;gap:40px;margin-bottom:6px;align-items:center">
      <input type="text" id="channel" value="${config.NOTIF_CHANNEL || ''}" placeholder="Channel ID" style="width:100%;padding:14px 16px;border:1px solid #3a3a42;border-radius:10px;background:#1d2028;color:#ffffff;font-size:14px;caret-color:#ffffff;">
      <span id="channelDisplay" style="padding:10px 12px;background:#26262c;border-radius:8px;display:flex;align-items:center;font-size:13px;min-height:34px;justify-content:center;line-height:1.2;min-width:300px"></span>
      <button onclick="saveChannel()" style="padding:4px 6px;font-size:10px;line-height:1;white-space:nowrap;height:28px;border-radius:8px;">Save</button>
    </div>
    <div style="color:#72767d;font-size:12px;margin-bottom:18px">Leave blank to use the channel where the bot was set up.</div>

    <label style="margin-top:18px">Twitch Channel:</label>
    <div style="display:grid;grid-template-columns:0.6fr 300px 72px;gap:40px;margin-bottom:18px;align-items:center">
      <input type="text" id="twitchChannel" value="${config.TWITCH_CHANNEL || ''}" placeholder="Channel name" style="width:100%;padding:14px 16px;border:1px solid #3a3a42;border-radius:10px;background:#1d2028;color:#ffffff;font-size:14px;caret-color:#ffffff;">
      <span></span>
      <button onclick="saveTwitchChannel()" style="padding:4px 6px;font-size:10px;line-height:1;white-space:nowrap;height:28px;border-radius:8px;">Save</button>
    </div>

    <label style="margin-top:18px">Bot Timezone:</label>
    <h2>âš™ï¸ General Settings</h2>
    <label>Primary Notification Role:</label>
    <div style="display:grid;grid-template-columns:0.6fr 300px 72px;gap:40px;margin-bottom:18px;align-items:center">
      <input type="text" id="role" value="${config.ROLE_ID || ''}" placeholder="Role ID" style="width:100%;padding:14px 16px;border:1px solid #3a3a42;border-radius:10px;background:#1d2028;color:#ffffff;font-size:14px;caret-color:#ffffff;">
      <span id="roleDisplay" style="padding:10px 12px;background:#26262c;border-radius:8px;display:flex;align-items:center;font-size:13px;min-height:34px;justify-content:center;line-height:1.2;min-width:300px"></span>
      <button onclick="saveRole()" style="padding:4px 6px;font-size:10px;line-height:1;white-space:nowrap;height:28px;border-radius:8px;">Save</button>
    </div>
    
    <label style="margin-top:18px">Custom Notification Channel:</label>
    <div style="display:grid;grid-template-columns:0.6fr 300px 72px;gap:40px;margin-bottom:6px;align-items:center">
      <input type="text" id="customChannel" value="${config.CUSTOM_CHANNEL_ID || ''}" placeholder="Channel ID (optional)" style="width:100%;padding:14px 16px;border:1px solid #3a3a42;border-radius:10px;background:#1d2028;color:#ffffff;font-size:14px;caret-color:#ffffff;">
      <span id="channelDisplay" style="padding:10px 12px;background:#26262c;border-radius:8px;display:flex;align-items:center;font-size:13px;min-height:34px;justify-content:center;line-height:1.2;min-width:300px"></span>
      <button onclick="saveCustomChannel()" style="padding:4px 6px;font-size:10px;line-height:1;white-space:nowrap;height:28px;border-radius:8px;">Save</button>
    </div>
  </div>
</div>

<div id="section-notifications" data-config-section style="display:none">
  <div class="card">
    <h2>ðŸ”” Notification Role Assignments</h2>
    <p style="color:#b0b0b0;margin-bottom:20px">Configure specific roles for different notification types. If empty, uses the primary role.</p>
    ${renderNotificationRoleInputs()}
  </div>

  <div class="card">
    <h2>ðŸ“Š Stream Info</h2>
    <p><b>Current Title:</b> ${streamInfo.title}</p>
    <p><b>Current Game:</b> ${streamInfo.game}</p>
    <p><b>Viewers:</b> ${streamInfo.viewers}</p>
    <p><b>Stream Status:</b> ${streamInfo.startedAt ? 'ðŸ”´ LIVE' : 'âš« OFFLINE'}</p>
  </div>
</div>

<div id="section-commands" data-config-section style="display:none">
  ${renderCommandsTabContent()}
</div>

<script>
function displayRoleInfo(roleId, displayId) {
  const id = (roleId || '').trim();
  if (!id) {
    document.getElementById(displayId).textContent = 'Not set';
    return;
  }
  fetch(window.location.origin + '/role/info/' + encodeURIComponent(id))
    .then(r => {
      if (!r.ok) throw new Error('HTTP ' + r.status);
      return r.json();
    })
    .then(data => {
      if (data.name) {
        const color = data.hexColor || '#ffffff';
        document.getElementById(displayId).innerHTML = '<span style="color:' + color + '">â—</span> ' + data.name;
      } else {
        document.getElementById(displayId).textContent = 'Invalid role';
      }
    })
    .catch(err => document.getElementById(displayId).textContent = 'Error: ' + err.message);
}

function saveRole(){
  const roleId = document.getElementById('role').value;
  fetch('/options/save',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({ROLE_ID:roleId})})
    .then(()=>{
      alert('Saved');
      displayRoleInfo(roleId, 'roleDisplay');
    });
}

function saveNotificationRole(key){
  const roleId = document.getElementById('notif-' + key).value;
  const notificationRoles = {};
  notificationRoles[key] = roleId;
  fetch('/options/save',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({notificationRoles})})
    .then(()=>{
      alert('Saved');
      displayRoleInfo(roleId, 'notif-display-' + key);
    });
}

function toggleNotificationEnabled(key) {
  const isEnabled = document.getElementById('enable-' + key).checked;
  const notificationEnabled = {};
  notificationEnabled[key] = isEnabled;
  fetch('/options/save',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({notificationEnabled})})
    .then(()=>{
      console.log('Notification ' + key + ' ' + (isEnabled ? 'enabled' : 'disabled'));
    });
}

function toggleNotificationPing(key) {
  const pingEnabled = document.getElementById('ping-' + key).checked;
  const notificationPing = {};
  notificationPing[key] = pingEnabled;
  fetch('/options/save',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({notificationPing})})
    .then(()=>{
      console.log('Ping for ' + key + ' ' + (pingEnabled ? 'enabled' : 'disabled'));
    });
}

function saveNotificationChannel(key) {
  const channelId = document.getElementById('channel-' + key).value;
  const notificationChannels = {};
  notificationChannels[key] = channelId;
  fetch('/options/save',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({notificationChannels})})
    .then(()=>{
      alert('Saved');
      displayChannelInfo(channelId, 'channel-display-' + key);
    });
}

function displayChannelInfo(channelId, displayId) {
  const id = (channelId || '').trim();
  if (!id) {
    document.getElementById(displayId).textContent = 'Not set';
    return;
  }
  fetch(window.location.origin + '/channel/info/' + encodeURIComponent(id))
    .then(r => {
      if (!r.ok) throw new Error('HTTP ' + r.status);
      return r.json();
    })
    .then(data => {
      if (data.name) {
        document.getElementById(displayId).innerHTML = '<span style="display:inline-flex;align-items:center;gap:6px;white-space:nowrap;"><span style="display:inline-flex;align-items:center;gap:4px">#' + data.name + '</span><span style="color:#888;font-size:11px">(' + data.id + ')</span></span>';
      } else {
        document.getElementById(displayId).textContent = 'Invalid channel';
      }
    })
    .catch(err => document.getElementById(displayId).textContent = 'Error: ' + err.message);
}

function saveCustomChannel(){
  const channelId = document.getElementById('customChannel').value;
  fetch('/options/save',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({CUSTOM_CHANNEL_ID:channelId})})
    .then(()=>{
      alert('Saved');
      displayChannelInfo(channelId, 'channelDisplay');
    });
}

function updateSetting(key, value) {
  fetch('/settings/update', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({key, value})
  }).then(() => alert('Setting updated'));
}

// Load role info on page load
window.addEventListener('load', () => {
  displayRoleInfo(document.getElementById('role').value, 'roleDisplay');
  displayChannelInfo(document.getElementById('customChannel').value, 'channelDisplay');
  document.querySelectorAll('[id^="notif-"]').forEach(el => {
    if (el.id.startsWith('notif-') && !el.id.startsWith('notif-display-')) {
      const key = el.id.replace('notif-', '');
      displayRoleInfo(el.value, 'notif-display-' + key);
    }
  });
  
  // Load channel info for notification channels
  document.querySelectorAll('[id^="channel-"]').forEach(el => {
    if (el.id.startsWith('channel-') && !el.id.startsWith('channel-display-')) {
      const key = el.id.replace('channel-', '');
      displayChannelInfo(el.value, 'channel-display-' + key);
    }
  });
});
</script>`;
}

function renderSettingsTab() {
  return renderConfigTab();
}

function renderCommandsTabContent() {
  return renderCommandsTab();
}

// Helper to safely escape JSON for embedding in HTML (avoids script-breaking chars)
function safeJsonForHtml(obj) {
  return JSON.stringify(obj)
    .replace(/</g, '\\u003c')
    .replace(/>/g, '\\u003e')
    .replace(/&/g, '\\u0026')
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029');
}

// NEW: Leveling tab
function renderLevelingTab() {
  const top = Object.entries(leveling)
    .sort((a, b) => (b[1].level - a[1].level) || (b[1].xp - b[1].xp))
    .slice(0, 20);
  
  const prestigeData = typeof prestige !== 'undefined' ? prestige : {};
  
  // Build usernames map from cached data
  const usernames = {};
  Object.keys(leveling).forEach(id => {
    usernames[id] = userNameCache[id] || id;
  });
  
  return `
<div class="card" style="margin-bottom:20px">
  <div style="display:flex;gap:8px;flex-wrap:wrap;border-bottom:2px solid #3a3a42;padding-bottom:10px">
    <button class="small" id="tab-leaderboard" style="width:auto;background:#9146ff;color:white">ðŸ† Leaderboard</button>
    <button class="small" id="tab-prestige" style="width:auto;background:#2a2f3a;color:white">ðŸŽ–ï¸ Prestige</button>
    <button class="small" id="tab-settings" style="width:auto;background:#2a2f3a;color:white">âš™ï¸ Settings</button>
    <button class="small" id="tab-rewards" style="width:auto;background:#2a2f3a;color:white">ðŸŽ Rewards</button>
    <button class="small" id="tab-config" style="width:auto;background:#2a2f3a;color:white">ðŸ”§ Config</button>
  </div>
</div>

<div id="section-leaderboard" data-leveling-section>
  <div class="card">
    <h2>ðŸ† Level Leaderboard</h2>

    <div class="leaderboard-controls">
      <div class="leaderboard-row">
        <label style="color:#b0b0b0;font-size:12px">View:
          <select id="leaderboardView">
            <option value="all">All time</option>
            <option value="week">This week only</option>
          </select>
        </label>
        <label style="color:#b0b0b0;font-size:12px">Page size:
          <select id="leaderboardPageSize">
            <option value="20">20</option>
            <option value="50">50</option>
            <option value="100">100</option>
          </select>
        </label>
        <label class="leaderboard-checkbox"><input type="checkbox" id="leaderboardPrestigeOnly"> Prestige only</label>
        <label class="leaderboard-checkbox"><input type="checkbox" id="leaderboardExcludeBots"> Exclude bots/staff</label>
      </div>

      <div class="leaderboard-row">
        <input id="leaderboardSearch" placeholder="Search @user or ID" style="flex:1;min-width:200px">
        <button class="small" id="leaderboardSearchBtn" style="width:auto">Find</button>
        <button class="small" id="leaderboardClearSearchBtn" style="width:auto;background:#3a3a42">Clear</button>
        <div class="leaderboard-spacer"></div>
        <input id="leaderboardExportCount" type="number" min="20" value="100" style="width:120px" title="Export count">
        <button class="small" id="leaderboardExportBtn" style="width:auto">Export CSV</button>
        <button class="small" id="leaderboardImportBtn" style="width:auto;background:#4caf50">Import CSV</button>
        <input id="leaderboardImportFile" type="file" accept=".csv,text/csv" style="display:none">
      </div>
    </div>

    <div id="leaderboardCount" style="color:#b0b0b0;font-size:12px;margin-bottom:8px"></div>

    <div style="overflow-x:auto">
      <table style="width:100%;border-collapse:collapse;font-size:13px">
        <thead>
          <tr style="background:#26262c;position:sticky;top:0">
            <th style="padding:10px;text-align:left;border-bottom:2px solid #3a3a42">Rank</th>
            <th style="padding:10px;text-align:left;border-bottom:2px solid #3a3a42">User</th>
            <th style="padding:10px;text-align:center;border-bottom:2px solid #3a3a42">Level</th>
            <th id="leaderboardXpHeader" style="padding:10px;text-align:center;border-bottom:2px solid #3a3a42">XP</th>
            <th style="padding:10px;text-align:center;border-bottom:2px solid #3a3a42">Prestige</th>
            <th style="padding:10px;text-align:center;border-bottom:2px solid #3a3a42">Multiplier</th>
            <th style="padding:10px;text-align:center;border-bottom:2px solid #3a3a42">Actions</th>
          </tr>
        </thead>
        <tbody id="leaderboardBody"></tbody>
      </table>
    </div>

    <div class="leaderboard-pagination">
      <button class="small" id="leaderboardPrevPage" style="width:auto;background:#3a3a42">Prev</button>
      <select id="leaderboardPageSelect" style="width:auto"></select>
      <button class="small" id="leaderboardNextPage" style="width:auto;background:#3a3a42">Next</button>
      <button class="small" id="leaderboardLoadMore" style="width:auto">Load next 20</button>
      <span id="leaderboardRange" style="color:#b0b0b0;font-size:12px"></span>
    </div>
  </div>
</div>

<div id="section-prestige" data-leveling-section style="display:none">
  <div class="card">
    <h2>ðŸŽ–ï¸ Prestige Management</h2>
    <p style="color:#b0b0b0;margin-bottom:15px">Manage user prestige ranks and resets</p>
    
    <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
      <h3 style="margin-top:0">Grant Prestige</h3>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <input id="prestigeUserId" placeholder="User ID" style="flex:1;min-width:200px">
        <input id="prestigeLevel" type="number" min="0" placeholder="Prestige Level" style="flex:1;min-width:150px">
        <button class="small" id="prestigeGrantBtn" style="width:auto">Grant</button>
      </div>
      <small style="color:#999;display:block;margin-top:8px">This will also reset the user's level to 0</small>
    </div>
    
    <div style="padding:15px;background:#26262c;border-radius:6px">
      <h3 style="margin-top:0">Reset User Level</h3>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <input id="resetUserId" placeholder="User ID" style="flex:1;min-width:200px">
        <button class="small" id="resetLevelBtn" style="width:auto">Reset Level</button>
      </div>
      <small style="color:#999;display:block;margin-top:8px">Resets level and XP to 0 without changing prestige</small>
    </div>
  </div>

  <div class="card">
    <h3 style="margin-top:0">âš¡ Auto-Reset on Level (Prestige Thresholds)</h3>
    <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Set the level threshold where users auto-promote to next prestige. Automatically resets level to 1 and grants prestige rank.</p>
    <div id="prestigeThresholdsList" style="margin-bottom:15px"></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:15px">
      <input id="newPrestigeRank" type="number" min="1" placeholder="Prestige Rank" style="flex:1;min-width:120px">
      <input id="newPrestigeLvl" type="number" min="1" placeholder="Level to Reach" style="flex:1;min-width:120px">
      <input id="newPrestigeRoleId" placeholder="Role ID (optional)" style="flex:1;min-width:150px" onblur="resolvePrestigeRole()">
      <button class="small" id="prestigeAddBtn" style="width:auto">Add</button>
    </div>
    <small id="prestigeRoleName" style="color:#888;display:block;margin-bottom:15px"></small>
    
    <div style="padding:12px;background:#1a2a1a;border-radius:4px;border-left:3px solid #4caf50;margin-top:10px">
      <small style="color:#4caf50"><b>Preview:</b> Users will auto-prestige when they reach the specified level</small>
    </div>
  </div>

  <div class="card">
    <h3 style="margin-top:0">ðŸŽ Prestige Benefits</h3>
    <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Define perks for each prestige level (displayed on leaderboard)</p>
    <div id="prestigeBenefitsList" style="margin-bottom:15px;max-height:400px;overflow-y:auto"></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;padding:12px;background:#26262c;border-radius:6px">
      <input id="benefitPrestigeRank" type="number" min="1" placeholder="Prestige Rank" style="flex:0 0 120px">
      <input id="benefitXpMultiplier" type="number" min="0" step="0.1" placeholder="XP Multiplier (+%)" style="flex:0 0 140px">
      <input id="benefitDescription" placeholder="Perk description" style="flex:1;min-width:200px">
      <button class="small" id="addBenefitBtn" style="width:auto">Add Benefit</button>
    </div>
  </div>

  <div class="card">
    <h3 style="margin-top:0">ðŸ’° Prestige Requirements</h3>
    <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Set level and XP costs for prestiging</p>
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px">
      <div>
        <label style="display:block;margin-bottom:5px;font-size:12px;color:#b0b0b0"><b>Min Level to Prestige</b></label>
        <input id="prestigeMinLevel" type="number" min="0" value="${levelingConfig?.prestigeMinLevel ?? 50}" style="width:100%">
      </div>
      <div>
        <label style="display:block;margin-bottom:5px;font-size:12px;color:#b0b0b0"><b>XP Cost (0 = free)</b></label>
        <input id="prestigeXpCost" type="number" min="0" value="${levelingConfig?.prestigeXpCost ?? 0}" style="width:100%">
      </div>
    </div>
    <button id="savePrestigeReqBtn" style="width:100%;margin-top:12px">ðŸ’¾ Save Requirements</button>
  </div>

  <div class="card">
    <h3 style="margin-top:0">ðŸ“œ Prestige History</h3>
    <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Recent prestige promotions</p>
    <div id="prestigeHistoryList" style="max-height:300px;overflow-y:auto;border:1px solid #3a3a42;border-radius:4px;padding:10px">
      <div style="color:#888;text-align:center;padding:20px">Loading history...</div>
    </div>
  </div>
</div>

<div id="section-settings" data-leveling-section style="display:none">
  <div class="card">
    <div style="max-width:980px;margin:0 auto">
      <h2>âš™ï¸ XP Settings</h2>
      <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;margin-bottom:15px">
          <div>
            <label style="display:block;margin-bottom:5px;font-weight:bold">XP per message (min)</label>
            <input id="xpMin" type="number" min="0" value="${levelingConfig?.xpPerMessageMin ?? 15}" style="width:100%;box-sizing:border-box">
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-weight:bold">XP per message (max)</label>
            <input id="xpMax" type="number" min="0" value="${levelingConfig?.xpPerMessageMax ?? 25}" style="width:100%;box-sizing:border-box">
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-weight:bold">Message cooldown (seconds)</label>
            <input id="cooldown" type="number" min="0" value="${Math.round((levelingConfig?.messageCooldownMs ?? 45000)/1000)}" style="width:100%;box-sizing:border-box">
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-weight:bold">XP per voice minute</label>
            <input id="voiceXp" type="number" min="0" value="${levelingConfig?.xpPerVoiceMinute ?? 5}" style="width:100%;box-sizing:border-box">
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-weight:bold">XP per reaction</label>
            <input id="reactionXp" type="number" min="0" value="${levelingConfig?.xpPerReaction ?? 2}" style="width:100%;box-sizing:border-box">
          </div>
        </div>
        <div id="xpEstimate" style="padding:12px;background:#1a2a1a;border-radius:4px;border-left:3px solid #4caf50;margin-bottom:12px;color:#4caf50;font-size:12px;display:none">
          <b>ðŸ’¡ Estimated XP/hour:</b> <span id="xpEstimateValue">0</span> XP
        </div>
        <button id="saveLevelingBtn" style="width:100%">ðŸ’¾ Save XP Settings</button>
      </div>

      <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
        <h3 style="margin-top:0">ðŸ“Š XP Per Level Settings</h3>
        <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Choose how much XP is needed per level. In custom mode, values are used exactly (no base added).</p>

        <div style="display:flex;flex-wrap:wrap;gap:16px;align-items:center;margin-bottom:12px">
          <label style="display:flex;align-items:center;gap:8px;color:#b0b0b0">
            <input type="radio" name="xpMode" value="increment" ${levelingConfig?.xpMode !== 'custom' ? 'checked' : ''}>
            Use Increment Multiplier
          </label>
          <label style="display:flex;align-items:center;gap:8px;color:#b0b0b0">
            <input type="radio" name="xpMode" value="custom" ${levelingConfig?.xpMode === 'custom' ? 'checked' : ''}>
            Custom XP Per Level
          </label>
        </div>

        <div id="incrementMode" style="display:${levelingConfig?.xpMode !== 'custom' ? 'grid' : 'none'};grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;margin-bottom:12px">
          <div>
            <label style="display:block;margin-bottom:5px;font-weight:bold">Base XP (Level 1)</label>
            <input id="baseXp" type="number" min="0" value="${levelingConfig?.baseXp ?? 100}" style="width:100%">
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-weight:bold">Increment per Level</label>
            <input id="xpIncrement" type="number" min="0" step="5" value="${levelingConfig?.xpIncrement ?? 50}" style="width:100%">
          </div>
        </div>

        <div id="customMode" style="display:${levelingConfig?.xpMode === 'custom' ? 'block' : 'none'};overflow:hidden;border:1px solid #3a3a42;border-radius:6px;padding:12px;background:#0f0f12">
          <div id="customXpList" style="width:100%;max-width:980px;margin:0 auto;display:block"></div>
        </div>

        <button id="saveXpSettingsBtn" style="width:100%">ðŸ’¾ Save XP Settings</button>
      </div>


    </div>
  </div>
</div>

<div id="section-config" data-leveling-section style="display:none">
  <div class="card">
    <div style="max-width:900px;margin:0 auto">
      <h2>ðŸ”§ Leveling Configuration</h2>
      
      <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
        <h3 style="margin-top:0">ðŸ“Š Level Milestones</h3>
        <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Announce when users reach these levels (comma-separated)</p>
        <input id="milestones" placeholder="10,25,50,100" style="width:100%;margin-bottom:10px" value="${levelingConfig?.levelMilestones?.join(',') ?? '10,25,50,100'}">
        <button id="saveMilestonesBtn" style="width:100%">Save Milestones</button>
      </div>

      <div style="padding:15px;background:#26262c;border-radius:6px">
        <h3 style="margin-top:0">ðŸ“¢ Level-Up Announcements Channel</h3>
        <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Select where level-up notifications are posted</p>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px">
          <input id="levelUpChannel" placeholder="Channel ID" style="flex:1;min-width:200px" value="${dashboardSettings?.levelUpChannelId ?? ''}">
          <button class="small" id="saveLevelUpChannelBtn" style="width:auto">Save</button>
        </div>
        <div style="display:flex;align-items:center;gap:10px;margin-top:10px;padding:10px;background:#1a1a1d;border-radius:4px">
          <input type="checkbox" id="levelUpPingPlayer" style="width:18px;height:18px;cursor:pointer" ${dashboardSettings?.levelUpPingPlayer !== false ? 'checked' : ''}>
          <label for="levelUpPingPlayer" style="cursor:pointer;color:#b0b0b0;margin:0">Ping the player on level-up (otherwise just show name)</label>
        </div>
        <div id="levelUpChannelDisplay" style="padding:8px;background:#1a1a1d;border-radius:4px;color:#b0b0b0;font-size:12px;margin-top:10px"></div>
        <div id="channelNameBox" style="padding:10px;background:#2a2f3a;border-radius:4px;color:#9146ff;font-weight:bold;margin-top:8px;font-size:13px">ðŸ“Œ No channel selected</div>
      </div>

      <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
        <h3 style="margin-top:0">ðŸŽ¯ Ignored Channels & Roles</h3>
        <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Users in these channels or with these roles won't earn XP</p>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-bottom:12px">
          <div>
            <label style="display:block;margin-bottom:5px;font-weight:bold;font-size:12px">No XP Channels (comma-separated IDs)</label>
            <textarea id="ignoreChannels" placeholder="Channel IDs separated by commas" style="width:100%;min-height:80px">${(levelingConfig?.ignoreChannels || []).join(',')}</textarea>
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-weight:bold;font-size:12px">No XP Roles (comma-separated IDs)</label>
            <textarea id="ignoreRoles" placeholder="Role IDs separated by commas" style="width:100%;min-height:80px">${(levelingConfig?.ignoreRoles || []).join(',')}</textarea>
          </div>
        </div>
        <button id="saveIgnoreListBtn" style="width:100%">ðŸ’¾ Save Ignored Channels & Roles</button>
      </div>

      <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
        <h3 style="margin-top:0">â­ XP Multipliers</h3>
        <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Configure multiplier boosts for roles, channels, and global events</p>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px;margin-bottom:12px">
          <div>
            <label style="display:block;margin-bottom:5px;font-weight:bold;font-size:12px">Global Server Multiplier</label>
            <input id="globalMultiplier" type="number" min="1" step="0.1" value="${levelingConfig?.globalMultiplier ?? 1}" style="width:100%">
            <small style="color:#999">Default: 1.0 (increase during events)</small>
          </div>
        </div>
        <div style="margin-bottom:12px">
          <label style="display:block;margin-bottom:5px;font-weight:bold;font-size:12px">Role Multipliers (Role ID = multiplier, comma-separated)</label>
          <textarea id="roleMultipliers" placeholder="roleID1:2.0,roleID2:1.5" style="width:100%;min-height:80px">${(() => {
            const rm = levelingConfig?.roleMultipliers || {};
            return Object.entries(rm).map(([id, mult]) => id + ':' + mult).join(',');
          })()}</textarea>
          <small style="color:#999">Format: roleID:multiplier (e.g., 123456789:1.5 for 1.5Ã— boost)</small>
        </div>
        <div>
          <label style="display:block;margin-bottom:5px;font-weight:bold;font-size:12px">Channel Multipliers (Channel ID = multiplier, comma-separated)</label>
          <textarea id="channelMultipliers" placeholder="channelID1:1.2,channelID2:1.5" style="width:100%;min-height:80px">${(() => {
            const cm = levelingConfig?.channelMultipliers || {};
            return Object.entries(cm).map(([id, mult]) => id + ':' + mult).join(',');
          })()}</textarea>
          <small style="color:#999">Format: channelID:multiplier (e.g., 987654321:1.2 for 1.2Ã— boost)</small>
        </div>
        <button id="saveMultipliersBtn" style="width:100%;margin-top:12px">ðŸ’¾ Save Multipliers</button>
      </div>

      <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
        <h3 style="margin-top:0">ðŸŒ™ Weekend/Time Boost</h3>
        <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Enable higher XP during specific days/hours</p>
        <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;padding:10px;background:#1a1a1d;border-radius:4px">
          <input type="checkbox" id="enableTimeBoost" style="width:18px;height:18px;cursor:pointer" ${levelingConfig?.enableTimeBoost ? 'checked' : ''}>
          <label for="enableTimeBoost" style="cursor:pointer;color:#b0b0b0;margin:0">Enable time-based XP boost</label>
        </div>
        <div id="timeBoostSettings" style="display:${levelingConfig?.enableTimeBoost ? 'grid' : 'none'};grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px">
          <div>
            <label style="display:block;margin-bottom:5px;font-size:12px">Multiplier (e.g., 2.0)</label>
            <input id="timeBoostMultiplier" type="number" min="1" step="0.1" value="${levelingConfig?.timeBoostMultiplier ?? 2}" style="width:100%">
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-size:12px">Start Day (0=Sunday)</label>
            <input id="timeBoostStartDay" type="number" min="0" max="6" value="${levelingConfig?.timeBoostStartDay ?? 5}" style="width:100%">
            <small style="color:#999">5=Friday</small>
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-size:12px">End Day</label>
            <input id="timeBoostEndDay" type="number" min="0" max="6" value="${levelingConfig?.timeBoostEndDay ?? 0}" style="width:100%">
            <small style="color:#999">0=Sunday</small>
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-size:12px">Start Hour (0-23)</label>
            <input id="timeBoostStartHour" type="number" min="0" max="23" value="${levelingConfig?.timeBoostStartHour ?? 0}" style="width:100%">
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-size:12px">End Hour (0-23)</label>
            <input id="timeBoostEndHour" type="number" min="0" max="23" value="${levelingConfig?.timeBoostEndHour ?? 23}" style="width:100%">
          </div>
        </div>
        <button id="saveTimeBoostBtn" style="width:100%;margin-top:12px">ðŸ’¾ Save Time Boost</button>
      </div>

      <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
        <h3 style="margin-top:0">ðŸ“‰ XP Decay</h3>
        <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Optional: Users lose XP percentage if inactive for 14+ days</p>
        <div style="display:flex;align-items:center;gap:10px;margin-bottom:12px;padding:10px;background:#1a1a1d;border-radius:4px">
          <input type="checkbox" id="enableXpDecay" style="width:18px;height:18px;cursor:pointer" ${levelingConfig?.enableXpDecay ? 'checked' : ''}>
          <label for="enableXpDecay" style="cursor:pointer;color:#b0b0b0;margin:0">Enable XP decay for inactive users</label>
        </div>
        <div id="xpDecaySettings" style="display:${levelingConfig?.enableXpDecay ? 'grid' : 'none'};grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px">
          <div>
            <label style="display:block;margin-bottom:5px;font-size:12px">Inactivity days threshold</label>
            <input id="xpDecayDays" type="number" min="1" value="${levelingConfig?.xpDecayDays ?? 14}" style="width:100%">
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-size:12px">XP loss per day (%)</label>
            <input id="xpDecayPercent" type="number" min="0" max="100" value="${levelingConfig?.xpDecayPercent ?? 5}" style="width:100%">
            <small style="color:#999">0-100%</small>
          </div>
        </div>
        <button id="saveXpDecayBtn" style="width:100%;margin-top:12px">ðŸ’¾ Save XP Decay Settings</button>
      </div>

      <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
        <h3 style="margin-top:0">ðŸŽ‰ Custom Level-Up Message</h3>
        <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Customize the message sent when users level up. Variables: {user}, {mention}, {level}, {prestige}, {xp}, {next_level}</p>
        <textarea id="customLevelUpMessage" placeholder="Example: ðŸŽ‰ {mention} just reached Level {level}! ({prestige}â˜…)" style="width:100%;min-height:100px">${levelingConfig?.customLevelUpMessage ?? 'ðŸŽ‰ {mention} just reached Level {level}!'}</textarea>
        <button id="saveLevelUpMessageBtn" style="width:100%;margin-top:12px">ðŸ’¾ Save Custom Message</button>
      </div>

      <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
        <h3 style="margin-top:0">ðŸ“‹ Level-Up Announcement Options</h3>
        <div style="display:flex;align-items:center;gap:10px;margin-bottom:10px;padding:10px;background:#1a1a1d;border-radius:4px">
          <input type="checkbox" id="milestonesOnly" style="width:18px;height:18px;cursor:pointer" ${levelingConfig?.milestonesOnly ? 'checked' : ''}>
          <label for="milestonesOnly" style="cursor:pointer;color:#b0b0b0;margin:0">Only announce milestones (reduces spam)</label>
        </div>
        <div style="display:flex;align-items:center;gap:10px;padding:10px;background:#1a1a1d;border-radius:4px">
          <input type="checkbox" id="dmOnLevelUp" style="width:18px;height:18px;cursor:pointer" ${levelingConfig?.dmOnLevelUp ? 'checked' : ''}>
          <label for="dmOnLevelUp" style="cursor:pointer;color:#b0b0b0;margin:0">Also DM users when they level up</label>
        </div>
        <button id="saveLevelUpOptionsBtn" style="width:100%;margin-top:12px">ðŸ’¾ Save Announcement Options</button>
      </div>

      <div style="padding:15px;background:#26262c;border-radius:6px">
        <h3 style="margin-top:0">ðŸŽ¨ Embed Color & Image</h3>
        <p style="font-size:12px;color:#b0b0b0;margin-bottom:10px">Customize the appearance of level-up announcements</p>
        <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:12px">
          <div>
            <label style="display:block;margin-bottom:5px;font-size:12px">Embed Color (hex, e.g., #9146ff)</label>
            <input id="levelUpColor" type="text" placeholder="#9146ff" value="${levelingConfig?.levelUpColor ?? '#9146ff'}" style="width:100%">
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-size:12px">Thumbnail Image URL</label>
            <input id="levelUpThumbnail" type="text" placeholder="https://..." value="${levelingConfig?.levelUpThumbnail ?? ''}" style="width:100%">
          </div>
          <div>
            <label style="display:block;margin-bottom:5px;font-size:12px">Footer Text</label>
            <input id="levelUpFooter" type="text" placeholder="Congratulations!" value="${levelingConfig?.levelUpFooter ?? 'Keep grinding!'}" style="width:100%">
          </div>
        </div>
        <button id="saveEmbedStyleBtn" style="width:100%;margin-top:12px">ðŸ’¾ Save Embed Style</button>
      </div>
    </div>
  </div>
</div>

<div id="section-rewards" data-leveling-section style="display:none">
  <div class="card">
    <div style="max-width:900px;margin:0 auto">
      <h2>ðŸŽ Role Rewards</h2>
      <p style="color:#b0b0b0;margin-bottom:15px">Grant roles to users when they reach certain levels</p>
      <div style="padding:15px;background:#26262c;border-radius:6px;margin-bottom:15px">
        <h3 style="margin-top:0">Add Reward</h3>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px">
          <input id="rewardLevel" type="number" min="1" placeholder="Level" style="flex:1;min-width:100px">
          <input id="rewardRoleId" placeholder="Role ID" style="flex:1;min-width:150px" onblur="resolveRewardRole()">
          <button class="small" id="addRoleRewardBtn" style="width:auto">Add Reward</button>
        </div>
        <small id="rewardRoleName" style="color:#888;display:block;margin-top:4px"></small>
      </div>

      <div style="padding:15px;background:#26262c;border-radius:6px">
        <h3 style="margin-top:0">Current Rewards</h3>
        <div id="roleRewardsList"></div>
      </div>
    </div>
  </div>
</div>

<div id="editLevelModal" style="display:none;position:fixed;top:20%;left:50%;transform:translate(-50%,0);background:#23232b;padding:24px;border-radius:8px;z-index:1000;border:2px solid #9146ff;max-width:450px;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
  <h3 style="margin-top:0;color:#fff">Edit User Level/XP</h3>
  <input type="hidden" id="editUserId">
  <div style="margin:15px 0;padding:10px;background:#1a1a1d;border-radius:4px;color:#9146ff;font-weight:bold"><span id="editUserDisplay"></span></div>
  
  <div style="margin:15px 0">
    <label style="display:block;margin-bottom:5px;font-weight:bold">Level:</label>
    <input id="editLevel" type="number" min="0" style="width:100%;padding:10px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0">
  </div>
  <div style="margin:15px 0">
    <label style="display:block;margin-bottom:5px;font-weight:bold">XP:</label>
    <input id="editXP" type="number" min="0" style="width:100%;padding:10px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0">
  </div>
  <div style="margin:15px 0">
    <label style="display:block;margin-bottom:5px;font-weight:bold">XP Multiplier:</label>
    <input id="editMultiplier" type="number" min="1" step="0.1" value="1" style="width:100%;padding:10px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0">
    <small style="color:#999">Default: 1 (set higher for bonus XP)</small>
  </div>
  
  <div style="display:flex;gap:8px;margin-top:20px">
    <button id="saveLevelEditBtn" style="flex:1;padding:10px;background:#4caf50;color:white;border:none;border-radius:4px;font-weight:bold;cursor:pointer">Save Changes</button>
    <button id="closeLevelModalBtn" style="flex:1;padding:10px;background:#c43c3c;color:white;border:none;border-radius:4px;font-weight:bold;cursor:pointer">Cancel</button>
  </div>
</div>
<div id="quickActionModal" style="display:none;position:fixed;top:20%;left:50%;transform:translate(-50%,0);background:#23232b;padding:24px;border-radius:8px;z-index:1000;border:2px solid #4caf50;max-width:420px;box-shadow:0 8px 32px rgba(0,0,0,0.5)">
  <h3 style="margin-top:0;color:#fff" id="quickActionTitle">Quick Action</h3>
  <input type="hidden" id="quickActionUserId">
  <input type="hidden" id="quickActionType">
  <div style="margin:10px 0;padding:10px;background:#1a1a1d;border-radius:4px;color:#b0b0b0;font-size:12px">
    <span id="quickActionUserDisplay"></span>
  </div>
  <div id="quickActionXpRow" style="margin:15px 0;display:none">
    <label style="display:block;margin-bottom:5px;font-weight:bold">Add XP:</label>
    <input id="quickActionXp" type="number" min="1" style="width:100%;padding:10px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0">
  </div>
  <div id="quickActionPrestigeRow" style="margin:15px 0;display:none">
    <label style="display:block;margin-bottom:5px;font-weight:bold">Prestige Level:</label>
    <input id="quickActionPrestige" type="number" min="1" style="width:100%;padding:10px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0">
  </div>
  <div id="quickActionConfirmText" style="margin:12px 0;color:#b0b0b0;font-size:12px"></div>
  <div style="display:flex;gap:8px;margin-top:20px">
    <button id="quickActionConfirmBtn" style="flex:1;padding:10px;background:#4caf50;color:white;border:none;border-radius:4px;font-weight:bold;cursor:pointer">Confirm</button>
    <button id="quickActionCancelBtn" style="flex:1;padding:10px;background:#3a3a42;color:white;border:none;border-radius:4px;font-weight:bold;cursor:pointer">Cancel</button>
  </div>
</div>
<div id="modalBackdrop" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);z-index:999"></div>

<script>
console.log('=== LEVELING TAB SCRIPT LOADING ===');
window.switchLevelingTab = function(tab) {
  console.log('Switching to tab:', tab);
  document.querySelectorAll('[data-leveling-section]').forEach(el => el.style.display = 'none');
  document.getElementById('section-' + tab).style.display = 'block';
  document.querySelectorAll('[id^="tab-"]').forEach(btn => btn.style.background = '#2a2f3a');
  document.getElementById('tab-' + tab).style.background = '#9146ff';
}
console.log('switchLevelingTab defined:', typeof window.switchLevelingTab);
window.toggleXpMode = function(mode) {
  const incrementMode = document.getElementById('incrementMode');
  const customMode = document.getElementById('customMode');
  if (mode === 'increment') {
    incrementMode.style.display = 'flex';
    customMode.style.display = 'none';
  } else {
    incrementMode.style.display = 'none';
    customMode.style.display = 'flex';
    if (typeof window.renderCustomXpList === 'function') {
      window.renderCustomXpList();
    }
  }
}
window.renderCustomXpList = function() {
  const list = document.getElementById('customXpList');
  const customXp = (window.levelingConfig && window.levelingConfig.customXpPerLevel) || {};
  const maxLevel = Math.max(...Object.keys(customXp).map(Number), 100);
  let html = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:12px;width:100%">';
  for (let i = 1; i <= maxLevel + 1; i++) {
    html += '<div style="background:#26262c;padding:10px;border-radius:6px;border:1px solid #3a3a42">' +
      '<label style="display:block;font-size:11px;margin-bottom:6px;color:#9146ff;font-weight:600">Level ' + i + '</label>' +
      '<input type="number" min="0" value="' + (customXp[i] || 0) + '" style="width:100%;padding:6px;background:#1a1a1d;border:1px solid #4a4a4e;border-radius:4px;color:#fff;font-size:13px;text-align:center;box-sizing:border-box" data-level="' + i + '">' +
    '</div>';
  }
  html += '</div>' +
    '<div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;padding:12px 0;border-top:1px solid #3a3a42;margin-top:15px">' +
      '<button class="small" style="padding:8px 12px;white-space:nowrap" data-action="add-more-levels">+5 Levels</button>' +
      '<span style="font-size:12px;color:#b0b0b0">Fill every level you use (0 disables that level)</span>' +
    '</div>';
  list.innerHTML = html;
}
window.addMoreLevels = function() {
  const inputs = document.querySelectorAll('#customXpList input');
  const maxLevel = Math.max(...Array.from(inputs).map(i => parseInt(i.dataset.level)), 100);
  const customXp = (window.levelingConfig && window.levelingConfig.customXpPerLevel) || {};
  let html = '<div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:12px;width:100%">';
  for (let i = 1; i <= maxLevel + 5; i++) {
    html += '<div style="background:#26262c;padding:10px;border-radius:6px;border:1px solid #3a3a42">' +
      '<label style="display:block;font-size:11px;margin-bottom:6px;color:#9146ff;font-weight:600">Level ' + i + '</label>' +
      '<input type="number" min="0" value="' + (customXp[i] || 0) + '" style="width:100%;padding:6px;background:#1a1a1d;border:1px solid #4a4a4e;border-radius:4px;color:#fff;font-size:13px;text-align:center;box-sizing:border-box" data-level="' + i + '">' +
    '</div>';
  }
  html += '</div>' +
    '<div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;padding:12px 0;border-top:1px solid #3a3a42;margin-top:15px">' +
      '<button class="small" style="padding:8px 12px;white-space:nowrap" data-action="add-more-levels">+5 Levels</button>' +
      '<span style="font-size:12px;color:#b0b0b0">Fill every level you use (0 disables that level)</span>' +
    '</div>';
  document.getElementById('customXpList').innerHTML = html;
}
window.renderPrestigeThresholds = function() {
  const prestigeConfig = (window.levelingConfig && window.levelingConfig.prestigeThresholds) || {};
  const list = document.getElementById('prestigeThresholdsList');
  const entries = Object.entries(prestigeConfig).sort((a, b) => Number(a[0]) - Number(b[0]));
  if (entries.length === 0) {
    list.innerHTML = '<p style="color:#999;font-size:12px">No prestige thresholds configured yet</p>';
    return;
  }
  list.innerHTML = entries.map(([rank, config]) => 
    '<div style="padding:8px;background:#1a1a1d;border-radius:4px;margin-bottom:8px;display:flex;justify-content:space-between;align-items:center">' +
      '<div><strong>Prestige ' + rank + ':</strong> Reach Level ' + config.levelRequired + (config.roleId ? ' -> Role: ' + config.roleId : '') + '</div>' +
      '<button class="small" style="padding:4px 8px;font-size:11px" data-prestige-remove="' + rank + '">Remove</button>' +
    '</div>'
  ).join('');
}

window.resolvePrestigeRole = function() {
  const input = document.getElementById('newPrestigeRoleId');
  const display = document.getElementById('prestigeRoleName');
  const roleId = input && input.value ? input.value.trim() : '';
  
  if (!roleId) {
    display.textContent = '';
    return;
  }
  
  display.textContent = 'Loading...';
  fetch('/role/info/' + roleId)
    .then(r => r.json())
    .then(data => {
      if (data && data.name) {
        display.textContent = '\u2713 @' + data.name;
        display.style.color = data.hexColor || '#57F287';
      } else {
        display.textContent = '\u2717 Role not found';
        display.style.color = '#ED4245';
      }
    })
    .catch(() => {
      display.textContent = '\u2717 Error fetching role';
      display.style.color = '#ED4245';
    });
}

window.addPrestigeThreshold = function() {
  const rank = parseInt(document.getElementById('newPrestigeRank').value);
  const lvl = parseInt(document.getElementById('newPrestigeLvl').value);
  const roleId = document.getElementById('newPrestigeRoleId').value.trim();
  if (!rank || !lvl || rank < 1 || lvl < 1) return alert('Enter valid prestige rank and level');
  if (!window.levelingConfig) window.levelingConfig = {};
  if (!window.levelingConfig.prestigeThresholds) window.levelingConfig.prestigeThresholds = {};
  window.levelingConfig.prestigeThresholds[rank] = { levelRequired: lvl, roleId: roleId || null };
  window.renderPrestigeThresholds();
  document.getElementById('newPrestigeRank').value = '';
  document.getElementById('newPrestigeLvl').value = '';
  document.getElementById('newPrestigeRoleId').value = '';
  document.getElementById('prestigeRoleName').textContent = '';
  // Save to server
  window.saveLevelingConfig(false);
}
window.deletePrestigeThreshold = function(rank) {
  if (window.levelingConfig && window.levelingConfig.prestigeThresholds) {
    delete window.levelingConfig.prestigeThresholds[rank];
    window.renderPrestigeThresholds();
    // Save to server
    window.saveLevelingConfig(false);
  }
}

window.renderPrestigeBenefits = function() {
  const benefits = window.levelingConfig?.prestigeBenefits || {};
  const list = document.getElementById('prestigeBenefitsList');
  if (!list) return;
  
  const entries = Object.entries(benefits).sort((a, b) => Number(a[0]) - Number(b[0]));
  if (entries.length === 0) {
    list.innerHTML = '<p style="color:#999">No benefits configured yet</p>';
    return;
  }
  
  list.innerHTML = entries.map(([rank, benefit]) => {
    return '<div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:10px;background:#1a2a1a;border-radius:4px;margin-bottom:8px;border-left:3px solid #4caf50">' +
      '<div style="background:#4caf50;color:white;padding:6px 12px;border-radius:4px;font-weight:bold;min-width:70px;text-align:center">Prestige #' + rank + '</div>' +
      '<div style="flex:1 1 260px">' +
        '<div style="color:#e0e0e0;font-weight:bold">' + (benefit.description || 'No description') + '</div>' +
        '<div style="color:#999;font-size:11px">+' + (benefit.xpMultiplier * 100).toFixed(1) + '% XP Multiplier</div>' +
      '</div>' +
      '<button class="small danger" style="padding:6px 10px;font-size:11px;white-space:nowrap;margin-left:auto" data-benefit-remove="' + rank + '">Remove</button>' +
    '</div>';
  }).join('');
}

window.addPrestigeBenefit = function() {
  const rank = parseInt(document.getElementById('benefitPrestigeRank').value);
  const multiplier = parseFloat(document.getElementById('benefitXpMultiplier').value) || 0;
  const description = document.getElementById('benefitDescription').value.trim();
  
  if (!rank || rank < 1) return alert('Enter valid prestige rank');
  if (!description) return alert('Enter perk description');
  
  if (!window.levelingConfig) window.levelingConfig = {};
  if (!window.levelingConfig.prestigeBenefits) window.levelingConfig.prestigeBenefits = {};
  
  window.levelingConfig.prestigeBenefits[rank] = {
    xpMultiplier: 1 + (multiplier / 100),
    description: description
  };
  
  window.renderPrestigeBenefits();
  document.getElementById('benefitPrestigeRank').value = '';
  document.getElementById('benefitXpMultiplier').value = '';
  document.getElementById('benefitDescription').value = '';
  window.saveLevelingConfig(false);
}

window.deletePrestigeBenefit = function(rank) {
  if (window.levelingConfig && window.levelingConfig.prestigeBenefits) {
    delete window.levelingConfig.prestigeBenefits[rank];
    window.renderPrestigeBenefits();
    window.saveLevelingConfig(false);
  }
}

window.savePrestigeRequirements = function() {
  const minLevel = parseInt(document.getElementById('prestigeMinLevel').value) || 0;
  const xpCost = parseInt(document.getElementById('prestigeXpCost').value) || 0;
  
  if (!window.levelingConfig) window.levelingConfig = {};
  window.levelingConfig.prestigeMinLevel = minLevel;
  window.levelingConfig.prestigeXpCost = xpCost;
  
  window.saveLevelingConfig();
  alert('âœ… Prestige requirements saved!');
}

window.saveXpSettings = function() {
  const mode = document.querySelector('input[name="xpMode"]:checked').value;
  if (mode === 'increment') {
    window.levelingConfig.xpMode = 'increment';
    window.levelingConfig.baseXp = parseInt(document.getElementById('baseXp').value) || 100;
    window.levelingConfig.xpIncrement = parseInt(document.getElementById('xpIncrement').value) || 50;
    delete window.levelingConfig.customXpPerLevel;
  } else {
    const inputs = document.querySelectorAll('#customXpList input');
    const customXp = {};
    inputs.forEach(input => {
      const level = parseInt(input.dataset.level);
      const xp = parseInt(input.value) || 0;
      if (xp > 0) customXp[level] = xp;
    });
    if (Object.keys(customXp).length === 0) return alert('Enter XP values for at least one level');
    window.levelingConfig.xpMode = 'custom';
    window.levelingConfig.customXpPerLevel = customXp;
  }
  window.saveLevelingConfig();
}
window.searchLevelUser = function() {
  const input = document.getElementById('levelUser').value.trim().toLowerCase();
  if (!input) {
    document.getElementById('levelUserResult').innerHTML = '';
    return;
  }
  
  const results = [];
  for (const [id, data] of Object.entries(window.levelingData)) {
    const userName = window.nameCache && window.nameCache[id] ? window.nameCache[id].toLowerCase() : '';
    if (id.includes(input) || userName.includes(input)) {
      results.push({id, userName: userName || id, data});
    }
  }
  
  if (results.length === 0) {
    document.getElementById('levelUserResult').innerHTML = '<p style="color:#ef5350">âŒ No users found</p>';
    return;
  }
  
  document.getElementById('levelUserResult').innerHTML = results.map(r => 
    '<div style="padding:10px;background:#26262c;border-radius:4px;margin-bottom:8px">' +
      '<div style="color:#9146ff;font-weight:bold">' + r.userName + ' (ID: ' + r.id + ')</div>' +
      '<div style="color:#b0b0b0;font-size:12px">Level ' + r.data.level + ' â€¢ ' + r.data.xp + ' XP</div>' +
      '<button class="small" style="margin-top:5px;padding:4px 8px;font-size:11px" data-edit-id="' + r.id + '">Edit</button>' +
    '</div>'
  ).join('');
}

window.grantPrestige = function() {
  console.log('Granting prestige');
  const userId = document.getElementById('prestigeUserId').value.trim();
  const prestigeLevel = parseInt(document.getElementById('prestigeLevel').value);
  if (!userId || !prestigeLevel) return alert('Enter user ID and prestige level');
  
  fetch('/leveling/prestige', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({userId, prestigeLevel})
  }).then(r=>r.json()).then(data=>{
    if(data.success) {
      alert('âœ… Prestige granted!');
      document.getElementById('prestigeUserId').value = '';
      document.getElementById('prestigeLevel').value = '';
      location.reload();
    } else alert('Failed: ' + (data.error || 'Unknown'));
  }).catch(err => alert('Error: ' + err.message));
}

window.editLevel = function(id) {
  console.log('Editing level for:', id);
  const d = window.levelingData[id];
  const userName = Object.keys(window.nameCache || {}).find(k => window.nameCache[k] === id) || id;
  document.getElementById('editUserId').value = id;
  document.getElementById('editUserDisplay').textContent = userName;
  document.getElementById('editLevel').value = d.level;
  document.getElementById('editXP').value = d.xp;
  document.getElementById('editMultiplier').value = d.xpMultiplier || 1;
  document.getElementById('editLevelModal').style.display = 'block';
  document.getElementById('modalBackdrop').style.display = 'block';
}
window.closeLevelModal = function() {
  document.getElementById('editLevelModal').style.display = 'none';
  document.getElementById('modalBackdrop').style.display = 'none';
}
window.saveLevelEdit = function() {
  const id = document.getElementById('editUserId').value;
  const level = parseInt(document.getElementById('editLevel').value);
  const xp = parseInt(document.getElementById('editXP').value);
  const xpMultiplier = parseFloat(document.getElementById('editMultiplier').value) || 1;
  fetch('/leveling/edit', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({id, level, xp, xpMultiplier})
  }).then(r=>r.json()).then(data=>{
    if(data.success) {
      alert('âœ… User updated!');
      window.closeLevelModal();
      location.reload();
    }
    else alert('Failed to update');
  });
}

window.resetUserLevel = function() {
  const userId = document.getElementById('resetUserId').value.trim();
  if (!userId) return alert('Enter user ID');
  
  fetch('/leveling/reset-level', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({userId})
  }).then(r=>r.json()).then(data=>{
    if(data.success) {
      alert('âœ… User level reset!');
      document.getElementById('resetUserId').value = '';
      location.reload();
    } else alert('Failed: ' + (data.error || 'Unknown'));
  }).catch(err => alert('Error: ' + err.message));
}

window.renderRoleRewards = function(){
  const entries = Object.entries(window.levelingConfig.roleRewards || {}).sort((a,b)=>Number(a[0])-Number(b[0]));
  const el = document.getElementById('roleRewardsList');
  if(!el) return;
  if(entries.length === 0){
    el.innerHTML = '<p style="color:#999">No role rewards configured yet</p>';
    return;
  }
  el.innerHTML = entries.map(([lvl, role]) => {
    return '<div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding:10px;background:#1a1a1d;border-radius:4px;margin-bottom:8px">' +
      '<div style="background:#9146ff;color:white;padding:6px 10px;border-radius:4px;font-weight:bold;min-width:60px;text-align:center">Lvl ' + lvl + '</div>' +
      '<div style="flex:1 1 260px;color:#b0b0b0">Role: <span data-role-info="' + role + '" style="color:#e0e0e0">Loading...</span><span style="color:#666;margin-left:8px;font-size:11px">(' + role + ')</span></div>' +
      '<button class="small danger" style="padding:6px 10px;font-size:11px;white-space:nowrap;margin-left:auto" data-role-reward-remove="' + lvl + '">Remove</button>' +
    '</div>';
  }).join('');

  el.querySelectorAll('[data-role-info]').forEach(infoEl => {
    const roleId = infoEl.getAttribute('data-role-info');
    fetch('/role/info/' + roleId)
      .then(r => r.json())
      .then(data => {
        if (data && data.name) {
          infoEl.textContent = data.name;
          if (data.hexColor) infoEl.style.color = data.hexColor;
        } else {
          infoEl.textContent = 'Unknown role';
        }
      })
      .catch(() => {
        infoEl.textContent = 'Unknown role';
      });
  });
}

function gatherLevelingConfig(){
  const xpMin = parseInt(document.getElementById('xpMin').value) || 0;
  const xpMax = parseInt(document.getElementById('xpMax').value) || 0;
  const cooldown = parseInt(document.getElementById('cooldown').value) || 0;
  const voiceXp = parseInt(document.getElementById('voiceXp').value) || 5;
  const reactionXp = parseInt(document.getElementById('reactionXp').value) || 2;
  return {
    xpPerMessageMin: Math.max(0, xpMin),
    xpPerMessageMax: Math.max(xpMin, xpMax),
    messageCooldownMs: Math.max(0, cooldown * 1000),
    xpPerVoiceMinute: Math.max(0, voiceXp),
    xpPerReaction: Math.max(0, reactionXp),
    xpMultiplier: window.levelingConfig.xpMultiplier || 1,
    multiplierEndTime: window.levelingConfig.multiplierEndTime || null,
    levelMilestones: window.levelingConfig.levelMilestones || [10, 25, 50, 100],
    roleRewards: { ...(window.levelingConfig.roleRewards || {}) },
    xpMode: window.levelingConfig.xpMode || 'increment',
    baseXp: window.levelingConfig.baseXp ?? 100,
    xpIncrement: window.levelingConfig.xpIncrement ?? 50,
    customXpPerLevel: { ...(window.levelingConfig.customXpPerLevel || {}) },
    prestigeThresholds: { ...(window.levelingConfig.prestigeThresholds || {}) }
  };
}

window.saveLevelingConfig = function(showAlert=true){
  const cfg = gatherLevelingConfig();
  return fetch('/leveling/config', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(cfg)
  }).then(r=>{
    if(!r.ok) throw new Error('Failed');
    return r.json();
  }).then(()=>{
    window.levelingConfig = cfg;
    window.renderRoleRewards();
    if(showAlert) alert('âœ… Leveling settings saved');
  }).catch(err=>{
    console.error(err);
    alert('Failed to save settings');
  });
}

window.resolveRewardRole = function() {
  const input = document.getElementById('rewardRoleId');
  const display = document.getElementById('rewardRoleName');
  const roleId = input && input.value ? input.value.trim() : '';
  
  if (!roleId) {
    display.textContent = '';
    return;
  }
  
  display.textContent = 'Loading...';
  fetch('/role/info/' + roleId)
    .then(r => r.json())
    .then(data => {
      if (data && data.name) {
        display.textContent = '\u2713 @' + data.name;
        display.style.color = data.hexColor || '#57F287';
      } else {
        display.textContent = '\u2717 Role not found';
        display.style.color = '#ED4245';
      }
    })
    .catch(() => {
      display.textContent = '\u2717 Error fetching role';
      display.style.color = '#ED4245';
    });
}

window.addRoleReward = function(){
  const level = parseInt(document.getElementById('rewardLevel').value);
  const roleId = document.getElementById('rewardRoleId').value.trim();
  if(!level || !roleId) return alert('Enter a level and role ID');
  
  if(!window.levelingConfig.roleRewards) window.levelingConfig.roleRewards = {};
  window.levelingConfig.roleRewards[level] = roleId;
  window.renderRoleRewards();
  
  const fullConfig = {
    xpPerMessageMin: parseInt(document.getElementById('xpMin').value) || 0,
    xpPerMessageMax: parseInt(document.getElementById('xpMax').value) || 0,
    messageCooldownMs: (parseInt(document.getElementById('cooldown').value) || 0) * 1000,
    roleRewards: window.levelingConfig.roleRewards
  };
  
  fetch('/leveling/config', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(fullConfig)
  }).then(r => {
    if(!r.ok) throw new Error('Server error: ' + r.status);
    return r.json();
  }).then(data => {
    window.levelingConfig = data.levelingConfig || fullConfig;
    window.renderRoleRewards();
    alert('âœ… Role reward saved!');
    document.getElementById('rewardLevel').value = '';
    document.getElementById('rewardRoleId').value = '';
    document.getElementById('rewardRoleName').textContent = '';
  }).catch(err => {
    console.error('Error:', err);
    alert('Failed to save role reward: ' + err.message);
    if(window.levelingConfig.roleRewards) {
      delete window.levelingConfig.roleRewards[level];
    }
    window.renderRoleRewards();
  });
}

window.removeRoleReward = function(level){
  if(!window.levelingConfig.roleRewards) return;
  delete window.levelingConfig.roleRewards[level];
  window.saveLevelingConfig();
}

window.saveMilestones = function(){
  const input = document.getElementById('milestones').value.trim();
  const milestones = input.split(',').map(m => parseInt(m.trim())).filter(m => m > 0);
  if(!milestones.length) return alert('Enter at least one milestone level');
  
  window.levelingConfig.levelMilestones = milestones.sort((a,b) => a - b);
  window.saveLevelingConfig();
}

window.calculateXpEstimate = function() {
  const min = parseInt(document.getElementById('xpMin')?.value) || 15;
  const max = parseInt(document.getElementById('xpMax')?.value) || 25;
  const cooldown = parseInt(document.getElementById('cooldown')?.value) || 45;
  
  const avgXp = (min + max) / 2;
  const msgsPerHour = 3600 / cooldown;
  const xpPerHour = Math.round(avgXp * msgsPerHour);
  
  const est = document.getElementById('xpEstimate');
  if (est) {
    document.getElementById('xpEstimateValue').textContent = xpPerHour.toLocaleString();
    est.style.display = 'block';
  }
}

window.saveIgnoreList = function() {
  const channels = (document.getElementById('ignoreChannels').value || '').split(',').map(c => c.trim()).filter(c => c && /^\d+$/.test(c));
  const roles = (document.getElementById('ignoreRoles').value || '').split(',').map(r => r.trim()).filter(r => r && /^\d+$/.test(r));
  
  if (!window.levelingConfig) window.levelingConfig = {};
  window.levelingConfig.ignoreChannels = channels;
  window.levelingConfig.ignoreRoles = roles;
  window.saveLevelingConfig();
  alert('âœ… Ignore list saved! ' + channels.length + ' channels, ' + roles.length + ' roles');
}

window.saveMultipliers = function() {
  const global = parseFloat(document.getElementById('globalMultiplier').value) || 1;
  
  const roleStr = (document.getElementById('roleMultipliers').value || '').trim();
  const roleMultipliers = {};
  roleStr.split(',').forEach(item => {
    const [id, mult] = item.trim().split(':');
    if (id && /^\d+$/.test(id) && !isNaN(mult)) {
      roleMultipliers[id] = parseFloat(mult);
    }
  });
  
  const chanStr = (document.getElementById('channelMultipliers').value || '').trim();
  const channelMultipliers = {};
  chanStr.split(',').forEach(item => {
    const [id, mult] = item.trim().split(':');
    if (id && /^\d+$/.test(id) && !isNaN(mult)) {
      channelMultipliers[id] = parseFloat(mult);
    }
  });
  
  if (!window.levelingConfig) window.levelingConfig = {};
  window.levelingConfig.globalMultiplier = global;
  window.levelingConfig.roleMultipliers = roleMultipliers;
  window.levelingConfig.channelMultipliers = channelMultipliers;
  window.saveLevelingConfig();
  alert('âœ… Multipliers saved!');
}

window.saveTimeBoost = function() {
  const enabled = document.getElementById('enableTimeBoost').checked;
  
  if (!window.levelingConfig) window.levelingConfig = {};
  window.levelingConfig.enableTimeBoost = enabled;
  
  if (enabled) {
    window.levelingConfig.timeBoostMultiplier = parseFloat(document.getElementById('timeBoostMultiplier').value) || 2;
    window.levelingConfig.timeBoostStartDay = parseInt(document.getElementById('timeBoostStartDay').value) || 5;
    window.levelingConfig.timeBoostEndDay = parseInt(document.getElementById('timeBoostEndDay').value) || 0;
    window.levelingConfig.timeBoostStartHour = parseInt(document.getElementById('timeBoostStartHour').value) || 0;
    window.levelingConfig.timeBoostEndHour = parseInt(document.getElementById('timeBoostEndHour').value) || 23;
  }
  
  window.saveLevelingConfig();
  alert('âœ… Time boost settings saved!');
}

window.saveXpDecay = function() {
  const enabled = document.getElementById('enableXpDecay').checked;
  
  if (!window.levelingConfig) window.levelingConfig = {};
  window.levelingConfig.enableXpDecay = enabled;
  
  if (enabled) {
    window.levelingConfig.xpDecayDays = parseInt(document.getElementById('xpDecayDays').value) || 14;
    window.levelingConfig.xpDecayPercent = parseInt(document.getElementById('xpDecayPercent').value) || 5;
  }
  
  window.saveLevelingConfig();
  alert('âœ… XP decay settings saved!');
}

window.saveLevelUpMessage = function() {
  const msg = document.getElementById('customLevelUpMessage').value.trim();
  if (!msg) return alert('Enter a custom message');
  
  if (!window.levelingConfig) window.levelingConfig = {};
  window.levelingConfig.customLevelUpMessage = msg;
  window.saveLevelingConfig();
  alert('âœ… Custom message saved!');
}

window.saveLevelUpOptions = function() {
  const milestonesOnly = document.getElementById('milestonesOnly').checked;
  const dmOnLevelUp = document.getElementById('dmOnLevelUp').checked;
  
  if (!window.levelingConfig) window.levelingConfig = {};
  window.levelingConfig.milestonesOnly = milestonesOnly;
  window.levelingConfig.dmOnLevelUp = dmOnLevelUp;
  window.saveLevelingConfig();
  alert('âœ… Announcement options saved!');
}

window.saveEmbedStyle = function() {
  const color = document.getElementById('levelUpColor').value.trim() || '#9146ff';
  const thumbnail = document.getElementById('levelUpThumbnail').value.trim();
  const footer = document.getElementById('levelUpFooter').value.trim();
  
  if (!window.levelingConfig) window.levelingConfig = {};
  window.levelingConfig.levelUpColor = color;
  window.levelingConfig.levelUpThumbnail = thumbnail;
  window.levelingConfig.levelUpFooter = footer;
  window.saveLevelingConfig();
  alert('âœ… Embed style saved!');
}

window.saveLevelingBtn_setupListener = function() {
  const inputs = ['xpMin', 'xpMax', 'cooldown'];
  inputs.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', () => window.calculateXpEstimate?.());
  });
  window.calculateXpEstimate?.();
  
  const timeBoostCheckbox = document.getElementById('enableTimeBoost');
  if (timeBoostCheckbox) {
    timeBoostCheckbox.addEventListener('change', () => {
      document.getElementById('timeBoostSettings').style.display = timeBoostCheckbox.checked ? 'grid' : 'none';
    });
  }
  
  const xpDecayCheckbox = document.getElementById('enableXpDecay');
  if (xpDecayCheckbox) {
    xpDecayCheckbox.addEventListener('change', () => {
      document.getElementById('xpDecaySettings').style.display = xpDecayCheckbox.checked ? 'grid' : 'none';
    });
  }
}


window.saveLevelUpChannel = function(){
  const channelId = document.getElementById('levelUpChannel').value.trim();
  const pingPlayer = document.getElementById('levelUpPingPlayer').checked;
  fetch('/dashboard/levelupchannel', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({levelUpChannelId: channelId || null, levelUpPingPlayer: pingPlayer})
  }).then(r => r.json()).then(data => {
    if(data.success) {
      alert('Level-up settings updated!');
      if(channelId) {
        document.getElementById('levelUpChannelDisplay').textContent = 'Channel ID: ' + channelId + ' | ' + (pingPlayer ? 'Ping player' : 'Show name only');
        fetch('/channelname?id=' + channelId).then(r => r.json()).then(d => {
          document.getElementById('channelNameBox').textContent = 'Channel: #' + (d.name || 'Unknown');
        }).catch(() => {
          document.getElementById('channelNameBox').textContent = 'Channel ID: ' + channelId;
        });
      } else {
        document.getElementById('levelUpChannelDisplay').textContent = 'Will post in the channel where user levels up';
        document.getElementById('channelNameBox').textContent = 'No channel selected';
      }
    } else {
      alert('Failed: ' + (data.error || 'Unknown error'));
    }
  }).catch(err => {
    console.error(err);
    alert('Error saving level-up settings');
  });
}

window.leaderboardState = {
  view: 'all',
  prestigeOnly: false,
  excludeBots: false,
  page: 1,
  pageSize: 20,
  highlightId: null
};

window.getLeaderboardEntries = function() {
  const view = window.leaderboardState.view;
  const now = Date.now();
  const weekAgo = now - (7 * 24 * 60 * 60 * 1000);

  const baseIds = view === 'week'
    ? Object.keys(window.weeklyLeveling || {}).filter(id => {
        const entry = window.weeklyLeveling && window.weeklyLeveling[id];
        return (entry && entry.lastGain ? entry.lastGain : 0) >= weekAgo;
      })
    : Object.keys(window.levelingData || {});

  const entries = baseIds.map(id => {
    const data = (window.levelingData && window.levelingData[id]) || { xp: 0, level: 0 };
    const weekly = (window.weeklyLeveling && window.weeklyLeveling[id]) || { xp: 0, lastGain: 0 };
    const prestige = (window.prestigeData && window.prestigeData[id]) || 0;
    return {
      id,
      name: (window.usernamesData && window.usernamesData[id]) || id,
      level: data.level || 0,
      xp: data.xp || 0,
      weeklyXp: weekly.xp || 0,
      prestige,
      xpMultiplier: data.xpMultiplier || 1,
      flags: {
        bot: !!(data.bot || data.isBot),
        staff: !!(data.staff || data.isStaff)
      }
    };
  });

  let filtered = entries;
  if (window.leaderboardState.prestigeOnly) {
    filtered = filtered.filter(e => e.prestige > 0);
  }
  if (window.leaderboardState.excludeBots) {
    filtered = filtered.filter(e => !e.flags.bot && !e.flags.staff);
  }

  if (view === 'week') {
    filtered.sort((a, b) => b.weeklyXp - a.weeklyXp);
  } else {
    filtered.sort((a, b) => (b.level - a.level) || (b.xp - a.xp));
  }

  return filtered;
}

window.renderLeaderboard = function() {
  const data = window.getLeaderboardEntries();
  const view = window.leaderboardState.view;
  const pageSize = window.leaderboardState.pageSize;
  const total = data.length;
  const totalPages = Math.max(1, Math.ceil(total / pageSize));
  if (window.leaderboardState.page > totalPages) window.leaderboardState.page = totalPages;

  const page = window.leaderboardState.page;
  const startIndex = (page - 1) * pageSize;
  const pageItems = data.slice(startIndex, startIndex + pageSize);

  const body = document.getElementById('leaderboardBody');
  const xpHeader = document.getElementById('leaderboardXpHeader');
  if (xpHeader) xpHeader.textContent = view === 'week' ? 'XP (Week)' : 'XP';

  if (body) {
    body.innerHTML = pageItems.map((item, idx) => {
      const rank = startIndex + idx + 1;
      const rankLabel = rank === 1 ? '[1st]' : rank === 2 ? '[2nd]' : rank === 3 ? '[3rd]' : '#' + rank;
      const rowClasses = [item.prestige > 0 ? 'prestige-row' : '', window.leaderboardState.highlightId === item.id ? 'leaderboard-highlight' : '']
        .filter(Boolean)
        .join(' ');
      const xpValue = view === 'week' ? item.weeklyXp : item.xp;
      return '<tr class="' + rowClasses + '" data-user-id="' + item.id + '">' +
        '<td style="padding:10px"><b>' + rankLabel + '</b></td>' +
        '<td style="padding:10px">' + item.name + '<br><span style="font-size:11px;color:#888">ID: ' + item.id + '</span></td>' +
        '<td style="padding:10px;text-align:center;color:#9146ff;font-weight:bold">' + item.level + '</td>' +
        '<td style="padding:10px;text-align:center;color:#4caf50">' + xpValue + '</td>' +
        '<td style="padding:10px;text-align:center;color:#ffd700">' + item.prestige + '</td>' +
        '<td style="padding:10px;text-align:center">' + item.xpMultiplier + 'x</td>' +
        '<td style="padding:10px;text-align:center;display:flex;gap:6px;justify-content:center;flex-wrap:wrap">' +
          '<button class="small" style="padding:4px 8px;font-size:11px" data-edit-id="' + item.id + '">Edit</button>' +
          '<button class="small" style="padding:4px 8px;font-size:11px" data-action="add-xp" data-user-id="' + item.id + '">+XP</button>' +
          '<button class="small" style="padding:4px 8px;font-size:11px;background:#c43c3c" data-action="reset" data-user-id="' + item.id + '">Reset</button>' +
          '<button class="small" style="padding:4px 8px;font-size:11px;background:#f7b731" data-action="prestige" data-user-id="' + item.id + '">Prestige</button>' +
        '</td>' +
      '</tr>';
    }).join('');
  }

  const countEl = document.getElementById('leaderboardCount');
  if (countEl) countEl.textContent = total + ' users | Page ' + page + ' of ' + totalPages;

  const rangeEl = document.getElementById('leaderboardRange');
  if (rangeEl) {
    const endIndex = Math.min(startIndex + pageItems.length, total);
    rangeEl.textContent = total === 0 ? 'No results' : (startIndex + 1) + '-' + endIndex + ' of ' + total;
  }

  const pageSelect = document.getElementById('leaderboardPageSelect');
  if (pageSelect) {
    pageSelect.innerHTML = '';
    for (let i = 1; i <= totalPages; i++) {
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = 'Page ' + i;
      if (i === page) opt.selected = true;
      pageSelect.appendChild(opt);
    }
  }

  const highlightId = window.leaderboardState.highlightId;
  if (highlightId) {
    if (body) {
      const row = body.querySelector('tr[data-user-id="' + highlightId + '"]');
      if (row) row.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }
}

window.searchLevelUser = function() {
  const input = document.getElementById('leaderboardSearch');
  const query = ((input && input.value) || '').trim().toLowerCase();
  if (!query) return;

  const data = window.getLeaderboardEntries();
  const idx = data.findIndex(e => e.id.toLowerCase().includes(query) || (e.name || '').toLowerCase().includes(query));
  if (idx === -1) return alert('No matching user found');

  const page = Math.floor(idx / window.leaderboardState.pageSize) + 1;
  window.leaderboardState.page = page;
  window.leaderboardState.highlightId = data[idx].id;
  window.renderLeaderboard();
}

window.clearLeaderboardSearch = function() {
  const input = document.getElementById('leaderboardSearch');
  if (input) input.value = '';
  window.leaderboardState.highlightId = null;
  window.renderLeaderboard();
}

window.openLevelingImportPicker = function() {
  const input = document.getElementById('leaderboardImportFile');
  if (!input) return;
  input.value = '';
  input.click();
}

window.importLevelingCsvFile = function(file) {
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function() {
    const csv = String(reader.result || '');
    fetch('/leveling/import-csv', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ csv })
    })
      .then(r => r.json())
      .then(data => {
        if (!data || !data.success) {
          throw new Error((data && data.error) || 'CSV import failed');
        }
        const skippedInfo = data.skipped > 0 ? ('\\nSkipped: ' + data.skipped) : '';
        alert('âœ… CSV import complete\\nImported: ' + data.imported + skippedInfo);
        location.reload();
      })
      .catch(err => {
        alert('Import failed: ' + err.message);
      });
  };
  reader.onerror = function() {
    alert('Failed to read CSV file');
  };
  reader.readAsText(file);
}

window.openQuickAction = function(action, userId) {
  const modal = document.getElementById('quickActionModal');
  const backdrop = document.getElementById('modalBackdrop');
  const title = document.getElementById('quickActionTitle');
  const userDisplay = document.getElementById('quickActionUserDisplay');
  const typeInput = document.getElementById('quickActionType');
  const idInput = document.getElementById('quickActionUserId');
  const xpRow = document.getElementById('quickActionXpRow');
  const prestigeRow = document.getElementById('quickActionPrestigeRow');
  const confirmText = document.getElementById('quickActionConfirmText');

  const name = (window.nameCache && window.nameCache[userId]) || userId;
  idInput.value = userId;
  typeInput.value = action;
  userDisplay.textContent = 'User: ' + name + ' (' + userId + ')';

  xpRow.style.display = action === 'add-xp' ? 'block' : 'none';
  prestigeRow.style.display = action === 'prestige' ? 'block' : 'none';

  if (action === 'add-xp') {
    title.textContent = 'Add XP';
    confirmText.textContent = 'Adds XP to the user without changing level.';
    document.getElementById('quickActionXp').value = '';
  } else if (action === 'reset') {
    title.textContent = 'Reset Level';
    confirmText.textContent = 'Resets level and XP to 0.';
  } else if (action === 'prestige') {
    title.textContent = 'Grant Prestige';
    const current = (window.prestigeData && window.prestigeData[userId]) || 0;
    document.getElementById('quickActionPrestige').value = current + 1;
    confirmText.textContent = 'Grants a prestige rank and resets level.';
  }

  modal.style.display = 'block';
  backdrop.style.display = 'block';
}

window.closeQuickAction = function() {
  document.getElementById('quickActionModal').style.display = 'none';
  document.getElementById('modalBackdrop').style.display = 'none';
}

window.submitQuickAction = function() {
  const action = document.getElementById('quickActionType').value;
  const userId = document.getElementById('quickActionUserId').value;
  const data = (window.levelingData && window.levelingData[userId]) || { level: 0, xp: 0, xpMultiplier: 1 };

  if (action === 'add-xp') {
    const amount = parseInt(document.getElementById('quickActionXp').value) || 0;
    if (!amount) return alert('Enter XP amount');
    fetch('/leveling/edit', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ id: userId, level: data.level || 0, xp: (data.xp || 0) + amount, xpMultiplier: data.xpMultiplier || 1 })
    }).then(r => r.json()).then(resp => {
      if (resp.success) location.reload();
      else alert('Failed to add XP');
    });
    return;
  }

  if (action === 'reset') {
    fetch('/leveling/reset-level', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ userId })
    }).then(r => r.json()).then(resp => {
      if (resp.success) location.reload();
      else alert('Failed to reset');
    });
    return;
  }

  if (action === 'prestige') {
    const prestigeLevel = parseInt(document.getElementById('quickActionPrestige').value) || 0;
    if (!prestigeLevel) return alert('Enter prestige level');
    fetch('/leveling/prestige', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ userId, prestigeLevel })
    }).then(r => r.json()).then(resp => {
      if (resp.success) location.reload();
      else alert('Failed to grant prestige');
    });
  }
}
window.bindLevelingTabEvents = function() {
  const byId = (id) => document.getElementById(id);

  const onClick = (id, handler) => {
    const el = byId(id);
    if (el) el.addEventListener('click', handler);
  };
  const onChange = (id, handler) => {
    const el = byId(id);
    if (el) el.addEventListener('change', handler);
  };

  onClick('tab-leaderboard', () => window.switchLevelingTab('leaderboard'));
  onClick('tab-prestige', () => window.switchLevelingTab('prestige'));
  onClick('tab-settings', () => window.switchLevelingTab('settings'));
  onClick('tab-rewards', () => window.switchLevelingTab('rewards'));
  onClick('tab-config', () => window.switchLevelingTab('config'));

  onClick('leaderboardSearchBtn', () => window.searchLevelUser());
  onClick('leaderboardClearSearchBtn', () => window.clearLeaderboardSearch());
  onClick('leaderboardImportBtn', () => window.openLevelingImportPicker());
  onChange('leaderboardImportFile', (e) => {
    const file = e && e.target && e.target.files ? e.target.files[0] : null;
    if (file) window.importLevelingCsvFile(file);
  });
  onChange('leaderboardView', (e) => {
    window.leaderboardState.view = e.target.value;
    window.leaderboardState.page = 1;
    window.renderLeaderboard();
  });
  onChange('leaderboardPageSize', (e) => {
    window.leaderboardState.pageSize = parseInt(e.target.value, 10) || 20;
    window.leaderboardState.page = 1;
    window.renderLeaderboard();
  });
  onChange('leaderboardPrestigeOnly', (e) => {
    window.leaderboardState.prestigeOnly = e.target.checked;
    window.leaderboardState.page = 1;
    window.renderLeaderboard();
  });
  onChange('leaderboardExcludeBots', (e) => {
    window.leaderboardState.excludeBots = e.target.checked;
    window.leaderboardState.page = 1;
    window.renderLeaderboard();
  });
  onClick('leaderboardPrevPage', () => {
    if (window.leaderboardState.page > 1) {
      window.leaderboardState.page -= 1;
      window.renderLeaderboard();
    }
  });
  onClick('leaderboardNextPage', () => {
    window.leaderboardState.page += 1;
    window.renderLeaderboard();
  });
  onClick('leaderboardLoadMore', () => {
    window.leaderboardState.page += 1;
    window.renderLeaderboard();
  });
  onChange('leaderboardPageSelect', (e) => {
    window.leaderboardState.page = parseInt(e.target.value, 10) || 1;
    window.renderLeaderboard();
  });
  onClick('leaderboardExportBtn', () => {
    const count = parseInt(document.getElementById('leaderboardExportCount').value) || 100;
    const rows = window.getLeaderboardEntries().slice(0, Math.max(1, count));
    const header = ['user','level','xp','prestige'];
    const csv = [header.join(',')].concat(rows.map(r => [r.name, r.level, (window.leaderboardState.view === 'week' ? r.weeklyXp : r.xp), r.prestige].join(','))).join('\\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'leveling_leaderboard.csv';
    a.click();
    URL.revokeObjectURL(url);
  });
  onClick('prestigeGrantBtn', () => window.grantPrestige());
  onClick('resetLevelBtn', () => window.resetUserLevel());
  onClick('prestigeAddBtn', () => window.addPrestigeThreshold());
  onClick('saveXpSettingsBtn', () => window.saveXpSettings());
  onClick('saveLevelingBtn', () => window.saveLevelingConfig());
  onClick('saveMilestonesBtn', () => window.saveMilestones());
  onClick('saveLevelUpChannelBtn', () => window.saveLevelUpChannel());
  onClick('saveIgnoreListBtn', () => window.saveIgnoreList());
  onClick('saveMultipliersBtn', () => window.saveMultipliers());
  onClick('saveTimeBoostBtn', () => window.saveTimeBoost());
  onClick('saveXpDecayBtn', () => window.saveXpDecay());
  onClick('saveLevelUpMessageBtn', () => window.saveLevelUpMessage());
  onClick('saveLevelUpOptionsBtn', () => window.saveLevelUpOptions());
  onClick('saveEmbedStyleBtn', () => window.saveEmbedStyle());
  onClick('addRoleRewardBtn', () => window.addRoleReward());
  onClick('saveLevelEditBtn', () => window.saveLevelEdit());
  onClick('closeLevelModalBtn', () => window.closeLevelModal());
  onClick('modalBackdrop', () => {
    window.closeLevelModal();
    window.closeQuickAction();
  });
  onClick('quickActionConfirmBtn', () => window.submitQuickAction());
  onClick('quickActionCancelBtn', () => window.closeQuickAction());

  document.querySelectorAll('input[name="xpMode"]').forEach((input) => {
    input.addEventListener('change', (e) => window.toggleXpMode(e.target.value));
  });

  document.addEventListener('click', (e) => {
    const editBtn = e.target.closest('[data-edit-id]');
    if (editBtn) return window.editLevel(editBtn.getAttribute('data-edit-id'));

    const addMoreBtn = e.target.closest('[data-action="add-more-levels"]');
    if (addMoreBtn) return window.addMoreLevels();

    const quickActionBtn = e.target.closest('[data-action]');
    if (quickActionBtn && quickActionBtn.getAttribute('data-action') !== 'add-more-levels') {
      const action = quickActionBtn.getAttribute('data-action');
      const userId = quickActionBtn.getAttribute('data-user-id');
      if (userId && action) return window.openQuickAction(action, userId);
    }

    const prestigeRemove = e.target.closest('[data-prestige-remove]');
    if (prestigeRemove) return window.deletePrestigeThreshold(parseInt(prestigeRemove.getAttribute('data-prestige-remove')));

    const benefitRemove = e.target.closest('[data-benefit-remove]');
    if (benefitRemove) return window.deletePrestigeBenefit(parseInt(benefitRemove.getAttribute('data-benefit-remove')));

    const roleRemove = e.target.closest('[data-role-reward-remove]');
    if (roleRemove) return window.removeRoleReward(parseInt(roleRemove.getAttribute('data-role-reward-remove')));
  });

  onClick('addBenefitBtn', () => window.addPrestigeBenefit());
  onClick('savePrestigeReqBtn', () => window.savePrestigeRequirements());
  
  // Load prestige history on tab switch
  window.loadPrestigeHistory = function() {
    fetch('/api/leveling/prestige-history', { headers: { 'Authorization': 'Bearer ' + (window.dashboardToken || '') } })
      .then(r => r.json())
      .then(data => {
        const list = document.getElementById('prestigeHistoryList');
        if (!data || data.length === 0) {
          list.innerHTML = '<div style="color:#888;text-align:center;padding:20px">No prestige history yet</div>';
          return;
        }
        list.innerHTML = data.map((entry, i) => {
          const date = new Date(entry.timestamp).toLocaleDateString() + ' ' + new Date(entry.timestamp).toLocaleTimeString();
          return '<div style="padding:8px;border-bottom:1px solid #3a3a42;font-size:12px">' +
            '<b>' + (entry.username || 'Unknown') + '</b> prestiged to <b>#' + entry.prestigeLevel + '</b> on ' + date +
          '</div>';
        }).join('');
      });
  };
}

</script>
<pre id="levelingData" style="display:none">${safeJsonForHtml(leveling)}</pre>
<pre id="levelingConfig" style="display:none">${safeJsonForHtml(levelingConfig)}</pre>
<pre id="weeklyLeveling" style="display:none">${safeJsonForHtml(weeklyLeveling)}</pre>
<pre id="prestigeData" style="display:none">${safeJsonForHtml(typeof prestige !== 'undefined' ? prestige : {})}</pre>
<pre id="usernamesData" style="display:none">${safeJsonForHtml(usernames)}</pre>
<script>
window.levelingData = JSON.parse(document.getElementById('levelingData').textContent);
window.levelingConfig = JSON.parse(document.getElementById('levelingConfig').textContent);
window.weeklyLeveling = JSON.parse(document.getElementById('weeklyLeveling').textContent || '{}');
window.prestigeData = JSON.parse(document.getElementById('prestigeData').textContent);
window.usernamesData = JSON.parse(document.getElementById('usernamesData').textContent || '{}');
if (typeof window.renderRoleRewards !== 'function') {
  window.renderRoleRewards = function() {};
}
if (typeof window.renderPrestigeThresholds !== 'function') {
  window.renderPrestigeThresholds = function() {};
}
if (typeof window.toggleXpMode !== 'function') {
  window.toggleXpMode = function() {};
}
if (typeof window.renderCustomXpList !== 'function') {
  window.renderCustomXpList = function() {};
}
if (typeof window.bindLevelingTabEvents !== 'function') {
  window.bindLevelingTabEvents = function() {
    const byId = (id) => document.getElementById(id);
    const onClick = (id, handler) => {
      const el = byId(id);
      if (el) el.addEventListener('click', handler);
    };
    const onChange = (id, handler) => {
      const el = byId(id);
      if (el) el.addEventListener('change', handler);
    };

    onClick('tab-leaderboard', () => window.switchLevelingTab('leaderboard'));
    onClick('tab-prestige', () => window.switchLevelingTab('prestige'));
    onClick('tab-settings', () => window.switchLevelingTab('settings'));
    onClick('tab-rewards', () => window.switchLevelingTab('rewards'));
    onClick('tab-config', () => window.switchLevelingTab('config'));

    onClick('leaderboardSearchBtn', () => window.searchLevelUser());
    onClick('leaderboardClearSearchBtn', () => window.clearLeaderboardSearch());
    onChange('leaderboardView', (e) => {
      window.leaderboardState.view = e.target.value;
      window.leaderboardState.page = 1;
      window.renderLeaderboard();
    });
    onChange('leaderboardPageSize', (e) => {
      window.leaderboardState.pageSize = parseInt(e.target.value, 10) || 20;
      window.leaderboardState.page = 1;
      window.renderLeaderboard();
    });
    onChange('leaderboardPrestigeOnly', (e) => {
      window.leaderboardState.prestigeOnly = e.target.checked;
      window.leaderboardState.page = 1;
      window.renderLeaderboard();
    });
    onChange('leaderboardExcludeBots', (e) => {
      window.leaderboardState.excludeBots = e.target.checked;
      window.leaderboardState.page = 1;
      window.renderLeaderboard();
    });
    onClick('leaderboardPrevPage', () => {
      if (window.leaderboardState.page > 1) {
        window.leaderboardState.page -= 1;
        window.renderLeaderboard();
      }
    });
    onClick('leaderboardNextPage', () => {
      window.leaderboardState.page += 1;
      window.renderLeaderboard();
    });
    onClick('leaderboardLoadMore', () => {
      window.leaderboardState.page += 1;
      window.renderLeaderboard();
    });
    onChange('leaderboardPageSelect', (e) => {
      window.leaderboardState.page = parseInt(e.target.value, 10) || 1;
      window.renderLeaderboard();
    });
    onClick('leaderboardExportBtn', () => {
      const count = parseInt(document.getElementById('leaderboardExportCount').value) || 100;
      const rows = window.getLeaderboardEntries().slice(0, Math.max(1, count));
      const header = ['user','level','xp','prestige'];
      const csv = [header.join(',')].concat(rows.map(r => [r.name, r.level, (window.leaderboardState.view === 'week' ? r.weeklyXp : r.xp), r.prestige].join(','))).join('\\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'leveling_leaderboard.csv';
      a.click();
      URL.revokeObjectURL(url);
    });

    onClick('prestigeGrantBtn', () => window.grantPrestige());
    onClick('resetLevelBtn', () => window.resetUserLevel());
    onClick('prestigeAddBtn', () => window.addPrestigeThreshold());
    onClick('saveXpSettingsBtn', () => window.saveXpSettings());
    onClick('saveLevelingBtn', () => window.saveLevelingConfig());
    onClick('saveMilestonesBtn', () => window.saveMilestones());
    onClick('saveLevelUpChannelBtn', () => window.saveLevelUpChannel());
    onClick('addRoleRewardBtn', () => window.addRoleReward());
    onClick('saveLevelEditBtn', () => window.saveLevelEdit());
    onClick('closeLevelModalBtn', () => window.closeLevelModal());
    onClick('modalBackdrop', () => {
      window.closeLevelModal();
      window.closeQuickAction();
    });
    onClick('quickActionConfirmBtn', () => window.submitQuickAction());
    onClick('quickActionCancelBtn', () => window.closeQuickAction());

    document.querySelectorAll('input[name="xpMode"]').forEach((input) => {
      input.addEventListener('change', (e) => window.toggleXpMode(e.target.value));
    });

    document.addEventListener('click', (e) => {
      const editBtn = e.target.closest('[data-edit-id]');
      if (editBtn) return window.editLevel(editBtn.getAttribute('data-edit-id'));

      const addMoreBtn = e.target.closest('[data-action="add-more-levels"]');
      if (addMoreBtn) return window.addMoreLevels();

      const quickActionBtn = e.target.closest('[data-action]');
      if (quickActionBtn && quickActionBtn.getAttribute('data-action') !== 'add-more-levels') {
        const action = quickActionBtn.getAttribute('data-action');
        const userId = quickActionBtn.getAttribute('data-user-id');
        if (userId && action) return window.openQuickAction(action, userId);
      }

      const prestigeRemove = e.target.closest('[data-prestige-remove]');
      if (prestigeRemove) return window.deletePrestigeThreshold(parseInt(prestigeRemove.getAttribute('data-prestige-remove')));

      const roleRemove = e.target.closest('[data-role-reward-remove]');
      if (roleRemove) return window.removeRoleReward(parseInt(roleRemove.getAttribute('data-role-reward-remove')));
    });
  };
}
window.nameCache = {};
Object.entries(window.levelingData).forEach(([id, _]) => {
  window.nameCache[id] = id;
});
if (typeof window.renderRoleRewards === 'function') {
  window.renderRoleRewards();
}

const channelId = document.getElementById('levelUpChannel').value;
const pingPlayer = document.getElementById('levelUpPingPlayer').checked;
if(channelId) {
  document.getElementById('levelUpChannelDisplay').textContent = 'Channel ID: ' + channelId + ' | ' + (pingPlayer ? 'Ping player' : 'Show name only');
  fetch('/channelname?id=' + channelId).then(r => r.json()).then(d => {
    document.getElementById('channelNameBox').textContent = 'Channel: #' + (d.name || 'Unknown');
  }).catch(() => {
    document.getElementById('channelNameBox').textContent = 'Channel ID: ' + channelId;
  });
} else {
  document.getElementById('levelUpChannelDisplay').textContent = 'Will post in the channel where user levels up';
  document.getElementById('channelNameBox').textContent = 'No channel selected';
}
if (typeof window.renderPrestigeThresholds === 'function') {
  window.renderPrestigeThresholds();
}
if (typeof window.renderPrestigeBenefits === 'function') {
  window.renderPrestigeBenefits();
}
if (typeof window.loadPrestigeHistory === 'function') {
  window.loadPrestigeHistory();
}
const activeXpMode = (window.levelingConfig && window.levelingConfig.xpMode) === 'custom' ? 'custom' : 'increment';
window.toggleXpMode(activeXpMode);
if ((window.levelingConfig && window.levelingConfig.xpMode) === 'custom') {
  document.querySelector('input[name="xpMode"][value="custom"]').checked = true;
  if (typeof window.renderCustomXpList === 'function') {
    window.renderCustomXpList();
  }
}

window.bindLevelingTabEvents();

// Setup additional event listeners and initializations
if (typeof window.saveLevelingBtn_setupListener === 'function') {
  window.saveLevelingBtn_setupListener();
}

// Initialize leaderboard controls and render
const viewSelect = document.getElementById('leaderboardView');
if (viewSelect) viewSelect.value = window.leaderboardState.view;
const pageSizeSelect = document.getElementById('leaderboardPageSize');
if (pageSizeSelect) pageSizeSelect.value = String(window.leaderboardState.pageSize);
const prestigeOnly = document.getElementById('leaderboardPrestigeOnly');
if (prestigeOnly) prestigeOnly.checked = window.leaderboardState.prestigeOnly;
const excludeBots = document.getElementById('leaderboardExcludeBots');
if (excludeBots) excludeBots.checked = window.leaderboardState.excludeBots;
window.renderLeaderboard();

// Default to leaderboard tab highlighted
window.switchLevelingTab('leaderboard');
</script>
`;
}

// NEW: Notifications tab
function renderNotificationsTab() {
  return `
<div class="card">
  <h2>ðŸ”” Notification Filters</h2>
  <p style="color:#b0b0b0">Manage which events trigger notifications in your server</p>
</div>

<div class="card">
  <h2>Filter Events</h2>
  <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:10px;margin:15px 0">
    <label><input type="checkbox" id="notif-live" onchange="toggleNotif('live')"> Stream Goes Live</label>
    <label><input type="checkbox" id="notif-offline" onchange="toggleNotif('offline')"> Stream Goes Offline</label>
    <label><input type="checkbox" id="notif-title" onchange="toggleNotif('title')"> Title Changed</label>
    <label><input type="checkbox" id="notif-game" onchange="toggleNotif('game')"> Game Changed</label>
    <label><input type="checkbox" id="notif-raid" onchange="toggleNotif('raid')"> Raid Received</label>
    <label><input type="checkbox" id="notif-clip" onchange="toggleNotif('clip')"> Clip Created</label>
    <label><input type="checkbox" id="notif-follow" onchange="toggleNotif('follow')"> Follower Milestone</label>
    <label><input type="checkbox" id="notif-viewer" onchange="toggleNotif('viewer')"> Viewer Milestone</label>
  </div>
  <button onclick="saveNotifications()" style="margin-top:15px">Save Preferences</button>
</div>

<div class="card">
  <h2>ï¸ Auto-Delete Settings</h2>
  <p style="color:#b0b0b0">Automatically delete notification messages after a set time (does not apply to live/delay/cancelled announcements)</p>
  
  <div style="margin:15px 0">
    <label style="display:block;margin-bottom:8px;font-weight:500">Delete Delay (seconds):</label>
    <input type="number" id="autoDeleteDelay" value="${(engagementSettings.autoDeleteDelay || 60000) / 1000}" min="5" max="3600" style="width:200px">
    <small style="color:#888;display:block;margin-top:4px">Time to wait before deleting notifications (5-3600 seconds)</small>
  </div>
  
  <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(250px,1fr));gap:15px;margin:20px 0;padding:15px;background:#2a2a2e;border-radius:8px">
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="autoDeleteTitleChange" ${engagementSettings.autoDeleteTitleChange ? 'checked' : ''} style="width:18px;height:18px">
      <span>ðŸ“ Title Change</span>
    </label>
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="autoDeleteGameChange" ${engagementSettings.autoDeleteGameChange ? 'checked' : ''} style="width:18px;height:18px">
      <span>ðŸŽ® Game Change</span>
    </label>
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="autoDeleteVod" ${engagementSettings.autoDeleteVod ? 'checked' : ''} style="width:18px;height:18px">
      <span>ðŸ“¹ VOD Available</span>
    </label>
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="autoDeleteRaid" ${engagementSettings.autoDeleteRaid ? 'checked' : ''} style="width:18px;height:18px">
      <span>âš”ï¸ Raid Notification</span>
    </label>
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="autoDeleteClip" ${engagementSettings.autoDeleteClip ? 'checked' : ''} style="width:18px;height:18px">
      <span>ðŸŽ¬ Clip Created</span>
    </label>
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="autoDeleteFollowerMilestone" ${engagementSettings.autoDeleteFollowerMilestone ? 'checked' : ''} style="width:18px;height:18px">
      <span>ðŸ‘¥ Follower Milestone</span>
    </label>
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
      <input type="checkbox" id="autoDeleteViewerMilestone" ${engagementSettings.autoDeleteViewerMilestone ? 'checked' : ''} style="width:18px;height:18px">
      <span>ðŸ‘€ Viewer Milestone</span>
    </label>
  </div>
  
  <button onclick="saveAutoDeleteSettings()" style="margin-top:10px">ðŸ’¾ Save Auto-Delete Settings</button>
</div>

<div class="card">
  <h2>ðŸ“œ Notification History</h2>
  ${notificationHistory.length === 0 ? '<p style="color:#999">No notifications yet</p>' : `
<table style="width:100%;font-size:12px">
  <tr style="background:#2a2f3a">
    <th style="padding:8px;text-align:left">Type</th>
    <th style="padding:8px;text-align:left">Message</th>
    <th style="padding:8px;text-align:left">Time</th>
  </tr>
  ${notificationHistory.slice(-20).reverse().map(n => '<tr style="border-bottom:1px solid #3a3a42">' +
    '<td style="padding:8px"><b>' + n.type + '</b></td>' +
    '<td style="padding:8px">' + n.message + '</td>' +
    '<td style="padding:8px;color:#999;font-size:11px">' + new Date(n.timestamp).toLocaleString() + '</td>' +
  '</tr>').join('')}
</table>`}
</div>

<script>
const notifs = ${JSON.stringify(notificationFilters)};
document.querySelectorAll('[id^="notif-"]').forEach(el => {
  const event = el.id.replace('notif-', '');
  el.checked = notifs.includes(event);
});

function toggleNotif(event) {
  const idx = notifs.indexOf(event);
  if (document.getElementById('notif-' + event).checked) {
    if (idx === -1) notifs.push(event);
  } else {
    if (idx !== -1) notifs.splice(idx, 1);
  }
}

function saveNotifications() {
  fetch('/notifications/save', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({filters: notifs})
  }).then(() => alert('Notification preferences saved!'));
}

function saveAutoDeleteSettings() {
  const settings = {
    autoDeleteTitleChange: document.getElementById('autoDeleteTitleChange').checked,
    autoDeleteGameChange: document.getElementById('autoDeleteGameChange').checked,
    autoDeleteVod: document.getElementById('autoDeleteVod').checked,
    autoDeleteRaid: document.getElementById('autoDeleteRaid').checked,
    autoDeleteClip: document.getElementById('autoDeleteClip').checked,
    autoDeleteFollowerMilestone: document.getElementById('autoDeleteFollowerMilestone').checked,
    autoDeleteViewerMilestone: document.getElementById('autoDeleteViewerMilestone').checked,
    autoDeleteDelay: parseInt(document.getElementById('autoDeleteDelay').value) * 1000
  };
  
  fetch('/api/engagement-settings', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(settings)
  })
  .then(r => r.json())
  .then(data => {
    if (data.success) {
      alert('âœ… Auto-delete settings saved!');
    } else {
      alert('âŒ Failed to save: ' + (data.error || 'Unknown error'));
    }
  })
  .catch(err => alert('âŒ Error: ' + err.message));
}
</script>
`;
}

// NEW: Custom Commands/Tags tab
function renderCustomCommandsTab() {
  return `
<div class="card">
  <h2>ðŸ·ï¸ Custom Commands / Tags</h2>
  <p style="color:#b0b0b0">Create custom commands that respond with preset messages</p>
  
  <input type="hidden" id="editingIndex" value="-1">
  <div style="margin:15px 0;display:grid;grid-template-columns:1fr 2fr;gap:15px">
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Command Name(s):</label>
      <input id="cmdName" placeholder="!hello, !hi" style="width:100%">
      <small style="color:#888;display:block;margin-top:4px">Separate multiple commands with commas.</small>
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Response(s):</label>
      <textarea id="cmdResponse" placeholder="Command response text\n\nFor multiple links/responses, put each on a new line" style="width:100%;min-height:80px;resize:vertical"></textarea>
      <small style="color:#888;display:block;margin-top:4px">ðŸ’¡ Tip: Put each link/response on a separate line for multiple responses</small>
    </div>
  </div>
  <div style="margin:15px 0;display:grid;grid-template-columns:1fr 1fr;gap:15px">
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Auto-delete command after uses (optional):</label>
      <input id="cmdAutoDeleteUses" type="number" min="1" placeholder="e.g. 10" style="width:100%">
      <small style="color:#888;display:block;margin-top:4px">Deletes the command after it has been used X times.</small>
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Auto-delete response after seconds (optional):</label>
      <input id="cmdAutoDeleteDelay" type="number" min="1" placeholder="e.g. 30" style="width:100%">
      <small style="color:#888;display:block;margin-top:4px">Deletes the bot reply after X seconds.</small>
    </div>
  </div>
  <div style="margin:15px 0;display:grid;grid-template-columns:1fr 1fr;gap:15px">
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Cooldown (seconds, optional):</label>
      <input id="cmdCooldown" type="number" min="0" placeholder="e.g. 10" style="width:100%">
      <small style="color:#888;display:block;margin-top:4px">Per-user cooldown before they can use it again.</small>
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Embed Response:</label>
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
        <input id="cmdEmbed" type="checkbox" checked>
        <span>Send as embed</span>
      </label>
      <small style="color:#888;display:block;margin-top:4px">All command responses use embeds.</small>
    </div>
  </div>
  <div style="margin:15px 0;display:grid;grid-template-columns:1fr 1fr;gap:15px">
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Allowed Roles (IDs, optional):</label>
      <input id="cmdAllowedRoles" placeholder="Role IDs (space or comma separated)" style="width:100%">
      <small style="color:#888;display:block;margin-top:4px">Only these roles can use the command.</small>
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Allowed Channels (IDs, optional):</label>
      <input id="cmdAllowedChannels" placeholder="Channel IDs (space or comma separated)" style="width:100%">
      <small style="color:#888;display:block;margin-top:4px">Only these channels can use the command.</small>
    </div>
  </div>
  <div style="margin:15px 0;display:grid;grid-template-columns:1fr 1fr;gap:15px">
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Category (optional):</label>
      <input id="cmdCategory" placeholder="e.g. Utility" style="width:100%">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Tags (optional):</label>
      <input id="cmdTags" placeholder="comma separated tags" style="width:100%">
    </div>
  </div>
  <div style="margin:15px 0">
    <label style="display:block;margin-bottom:5px;font-weight:500">Image URL (optional):</label>
    <div id="imageDropZone" style="border:2px dashed #9146ff;border-radius:8px;padding:30px;text-align:center;cursor:pointer;background:#2a2a2e;transition:all 0.3s">
      <div style="margin-bottom:10px;font-size:40px">ðŸ“</div>
      <div style="color:#e0e0e0;margin-bottom:5px">Drag & drop an image here or click to browse</div>
      <small style="color:#888">Supports: JPG, PNG, GIF, WEBP</small>
      <input type="file" id="imageFileInput" accept="image/*" style="display:none">
      <input id="cmdImageUrl" placeholder="https://i.imgur.com/example.png" style="width:100%;margin-top:15px">
    </div>
    <div id="imagePreview" style="margin-top:10px;display:none">
      <img id="previewImg" style="max-width:200px;max-height:200px;border-radius:8px;border:2px solid #9146ff">
    </div>
    <small style="color:#888;display:block;margin-top:4px">Optional: Add an image to display with the command response</small>
  </div>
  <button id="addCommandBtn" onclick="addCustomCommand()">Add Command</button>
  <button id="cancelEditBtn" onclick="cancelEdit()" style="display:none;margin-left:10px;background:#6c757d">Cancel</button>
</div>

<div class="card">
  <h2>ðŸ“‹ Your Commands</h2>
  <div style="display:grid;grid-template-columns:2fr 1fr 1fr 1fr;gap:10px;margin:10px 0">
    <input id="cmdSearch" placeholder="Search by name, tag, category" style="width:100%">
    <select id="cmdFilterStatus" style="width:100%">
      <option value="">All status</option>
      <option value="active">Active</option>
      <option value="paused">Paused</option>
    </select>
    <input id="cmdFilterTag" placeholder="Filter tag" style="width:100%">
    <select id="cmdSort" style="width:100%">
      <option value="name">Sort: Name</option>
      <option value="uses">Sort: Uses</option>
    </select>
  </div>
  ${customCommands.length === 0 ? '<p>No custom commands yet</p>' : `<table style="width:100%;font-size:12px">
    <tr style="background:#2a2f3a">
      <th style="padding:8px">Command</th>
      <th style="padding:8px">Response</th>
      <th style="padding:8px">Uses</th>
      <th style="padding:8px">Status/info</th>
      <th style="padding:8px">Action</th>
    </tr>
    ${customCommands.map((c,i) => {
      // Parse response to show first 2 links/lines
      let displayText = '';
      const lines = c.response.split('\n').filter(l => l.trim());
      
      if (lines.length === 1) {
        // Single response - truncate if too long
        displayText = c.response.substring(0, 40) + (c.response.length > 40 ? '...' : '');
      } else if (lines.length === 2) {
        // Exactly 2 - show both with ellipsis if truncated
        displayText = lines.map(l => l.substring(0, 30) + (l.length > 30 ? '...' : '')).join('<br>');
      } else {
        // More than 2 - show first 2 + counter
        const first = lines[0].substring(0, 30) + (lines[0].length > 30 ? '...' : '');
        const second = lines[1].substring(0, 30) + (lines[1].length > 30 ? '...' : '');
        const remaining = lines.length - 2;
        displayText = first + '<br>' + second + '<br><span style="color:#9146ff;font-weight:bold">+' + remaining + ' more</span>';
      }
      
      const imageBadge = c.imageUrl ? '<div style="margin-top:4px;font-size:11px;color:#57f287">ðŸ–¼ï¸ Picture enabled</div>' : '';
      const autoDeleteUses = c.autoDeleteAfterUses ? '<div style="margin-top:4px;font-size:11px;color:#ffca28">ðŸ§¹ Deletes after ' + c.autoDeleteAfterUses + ' uses</div>' : '';
      const autoDeleteDelay = c.autoDeleteDelayMs ? '<div style="margin-top:4px;font-size:11px;color:#ffca28">â±ï¸ Deletes reply after ' + Math.round(c.autoDeleteDelayMs / 1000) + 's</div>' : '';
      const cooldownInfo = c.cooldownMs ? '<div style="margin-top:4px;font-size:11px;color:#ffca28">â³ Cooldown: ' + Math.round(c.cooldownMs / 1000) + 's</div>' : '';
      const categoryBadge = c.category ? '<div style="margin-top:4px;font-size:11px;color:#9146ff">ðŸ·ï¸ ' + c.category + '</div>' : '';
      const tagsBadge = Array.isArray(c.tags) && c.tags.length ? '<div style="margin-top:4px;font-size:11px;color:#6f86ff">Tags: ' + c.tags.join(', ') + '</div>' : '';
      return `<tr style="border-bottom:1px solid #3a3a42" data-cmd-name="${c.name}" data-cmd-status="${c.paused ? 'paused' : 'active'}" data-cmd-tags="${(c.tags || []).join(',').toLowerCase()}" data-cmd-category="${(c.category || '').toLowerCase()}" data-cmd-uses="${c.uses || 0}">
      <td style="padding:8px"><b>${c.name}</b></td>
      <td style="padding:8px;font-size:12px">${displayText}</td>
      <td style="padding:8px">${c.uses || 0}</td>
      <td style="padding:8px">${c.paused ? 'Paused' : 'Active'}${imageBadge}${autoDeleteUses}${autoDeleteDelay}${cooldownInfo}${categoryBadge}${tagsBadge}</td>
      <td style="padding:8px;display:flex;gap:6px;align-items:center">
        <button class="small" onclick="showFullResponse(${i})" title="View command info & usage stats">â„¹ï¸</button>
        <button class="small" onclick="previewCommand(${i})" title="Preview embed">ðŸ‘ï¸</button>
        <button class="small" onclick="copyCommandResponse(${i})" title="Copy response">ðŸ“‹</button>
        <button class="small" onclick="editCommand(${i})" title="Edit command">âœï¸</button>
        <button class="small" onclick="toggleCommand(${i})">${c.paused ? 'Unpause' : 'Pause'}</button>
        <button class="small danger" onclick="deleteCommand(${i})" data-cmd-index="${i}">Delete</button>
      </td>
    </tr>`;
    }).join('')}
  </table>`}
</div>
`;
}

// NEW: Giveaways tab
function renderGiveawaysTab() {
  return `
<div class="card">
  <h2>ðŸŽ Giveaways</h2>
  <p style="color:#b0b0b0">Create and manage channel giveaways</p>

  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:15px;margin:15px 0">
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Prize:</label>
      <input id="givePrize" placeholder="e.g., $50 Gift Card" style="width:100%">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Duration (minutes):</label>
      <input id="giveDuration" type="number" value="60" style="width:100%">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Winners:</label>
      <input id="giveWinners" type="number" min="1" value="1" style="width:100%">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Embed Image URL (optional):</label>
      <input id="giveImageUrl" placeholder="https://..." style="width:100%">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Embed Color (hex, optional):</label>
      <input id="giveEmbedColor" placeholder="${config.giveawayDefaultColor || '#FFD700'}" style="width:100%">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Tag:</label>
      <select id="giveTag" style="width:100%">
        <option value="">None</option>
        <option value="game">Game</option>
        <option value="cash">Cash</option>
        <option value="nitro">Nitro</option>
        <option value="event">Event</option>
        <option value="other">Other</option>
      </select>
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Post Channel ID (optional):</label>
      <input id="giveChannel" placeholder="Defaults to DISCORD_CHANNEL_ID" style="width:100%" onblur="resolveGiveChannel()">
      <small id="giveChannelName" style="color:#888;display:block;margin-top:4px"></small>
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Ping Role ID (optional):</label>
      <input id="givePingRole" placeholder="Role ID to ping" style="width:100%" onblur="resolveGivePingRole()">
      <small id="givePingRoleName" style="color:#888;display:block;margin-top:4px"></small>
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Minimum Account Age (days):</label>
      <input id="giveMinAccountAge" type="number" min="0" placeholder="e.g., 7" style="width:100%">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Minimum Level:</label>
      <input id="giveMinLevel" type="number" min="0" placeholder="e.g., 5" style="width:100%">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Minimum XP:</label>
      <input id="giveMinXp" type="number" min="0" placeholder="e.g., 1000" style="width:100%">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Created By (optional):</label>
      <input id="giveCreatedBy" placeholder="Mod name" style="width:100%">
    </div>
  </div>

  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:15px;margin:10px 0 15px">
    <div style="padding:12px;background:#26262c;border-radius:6px">
      <h4 style="margin:0 0 8px 0">Bulk Exclusions</h4>
      <label style="display:flex;align-items:center;gap:8px;margin:6px 0;cursor:pointer">
        <input type="checkbox" id="giveExcludePrevWinners" />
        <span>Exclude previous winners</span>
      </label>
      <label style="display:flex;align-items:center;gap:8px;margin:6px 0;cursor:pointer">
        <input type="checkbox" id="giveExcludeBots" checked />
        <span>Exclude bots</span>
      </label>
      <label style="display:block;margin:10px 0 5px 0;font-weight:500">Exclude staff roles (IDs):</label>
      <input id="giveExcludeStaffRoles" placeholder="Role IDs (space or comma separated)" style="width:100%">
      <small style="color:#888;display:block;margin-top:6px">Members with these roles wonâ€™t be eligible.</small>
    </div>
  </div>

  <div style="padding:12px;background:#26262c;border-radius:6px;margin:0 0 15px 0">
    <h4 style="margin:0 0 8px 0">Giveaway Claim Contact</h4>
    <input id="giveawayClaimContact" placeholder="e.g., Contact @Mod or @Admin to claim your prize" value="${config.giveawayClaimContact || ''}" style="width:100%">
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px;margin-top:10px">
      <div>
        <label style="display:block;margin-bottom:5px;font-weight:500">Default Embed Color (hex):</label>
        <input id="giveawayDefaultColor" placeholder="#FFD700" value="${config.giveawayDefaultColor || ''}" style="width:100%">
      </div>
      <div>
        <label style="display:block;margin-bottom:5px;font-weight:500">Giveaway Log Channel ID:</label>
        <input id="giveawayLogChannelId" placeholder="Channel ID" value="${config.giveawayLogChannelId || ''}" style="width:100%">
      </div>
    </div>
    <small style="color:#888;display:block;margin-top:6px">Shown in the giveaway end message.</small>
    <div style="display:flex;justify-content:flex-end;margin-top:10px">
      <button class="small" style="width:auto" onclick="saveGiveawaySettings()">Save Giveaway Settings</button>
    </div>
  </div>

  <div style="padding:12px;background:#26262c;border-radius:6px;margin:0 0 15px 0">
    <h4 style="margin:0 0 8px 0">Templates</h4>
    <div style="display:flex;gap:8px;flex-wrap:wrap">
      <input id="giveTemplateName" placeholder="Template name" style="flex:1;min-width:160px">
      <button class="small" style="width:auto" onclick="saveGiveawayTemplate()">Save Template</button>
      <select id="giveTemplateSelect" style="flex:1;min-width:160px">
        <option value="">Select template</option>
      </select>
      <button class="small" style="width:auto" onclick="loadGiveawayTemplate()">Load</button>
      <button class="small danger" style="width:auto" onclick="deleteGiveawayTemplate()">Delete</button>
    </div>
  </div>

  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:15px;margin:10px 0 15px">
    <div style="padding:12px;background:#26262c;border-radius:6px">
      <h4 style="margin:0 0 8px 0">Eligible Roles</h4>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px">
        <input id="giveRoleInput" placeholder="Role ID" style="flex:1;min-width:160px">
        <button class="small" id="giveRoleAddBtn" style="width:auto" data-giveaway-action="add-role">Add Role</button>
      </div>
      <div id="giveRoleList" style="font-size:12px;color:#b0b0b0">No roles added</div>
      <small style="color:#888;display:block;margin-top:6px">Only members with these roles can win.</small>
    </div>

    <div style="padding:12px;background:#26262c;border-radius:6px">
      <h4 style="margin:0 0 8px 0">Excluded Users</h4>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px">
        <input id="giveExcludeInput" placeholder="User ID" style="flex:1;min-width:160px">
        <button class="small" id="giveExcludeAddBtn" style="width:auto" data-giveaway-action="add-exclude">Exclude</button>
      </div>
      <div id="giveExcludeList" style="font-size:12px;color:#b0b0b0">No exclusions</div>
      <small style="color:#888;display:block;margin-top:6px">Excluded users wonâ€™t be picked.</small>
    </div>
  </div>

  <div id="giveMemberPreviewContainer" style="display:none;padding:12px;background:#26262c;border-radius:6px;margin:15px 0">
    <h4 style="margin:0 0 8px 0">ðŸ‘¥ Eligible Members Preview</h4>
    <input id="giveMemberSearch" placeholder="Search by username..." style="width:100%;margin-bottom:8px">
    <div id="giveMemberPreviewList" style="font-size:12px;color:#b0b0b0;max-height:280px;overflow-y:auto">No members found</div>
    <small style="color:#888;display:block;margin-top:6px">Showing up to 5 members</small>
  </div>

  <button onclick="startGiveaway()">Start Giveaway</button>
</div>

  <div class="card">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
      <h2>ðŸ“Š Active & Past Giveaways</h2>
      <button class="small" style="width:auto" onclick="exportGiveawayWinners()">Export Winners CSV</button>
    </div>
  ${giveaways.length === 0 ? '<p>No giveaways yet</p>' : `<table style="width:100%;font-size:12px">
    <tr style="background:#2a2f3a">
      <th style="padding:8px">Prize</th>
      <th style="padding:8px">Tag</th>
      <th style="padding:8px">Entries</th>
      <th style="padding:8px">Status</th>
      <th style="padding:8px">Winners</th>
        <th style="padding:8px">Created By</th>
      <th style="padding:8px">Actions</th>
    </tr>
    ${giveaways.map((g,i) => {
      const isActive = !!g.active && g.endTime > Date.now();
      const isArchived = !!g.archived;
      const isPaused = !!g.paused;
      const status = isArchived ? 'ðŸ“¦ ARCHIVED' : (isPaused ? 'â¸ï¸ PAUSED' : (isActive ? 'ðŸŸ¢ ACTIVE' : 'ðŸ”´ ENDED'));
      const excludedCount = Array.isArray(g.excludedUserIds) ? g.excludedUserIds.length : 0;
      const tagLabel = g.tag ? String(g.tag) : '';
      const entriesCount = Number.isFinite(g.entryCount)
        ? g.entryCount
        : (Array.isArray(g.entries) ? g.entries.length : (Array.isArray(g.participants) ? g.participants.length : 0));
      
      let winnerDisplay = 'TBD';
      if (Array.isArray(g.winners) && g.winners.length > 0) {
        const shown = g.winners.slice(0, 2);
        const more = g.winners.length - shown.length;
        const shownHtml = shown.map(id => `<span data-user-info="${id}">Loading...</span>`).join(', ');
        const moreHtml = more > 0 ? ` <button type="button" class="small" data-giveaway-winners="${g.id}" style="width:auto;background:#2a2f3a;border:1px solid #3a3a42;padding:2px 6px;font-size:10px">+${more}</button>` : '';
        winnerDisplay = `<div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap">${shownHtml}${moreHtml}</div>`;
      } else if (g.winner) {
        winnerDisplay = `<span data-user-info="${g.winner}">Loading...</span>`;
      } else if (g.winners) {
        winnerDisplay = String(g.winners);
      }
      
      return `<tr style="border-bottom:1px solid #3a3a42">
        <td style="padding:8px"><b>${g.prize}</b></td>
        <td style="padding:8px">${tagLabel ? `<span style="background:#2a2f3a;border:1px solid #3a3a42;border-radius:12px;padding:2px 8px;font-size:10px">${tagLabel}</span>` : '-'}</td>
        <td style="padding:8px">
          <button type="button" data-giveaway-entries="${g.id}" style="background:#2a2f3a;border:1px solid #3a3a42;color:#e0e0e0;border-radius:6px;padding:4px 8px;font-size:11px;cursor:pointer">${entriesCount}</button>
        </td>
        <td style="padding:8px">
          ${isActive && !isPaused ? `<span data-giveaway-countdown="${g.endTime}">Ends in ${Math.max(0, g.endTime - Date.now())}ms</span>` : status}
        </td>
        <td style="padding:8px">${winnerDisplay}</td>
        <td style="padding:8px">${g.createdBy || 'Dashboard'}</td>
        <td style="padding:8px;min-width:150px;width:150px">
          <div style="display:flex;gap:4px;align-items:center;flex-wrap:nowrap;white-space:nowrap">
            <button onclick="showGiveawayInfo('${g.id}')" style="background:#3a3f4b;color:#e0e0e0;border:none;padding:3px 6px;border-radius:3px;cursor:pointer;font-size:10px;line-height:1;min-width:22px;display:inline-flex;align-items:center;justify-content:center">â„¹ï¸</button>
            ${isActive ? `<button onclick="endGiveawayNow('${g.id}')" style="background:#ffaa00;color:black;border:none;padding:3px 6px;border-radius:3px;cursor:pointer;font-size:10px;line-height:1;display:inline-flex;align-items:center;justify-content:center">End</button>` : ''}
            ${isActive && !isPaused ? `<button onclick="pauseGiveaway('${g.id}')" style="background:#3a3f4b;color:#e0e0e0;border:none;padding:3px 6px;border-radius:3px;cursor:pointer;font-size:10px;line-height:1;display:inline-flex;align-items:center;justify-content:center">Pause</button>` : ''}
            ${isActive && isPaused ? `<button onclick="resumeGiveaway('${g.id}')" style="background:#57F287;color:black;border:none;padding:3px 6px;border-radius:3px;cursor:pointer;font-size:10px;line-height:1;display:inline-flex;align-items:center;justify-content:center">Resume</button>` : ''}
            ${!isActive ? `<button onclick="rerollGiveaway('${g.id}')" style="background:#5865F2;color:white;border:none;padding:3px 6px;border-radius:3px;cursor:pointer;font-size:10px;line-height:1;display:inline-flex;align-items:center;justify-content:center">Reroll</button>` : ''}
            ${!isActive && Array.isArray(g.winners) && g.winners.length ? `<button onclick="pingGiveawayWinners('${g.id}')" style="background:#57F287;color:black;border:none;padding:3px 6px;border-radius:3px;cursor:pointer;font-size:10px;line-height:1;display:inline-flex;align-items:center;justify-content:center">Ping</button>` : ''}
            <button onclick="duplicateGiveawayPreset('${g.id}')" style="background:#2a2f3a;color:#e0e0e0;border:1px solid #3a3a42;padding:3px 6px;border-radius:3px;cursor:pointer;font-size:10px;line-height:1;display:inline-flex;align-items:center;justify-content:center">Duplicate</button>
            <button onclick="showRemoveExclusionModal('${g.id}')" style="background:#f04747;color:white;border:none;padding:3px 6px;border-radius:3px;cursor:pointer;font-size:10px;line-height:1;display:inline-flex;align-items:center;justify-content:center" title="Remove ${excludedCount}">âœ• ${excludedCount}</button>
            <button onclick="archiveGiveaway('${g.id}')" style="background:#3a3f4b;color:#e0e0e0;border:none;padding:3px 6px;border-radius:3px;cursor:pointer;font-size:10px;line-height:1;display:inline-flex;align-items:center;justify-content:center">Archive</button>
            <button onclick="deleteGiveaway('${g.id}')" style="background:#ff4444;color:white;border:none;padding:3px 6px;border-radius:3px;cursor:pointer;font-size:10px;line-height:1;display:inline-flex;align-items:center;justify-content:center">Delete</button>
          </div>
        </td>
      </tr>`;
    }).join('')}
  </table>`}
</div>
`;
}

function renderGiveawayRoleList(){
  const el = document.getElementById('giveRoleList');
  if (!el) return;
  if (giveawayRoleIds.length === 0) {
    el.textContent = 'No roles added';
    return;
  }
  el.innerHTML = giveawayRoleIds.map(id => (
    '<div style="display:flex;gap:8px;align-items:center;margin:4px 0">' +
      '<span data-role-info="' + id + '" style="color:#e0e0e0">Loadingâ€¦</span>' +
      '<span style="color:#666">(' + id + ')</span>' +
      '<button class="small danger" style="padding:4px 6px;font-size:10px" data-giveaway-remove-role="' + id + '">Remove</button>' +
    '</div>'
  )).join('');
  el.querySelectorAll('[data-role-info]').forEach(infoEl => {
    const roleId = infoEl.getAttribute('data-role-info');
    fetch('/role/info/' + roleId)
      .then(r => r.json())
      .then(data => {
        infoEl.textContent = (data && data.name) ? data.name : 'Unknown role';
        if (data && data.hexColor) infoEl.style.color = data.hexColor;
      })
      .catch(() => infoEl.textContent = 'Unknown role');
  });
}

function renderGiveawayExcludeList(){
  const el = document.getElementById('giveExcludeList');
  if (!el) return;
  if (giveawayExcludeIds.length === 0) {
    el.textContent = 'No exclusions';
    return;
  }
  el.innerHTML = giveawayExcludeIds.map(id => (
    '<div style="display:flex;gap:8px;align-items:center;margin:4px 0">' +
      '<span data-user-info="' + id + '" style="color:#e0e0e0">Loadingâ€¦</span>' +
      '<span style="color:#666">(' + id + ')</span>' +
      '<button class="small danger" style="padding:4px 6px;font-size:10px" data-giveaway-remove-exclude="' + id + '">Remove</button>' +
    '</div>'
  )).join('');
  el.querySelectorAll('[data-user-info]').forEach(infoEl => {
    const userId = infoEl.getAttribute('data-user-info');
    fetch('/discord/user/' + userId)
      .then(r => r.json())
      .then(data => {
        infoEl.textContent = (data && (data.displayName || data.username)) ? (data.displayName || data.username) : 'Unknown user';
      })
      .catch(() => infoEl.textContent = 'Unknown user');
  });
}

function addGiveawayRole(){
  const input = document.getElementById('giveRoleInput');
  const id = input && input.value ? input.value.trim() : '';
  if (!id) return;
  if (!giveawayRoleIds.includes(id)) giveawayRoleIds.push(id);
  input.value = '';
  renderGiveawayRoleList();
}

function removeGiveawayRole(id){
  giveawayRoleIds = giveawayRoleIds.filter(r => r !== id);
  renderGiveawayRoleList();
}

function addGiveawayExclude(){
  const input = document.getElementById('giveExcludeInput');
  const id = input && input.value ? input.value.trim() : '';
  if (!id) return;
  if (!giveawayExcludeIds.includes(id)) giveawayExcludeIds.push(id);
  input.value = '';
  renderGiveawayExcludeList();
}

function removeGiveawayExclude(id){
  giveawayExcludeIds = giveawayExcludeIds.filter(u => u !== id);
  renderGiveawayExcludeList();
}

function resolveGiveChannel() {
  const input = document.getElementById('giveChannel');
  const display = document.getElementById('giveChannelName');
  const channelId = input && input.value ? input.value.trim() : '';
  
  if (!channelId) {
    display.textContent = '';
    return;
  }
  
  display.textContent = 'Loading...';
  fetch('/channel/info/' + channelId)
    .then(r => r.json())
    .then(data => {
      if (data && data.name) {
        display.textContent = 'âœ“ #' + data.name;
        display.style.color = '#57F287';
      } else {
        display.textContent = 'âœ— Channel not found';
        display.style.color = '#ED4245';
      }
    })
    .catch(() => {
      display.textContent = 'âœ— Error fetching channel';
      display.style.color = '#ED4245';
    });
}

function resolveGivePingRole() {
  const input = document.getElementById('givePingRole');
  const display = document.getElementById('givePingRoleName');
  const roleId = input && input.value ? input.value.trim() : '';
  
  if (!roleId) {
    display.textContent = '';
    return;
  }
  
  display.textContent = 'Loading...';
  fetch('/role/info/' + roleId)
    .then(r => r.json())
    .then(data => {
      if (data && data.name) {
        display.textContent = 'âœ“ @' + data.name;
        display.style.color = data.hexColor || '#57F287';
      } else {
        display.textContent = 'âœ— Role not found';
        display.style.color = '#ED4245';
      }
    })
    .catch(() => {
      display.textContent = 'âœ— Error fetching role';
      display.style.color = '#ED4245';
    });
}

let previewTimeout;

async function loadEligibleMembers() {
  clearTimeout(previewTimeout);
  const container = document.getElementById('giveMemberPreviewContainer');
  const list = document.getElementById('giveMemberPreviewList');

  if (!giveawayRoleIds || giveawayRoleIds.length === 0) {
    container.style.display = 'none';
    return;
  }
  
  container.style.display = 'block';
  list.textContent = 'Loading members...';
  
  // Debounce: wait 300ms before fetching to avoid Discord rate limits
  previewTimeout = setTimeout(async () => {
    try {
      const payload = {
        roleIds: giveawayRoleIds,
        excludeIds: giveawayExcludeIds,
        excludePreviousWinners: !!document.getElementById('giveExcludePrevWinners')?.checked,
        excludeBots: !!document.getElementById('giveExcludeBots')?.checked,
        excludeStaffRoleIds: splitIdTokens(document.getElementById('giveExcludeStaffRoles')?.value || ''),
        minAccountAgeDays: parseInt(document.getElementById('giveMinAccountAge')?.value || '0', 10) || 0,
        minLevel: parseInt(document.getElementById('giveMinLevel')?.value || '0', 10) || 0,
        minXp: parseInt(document.getElementById('giveMinXp')?.value || '0', 10) || 0
      };
      const res = await fetch('/giveaway/preview-members', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      
      const data = await res.json();
      
      if (!res.ok) {
        list.textContent = data && data.error ? data.error : 'Error loading members';
        return;
      }

    if (!data.members || data.members.length === 0) {
      list.textContent = 'No eligible members found';
      return;
    }
    
      // Store all members and render with search
      window.allEligibleMembers = data.members;
      renderMemberPreview(data.members);
    } catch (err) {
      list.textContent = 'Error loading members';
    }
  }, 300);
}

function renderMemberPreview(members) {
  const list = document.getElementById('giveMemberPreviewList');
  const search = (document.getElementById('giveMemberSearch').value || '').toLowerCase();
  
  let filtered = members;
  if (search) {
    filtered = members.filter(m => 
      (m.username && m.username.toLowerCase().includes(search)) ||
      (m.displayName && m.displayName.toLowerCase().includes(search))
    );
  }
  
  if (filtered.length === 0) {
    list.textContent = search ? 'No members match search' : 'No members found';
    return;
  }
  
  const shown = filtered.slice(0, 5);
  list.innerHTML = shown.map(m => (
    '<div style="display:flex;gap:8px;align-items:center;margin:6px 0;padding:6px;background:#1f1f23;border-radius:4px">' +
      '<span style="color:#e0e0e0">' + (m.displayName || m.username || 'Unknown') + '</span>' +
      '<span style="color:#666;font-size:11px">(' + m.id + ')</span>' +
    '</div>'
  )).join('');
  
  if (filtered.length > 5) {
    list.innerHTML += '<small style="color:#666;display:block;margin-top:6px">...and ' + (filtered.length - 5) + ' more</small>';
  }
}

const giveawayEntriesCache = new Map();

function formatCountdown(ms) {
  if (ms <= 0) return 'Ended';
  const totalSec = Math.floor(ms / 1000);
  const days = Math.floor(totalSec / 86400);
  const hours = Math.floor((totalSec % 86400) / 3600);
  const mins = Math.floor((totalSec % 3600) / 60);
  const secs = totalSec % 60;
  const parts = [];
  if (days) parts.push(days + 'd');
  if (hours || days) parts.push(hours + 'h');
  parts.push(mins + 'm');
  parts.push(secs + 's');
  return 'Ends in ' + parts.join(' ');
}

function initGiveawayCountdowns() {
  const items = document.querySelectorAll('[data-giveaway-countdown]');
  if (!items.length) return;
  const tick = () => {
    items.forEach(el => {
      const endTime = Number(el.getAttribute('data-giveaway-countdown'));
      if (!endTime) return;
      el.textContent = formatCountdown(endTime - Date.now());
    });
  };
  tick();
  setInterval(tick, 1000);
}

function showWinnersModal(winners) {
  const list = winners.map(id => `<div style="margin:6px 0"><span data-user-info="${id}">Loading...</span> <span style="color:#666">(${id})</span></div>`).join('');
  const html = '<div style="background:#23232b;padding:16px;border-radius:8px">'
    + '<h3 style="margin:0 0 8px 0">Winners</h3>'
    + '<div style="max-height:240px;overflow:auto">' + list + '</div>'
    + '<div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">'
    + '<button type="button" onclick="copyWinnersToClipboard()" style="background:#9146ff;border:1px solid #9146ff;color:white;padding:6px 10px;border-radius:4px;cursor:pointer">Copy</button>'
    + '<button type="button" onclick="closeModal()" style="background:#3a3f4b;color:#e0e0e0;border:none;padding:6px 10px;border-radius:4px;cursor:pointer">Close</button>'
    + '</div></div>';
  window.__giveawayWinnersToCopy = winners;
  showGiveawayModal(html);

  document.querySelectorAll('[data-user-info]').forEach(infoEl => {
    const userId = infoEl.getAttribute('data-user-info');
    fetch('/discord/user/' + userId)
      .then(r => r.json())
      .then(data => {
        infoEl.textContent = (data && (data.displayName || data.username)) ? (data.displayName || data.username) : 'Unknown user';
      })
      .catch(() => infoEl.textContent = 'Unknown user');
  });
}

function copyWinnersToClipboard() {
  const winners = window.__giveawayWinnersToCopy || [];
  if (!winners.length) return;
  const text = winners.map(id => `<@${id}>`).join(', ');
  navigator.clipboard.writeText(text).then(() => alert('Copied winners!'));
}

function fetchGiveawayEntries(giveawayId) {
  const cached = giveawayEntriesCache.get(giveawayId);
  if (cached && (Date.now() - cached.ts) < 30000) {
    return Promise.resolve(cached.data);
  }
  return fetch('/giveaway/entries/' + giveawayId)
    .then(r => r.json())
    .then(data => {
      giveawayEntriesCache.set(giveawayId, { ts: Date.now(), data });
      return data;
    });
}

function showEntriesModal(entries) {
  const list = entries.map(u => `<div style="margin:6px 0"><span>${u.name || 'Unknown'}</span> <span style="color:#666">(${u.id})</span></div>`).join('');
  const html = '<div style="background:#23232b;padding:16px;border-radius:8px">'
    + '<h3 style="margin:0 0 8px 0">Entries</h3>'
    + '<div style="max-height:240px;overflow:auto">' + (list || '<div style="color:#777">No entries</div>') + '</div>'
    + '<div style="display:flex;gap:8px;justify-content:flex-end;margin-top:12px">'
    + '<button type="button" onclick="copyEntriesToClipboard()" style="background:#9146ff;border:1px solid #9146ff;color:white;padding:6px 10px;border-radius:4px;cursor:pointer">Copy</button>'
    + '<button type="button" onclick="closeModal()" style="background:#3a3f4b;color:#e0e0e0;border:none;padding:6px 10px;border-radius:4px;cursor:pointer">Close</button>'
    + '</div></div>';
  window.__giveawayEntriesToCopy = entries;
  showGiveawayModal(html);
}

function copyEntriesToClipboard() {
  const entries = window.__giveawayEntriesToCopy || [];
  const text = entries.map(u => `<@${u.id}>`).join(', ');
  navigator.clipboard.writeText(text).then(() => alert('Copied entries!'));
}

function pingGiveawayWinners(id) {
  fetch('/giveaway/ping-winners', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id })
  }).then(r => r.json()).then(data => {
    if (data && data.success) alert('Winners pinged!');
    else alert('Error: ' + (data.error || 'Unknown error'));
  });
}

function duplicateGiveawayPreset(id) {
  fetch('/giveaway/info/' + id)
    .then(r => r.json())
    .then(data => {
      if (!data) return;
      document.getElementById('givePrize').value = data.prize || '';
      document.getElementById('giveDuration').value = Math.round((data.duration || 0) / 60000) || 60;
      document.getElementById('giveChannel').value = data.channelId || '';
      document.getElementById('givePingRole').value = data.pingRoleId || '';
      document.getElementById('giveTag').value = data.tag || '';
      document.getElementById('giveExcludePrevWinners').checked = !!data.excludePreviousWinners;
      document.getElementById('giveExcludeBots').checked = data.excludeBots !== false;
      document.getElementById('giveExcludeStaffRoles').value = Array.isArray(data.excludeStaffRoleIds) ? data.excludeStaffRoleIds.join(' ') : '';
      giveawayRoleIds = Array.isArray(data.allowedRoleIds) ? data.allowedRoleIds.slice() : [];
      giveawayExcludeIds = Array.isArray(data.excludedUserIds) ? data.excludedUserIds.slice() : [];
      renderGiveawayRoleList();
      renderGiveawayExcludeList();
      resolveGiveChannel();
      resolveGivePingRole();
      window.scrollTo({ top: 0, behavior: 'smooth' });
    });
}

function archiveGiveaway(id) {
  if (!confirm('Archive this giveaway?')) return;
  fetch('/giveaway/archive', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id })
  }).then(r => r.json()).then(data => {
    if (data && data.success) location.reload();
    else alert('Error: ' + (data.error || 'Unknown error'));
  });
}

function deleteGiveaway(id) {
  if (!confirm('Delete this giveaway permanently?')) return;
  fetch('/giveaway/delete', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id })
  }).then(r => r.json()).then(data => {
    if (data && data.success) location.reload();
    else alert('Error: ' + (data.error || 'Unknown error'));
  });
}

// Client-side event listeners - only run in browser
if (typeof window !== 'undefined') {
  window.addEventListener('load', () => {
    renderGiveawayRoleList();
    renderGiveawayExcludeList();
    initGiveawayCountdowns();
    
    // Resolve winner names in giveaway table
    document.querySelectorAll('[data-user-info]').forEach(infoEl => {
      const userId = infoEl.getAttribute('data-user-info');
      fetch('/discord/user/' + userId)
        .then(r => r.json())
        .then(data => {
          infoEl.textContent = (data && (data.displayName || data.username)) ? (data.displayName || data.username) : 'Unknown user';
        })
        .catch(() => infoEl.textContent = 'Unknown user');
    });
  });

  document.addEventListener('click', (e) => {
    const winnersBtn = e.target.closest('[data-giveaway-winners]');
    if (winnersBtn) {
      e.preventDefault();
      const giveawayId = winnersBtn.getAttribute('data-giveaway-winners');
      fetch('/giveaway/info/' + giveawayId)
        .then(r => r.json())
        .then(data => {
          const winners = Array.isArray(data?.winners) ? data.winners : [];
          showWinnersModal(winners);
        });
      return;
    }

    const entriesBtn = e.target.closest('[data-giveaway-entries]');
    if (entriesBtn) {
      e.preventDefault();
      const giveawayId = entriesBtn.getAttribute('data-giveaway-entries');
      entriesBtn.textContent = '...';
      fetchGiveawayEntries(giveawayId).then(data => {
        if (data && Array.isArray(data.entries)) {
          entriesBtn.textContent = data.entries.length;
          showEntriesModal(data.entries);
        } else {
          entriesBtn.textContent = '0';
        }
      }).catch(() => entriesBtn.textContent = '0');
      return;
    }

    const addRoleBtn = e.target.closest('[data-giveaway-action="add-role"]');
    if (addRoleBtn) {
      e.preventDefault();
      addGiveawayRole();
      loadEligibleMembers();
      return;
    }
    const addExcludeBtn = e.target.closest('[data-giveaway-action="add-exclude"]');
    if (addExcludeBtn) {
      e.preventDefault();
      addGiveawayExclude();
      loadEligibleMembers();
      return;
    }
    const removeRoleBtn = e.target.closest('[data-giveaway-remove-role]');
  if (removeRoleBtn) {
    e.preventDefault();
    removeGiveawayRole(removeRoleBtn.getAttribute('data-giveaway-remove-role'));
    loadEligibleMembers();
    return;
  }
  const removeExcludeBtn = e.target.closest('[data-giveaway-remove-exclude]');
  if (removeExcludeBtn) {
    e.preventDefault();
    removeGiveawayExclude(removeExcludeBtn.getAttribute('data-giveaway-remove-exclude'));
    loadEligibleMembers();
    return;
  }
  });

  let entriesHoverTimer = null;
  document.addEventListener('mouseover', (e) => {
    const entriesBtn = e.target.closest('[data-giveaway-entries]');
    if (!entriesBtn) return;
    const giveawayId = entriesBtn.getAttribute('data-giveaway-entries');
    fetchGiveawayEntries(giveawayId)
      .then(data => {
        if (data && Array.isArray(data.entries)) {
          entriesBtn.textContent = data.entries.length;
        }
      })
      .catch(() => {});

    clearTimeout(entriesHoverTimer);
    entriesHoverTimer = setTimeout(() => {
      fetchGiveawayEntries(giveawayId).then(data => {
        if (data && Array.isArray(data.entries)) {
          showEntriesModal(data.entries);
        }
      });
    }, 400);
  }, true);

  document.addEventListener('mouseout', (e) => {
    const entriesBtn = e.target.closest('[data-giveaway-entries]');
    if (!entriesBtn) return;
    clearTimeout(entriesHoverTimer);
  }, true);

  document.getElementById('giveMemberSearch')?.addEventListener('input', () => {
    if (window.allEligibleMembers) {
      renderMemberPreview(window.allEligibleMembers);
    }
  });
}

function startGiveaway() {
  const prize = document.getElementById('givePrize').value.trim();
  const duration = parseInt(document.getElementById('giveDuration').value);
  const winnersCount = parseInt(document.getElementById('giveWinners')?.value || '1', 10) || 1;
  const channelId = document.getElementById('giveChannel').value.trim();
  const pingRoleId = document.getElementById('givePingRole').value.trim();
  const imageUrl = (document.getElementById('giveImageUrl')?.value || '').trim();
  const embedColor = (document.getElementById('giveEmbedColor')?.value || '').trim();
  const tag = (document.getElementById('giveTag')?.value || '').trim();
  const minAccountAgeDays = parseInt(document.getElementById('giveMinAccountAge')?.value || '0', 10) || 0;
  const minLevel = parseInt(document.getElementById('giveMinLevel')?.value || '0', 10) || 0;
  const minXp = parseInt(document.getElementById('giveMinXp')?.value || '0', 10) || 0;
  const createdBy = (document.getElementById('giveCreatedBy')?.value || '').trim();
  const excludePrevWinners = !!document.getElementById('giveExcludePrevWinners')?.checked;
  const excludeBots = !!document.getElementById('giveExcludeBots')?.checked;
  const excludeStaffRolesRaw = (document.getElementById('giveExcludeStaffRoles')?.value || '').trim();
  const excludeStaffRoleIds = excludeStaffRolesRaw ? splitIdTokens(excludeStaffRolesRaw) : [];
  if (!prize || !duration) { alert('Fill all fields'); return; }
  
  fetch('/giveaway/start', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
      prize,
      durationMinutes: duration,
      channelId: channelId || null,
      pingRoleId: pingRoleId || null,
      allowedRoleIds: giveawayRoleIds,
      excludedUserIds: giveawayExcludeIds,
      imageUrl: imageUrl || null,
      embedColor: embedColor || null,
      tag: tag || null,
      winnersCount: winnersCount,
      minAccountAgeDays: minAccountAgeDays,
      minLevel: minLevel,
      minXp: minXp,
      createdBy: createdBy || null,
      excludePreviousWinners: excludePrevWinners,
      excludeBots: excludeBots,
      excludeStaffRoleIds: excludeStaffRoleIds
    })
  }).then(r=>r.json()).then(data => {
    if(data.success) { alert('Giveaway started!'); location.reload(); }
  });
}

function endGiveawayNow(id) {
  if (!confirm('End this giveaway now?')) return;
  fetch('/giveaway/end', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({id})
  }).then(r=>r.json()).then(data => {
    if(data.success) { alert('Giveaway ended!'); location.reload(); }
    else { alert('Error: ' + (data.error || 'Unknown error')); }
  });
}

function rerollGiveaway(id) {
  if (!confirm('Reroll winners for this giveaway?')) return;
  fetch('/giveaway/reroll', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({id})
  }).then(r=>r.json()).then(data => {
    if(data.success) { alert('Giveaway rerolled!'); location.reload(); }
    else { alert('Error: ' + (data.error || 'Unknown error')); }
  });
}

function removeGiveawayExclusionPrompt(giveawayId) {
  fetch('/giveaway/info/' + giveawayId)
    .then(r => r.json())
    .then(data => {
      if (!data || !data.excludedUsers || data.excludedUsers.length === 0) {
        alert('No exclusions found for this giveaway');
        return;
      }
      
      let message = 'Excluded users:\\n\\n';
      data.excludedUsers.forEach((user, index) => {
        message += (index + 1) + '. ' + user.name + ' (ID: ' + user.id + ')\\n';
      });
      message += '\\nEnter the User ID to remove:';
      
      const userId = prompt(message);
      if (!userId) return;
      
      fetch('/giveaway/exclusions/remove', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ id: giveawayId, userId: userId.trim() })
      }).then(r=>r.json()).then(data => {
        if (data && data.success) {
          location.reload();
        } else {
          alert('Error: ' + (data.error || 'Unknown error'));
        }
      }).catch(() => alert('Error removing exclusion'));
    })
    .catch(() => alert('Error loading giveaway info'));
}

function showRemoveExclusionModal(giveawayId) {
  fetch('/giveaway/info/' + giveawayId)
    .then(r => r.json())
    .then(data => {
      if (!data || !data.excludedUsers || data.excludedUsers.length === 0) {
        alert('No exclusions found');
        return;
      }
      
      let html = '<div style="background:#2f3136;padding:20px;border-radius:8px;max-width:400px">';
      html += '<h3 style="margin-top:0;color:#e0e0e0">Remove Exclusion</h3>';
      html += '<div style="margin:15px 0">';
      
      data.excludedUsers.forEach((user, index) => {
        html += '<button onclick="removeExclusionAction(\'' + giveawayId + '\', \'' + user.id + '\')" style="display:block;width:100%;margin:5px 0;background:#f04747;color:white;border:none;padding:8px;border-radius:4px;cursor:pointer;text-align:left">';
        html += '<span>' + (index + 1) + '. ' + user.name + ' (' + user.id + ')</span>';
        html += '</button>';
      });
      
      html += '</div><button onclick="closeModal()" style="width:100%;background:#3a3f4b;color:#e0e0e0;border:none;padding:8px;border-radius:4px;cursor:pointer;margin-top:10px">Cancel</button>';
      html += '</div>';
      
      showGiveawayModal(html);
    })
    .catch(() => alert('Error loading exclusions'));
}

function removeExclusionAction(giveawayId, userId) {
  fetch('/giveaway/exclusions/remove', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ id: giveawayId, userId: userId })
  }).then(r => r.json()).then(data => {
    if (data && data.success) {
      closeModal();
      location.reload();
    } else {
      alert('Error: ' + (data.error || 'Unknown error'));
    }
  }).catch(() => alert('Error removing exclusion'));
}

function showGiveawayModal(html) {
  let modal = document.getElementById('customModal');
  if (!modal) {
    modal = document.createElement('div');
    modal.id = 'customModal';
    document.body.appendChild(modal);
  }
  modal.innerHTML = html;
  modal.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:10000';
  modal.querySelector('div').style.cssText += ';margin:auto';
}

function closeModal() {
  const modal = document.getElementById('customModal');
  if (modal) modal.remove();
}

function showGiveawayInfo(giveawayId) {
  fetch('/giveaway/info/' + giveawayId)
    .then(r => r.json())
    .then(data => {
      if (!data) { alert('Giveaway not found'); return; }
      let info = 'Prize: ' + data.prize + '\\n';
      info += 'Duration: ' + Math.round(data.duration / 60000) + ' minutes\\n';
      if (data.channelId) info += 'Channel: ' + data.channelId + '\\n';
      if (data.pingRoleId) info += 'Ping Role: ' + data.pingRoleId + '\\n';
      if (data.allowedRoleIds && data.allowedRoleIds.length > 0) {
        info += 'Eligible Roles: ' + data.allowedRoleIds.join(', ') + '\\n';
      }
      if (data.excludedUserIds && data.excludedUserIds.length > 0) {
        info += 'Excluded Users: ' + data.excludedUserIds.join(', ') + '\\n';
      }
      info += 'Active: ' + (data.active ? 'Yes' : 'No') + '\\n';
      info += 'Created: ' + new Date(data.endTime - (data.duration || 0)).toLocaleString();
      alert(info);
    })
    .catch(() => alert('Error loading giveaway info'));
}

// Giveaway variables and functions
var giveawayRoleIds = [];
var giveawayExcludeIds = [];

function renderPollsTab() {
  return `
<div class="card">
  <h2>ðŸ“Š Polls</h2>
  <p style="color:#b0b0b0">Create quick polls for your community</p>
  
  <div style="margin:15px 0">
    <label style="display:block;margin-bottom:5px;font-weight:500">Question:</label>
    <input id="pollQuestion" placeholder="What should I play next?" style="width:100%">
  </div>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;margin:15px 0">
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Duration (minutes, optional):</label>
      <input id="pollDuration" type="number" placeholder="e.g., 30" style="width:100%">
    </div>
  </div>
  
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:15px;margin:15px 0">
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Option 1:</label>
      <input id="pollOpt1" placeholder="Option A" style="width:100%;margin-bottom:4px">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Option 2:</label>
      <input id="pollOpt2" placeholder="Option B" style="width:100%;margin-bottom:4px">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Option 3 (optional):</label>
      <input id="pollOpt3" placeholder="Option C" style="width:100%;margin-bottom:4px">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Option 4 (optional):</label>
      <input id="pollOpt4" placeholder="Option D" style="width:100%;margin-bottom:4px">
    </div>
  </div>
  
  <button onclick="createPoll()">Create Poll</button>
</div>

<div class="card">
  <h2>ðŸ“ˆ Poll Results</h2>
  ${polls.length === 0 ? '<p>No polls yet</p>' : `<div style="display:grid;gap:15px">
    ${polls.slice().reverse().map(p => {
      const isActive = p.active;
      const results = p.results || [];
      const total = results.length ? results.reduce((a, b) => a + (b.votes || 0), 0) : ((p.votes || []).reduce((a, b) => a + b, 0));
      const pollIndex = polls.indexOf(p);
      return `
      <div style="background:#2a2f3a;padding:12px;border-radius:4px">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
          <div style="font-weight:bold">${p.question}</div>
          <div style="display:flex;gap:8px">
            ${isActive ? `<button onclick="endPollNow('${p.id}')" style="background:#ffaa00;color:black;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:11px">End Now</button>` : ''}
            <button onclick="deletePoll('${p.id || ''}','${p.messageId || ''}',${pollIndex})" style="background:#ff4444;color:white;border:none;padding:4px 8px;border-radius:3px;cursor:pointer;font-size:11px">Delete</button>
          </div>
        </div>
        ${(results.length ? results : p.options.map((opt, idx) => ({ option: opt, votes: (p.votes?.[idx] || 0) }))).map(r => {
          const pct = total ? Math.round(((r.votes || 0) / total) * 100) : 0;
          return `<div style="margin:5px 0;display:flex;align-items:center;gap:10px">
            <div style="flex:1">${r.option}</div>
            <div style="width:100px;background:#1a1a1d;border-radius:3px;height:20px;position:relative;overflow:hidden">
              <div style="width:${pct}%;height:100%;background:#9146ff"></div>
            </div>
            <div style="width:50px;text-align:right">${pct}%</div>
          </div>`;
        }).join('')}
        <div style="color:#999;font-size:11px;margin-top:8px">
          ${isActive ? (p.endTime ? `Active â€¢ Ends: ${new Date(p.endTime).toLocaleString()}` : 'Active â€¢ No time limit') : `Ended â€¢ Total votes: ${total}`}
          &nbsp;|&nbsp; ID: ${p.id || 'N/A'}
        </div>
      </div>`;
    }).join('')}
  </div>`}
</div>

<script>
function createPoll() {
  const q = document.getElementById('pollQuestion').value.trim();
  const duration = parseInt(document.getElementById('pollDuration').value);
  const opts = [
    document.getElementById('pollOpt1').value.trim(),
    document.getElementById('pollOpt2').value.trim(),
    document.getElementById('pollOpt3').value.trim(),
    document.getElementById('pollOpt4').value.trim()
  ].filter(o => o);
  
  if (!q || opts.length < 2) { alert('Need question + at least 2 options'); return; }
  
  fetch('/poll/create', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({question: q, options: opts, durationMinutes: isNaN(duration) ? 0 : duration})
  }).then(r=>r.json()).then(data => {
    if(data.success) { alert('Poll created!'); location.reload(); }
  });

}

function endPollNow(pollId) {
  if (!confirm('End this poll now?')) return;
  fetch('/poll/end', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({pollId})
  }).then(r=>r.json()).then(data => {
    if(data.success) { alert('Poll ended!'); location.reload(); }
    else { alert('Error: ' + (data.error || 'Unknown error')); }
  });
}

function deletePoll(pollId, messageId, pollIndex) {
  if (!confirm('Delete this poll? This will also remove it from Discord.')) return;
  
  fetch('/poll/delete', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({pollId, messageId, pollIndex})
  }).then(r=>r.json()).then(data => {
    if(data.success) { alert('Poll deleted!'); location.reload(); }
    else { alert('Error: ' + (data.error || 'Unknown error')); }
  });
}
</script>
`;
}

// NEW: Reminders tab
function renderRemindersTab() {
  return `
<div class="card">
  <h2>â° Reminders</h2>
  <p style="color:#b0b0b0">Set reminders for important events</p>
  
  <div style="margin:15px 0">
    <label>Reminder Message:</label>
    <input id="remText" placeholder="e.g., Check stream analytics" style="width:100%;margin-bottom:10px">
    
    <label>Remind me in:</label>
    <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px">
      <button class="small" onclick="setReminderTime(5)">5 minutes</button>
      <button class="small" onclick="setReminderTime(15)">15 minutes</button>
      <button class="small" onclick="setReminderTime(30)">30 minutes</button>
      <button class="small" onclick="setReminderTime(60)">1 hour</button>
      <button class="small" onclick="setReminderTime(120)">2 hours</button>
      <button class="small" onclick="setReminderTime(1440)">1 day</button>
    </div>
    
    <div style="margin-top:20px;display:flex;gap:10px;align-items:center">
      <label style="font-weight:500;white-space:nowrap">Or custom minutes:</label>
      <input id="remMinutes" type="number" min="1" max="525600" placeholder="30" style="width:150px">
    </div>
  </div>
  
  <button onclick="addReminder()">Add Reminder</button>
</div>

<div class="card">
  <h2>ðŸ“ Active Reminders</h2>
  ${reminders.length === 0 ? '<p>No reminders set</p>' : `<table style="width:100%;font-size:12px">
    <tr style="background:#2a2f3a">
      <th style="padding:8px">Message</th>
      <th style="padding:8px">Fires At</th>
      <th style="padding:8px">Status</th>
      <th style="padding:8px">Action</th>
    </tr>
    ${reminders.map((r,i) => {
      const status = r.active ? 'â³ Pending' : 'âœ… Sent';
      const timeStr = r.reminderTime ? new Date(r.reminderTime).toLocaleString() : 'N/A';
      const msg = r.message || r.text || 'No message';
      const timeLeft = r.active && r.reminderTime ? Math.max(0, Math.floor((r.reminderTime - Date.now()) / 60000)) + ' min' : '';
      return `<tr style="border-bottom:1px solid #3a3a42">
        <td style="padding:8px">${msg}</td>
        <td style="padding:8px">${timeStr}${timeLeft ? ' (' + timeLeft + ')' : ''}</td>
        <td style="padding:8px">${status}</td>
        <td style="padding:8px"><button class="small danger" onclick="deleteReminder(${i})">Delete</button></td>
      </tr>`;
    }).join('')}
  </table>`}
</div>

<script>
let selectedMinutes = null;

function setReminderTime(minutes) {
  selectedMinutes = minutes;
  document.getElementById('remMinutes').value = minutes;
  document.querySelectorAll('.card button.small').forEach(b => {
    if(b.textContent.includes('minute') || b.textContent.includes('hour') || b.textContent.includes('day')) {
      b.style.background = '';
    }
  });
  event.target.style.background = '#a955ff';
}

function addReminder() {
  const text = document.getElementById('remText').value.trim();
  const minutes = parseInt(document.getElementById('remMinutes').value) || selectedMinutes;
  
  if (!text) { alert('Please enter a reminder message'); return; }
  if (!minutes || minutes < 1) { alert('Please select or enter a time'); return; }
  
  fetch('/reminder/add', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({text, time: minutes})
  }).then(r=>r.json()).then(data => {
    if(data.success) { 
      alert('Reminder set for ' + minutes + ' minutes from now!'); 
      location.reload(); 
    } else {
      alert(data.error || 'Failed to add reminder');
    }
  }).catch(err => {
    alert('Error: ' + err.message);
  });
}

function deleteReminder(id) {
  if(confirm('Delete this reminder?')) {
    fetch('/reminder/delete', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({id})
    }).then(r=>r.json()).then(data => {
      if(data.success) location.reload();
    });
  }
}
</script>
`;
}

// NEW: Embeds tab
function renderEmbedsTab() {
  return `
<div class="card">
  <h2>ðŸ§± Embed Builder</h2>
  <p style="color:#b0b0b0">Compose and preview a rich embed, then post it to Discord.</p>

  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:15px;margin:15px 0">
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Title</label>
      <input id="embTitle" placeholder="Title">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Color (hex)</label>
      <input id="embColor" placeholder="#5865F2">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Channel ID (optional)</label>
      <input id="embChannel" placeholder="Defaults to DISCORD_CHANNEL_ID">
    </div>
  </div>

  <div style="margin:15px 0">
    <label style="display:block;margin-bottom:5px;font-weight:500">Description</label>
    <textarea id="embDesc" placeholder="Main description"></textarea>
  </div>

  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:15px;margin:15px 0">
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Footer</label>
      <input id="embFooter" placeholder="Footer text">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Thumbnail URL</label>
      <input id="embThumb" placeholder="https://...">
    </div>
    <div>
      <label style="display:block;margin-bottom:5px;font-weight:500">Image URL</label>
      <input id="embImage" placeholder="https://...">
    </div>
    <div style="display:flex;align-items:flex-end">
      <label style="display:flex;align-items:center;gap:6px;background:#1f1f23;border:1px solid #3a3a42;border-radius:6px;padding:6px 10px"><input id="embTimestamp" type="checkbox" style="margin:0;width:auto"> Add timestamp</label>
    </div>
  </div>

  <div class="card" style="background:#2a2f3a">
    <h3 style="margin-top:0">Fields</h3>
    <div id="fieldsList"></div>
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px">
      <input id="fieldName" placeholder="Field name" style="background:#1f1f23;border:1px solid #3a3a42">
      <input id="fieldValue" placeholder="Field value" style="background:#1f1f23;border:1px solid #3a3a42">
      <label style="display:flex;align-items:center;gap:6px;background:#1f1f23;border:1px solid #3a3a42;border-radius:6px;padding:6px 10px"><input id="fieldInline" type="checkbox" style="margin:0;width:auto"> Inline</label>
      <button class="small" onclick="addField()">Add Field</button>
    </div>
  </div>

  <div class="card" style="background:#2a2f3a">
    <h3 style="margin-top:0">Preview</h3>
    <div id="embedPreview" style="background:#1f1f23;border:1px solid #3a3a42;border-radius:6px;padding:12px">Fill fields to see preview.</div>
  </div>

  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:10px">
    <button onclick="updatePreview()">Update Preview</button>
    <button onclick="sendEmbed()">Post Embed</button>
    <button class="danger" onclick="resetEmbed()">Reset Embed</button>
  </div>
</div>

<script>
var embFields = [];

function resetEmbed(){
  embFields = [];
  const ids = ['embTitle','embColor','embChannel','embDesc','embFooter','embThumb','embImage','fieldName','fieldValue'];
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.value = '';
  });
  const inline = document.getElementById('fieldInline');
  if (inline) inline.checked = false;
  const ts = document.getElementById('embTimestamp');
  if (ts) ts.checked = false;
  const preview = document.getElementById('embedPreview');
  if (preview) preview.innerHTML = 'Fill fields to see preview.';
  renderFields();
}

function escHtml(s){
  return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function renderFields(){
  var el = document.getElementById('fieldsList');
  if(!el) return;
  if(embFields.length === 0){
    el.innerHTML = '<p style="color:#b0b0b0">No fields yet</p>';
    return;
  }
  var html = '';
  for(var i=0;i<embFields.length;i++){
    var f = embFields[i];
    html += '<div style="display:flex;justify-content:space-between;align-items:center;background:#1f1f23;border:1px solid #3a3a42;border-radius:4px;padding:8px;margin:6px 0">'
      + '<div>'
      + '<div style="font-weight:bold">' + escHtml(f.name) + '</div>'
      + '<div style="color:#b0b0b0;font-size:12px">' + escHtml(f.value) + '</div>'
      + '</div>'
      + '<div style="display:flex;gap:8px;align-items:center">'
      + '<span style="font-size:11px;color:#999">' + (f.inline ? 'inline' : 'block') + '</span>'
      + '<button class="small danger" onclick="removeField(' + i + ')">Remove</button>'
      + '</div>'
      + '</div>';
  }
  el.innerHTML = html;
}

function addField(){
  var name = document.getElementById('fieldName').value.trim();
  var value = document.getElementById('fieldValue').value.trim();
  var inline = !!document.getElementById('fieldInline').checked;
  if(!name || !value){ alert('Enter field name and value'); return; }
  embFields.push({ name: name, value: value, inline: inline });
  document.getElementById('fieldName').value='';
  document.getElementById('fieldValue').value='';
  document.getElementById('fieldInline').checked=false;
  renderFields();
  updatePreview();
}

function removeField(i){ embFields.splice(i,1); renderFields(); updatePreview(); }

function updatePreview(){
  var title = document.getElementById('embTitle').value.trim();
  var desc = document.getElementById('embDesc').value.trim();
  var footer = document.getElementById('embFooter').value.trim();
  var image = document.getElementById('embImage').value.trim();
  var ts = !!document.getElementById('embTimestamp').checked;
  var out = '';
  if(title) out += '<div style="font-weight:bold;color:#fff;font-size:16px">' + escHtml(title) + '</div>';
  if(desc) out += '<div style="margin:8px 0">' + escHtml(desc).replace(/\\n/g,'<br>') + '</div>';
  if(embFields.length){
    for(var i=0;i<embFields.length;i++){
      var f = embFields[i];
      out += '<div style="margin:6px 0"><div style="font-weight:bold">' + escHtml(f.name) + '</div><div>' + escHtml(f.value) + '</div></div>';
    }
  }
  if(image) out += '<div style="margin-top:8px"><img src="' + escHtml(image) + '" style="max-width:100%" /></div>';
  if(footer || ts) out += '<div style="margin-top:8px;color:#999;font-size:12px">' + escHtml(footer || '') + (ts ? ' â€¢ timestamp' : '') + '</div>';
  document.getElementById('embedPreview').innerHTML = out || 'Fill fields to see preview.';
}

function sendEmbed(){
  var payload = {
    title: document.getElementById('embTitle').value.trim(),
    description: document.getElementById('embDesc').value.trim(),
    color: document.getElementById('embColor').value.trim(),
    footer: document.getElementById('embFooter').value.trim(),
    thumbnail: document.getElementById('embThumb').value.trim(),
    image: document.getElementById('embImage').value.trim(),
    timestamp: !!document.getElementById('embTimestamp').checked,
    fields: embFields,
    channelId: document.getElementById('embChannel').value.trim() || null
  };

  fetch('/embed/send', {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(payload)
  }).then(function(r){ return r.json(); }).then(function(data){
    if(data.success){ alert('Embed posted!'); }
    else { alert('Error: ' + (data.error || 'Unknown error')); }
  });
}

renderFields();
updatePreview();
</script>
`;
}

// NEW: Welcome tab
function renderWelcomeTab() {
  const ws = dashboardSettings.welcomeSettings || {
    enabled: false,
    channelId: '',
    message: 'Welcome {user} to the server!',
    autoRoles: [],
    useEmbed: false,
    embedTitle: 'Welcome to {server}! ðŸ‘‹',
    embedDescription: 'Hey {user}, welcome to **{server}**! We now have **{count}** members!',
    embedColor: '#9146ff',
    embedThumbnail: 'avatar',
    embedThumbnailUrl: '',
    embedImage: '',
    embedFooter: 'Member #{position} â€¢ Joined {time}',
    embedFields: [],
    messages: [],
    messageMode: 'single',
    dmEnabled: false,
    dmMessage: '',
    dmUseEmbed: false,
    antiSpamEnabled: false,
    antiSpamRoles: [],
    goodbyeEnabled: false,
    goodbyeChannelId: '',
    goodbyeMessage: 'Goodbye {username}, we\'ll miss you! ðŸ‘‹',
    goodbyeUseEmbed: false,
    goodbyeEmbedTitle: 'Goodbye! ðŸ‘‹',
    goodbyeEmbedDescription: '{username} has left us. We now have **{count}** members.',
    goodbyeEmbedColor: '#E74C3C',
    goodbyeEmbedThumbnail: 'avatar',
    goodbyeEmbedThumbnailUrl: '',
    goodbyeEmbedImage: '',
    goodbyeEmbedFooter: 'We\'ll miss you!',
    goodbyeMessages: [],
    goodbyeMessageMode: 'single',
    autoRoleConditions: []
  };

  return `
<!-- Variables Reference Card -->
<div class="card" style="background:linear-gradient(135deg,#1f1f23 0%,#2a2f3a 100%);border-left:4px solid #9146ff">
  <h2>ðŸ“ Available Variables</h2>
  <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:10px">
    <code style="background:#1a1a1d;padding:4px 8px;border-radius:4px;font-size:12px">{user}</code>
    <code style="background:#1a1a1d;padding:4px 8px;border-radius:4px;font-size:12px">{username}</code>
    <code style="background:#1a1a1d;padding:4px 8px;border-radius:4px;font-size:12px">{server}</code>
    <code style="background:#1a1a1d;padding:4px 8px;border-radius:4px;font-size:12px">{count}</code>
    <code style="background:#1a1a1d;padding:4px 8px;border-radius:4px;font-size:12px">{position}</code>
    <code style="background:#1a1a1d;padding:4px 8px;border-radius:4px;font-size:12px">{time}</code>
    <code style="background:#1a1a1d;padding:4px 8px;border-radius:4px;font-size:12px">{avatar}</code>
    <code style="background:#1a1a1d;padding:4px 8px;border-radius:4px;font-size:12px">{mention}</code>
  </div>
  <p style="color:#888;font-size:12px;margin-top:8px">{user} = mention, {username} = name, {count} = total members, {position} = join #, {time} = join time, {avatar} = avatar URL</p>
</div>

<!-- Welcome Messages Card -->
<div class="card">
  <h2>ðŸ‘‹ Welcome Messages</h2>
  <p style="color:#b0b0b0">Configure automatic welcome messages for new members with embeds, rotation, and DM options.</p>

  <div style="margin-top:16px">
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:12px">
      <input type="checkbox" id="welcomeEnabled" ${ws.enabled ? 'checked' : ''}>
      <span style="font-weight:600;color:#fff">Enable Welcome Messages</span>
    </label>

    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px">
      <div>
        <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Channel ID</label>
        <input type="text" id="welcomeChannelId" placeholder="Paste channel ID" value="${ws.channelId || ''}" style="margin:0">
      </div>
      <div>
        <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Message Mode</label>
        <select id="messageMode" style="margin:0">
          <option value="single" ${ws.messageMode==='single'?'selected':''}>Single Message</option>
          <option value="rotation" ${ws.messageMode==='rotation'?'selected':''}>Rotation</option>
          <option value="random" ${ws.messageMode==='random'?'selected':''}>Random</option>
        </select>
      </div>
    </div>

    <div>
      <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Welcome Message</label>
      <textarea id="welcomeMessage" placeholder="Welcome {user} to {server}!" style="min-height:60px;margin:0">${ws.message || 'Welcome {user} to the server!'}</textarea>
    </div>

    <div style="margin-top:12px;padding:16px;background:#1a1a1d;border-radius:6px;border:1px solid #2a2f3a">
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:12px">
        <input type="checkbox" id="useEmbed" ${ws.useEmbed ? 'checked' : ''}>
        <span style="font-weight:600;color:#fff">Use Embed</span>
      </label>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Embed Title</label>
          <input type="text" id="embedTitle" value="${(ws.embedTitle||'').replace(/"/g,'&quot;')}" style="margin:0">
        </div>
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Embed Color</label>
          <input type="text" id="embedColorHex" value="${ws.embedColor || '#9146ff'}" placeholder="#9146ff" style="margin:0">
        </div>
      </div>
      <div style="margin-top:8px">
        <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Embed Description</label>
        <textarea id="embedDescription" style="min-height:60px;margin:0">${(ws.embedDescription||'').replace(/</g,'&lt;')}</textarea>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:8px">
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Thumbnail</label>
          <select id="embedThumbnail" style="margin:0">
            <option value="avatar" ${ws.embedThumbnail==='avatar'?'selected':''}>User Avatar</option>
            <option value="custom" ${ws.embedThumbnail==='custom'?'selected':''}>Custom URL</option>
            <option value="none" ${ws.embedThumbnail==='none'?'selected':''}>None</option>
          </select>
        </div>
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Thumbnail URL (if custom)</label>
          <input type="text" id="embedThumbnailUrl" value="${ws.embedThumbnailUrl || ''}" style="margin:0">
        </div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:8px">
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Image URL</label>
          <input type="text" id="embedImage" value="${ws.embedImage || ''}" style="margin:0">
        </div>
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Footer</label>
          <input type="text" id="embedFooter" value="${(ws.embedFooter||'').replace(/"/g,'&quot;')}" style="margin:0">
        </div>
      </div>
      <div style="margin-top:12px">
        <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Embed Fields</label>
        <div id="embedFieldsContainer">
          ${(ws.embedFields||[]).map(f => 
          '<div class="embed-field-row" style="display:flex;gap:8px;margin-bottom:8px;align-items:center;background:#0e0e10;padding:8px;border-radius:4px">' +
            '<input class="embed-field-name" placeholder="Field Name" value="' + (f.name||'').replace(/"/g,'&quot;') + '" style="flex:1;margin:0">' +
            '<input class="embed-field-value" placeholder="Field Value" value="' + (f.value||'').replace(/"/g,'&quot;') + '" style="flex:2;margin:0">' +
            '<label style="display:flex;align-items:center;gap:4px;white-space:nowrap"><input type="checkbox" class="embed-field-inline" ' + (f.inline?'checked':'') + '><span style="font-size:12px">Inline</span></label>' +
            '<button class="small danger" type="button" onclick="removeEmbedField(this)">âœ•</button>' +
          '</div>'
          ).join('')}
        </div>
        <button class="small" type="button" onclick="addEmbedField()" style="margin-top:4px">+ Add Field</button>
      </div>
    </div>

    <div id="messagesContainer" style="margin-top:12px">
      ${(ws.messages||[]).map((m,i) => 
      '<div class="rotation-message-row" style="background:#1b1d20;padding:12px;border-radius:6px;margin-bottom:8px;border-left:3px solid #9146ff">' +
        '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">' +
          '<span style="font-weight:500">Message ' + (i+1) + '</span>' +
          '<button class="small danger" type="button" onclick="removeRotationMessage(this)">Remove</button>' +
        '</div>' +
        '<textarea class="rotation-message-text" style="width:100%;min-height:60px;resize:vertical;margin:0">' + (m.text||'') + '</textarea>' +
      '</div>'
      ).join('')}
    </div>
    <button class="small" type="button" onclick="addRotationMessage()" style="margin-top:4px">+ Add Rotation Message</button>

    <div style="margin-top:16px;padding:16px;background:#1a1a1d;border-radius:6px;border:1px solid #2a2f3a">
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:8px">
        <input type="checkbox" id="dmEnabled" ${ws.dmEnabled ? 'checked' : ''}>
        <span style="font-weight:600;color:#fff">Send DM on Join</span>
      </label>
      <textarea id="dmMessage" placeholder="DM welcome message..." style="min-height:60px;margin:0">${ws.dmMessage || ''}</textarea>
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-top:8px">
        <input type="checkbox" id="dmUseEmbed" ${ws.dmUseEmbed ? 'checked' : ''}>
        <span style="font-size:13px;color:#b0b0b0">Use embed for DM</span>
      </label>
    </div>

    <div style="margin-top:16px;padding:16px;background:#1a1a1d;border-radius:6px;border:1px solid #2a2f3a">
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:8px">
        <input type="checkbox" id="antiSpamEnabled" ${ws.antiSpamEnabled ? 'checked' : ''}>
        <span style="font-weight:600;color:#fff">Anti-spam Protection</span>
      </label>
      <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Exempt Role IDs (comma separated)</label>
      <input type="text" id="antiSpamRoles" value="${(ws.antiSpamRoles||[]).join(', ')}" placeholder="Role IDs to exempt" style="margin:0">
    </div>

    <div style="display:flex;gap:10px;margin-top:16px">
      <button onclick="saveWelcomeSettings()">ðŸ’¾ Save Welcome Settings</button>
      <button class="small" onclick="previewWelcome()" style="background:#2a2f3a">ðŸ‘ï¸ Preview</button>
    </div>
  </div>
</div>

<!-- Goodbye Messages Card -->
<div class="card">
  <h2>ðŸ‘‹ Goodbye Messages</h2>
  <p style="color:#b0b0b0">Configure automatic goodbye messages when members leave.</p>
  <div style="margin-top:16px">
    <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:12px">
      <input type="checkbox" id="goodbyeEnabled" ${ws.goodbyeEnabled ? 'checked' : ''}>
      <span style="font-weight:600;color:#fff">Enable Goodbye Messages</span>
    </label>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:16px">
      <div>
        <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Channel ID</label>
        <input type="text" id="goodbyeChannelId" placeholder="Paste channel ID" value="${ws.goodbyeChannelId || ''}" style="margin:0">
      </div>
      <div>
        <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Message Mode</label>
        <select id="goodbyeMessageMode" style="margin:0">
          <option value="single" ${ws.goodbyeMessageMode==='single'?'selected':''}>Single</option>
          <option value="rotation" ${ws.goodbyeMessageMode==='rotation'?'selected':''}>Rotation</option>
          <option value="random" ${ws.goodbyeMessageMode==='random'?'selected':''}>Random</option>
        </select>
      </div>
    </div>
    <div>
      <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Goodbye Message</label>
      <textarea id="goodbyeMessage" placeholder="Goodbye {username}!" style="min-height:60px;margin:0">${ws.goodbyeMessage || ''}</textarea>
    </div>
    <div style="margin-top:12px;padding:16px;background:#1a1a1d;border-radius:6px;border:1px solid #2a2f3a">
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer;margin-bottom:12px">
        <input type="checkbox" id="goodbyeUseEmbed" ${ws.goodbyeUseEmbed ? 'checked' : ''}>
        <span style="font-weight:600;color:#fff">Use Embed</span>
      </label>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px">
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Embed Title</label>
          <input type="text" id="goodbyeEmbedTitle" value="${(ws.goodbyeEmbedTitle||'').replace(/"/g,'&quot;')}" style="margin:0">
        </div>
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Embed Color</label>
          <input type="text" id="goodbyeEmbedColorHex" value="${ws.goodbyeEmbedColor || '#E74C3C'}" style="margin:0">
        </div>
      </div>
      <div style="margin-top:8px">
        <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Embed Description</label>
        <textarea id="goodbyeEmbedDescription" style="min-height:60px;margin:0">${(ws.goodbyeEmbedDescription||'').replace(/</g,'&lt;')}</textarea>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:8px">
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Thumbnail</label>
          <select id="goodbyeEmbedThumbnail" style="margin:0">
            <option value="avatar" ${ws.goodbyeEmbedThumbnail==='avatar'?'selected':''}>User Avatar</option>
            <option value="custom" ${ws.goodbyeEmbedThumbnail==='custom'?'selected':''}>Custom URL</option>
            <option value="none" ${ws.goodbyeEmbedThumbnail==='none'?'selected':''}>None</option>
          </select>
        </div>
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Thumbnail URL</label>
          <input type="text" id="goodbyeEmbedThumbnailUrl" value="${ws.goodbyeEmbedThumbnailUrl || ''}" style="margin:0">
        </div>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:8px">
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Image URL</label>
          <input type="text" id="goodbyeEmbedImage" value="${ws.goodbyeEmbedImage || ''}" style="margin:0">
        </div>
        <div>
          <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Footer</label>
          <input type="text" id="goodbyeEmbedFooter" value="${(ws.goodbyeEmbedFooter||'').replace(/"/g,'&quot;')}" style="margin:0">
        </div>
      </div>
    </div>
    <div style="display:flex;gap:10px;margin-top:16px">
      <button onclick="saveGoodbyeSettings()">ðŸ’¾ Save Goodbye Settings</button>
      <button class="small" onclick="previewGoodbye()" style="background:#2a2f3a">ðŸ‘ï¸ Preview</button>
    </div>
  </div>
</div>

<!-- Auto-Roles Card -->
<div class="card">
  <h2>ðŸŽ­ Auto Roles</h2>
  <p style="color:#b0b0b0">Automatically assign roles to new members when they join.</p>
  <div style="margin-top:16px">
    <div style="display:grid;grid-template-columns:2fr 1fr 1fr auto;gap:8px;align-items:end;margin-bottom:12px">
      <div>
        <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Role ID</label>
        <input type="text" id="autoRoleId" placeholder="Role ID" style="margin:0">
      </div>
      <div>
        <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Condition</label>
        <select id="autoRoleCondition" style="margin:0">
          <option value="always">Always</option>
          <option value="account_age">Account Age</option>
          <option value="verified">Verified Email</option>
        </select>
      </div>
      <div>
        <label style="font-size:12px;color:#8b8fa3;display:block;margin-bottom:4px">Min Age (days)</label>
        <input type="number" id="autoRoleMinAge" value="7" min="0" style="margin:0">
      </div>
      <button class="small" onclick="addAutoRole()" style="margin-bottom:0">+ Add</button>
    </div>
    <div style="margin-bottom:12px">
      ${(ws.autoRoles||[]).map(r => {
        const rid = r.roleId || r;
        const cond = r.condition || 'always';
        return '<div class="role-display" data-role-id="' + rid + '" style="display:flex;align-items:center;gap:8px;padding:8px 12px;background:#1a1a1d;border-radius:4px;margin-bottom:4px">' +
          '<span class="role-name-badge" style="flex:1;font-size:13px">' + rid + '</span>' +
          '<span style="font-size:11px;color:#8b8fa3">' + cond + '</span>' +
          '<button class="small danger" onclick="removeAutoRole(\'' + rid + '\')" style="padding:4px 8px;margin:0">âœ•</button>' +
        '</div>';
      }).join('')}
    </div>
    <details style="margin-top:8px">
      <summary>Bulk Add Roles</summary>
      <div style="margin-top:8px">
        <textarea id="bulkRoleIds" placeholder="Paste role IDs, one per line or comma separated" style="min-height:60px;margin:0"></textarea>
        <button class="small" onclick="bulkAddRoles()" style="margin-top:6px">Add All</button>
      </div>
    </details>
    <button class="small" onclick="testAutoRoles()" style="margin-top:8px;background:#2a2f3a">ðŸ§ª Test Auto Roles</button>
  </div>
</div>

<!-- Preview Modal -->
<div id="welcomePreviewModal" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:1000;justify-content:center;align-items:center">
  <div style="background:#36393f;border-radius:8px;padding:20px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
      <h3 style="margin:0;color:#fff">Preview</h3>
      <button class="small" onclick="closePreviewModal()" style="background:#2a2f3a;margin:0">âœ•</button>
    </div>
    <div id="previewContent"></div>
  </div>
</div>

<script>
function addEmbedField() {
  const container = document.getElementById('embedFieldsContainer');
  const row = document.createElement('div');
  row.className = 'embed-field-row';
  row.style.cssText = 'display:flex;gap:8px;margin-bottom:8px;align-items:center;background:#0e0e10;padding:8px;border-radius:4px';
  row.innerHTML = '<input class="embed-field-name" placeholder="Field Name" style="flex:1;margin:0"><input class="embed-field-value" placeholder="Field Value" style="flex:2;margin:0"><label style="display:flex;align-items:center;gap:4px;white-space:nowrap"><input type="checkbox" class="embed-field-inline"><span style="font-size:12px">Inline</span></label><button class="small danger" type="button" onclick="removeEmbedField(this)">âœ•</button>';
  container.appendChild(row);
}
function removeEmbedField(btn) { btn.closest('.embed-field-row').remove(); }

function addRotationMessage() {
  const container = document.getElementById('messagesContainer');
  const count = container.children.length + 1;
  const row = document.createElement('div');
  row.className = 'rotation-message-row';
  row.style.cssText = 'background:#1b1d20;padding:12px;border-radius:6px;margin-bottom:8px;border-left:3px solid #9146ff';
  row.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px"><span style="font-weight:500">Message ' + count + '</span><button class="small danger" type="button" onclick="removeRotationMessage(this)">Remove</button></div><textarea class="rotation-message-text" placeholder="Welcome message..." style="width:100%;min-height:60px;resize:vertical;margin:0"></textarea>';
  container.appendChild(row);
}
function removeRotationMessage(btn) {
  btn.closest('.rotation-message-row').remove();
  document.querySelectorAll('.rotation-message-row').forEach(function(row, i) { row.querySelector('span').textContent = 'Message ' + (i + 1); });
}

function collectEmbedFields() {
  var fields = [];
  document.querySelectorAll('.embed-field-row').forEach(function(row) {
    var name = row.querySelector('.embed-field-name').value.trim();
    var value = row.querySelector('.embed-field-value').value.trim();
    var inline = row.querySelector('.embed-field-inline').checked;
    if (name && value) fields.push({ name: name, value: value, inline: inline });
  });
  return fields;
}

function collectRotationMessages() {
  var messages = [];
  document.querySelectorAll('.rotation-message-text').forEach(function(textarea) {
    var text = textarea.value.trim();
    if (text) messages.push({ text: text });
  });
  return messages;
}

function saveWelcomeSettings() {
  var settings = {
    enabled: document.getElementById('welcomeEnabled').checked,
    channelId: document.getElementById('welcomeChannelId').value.trim(),
    message: document.getElementById('welcomeMessage').value.trim(),
    useEmbed: document.getElementById('useEmbed').checked,
    embedTitle: document.getElementById('embedTitle').value.trim(),
    embedDescription: document.getElementById('embedDescription').value.trim(),
    embedColor: document.getElementById('embedColorHex').value.trim() || '#9146ff',
    embedThumbnail: document.getElementById('embedThumbnail').value,
    embedThumbnailUrl: document.getElementById('embedThumbnailUrl').value.trim(),
    embedImage: document.getElementById('embedImage').value.trim(),
    embedFooter: document.getElementById('embedFooter').value.trim(),
    embedFields: collectEmbedFields(),
    messageMode: document.getElementById('messageMode').value,
    messages: collectRotationMessages(),
    dmEnabled: document.getElementById('dmEnabled').checked,
    dmMessage: document.getElementById('dmMessage').value.trim(),
    dmUseEmbed: document.getElementById('dmUseEmbed').checked,
    antiSpamEnabled: document.getElementById('antiSpamEnabled').checked,
    antiSpamRoles: document.getElementById('antiSpamRoles').value.split(/[,\\n]/).map(function(s){return s.trim()}).filter(Boolean)
  };
  fetch('/api/welcome-settings', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(settings) })
    .then(function(r){return r.json()}).then(function(data) {
      if (data.success) { alert('\\u2705 Welcome settings saved!'); location.reload(); }
      else alert('\\u274C Error: ' + (data.error || 'Unknown error'));
    }).catch(function(err){ alert('\\u274C Error: ' + err.message); });
}

function saveGoodbyeSettings() {
  var settings = {
    goodbyeEnabled: document.getElementById('goodbyeEnabled').checked,
    goodbyeChannelId: document.getElementById('goodbyeChannelId').value.trim(),
    goodbyeMessage: document.getElementById('goodbyeMessage').value.trim(),
    goodbyeUseEmbed: document.getElementById('goodbyeUseEmbed').checked,
    goodbyeEmbedTitle: document.getElementById('goodbyeEmbedTitle').value.trim(),
    goodbyeEmbedDescription: document.getElementById('goodbyeEmbedDescription').value.trim(),
    goodbyeEmbedColor: document.getElementById('goodbyeEmbedColorHex').value.trim() || '#E74C3C',
    goodbyeEmbedThumbnail: document.getElementById('goodbyeEmbedThumbnail').value,
    goodbyeEmbedThumbnailUrl: (document.getElementById('goodbyeEmbedThumbnailUrl') || {}).value || '',
    goodbyeEmbedImage: document.getElementById('goodbyeEmbedImage').value.trim(),
    goodbyeEmbedFooter: document.getElementById('goodbyeEmbedFooter').value.trim(),
    goodbyeMessageMode: document.getElementById('goodbyeMessageMode').value
  };
  fetch('/api/welcome-settings', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(settings) })
    .then(function(r){return r.json()}).then(function(data) {
      if (data.success) { alert('\\u2705 Goodbye settings saved!'); location.reload(); }
      else alert('\\u274C Error: ' + (data.error || 'Unknown error'));
    }).catch(function(err){ alert('\\u274C Error: ' + err.message); });
}

function addAutoRole() {
  var roleId = document.getElementById('autoRoleId').value.trim();
  var condition = document.getElementById('autoRoleCondition').value;
  var minAge = parseInt(document.getElementById('autoRoleMinAge').value) || 7;
  if (!roleId) { alert('Please enter a role ID'); return; }
  fetch('/api/welcome-settings/add-role', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ roleId: roleId, condition: condition, minAccountAge: minAge }) })
    .then(function(r){return r.json()}).then(function(data) { if (data.success) location.reload(); else alert('\\u274C Error: ' + (data.error || 'Unknown error')); })
    .catch(function(err){ alert('\\u274C Error: ' + err.message); });
}

function removeAutoRole(roleId) {
  fetch('/api/welcome-settings/remove-role', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ roleId: roleId }) })
    .then(function(r){return r.json()}).then(function(data) { if (data.success) location.reload(); else alert('\\u274C Error: ' + (data.error || 'Unknown error')); })
    .catch(function(err){ alert('\\u274C Error: ' + err.message); });
}

function bulkAddRoles() {
  var input = document.getElementById('bulkRoleIds').value;
  var roleIds = input.split(/[,\\n]/).map(function(s){return s.trim()}).filter(function(s){return s && /^\\d+$/.test(s)});
  if (roleIds.length === 0) { alert('No valid role IDs found'); return; }
  fetch('/api/welcome-settings/bulk-add-roles', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ roleIds: roleIds }) })
    .then(function(r){return r.json()}).then(function(data) {
      if (data.success) { alert('\\u2705 Added ' + (data.added || roleIds.length) + ' roles'); location.reload(); }
      else alert('\\u274C Error: ' + (data.error || 'Unknown error'));
    }).catch(function(err){ alert('\\u274C Error: ' + err.message); });
}

function testAutoRoles() {
  fetch('/api/welcome-settings/test-roles', { method: 'POST' })
    .then(function(r){return r.json()}).then(function(data) {
      if (data.success) alert('\\u2705 Test complete!\\n' + (data.results || []).join('\\n'));
      else alert('\\u274C Error: ' + (data.error || 'Unknown error'));
    }).catch(function(err){ alert('\\u274C Error: ' + err.message); });
}

function replacePlaceholders(text, data) {
  return text.replace(/{user}/g,data.user).replace(/{username}/g,data.username).replace(/{server}/g,data.server).replace(/{count}/g,data.count).replace(/{position}/g,data.position).replace(/{time}/g,data.time).replace(/{avatar}/g,data.avatar).replace(/{mention}/g,data.user);
}

function previewWelcome() {
  var useEmbed = document.getElementById('useEmbed').checked;
  var modal = document.getElementById('welcomePreviewModal');
  var content = document.getElementById('previewContent');
  var data = { user:'@ExampleUser', username:'ExampleUser', server:'My Awesome Server', count:'1,234', position:'1234', time:new Date().toLocaleString(), avatar:'https://cdn.discordapp.com/embed/avatars/0.png' };
  if (useEmbed) {
    var color = document.getElementById('embedColorHex').value || '#9146ff';
    var title = replacePlaceholders(document.getElementById('embedTitle').value || '', data);
    var desc = replacePlaceholders(document.getElementById('embedDescription').value || '', data);
    var footer = replacePlaceholders(document.getElementById('embedFooter').value || '', data);
    var image = document.getElementById('embedImage').value;
    var thumbnail = document.getElementById('embedThumbnail').value;
    var thumbnailUrl = thumbnail==='avatar' ? data.avatar : (thumbnail==='custom' ? document.getElementById('embedThumbnailUrl').value : '');
    var fieldsHtml = '';
    collectEmbedFields().forEach(function(f) {
      fieldsHtml += '<div style="flex:'+(f.inline?'1':'100%')+';min-width:'+(f.inline?'100px':'100%')+';margin-top:8px"><div style="font-weight:600;font-size:13px;color:#fff">'+f.name+'</div><div style="font-size:14px;color:#dcddde">'+f.value+'</div></div>';
    });
    content.innerHTML = '<div style="display:flex;gap:16px"><div style="width:4px;background:'+color+';border-radius:4px"></div><div style="flex:1">'+(title?'<div style="font-weight:600;color:#fff;margin-bottom:8px">'+title+'</div>':'')+(desc?'<div style="color:#dcddde;white-space:pre-wrap">'+desc+'</div>':'')+(fieldsHtml?'<div style="display:flex;flex-wrap:wrap;gap:8px">'+fieldsHtml+'</div>':'')+(image?'<img src="'+image+'" style="max-width:100%;margin-top:12px;border-radius:4px">':'')+(footer?'<div style="margin-top:12px;font-size:12px;color:#72767d">'+footer+'</div>':'')+'</div>'+(thumbnailUrl?'<img src="'+thumbnailUrl+'" style="width:80px;height:80px;border-radius:4px;object-fit:cover">':'')+'</div>';
  } else {
    var msg = replacePlaceholders(document.getElementById('welcomeMessage').value || 'Welcome {user} to {server}!', data);
    content.innerHTML = '<div style="color:#dcddde;white-space:pre-wrap">'+msg+'</div>';
  }
  modal.style.display = 'flex';
}

function previewGoodbye() {
  var useEmbed = document.getElementById('goodbyeUseEmbed').checked;
  var modal = document.getElementById('welcomePreviewModal');
  var content = document.getElementById('previewContent');
  var data = { user:'@ExampleUser', username:'ExampleUser', server:'My Awesome Server', count:'1,233', position:'1234', time:new Date().toLocaleString(), avatar:'https://cdn.discordapp.com/embed/avatars/0.png' };
  if (useEmbed) {
    var color = document.getElementById('goodbyeEmbedColorHex').value || '#E74C3C';
    var title = replacePlaceholders(document.getElementById('goodbyeEmbedTitle').value || '', data);
    var desc = replacePlaceholders(document.getElementById('goodbyeEmbedDescription').value || '', data);
    var footer = replacePlaceholders(document.getElementById('goodbyeEmbedFooter').value || '', data);
    var thumbnailUrl = document.getElementById('goodbyeEmbedThumbnail').value==='avatar' ? data.avatar : '';
    content.innerHTML = '<div style="display:flex;gap:16px"><div style="width:4px;background:'+color+';border-radius:4px"></div><div style="flex:1">'+(title?'<div style="font-weight:600;color:#fff;margin-bottom:8px">'+title+'</div>':'')+(desc?'<div style="color:#dcddde;white-space:pre-wrap">'+desc+'</div>':'')+(footer?'<div style="margin-top:12px;font-size:12px;color:#72767d">'+footer+'</div>':'')+'</div>'+(thumbnailUrl?'<img src="'+thumbnailUrl+'" style="width:80px;height:80px;border-radius:4px;object-fit:cover">':'')+'</div>';
  } else {
    var msg = replacePlaceholders(document.getElementById('goodbyeMessage').value || 'Goodbye {username}!', data);
    content.innerHTML = '<div style="color:#dcddde;white-space:pre-wrap">'+msg+'</div>';
  }
  modal.style.display = 'flex';
}

function closePreviewModal() { document.getElementById('welcomePreviewModal').style.display = 'none'; }
document.getElementById('welcomePreviewModal')?.addEventListener('click', function(e) { if (e.target === this) closePreviewModal(); });

function resolveRoleNames() {
  document.querySelectorAll('.role-name-badge').forEach(function(badge) {
    var parent = badge.closest('.role-display');
    var roleId = parent ? parent.getAttribute('data-role-id') : null;
    if (!roleId) return;
    fetch('/role/info/' + roleId).then(function(r){return r.json()}).then(function(data) {
      if (data && data.name) { badge.textContent = data.name; if (data.color) badge.style.borderLeft = '3px solid #' + data.color.toString(16).padStart(6, '0'); }
      else { badge.textContent = 'Unknown Role'; badge.style.color = '#ff6b6b'; }
    }).catch(function() { badge.textContent = 'Lookup Failed'; badge.style.color = '#ff6b6b'; });
  });
}
document.addEventListener('DOMContentLoaded', resolveRoleNames);
</script>
`;
}

// NEW: Member Logs tab
function renderAuditLogTab() {
  const als = dashboardSettings.auditLogSettings || {};
  const auditLogSettings = {
    enabled: false,
    channelId: '',
    logMessageEdits: true,
    logMessageDeletes: true,
    logMessageBulkDeletes: true,
    logMessagePins: true,
    logUsernameChanges: true,
    logAvatarChanges: true,
    logNicknameChanges: true,
    logRoleChanges: true,
    logMemberJoins: true,
    logMemberLeaves: true,
    logMemberBans: true,
    logMemberUnbans: true,
    logMemberTimeouts: true,
    logMemberMutes: true,
    logMemberBoosts: true,
    logJoinPosition: true,
    logServerUpdates: true,
    logIntegrations: true,
    warnNewAccounts: true,
    newAccountThresholdDays: 7,
    excludedChannels: [],
    excludedRoles: [],
    excludedUsers: [],
    muteRoleIds: [],
    logRetentionDays: 30,
    autoCleanupEnabled: false,
    eventColors: {},
    alertKeywords: [],
    alertUserId: '',
    alertEnabled: false,
    dmNotificationsEnabled: false,
    dmNotifyUserId: '',
    dmNotifyEvents: { bans: true, newAccounts: true, serverChanges: false, botChanges: true },
    webhookUrl: '',
    webhookEnabled: false,
    autoDetectMuteRole: false,
    ...als
  };

  // Calculate stats for summary
  const now = new Date();
  const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const weekLogs = auditLogHistory.filter(e => new Date(e.timestamp) >= weekAgo);
  const statsData = {
    totalLogs: auditLogHistory.length,
    logsThisWeek: weekLogs.length,
    bansThisWeek: weekLogs.filter(e => e.action === 'member_ban').length,
    timeoutsThisWeek: weekLogs.filter(e => e.action === 'member_timeout').length,
    joinsThisWeek: weekLogs.filter(e => e.action === 'member_join').length,
    newAccountWarnings: weekLogs.filter(e => e.action === 'member_join' && e.type === 'warn').length
  };

  return `
<!-- Stats Summary Card -->
<div class="card" style="background:linear-gradient(135deg, #1f1f23 0%, #2a2f3a 100%);border-left:4px solid #9146ff">
  <h2>ðŸ“Š Log Stats Summary</h2>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:12px;margin-top:12px">
    <div style="background:#1a1a1d;padding:12px;border-radius:6px;text-align:center">
      <div style="font-size:24px;font-weight:bold;color:#9146ff">${statsData.logsThisWeek}</div>
      <div style="font-size:11px;color:#888">Events This Week</div>
    </div>
    <div style="background:#1a1a1d;padding:12px;border-radius:6px;text-align:center">
      <div style="font-size:24px;font-weight:bold;color:#E74C3C">${statsData.bansThisWeek}</div>
      <div style="font-size:11px;color:#888">Bans</div>
    </div>
    <div style="background:#1a1a1d;padding:12px;border-radius:6px;text-align:center">
      <div style="font-size:24px;font-weight:bold;color:#E67E22">${statsData.timeoutsThisWeek}</div>
      <div style="font-size:11px;color:#888">Timeouts</div>
    </div>
    <div style="background:#1a1a1d;padding:12px;border-radius:6px;text-align:center">
      <div style="font-size:24px;font-weight:bold;color:#2ECC71">${statsData.joinsThisWeek}</div>
      <div style="font-size:11px;color:#888">Joins</div>
    </div>
    <div style="background:#1a1a1d;padding:12px;border-radius:6px;text-align:center">
      <div style="font-size:24px;font-weight:bold;color:#F39C12">${statsData.newAccountWarnings}</div>
      <div style="font-size:11px;color:#888">New Acct Warns</div>
    </div>
    <div style="background:#1a1a1d;padding:12px;border-radius:6px;text-align:center">
      <div style="font-size:24px;font-weight:bold;color:#3498DB">${statsData.totalLogs}</div>
      <div style="font-size:11px;color:#888">Total Stored</div>
    </div>
  </div>
</div>

<div class="card">
  <h2>ðŸ•µï¸ Member Logs</h2>
  <p style="color:#b0b0b0">Log member activity. Click the info icons for example previews.</p>

  <div style="margin:20px 0">
    <label style="display:flex;align-items:center;cursor:pointer;justify-content:flex-start">
      <input type="checkbox" id="auditEnabled" ${auditLogSettings.enabled ? 'checked' : ''} onchange="updateAuditChannelDropdown()" />
      <span style="font-weight:500">Enable Member Logs</span>
    </label>
  </div>

  <div style="margin:15px 0">
    <label style="display:block;margin-bottom:5px;font-weight:500">Log Channel ID:</label>
    <input id="auditChannelId" type="text" value="${auditLogSettings.channelId || ''}" placeholder="Channel ID (leave empty to disable)" oninput="updateAuditChannelName();" style="width:100%" />
    <small id="auditChannelName" style="color:#888;display:block;margin-top:4px">Leave empty to disable logging</small>
  </div>

  <div style="margin:15px 0">
    <label style="display:block;margin-bottom:5px;font-weight:500">Log Level:</label>
    <select id="auditLogLevel" onchange="updateAuditLogLevel();" style="width:100%">
      <option value="all" ${auditLogSettings.logLevel === 'all' ? 'selected' : ''}>All Events</option>
      <option value="important" ${auditLogSettings.logLevel === 'important' ? 'selected' : ''}>Important Only (bans, mutes, timeouts, role changes)</option>
      <option value="minimal" ${auditLogSettings.logLevel === 'minimal' ? 'selected' : ''}>Minimal (bans, unbans, member joins/leaves)</option>
    </select>
  </div>

  <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:6px">
    <button class="small" type="button" onclick="openPerEventChannelsModal()" style="width:auto;background:#2a2f3a;border:1px solid #9146ff">ðŸ”— Per-Event Channels</button>
    <button class="small" type="button" onclick="openPerEventPingsModal()" style="width:auto;background:#2a2f3a;border:1px solid #9146ff">ðŸ“¢ Event Pings</button>
    <button class="small" type="button" onclick="openLivePreviewModal()" style="width:auto;background:#2a2f3a;border:1px solid #9146ff">â„¹ï¸ Live Preview</button>
    <button class="small" type="button" onclick="openEventColorsModal()" style="width:auto;background:#2a2f3a;border:1px solid #9146ff">ðŸŽ¨ Event Colors</button>
  </div>

  <!-- Collapsible Event Groups -->
  <details open style="margin-top:18px">
    <summary style="cursor:pointer;font-weight:600;padding:8px;background:#2a2f3a;border-radius:4px;margin-bottom:8px">ðŸ‘¥ Join/Leave Events</summary>
    <div style="padding:8px 0 8px 12px;display:flex;flex-direction:column;gap:6px">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logMemberJoins" ${auditLogSettings.logMemberJoins ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Member joins & join position</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logMemberLeaves" ${auditLogSettings.logMemberLeaves ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Member leaves</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="warnNewAccounts" ${auditLogSettings.warnNewAccounts ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Warn on new accounts</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logMemberBoosts" ${auditLogSettings.logMemberBoosts ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Boosts / stops boosting</span>
      </label>
      <div style="margin-left:22px;margin-top:6px">
        <label style="display:block;margin-bottom:5px;font-weight:500">New account threshold (days):</label>
        <input id="newAccountThresholdDays" type="number" min="1" max="365" value="${auditLogSettings.newAccountThresholdDays || 7}" style="width:120px" />
      </div>
    </div>
  </details>

  <details open style="margin-top:8px">
    <summary style="cursor:pointer;font-weight:600;padding:8px;background:#2a2f3a;border-radius:4px;margin-bottom:8px">ðŸ›¡ï¸ Moderation Actions</summary>
    <div style="padding:8px 0 8px 12px;display:flex;flex-direction:column;gap:6px">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logMemberBans" ${auditLogSettings.logMemberBans ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Member bans & unbans</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logMemberTimeouts" ${auditLogSettings.logMemberTimeouts ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Timeouts / timeout expires</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logMemberMutes" ${auditLogSettings.logMemberMutes ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Mute roles (add/remove)</span>
      </label>
    </div>
  </details>

  <details style="margin-top:8px">
    <summary style="cursor:pointer;font-weight:600;padding:8px;background:#2a2f3a;border-radius:4px;margin-bottom:8px">ðŸ‘¤ Profile Changes</summary>
    <div style="padding:8px 0 8px 12px;display:flex;flex-direction:column;gap:6px">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logUsernameChanges" ${auditLogSettings.logUsernameChanges ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Name changes (username & nickname)</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logAvatarChanges" ${auditLogSettings.logAvatarChanges ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Avatar changes</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logRoleChanges" ${auditLogSettings.logRoleChanges ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Role updates</span>
      </label>
    </div>
  </details>

  <details style="margin-top:8px">
    <summary style="cursor:pointer;font-weight:600;padding:8px;background:#2a2f3a;border-radius:4px;margin-bottom:8px">ðŸ’¬ Message Events</summary>
    <div style="padding:8px 0 8px 12px;display:flex;flex-direction:column;gap:6px">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logMessageEdits" ${auditLogSettings.logMessageEdits ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Message edits</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logMessageDeletes" ${auditLogSettings.logMessageDeletes ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Message deletes & bulk deletes</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logMessagePins" ${auditLogSettings.logMessagePins ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Message pins / unpins</span>
      </label>
    </div>
  </details>

  <details style="margin-top:8px">
    <summary style="cursor:pointer;font-weight:600;padding:8px;background:#2a2f3a;border-radius:4px;margin-bottom:8px">âš™ï¸ Server Changes</summary>
    <div style="padding:8px 0 8px 12px;display:flex;flex-direction:column;gap:6px">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logServerUpdates" ${auditLogSettings.logServerUpdates ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Server settings updates</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="logIntegrations" ${auditLogSettings.logIntegrations ? 'checked' : ''} onchange="updateLivePreview()" />
        <span>Integrations / bots added or removed</span>
      </label>
    </div>
  </details>

  <div id="auditLogData" data-per-event-channels='${JSON.stringify(auditLogSettings.perEventChannels || {}).replace(/"/g, '&quot;')}' data-per-event-pings='${JSON.stringify(auditLogSettings.perEventPings || {}).replace(/"/g, '&quot;')}' data-event-colors='${JSON.stringify(auditLogSettings.eventColors || {}).replace(/"/g, '&quot;')}' style="display:none"></div>

  <div id="livePreviewPanel" style="margin-top:18px;background:#1a1c1f;padding:12px;border-radius:6px;border-left:4px solid #7b68ee">
    <h3 style="margin:0 0 8px 0">ðŸ“Š Live Preview</h3>
    <div id="livePreviewContent" style="color:#ccc;font-size:13px;font-family:monospace">Select events above to see preview...</div>
  </div>

  <div style="margin-top:18px;background:#222;padding:12px;border-radius:6px">
    <h3 style="margin:0 0 8px 0">Exclusions</h3>
    <p style="color:#b0b0b0;margin-top:0;margin-bottom:8px;font-size:13px">Channels, roles, or users that will be ignored by the logs. Use comma or new-line separated IDs.</p>
    <div style="display:flex;gap:12px;flex-wrap:wrap">
      <div style="flex:1;min-width:220px">
        <div style="font-size:12px;color:#aaa;margin-bottom:6px">Excluded Channels</div>
        <textarea id="excludedChannelsInput" style="background:#1b1d20;padding:8px;border-radius:6px;min-height:60px;width:100%" placeholder="123..., 456...">${(auditLogSettings.excludedChannels || []).join(', ')}</textarea>
      </div>
      <div style="flex:1;min-width:220px">
        <div style="font-size:12px;color:#aaa;margin-bottom:6px">Excluded Roles</div>
        <textarea id="excludedRolesInput" style="background:#1b1d20;padding:8px;border-radius:6px;min-height:60px;width:100%" placeholder="Role IDs">${(auditLogSettings.excludedRoles || []).join(', ')}</textarea>
      </div>
      <div style="flex:1;min-width:220px">
        <div style="font-size:12px;color:#aaa;margin-bottom:6px">Excluded Users</div>
        <textarea id="excludedUsersInput" style="background:#1b1d20;padding:8px;border-radius:6px;min-height:60px;width:100%" placeholder="User IDs">${(auditLogSettings.excludedUsers || []).join(', ')}</textarea>
      </div>
      <div style="flex:1;min-width:220px">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px">
          <div style="font-size:12px;color:#aaa">Mute Role IDs</div>
          <button class="small" type="button" onclick="autoDetectMuteRoles()" style="width:auto;padding:2px 8px;font-size:10px">ðŸ” Auto-Detect</button>
        </div>
        <textarea id="muteRoleIdsInput" style="background:#1b1d20;padding:8px;border-radius:6px;min-height:60px;width:100%" placeholder="Mute role IDs">${(auditLogSettings.muteRoleIds || []).join(', ')}</textarea>
      </div>
    </div>
  </div>

  <div style="margin-top:16px">
    <button onclick="saveAuditLogSettings()">ðŸ’¾ Save Member Log Settings</button>
  </div>
</div>

<!-- Log Retention & Cleanup Card -->
<div class="card">
  <h2>ðŸ—‘ï¸ Log Retention & Cleanup</h2>
  <p style="color:#b0b0b0;margin-bottom:12px">Manage how long logs are stored and auto-cleanup old entries.</p>
  
  <div style="display:flex;gap:15px;flex-wrap:wrap;align-items:flex-end">
    <div style="flex:1;min-width:200px">
      <label style="display:block;margin-bottom:5px;font-weight:500">Keep logs for (days):</label>
      <input id="logRetentionDays" type="number" min="1" max="365" value="${auditLogSettings.logRetentionDays || 30}" style="width:100%" />
    </div>
    <div style="flex:1;min-width:200px">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="autoCleanupEnabled" ${auditLogSettings.autoCleanupEnabled ? 'checked' : ''} />
        <span>Enable auto-cleanup (daily)</span>
      </label>
    </div>
  </div>
  
  <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:12px">
    <button class="small" type="button" onclick="manualCleanupLogs()">ðŸ§¹ Cleanup Now</button>
    <button class="small" type="button" onclick="exportAuditLogs()">ðŸ“¥ Export Logs (JSON)</button>
  </div>
</div>

<!-- Keyword Alerts Card -->
<div class="card">
  <h2>ðŸ”” Keyword/Phrase Alerts</h2>
  <p style="color:#b0b0b0;margin-bottom:12px">Get notified (DM) when specific keywords appear in audit logs.</p>
  
  <div style="margin-bottom:12px">
    <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
      <input type="checkbox" id="alertEnabled" ${auditLogSettings.alertEnabled ? 'checked' : ''} />
      <span style="font-weight:500">Enable Keyword Alerts</span>
    </label>
  </div>
  
  <div style="display:flex;gap:15px;flex-wrap:wrap">
    <div style="flex:2;min-width:280px">
      <label style="display:block;margin-bottom:5px;font-weight:500">Alert Keywords (comma-separated):</label>
      <textarea id="alertKeywords" style="background:#1b1d20;padding:8px;border-radius:6px;min-height:60px;width:100%" placeholder="ban, timeout, spam, raid, your username...">${(auditLogSettings.alertKeywords || []).join(', ')}</textarea>
    </div>
    <div style="flex:1;min-width:200px">
      <label style="display:block;margin-bottom:5px;font-weight:500">Your User ID (for DM):</label>
      <input id="alertUserId" type="text" value="${auditLogSettings.alertUserId || ''}" placeholder="Your Discord User ID" style="width:100%" />
    </div>
  </div>
</div>

<!-- DM/Webhook Notifications Card -->
<div class="card">
  <h2>ðŸ“² Critical Event Notifications</h2>
  <p style="color:#b0b0b0;margin-bottom:12px">Get DMs or webhook notifications for important events without checking the log channel.</p>
  
  <div style="display:flex;gap:15px;flex-wrap:wrap;margin-bottom:12px">
    <div style="flex:1;min-width:200px">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="dmNotificationsEnabled" ${auditLogSettings.dmNotificationsEnabled ? 'checked' : ''} />
        <span style="font-weight:500">Enable DM Notifications</span>
      </label>
    </div>
    <div style="flex:1;min-width:200px">
      <label style="display:block;margin-bottom:5px;font-weight:500">DM User ID:</label>
      <input id="dmNotifyUserId" type="text" value="${auditLogSettings.dmNotifyUserId || ''}" placeholder="User ID to DM" style="width:100%" />
    </div>
  </div>
  
  <div style="background:#1b1d20;padding:12px;border-radius:6px;margin-bottom:12px">
    <div style="font-weight:500;margin-bottom:8px">DM me on:</div>
    <div style="display:flex;gap:15px;flex-wrap:wrap">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="dmNotifyBans" ${auditLogSettings.dmNotifyEvents?.bans !== false ? 'checked' : ''} />
        <span>Bans</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="dmNotifyNewAccounts" ${auditLogSettings.dmNotifyEvents?.newAccounts !== false ? 'checked' : ''} />
        <span>New Account Joins</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="dmNotifyServerChanges" ${auditLogSettings.dmNotifyEvents?.serverChanges ? 'checked' : ''} />
        <span>Server Changes</span>
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer">
        <input type="checkbox" id="dmNotifyBotChanges" ${auditLogSettings.dmNotifyEvents?.botChanges !== false ? 'checked' : ''} />
        <span>Bot Add/Remove</span>
      </label>
    </div>
  </div>
  
  <div style="display:flex;gap:15px;flex-wrap:wrap;align-items:flex-end">
    <div style="flex:1;min-width:200px">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer;margin-bottom:8px">
        <input type="checkbox" id="webhookEnabled" ${auditLogSettings.webhookEnabled ? 'checked' : ''} />
        <span style="font-weight:500">Enable Webhook Notifications</span>
      </label>
    </div>
    <div style="flex:2;min-width:300px">
      <label style="display:block;margin-bottom:5px;font-weight:500">Webhook URL:</label>
      <input id="webhookUrl" type="text" value="${auditLogSettings.webhookUrl || ''}" placeholder="https://discord.com/api/webhooks/... or IFTTT URL" style="width:100%" />
    </div>
  </div>
</div>

<!-- Searchable Log History Card -->
<div class="card">
  <h2>ðŸ” Search Log History</h2>
  <p style="color:#b0b0b0;margin-bottom:12px">Search past audit logs by user, event type, date, or keyword.</p>
  
  <div style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px">
    <input id="logSearchUser" type="text" placeholder="User ID or name..." style="flex:1;min-width:150px" />
    <select id="logSearchEventType" style="flex:1;min-width:150px">
      <option value="">All Event Types</option>
      <option value="member_join">Member Join</option>
      <option value="member_leave">Member Leave</option>
      <option value="member_ban">Ban</option>
      <option value="member_unban">Unban</option>
      <option value="member_timeout">Timeout</option>
      <option value="role_change">Role Change</option>
      <option value="message_edit">Message Edit</option>
      <option value="message_delete">Message Delete</option>
      <option value="name_change">Name Change</option>
      <option value="server_update">Server Update</option>
    </select>
    <input id="logSearchKeyword" type="text" placeholder="Keyword..." style="flex:1;min-width:150px" />
    <input id="logSearchStartDate" type="date" style="width:140px" />
    <input id="logSearchEndDate" type="date" style="width:140px" />
    <button class="small" type="button" onclick="searchAuditLogs()">ðŸ” Search</button>
  </div>
  
  <div id="logSearchResults" style="max-height:400px;overflow-y:auto;background:#1b1d20;border-radius:6px;padding:12px">
    <p style="color:#666;text-align:center;margin:0">Enter search criteria and click Search</p>
  </div>
  
  <div id="logSearchPagination" style="display:flex;gap:8px;justify-content:center;margin-top:12px"></div>
</div>

<script>
// Event colors modal
function openEventColorsModal() {
  const defaultColors = {
    ban: '#E74C3C',
    timeout: '#E67E22',
    mute: '#F39C12',
    kick: '#E74C3C',
    join: '#2ECC71',
    leave: '#95A5A6',
    boost: '#F47FFF',
    edit: '#3498DB',
    delete: '#E74C3C',
    roleChange: '#9B59B6',
    nameChange: '#1ABC9C',
    serverUpdate: '#7289DA'
  };
  
  const dataEl = document.getElementById('auditLogData');
  let savedColors = {};
  try { savedColors = JSON.parse(dataEl.getAttribute('data-event-colors').replace(/&quot;/g, '"') || '{}'); } catch {}
  
  const colorLabels = {
    ban: 'Bans/Unbans',
    timeout: 'Timeouts',
    mute: 'Mutes',
    join: 'Member Joins',
    leave: 'Member Leaves',
    boost: 'Boosts',
    edit: 'Message Edits',
    delete: 'Message Deletes',
    roleChange: 'Role Changes',
    nameChange: 'Name Changes',
    serverUpdate: 'Server Updates'
  };
  
  const rows = Object.entries(colorLabels).map(([key, label]) => {
    const color = savedColors[key] || defaultColors[key];
    return '<div style="display:flex;align-items:center;gap:12px;margin-bottom:8px">'
      + '<input type="color" id="eventColor_' + key + '" value="' + color + '" style="width:50px;height:30px;border:none;cursor:pointer" />'
      + '<span style="color:#ddd">' + label + '</span>'
      + '</div>';
  }).join('');
  
  showCustomModal('<div><h3>Event Colors</h3><p style="color:#888;margin-bottom:12px">Customize embed colors for each event type.</p>' + rows + '</div>', () => {
    const colors = {};
    Object.keys(colorLabels).forEach(key => {
      const input = document.getElementById('eventColor_' + key);
      if (input) colors[key] = input.value;
    });
    document.getElementById('auditLogData').setAttribute('data-event-colors', JSON.stringify(colors).replace(/"/g, '&quot;'));
    hideCustomModal();
    alert('Colors updated! Click "Save Member Log Settings" to persist.');
  });
}

// Auto-detect mute roles
function autoDetectMuteRoles() {
  fetch('/api/detect-mute-role')
    .then(r => r.json())
    .then(data => {
      if (data.success && data.roles.length > 0) {
        const ids = data.roles.map(r => r.id).join(', ');
        const names = data.roles.map(r => r.name).join(', ');
        if (confirm('Found mute roles: ' + names + '\\n\\nAdd these to the mute role list?')) {
          document.getElementById('muteRoleIdsInput').value = ids;
        }
      } else {
        alert('No mute roles detected. Try adding them manually.');
      }
    })
    .catch(err => alert('Error: ' + err.message));
}

// Manual cleanup
function manualCleanupLogs() {
  const days = document.getElementById('logRetentionDays').value || 30;
  if (!confirm('Delete all logs older than ' + days + ' days?')) return;
  
  fetch('/api/audit-log-cleanup', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ days: parseInt(days) })
  })
  .then(r => r.json())
  .then(data => {
    if (data.success) {
      alert('Removed ' + data.removed + ' old entries. ' + data.remaining + ' entries remaining.');
      location.reload();
    } else {
      alert('Error: ' + (data.error || 'Unknown error'));
    }
  })
  .catch(err => alert('Error: ' + err.message));
}

// Export logs
function exportAuditLogs() {
  window.location.href = '/api/audit-log-export?format=json';
}

// Search audit logs
let currentSearchPage = 1;
function searchAuditLogs(page = 1) {
  currentSearchPage = page;
  const params = new URLSearchParams();
  
  const userId = document.getElementById('logSearchUser').value.trim();
  const eventType = document.getElementById('logSearchEventType').value;
  const keyword = document.getElementById('logSearchKeyword').value.trim();
  const startDate = document.getElementById('logSearchStartDate').value;
  const endDate = document.getElementById('logSearchEndDate').value;
  
  if (userId) params.append('userId', userId);
  if (eventType) params.append('eventType', eventType);
  if (keyword) params.append('keyword', keyword);
  if (startDate) params.append('startDate', startDate);
  if (endDate) params.append('endDate', endDate);
  params.append('page', page);
  params.append('limit', 25);
  
  fetch('/api/audit-log-history?' + params.toString())
    .then(r => r.json())
    .then(data => {
      const container = document.getElementById('logSearchResults');
      const pagination = document.getElementById('logSearchPagination');
      
      if (!data.success || !data.data.length) {
        container.innerHTML = '<p style="color:#666;text-align:center;margin:0">No results found</p>';
        pagination.innerHTML = '';
        return;
      }
      
      container.innerHTML = '<table style="width:100%;font-size:12px;border-collapse:collapse">'
        + '<tr style="background:#2a2f3a"><th style="padding:8px;text-align:left">Time</th><th style="padding:8px;text-align:left">Event</th><th style="padding:8px;text-align:left">User</th><th style="padding:8px;text-align:left">Details</th></tr>'
        + data.data.map(e => {
          const time = new Date(e.timestamp).toLocaleString();
          return '<tr style="border-bottom:1px solid #333">'
            + '<td style="padding:6px;color:#888">' + time + '</td>'
            + '<td style="padding:6px">' + (e.action || 'Unknown') + '</td>'
            + '<td style="padding:6px">' + (e.userTag || e.userId || 'Unknown') + '</td>'
            + '<td style="padding:6px;color:#aaa">' + (e.details?.summary || '-') + '</td>'
            + '</tr>';
        }).join('')
        + '</table>';
      
      // Pagination
      const { page: p, totalPages } = data.pagination;
      let paginationHtml = '';
      if (p > 1) paginationHtml += '<button class="small" onclick="searchAuditLogs(' + (p-1) + ')">â† Prev</button>';
      paginationHtml += '<span style="color:#888;padding:0 10px">Page ' + p + ' of ' + totalPages + '</span>';
      if (p < totalPages) paginationHtml += '<button class="small" onclick="searchAuditLogs(' + (p+1) + ')">Next â†’</button>';
      pagination.innerHTML = paginationHtml;
    })
    .catch(err => {
      document.getElementById('logSearchResults').innerHTML = '<p style="color:#E74C3C;text-align:center">Error: ' + err.message + '</p>';
    });
}

// Override saveAuditLogSettings to include new fields
const originalSaveAuditLogSettings = typeof saveAuditLogSettings === 'function' ? saveAuditLogSettings : null;
window.saveAuditLogSettings = function() {
  const nameChangesChecked = document.getElementById('logUsernameChanges').checked;
  const bansChecked = document.getElementById('logMemberBans').checked;
  const joinsChecked = document.getElementById('logMemberJoins').checked;
  const deletesChecked = document.getElementById('logMessageDeletes').checked;

  const perEventChannels = {};
  const perEventPings = {};
  let eventColors = {};

  const channelInputs = document.querySelectorAll('[id^="perEventChannel_"]');
  if (channelInputs.length) {
    channelInputs.forEach(input => {
      const eventId = input.id.replace('perEventChannel_', '');
      const value = input.value.trim();
      if (value) perEventChannels[eventId] = value;
    });
  } else if (typeof auditPerEventChannelsDraft !== 'undefined') {
    Object.keys(auditPerEventChannelsDraft || {}).forEach(eventId => {
      const value = (auditPerEventChannelsDraft[eventId] || '').trim();
      if (value) perEventChannels[eventId] = value;
    });
  }

  const pingInputs = document.querySelectorAll('[id^="perEventPing_"]');
  if (pingInputs.length) {
    pingInputs.forEach(input => {
      const eventId = input.id.replace('perEventPing_', '');
      if (input.value.trim()) {
        perEventPings[eventId] = splitIdTokens(input.value);
      }
    });
  } else if (typeof auditPerEventPingsDraft !== 'undefined') {
    Object.keys(auditPerEventPingsDraft || {}).forEach(eventId => {
      const list = Array.isArray(auditPerEventPingsDraft[eventId]) ? auditPerEventPingsDraft[eventId] : splitIdTokens(String(auditPerEventPingsDraft[eventId] || ''));
      if (list.length) perEventPings[eventId] = list;
    });
  }

  // Get event colors
  const dataEl = document.getElementById('auditLogData');
  if (dataEl) {
    try { eventColors = JSON.parse(dataEl.getAttribute('data-event-colors').replace(/&quot;/g, '"') || '{}'); } catch {}
  }

  const settings = {
    enabled: document.getElementById('auditEnabled').checked,
    channelId: document.getElementById('auditChannelId').value.trim(),
    logLevel: document.getElementById('auditLogLevel').value,
    logMessageEdits: document.getElementById('logMessageEdits').checked,
    logMessageDeletes: deletesChecked,
    logMessageBulkDeletes: deletesChecked,
    logMessagePins: document.getElementById('logMessagePins').checked,
    logUsernameChanges: nameChangesChecked,
    logAvatarChanges: document.getElementById('logAvatarChanges').checked,
    logNicknameChanges: nameChangesChecked,
    logRoleChanges: document.getElementById('logRoleChanges').checked,
    logMemberJoins: joinsChecked,
    logMemberLeaves: document.getElementById('logMemberLeaves').checked,
    logMemberBans: bansChecked,
    logMemberUnbans: bansChecked,
    logMemberTimeouts: document.getElementById('logMemberTimeouts').checked,
    logMemberMutes: document.getElementById('logMemberMutes').checked,
    logMemberBoosts: document.getElementById('logMemberBoosts').checked,
    logJoinPosition: joinsChecked,
    logServerUpdates: document.getElementById('logServerUpdates').checked,
    logIntegrations: document.getElementById('logIntegrations').checked,
    warnNewAccounts: document.getElementById('warnNewAccounts').checked,
    newAccountThresholdDays: parseInt(document.getElementById('newAccountThresholdDays').value, 10) || 7,
    excludedChannels: parseIdList('excludedChannelsInput'),
    excludedRoles: parseIdList('excludedRolesInput'),
    excludedUsers: parseIdList('excludedUsersInput'),
    muteRoleIds: parseIdList('muteRoleIdsInput'),
    perEventChannels,
    perEventPings,
    // New settings
    logRetentionDays: parseInt(document.getElementById('logRetentionDays').value, 10) || 30,
    autoCleanupEnabled: document.getElementById('autoCleanupEnabled').checked,
    eventColors,
    alertKeywords: (document.getElementById('alertKeywords').value || '').split(',').map(s => s.trim()).filter(Boolean),
    alertUserId: document.getElementById('alertUserId').value.trim() || null,
    alertEnabled: document.getElementById('alertEnabled').checked,
    dmNotificationsEnabled: document.getElementById('dmNotificationsEnabled').checked,
    dmNotifyUserId: document.getElementById('dmNotifyUserId').value.trim() || null,
    dmNotifyEvents: {
      bans: document.getElementById('dmNotifyBans').checked,
      newAccounts: document.getElementById('dmNotifyNewAccounts').checked,
      serverChanges: document.getElementById('dmNotifyServerChanges').checked,
      botChanges: document.getElementById('dmNotifyBotChanges').checked
    },
    webhookUrl: document.getElementById('webhookUrl').value.trim() || null,
    webhookEnabled: document.getElementById('webhookEnabled').checked
  };

  fetch('/api/audit-log-settings', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(settings)
  })
  .then(r => r.json())
  .then(data => {
    if (data.success) {
      alert('âœ… Member log settings saved!');
      location.reload();
    } else {
      alert('âŒ Error: ' + (data.error || 'Unknown error'));
    }
  })
  .catch(err => alert('âŒ Error: ' + err.message));
};
</script>
`;
}

/* ======================
   RPG DASHBOARD TABS
====================== */
function renderRPGWorldsTab() {
  return `
  <style>
    .worlds-container { display: flex; gap: 20px; min-height: 600px; }
    .worlds-sidebar { width: 280px; background: #0a0e17; border-radius: 8px; padding: 15px; border: 1px solid #2a2a3e; overflow-y: auto; max-height: 600px; }
    .world-item { padding: 12px; margin: 8px 0; background: #1a1f2e; border-radius: 4px; cursor: pointer; border-left: 3px solid transparent; transition: all 0.2s; }
    .world-item.active { border-left-color: #9146ff; background: #2a2f3e; }
    .world-item:hover { background: #2a2f3e; }
    .world-item-name { font-weight: bold; color: #e0e0e0; }
    .world-item-desc { font-size: 11px; color: #888; margin-top: 3px; }
    .content-editor { flex: 1; }
    .entity-type-tabs { display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap; border-bottom: 2px solid #2a2a3e; }
    .entity-type-tab { padding: 10px 15px; cursor: pointer; border-bottom: 3px solid transparent; color: #888; font-size: 13px; transition: all 0.2s; }
    .entity-type-tab.active { color: #f59e0b; border-bottom-color: #f59e0b; }
    .entity-type-tab:hover { color: #e0e0e0; }
    .entity-list-tabs { display: flex; gap: 8px; margin-bottom: 15px; flex-wrap: wrap; }
    .entity-list-tab { padding: 8px 12px; background: #1a1f2e; cursor: pointer; border-radius: 4px; border: 1px solid #2a2a3e; color: #888; font-size: 11px; transition: all 0.2s; }
    .entity-list-tab.active { background: #2a2a3e; color: #f59e0b; border-color: #9146ff; }
    .entity-list-tab:hover { background: #2a2a3e; }
    .form-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .form-group { display: flex; flex-direction: column; }
    .form-group label { font-size: 11px; color: #f59e0b; margin-bottom: 5px; font-weight: bold; text-transform: uppercase; }
    .form-group input, .form-group textarea, .form-group select { background: #1a1f2e; border: 1px solid #2a2a3e; color: #e0e0e0; padding: 8px; border-radius: 4px; font-size: 12px; }
    .form-group input:focus, .form-group textarea:focus, .form-group select:focus { border-color: #9146ff; outline: none; }
    .form-group textarea { min-height: 70px; resize: vertical; }
    .editor-panel { background: #0a0e17; padding: 15px; border-radius: 8px; border: 1px solid #2a2a3e; max-height: 500px; overflow-y: auto; }
    .empty-state { text-align: center; padding: 40px 20px; color: #666; }
  </style>

  <div class="worlds-container">
    <div class="worlds-sidebar">
      <div style="font-weight: bold; color: #f59e0b; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #2a2a3e; text-transform: uppercase; font-size: 12px;">Worlds</div>
      <button class="small" onclick="worldCreateNew()" style="width: 100%; margin-bottom: 12px; background: #9146ff;">+ New World</button>
      <div id="worlds-list" style="max-height: 500px; overflow-y: auto;">
        <div style="color: #666; font-size: 12px; text-align: center; padding: 20px;">No worlds yet</div>
      </div>
    </div>
    
    <div class="content-editor">
      <div id="content-editor-area">
        <div class="empty-state">
          <div style="font-size: 48px; margin-bottom: 10px;">ðŸŒ</div>
          <div>Create or select a world to manage its content</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let worldData = {};
    let currentWorldId = null;
    let currentEntityType = 'monsters';
    let currentEntityId = null;

    const entityConfig = {
      monsters: { title: 'Monsters', icon: 'ðŸ‘¹', fields: [
        { name: 'name', label: 'Name', type: 'text' }, { name: 'type', label: 'Type', type: 'text' },
        { name: 'level', label: 'Level', type: 'number' }, { name: 'health', label: 'Health', type: 'number' },
        { name: 'mana', label: 'Mana', type: 'number' }, { name: 'strength', label: 'STR', type: 'number' },
        { name: 'intelligence', label: 'INT', type: 'number' }, { name: 'wisdom', label: 'WIS', type: 'number' },
        { name: 'dexterity', label: 'DEX', type: 'number' }, { name: 'constitution', label: 'CON', type: 'number' },
        { name: 'charisma', label: 'CHA', type: 'number' }, { name: 'skills', label: 'Skills', type: 'textarea' },
        { name: 'loot', label: 'Loot', type: 'textarea' }, { name: 'behavior', label: 'Behavior', type: 'text' }
      ] },
      items: { title: 'Items', icon: 'ðŸŽ', fields: [
        { name: 'name', label: 'Name', type: 'text' }, { name: 'type', label: 'Type', type: 'text' },
        { name: 'rarity', label: 'Rarity', type: 'text' }, { name: 'value', label: 'Gold', type: 'number' },
        { name: 'weight', label: 'Weight', type: 'number' }, { name: 'effect', label: 'Effect', type: 'textarea' },
        { name: 'requirements', label: 'Requirements', type: 'textarea' }, { name: 'crafting', label: 'Crafting', type: 'textarea' }
      ] },
      npcs: { title: 'NPCs', icon: 'ðŸ¤', fields: [
        { name: 'name', label: 'Name', type: 'text' }, { name: 'title', label: 'Title', type: 'text' },
        { name: 'race', label: 'Race', type: 'text' }, { name: 'age', label: 'Age', type: 'number' },
        { name: 'allegiance', label: 'Faction', type: 'text' }, { name: 'questGiver', label: 'Quest Giver', type: 'checkbox' },
        { name: 'merchant', label: 'Merchant', type: 'checkbox' }, { name: 'sells', label: 'Sells', type: 'textarea' },
        { name: 'buys', label: 'Buys', type: 'textarea' }, { name: 'dialogue', label: 'Dialogue', type: 'textarea' }
      ] },
      locations: { title: 'Locations', icon: 'ðŸ“', fields: [
        { name: 'name', label: 'Name', type: 'text' }, { name: 'type', label: 'Type', type: 'text' },
        { name: 'level', label: 'Level', type: 'number' }, { name: 'difficulty', label: 'Difficulty', type: 'text' },
        { name: 'areas', label: 'Areas', type: 'number' }, { name: 'inhabitants', label: 'Inhabitants', type: 'textarea' },
        { name: 'treasures', label: 'Treasures', type: 'textarea' }, { name: 'boss', label: 'Boss', type: 'text' },
        { name: 'lore', label: 'Lore', type: 'textarea' }
      ] },
      dungeons: { title: 'Dungeons', icon: 'ðŸ›ï¸', fields: [
        { name: 'name', label: 'Name', type: 'text' }, { name: 'level', label: 'Level', type: 'number' },
        { name: 'difficulty', label: 'Difficulty', type: 'text' }, { name: 'floors', label: 'Floors', type: 'number' },
        { name: 'boss', label: 'Boss', type: 'text' }, { name: 'minPlayers', label: 'Min Players', type: 'number' },
        { name: 'maxPlayers', label: 'Max Players', type: 'number' }, { name: 'timeLimit', label: 'Time Limit (min)', type: 'number' },
        { name: 'rewards', label: 'Rewards', type: 'textarea' }, { name: 'description', label: 'Description', type: 'textarea' }
      ] },
      raids: { title: 'Raids', icon: 'âš”ï¸', fields: [
        { name: 'name', label: 'Name', type: 'text' }, { name: 'level', label: 'Level', type: 'number' },
        { name: 'difficulty', label: 'Difficulty', type: 'text' }, { name: 'phases', label: 'Phases', type: 'number' },
        { name: 'bosses', label: 'Bosses', type: 'textarea' }, { name: 'minPlayers', label: 'Min Players', type: 'number' },
        { name: 'maxPlayers', label: 'Max Players', type: 'number' }, { name: 'timeLimit', label: 'Time Limit (min)', type: 'number' },
        { name: 'rewards', label: 'Rewards', type: 'textarea' }, { name: 'description', label: 'Description', type: 'textarea' }
      ] },
      worldBosses: { title: 'World Bosses', icon: 'ðŸ‘‘', fields: [
        { name: 'name', label: 'Name', type: 'text' }, { name: 'level', label: 'Level', type: 'number' },
        { name: 'health', label: 'Health', type: 'number' }, { name: 'mana', label: 'Mana', type: 'number' },
        { name: 'strength', label: 'STR', type: 'number' }, { name: 'intelligence', label: 'INT', type: 'number' },
        { name: 'dexterity', label: 'DEX', type: 'number' }, { name: 'wisdom', label: 'WIS', type: 'number' },
        { name: 'constitution', label: 'CON', type: 'number' }, { name: 'charisma', label: 'CHA', type: 'number' },
        { name: 'abilities', label: 'Abilities', type: 'textarea' }, { name: 'spawnLocation', label: 'Spawn Location', type: 'text' },
        { name: 'respawnTime', label: 'Respawn Time (hours)', type: 'number' }, { name: 'rewards', label: 'Rewards', type: 'textarea' }
      ] },
      quests: { title: 'Quests', icon: 'ðŸ“œ', fields: [
        { name: 'name', label: 'Name', type: 'text' }, { name: 'type', label: 'Type', type: 'text' },
        { name: 'level', label: 'Level', type: 'number' }, { name: 'questGiver', label: 'Quest Giver', type: 'text' },
        { name: 'description', label: 'Description', type: 'textarea' }, { name: 'objectives', label: 'Objectives', type: 'textarea' },
        { name: 'rewards', label: 'Rewards', type: 'textarea' }, { name: 'expReward', label: 'EXP Reward', type: 'number' },
        { name: 'goldReward', label: 'Gold Reward', type: 'number' }, { name: 'prerequisites', label: 'Prerequisites', type: 'textarea' },
        { name: 'repeatable', label: 'Repeatable', type: 'checkbox' }, { name: 'timeLimit', label: 'Time Limit (min)', type: 'number' }
      ] }
    };

    async function worldLoad() {
      try {
        const resp = await fetch('/api/rpg/worlds');
        const data = await resp.json();
        worldData = {};
        if (data.worlds && Array.isArray(data.worlds)) {
          data.worlds.forEach(w => { worldData[w.id] = w; });
        }
        worldRender();
      } catch(e) { console.error(e); }
    }

    function worldRender() {
      const list = document.getElementById('worlds-list');
      if (!list) return;
      let html = '';
      Object.keys(worldData).forEach(id => {
        const w = worldData[id];
        html += '<div class="world-item ' + (currentWorldId === id ? 'active' : '') + '" onclick="worldSelect(\\'' + id + '\\')">' +
                '<div class="world-item-name">' + (w.name || 'Unnamed') + ' <span onclick="event.stopPropagation(); worldDelete(\\'' + id + '\\')" style="float: right; color: #e74c3c; cursor: pointer; font-size: 14px;">âœ•</span></div>' +
                '<div class="world-item-desc">Tier ' + (w.tier || 1) + '</div></div>';
      });
      list.innerHTML = html || '<div style="color: #666; font-size: 12px; text-align: center; padding: 20px;">No worlds</div>';
    }

    function worldCreateNew() {
      const name = prompt('World name:');
      if (!name) return;
      const tier = parseInt(prompt('World tier:', '1')) || 1;
      const newWorld = {
        id: 'world_' + Date.now(),
        name: name,
        tier: tier,
        entities: { monsters: {}, items: {}, npcs: {}, locations: {}, dungeons: {}, raids: {}, worldBosses: {}, quests: {} },
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      fetch('/api/rpg/worlds', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newWorld)
      }).then(r => r.json()).then(data => {
        if (data.success) worldLoad();
      }).catch(e => console.error('Error creating world:', e));
    }

    function worldDelete(id) {
      if (!confirm('Delete this world?')) return;
      fetch('/api/rpg/worlds/' + id, { method: 'DELETE' })
        .then(r => r.json())
        .then(data => {
          if (data.success) {
            if (currentWorldId === id) currentWorldId = null;
            worldLoad();
          }
        }).catch(e => console.error('Error deleting world:', e));
    }

    function worldEdit(id) {
      const world = worldData[id];
      const newName = prompt('World name:', world.name);
      if (!newName) return;
      const newTier = parseInt(prompt('World tier:', world.tier)) || world.tier;
      world.name = newName;
      world.tier = newTier;
      world.updatedAt = new Date().toISOString();
      fetch('/api/rpg/worlds/' + id, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(world)
      }).then(r => r.json()).then(data => {
        if (data.success) worldLoad();
      }).catch(e => console.error('Error updating world:', e));
    }

    function worldSelect(id) {
      currentWorldId = id;
      currentEntityType = 'monsters';
      worldRender();
      renderEntityEditor();
    }

    function renderEntityEditor() {
      const area = document.getElementById('content-editor-area');
      if (!area) return;
      if (!currentWorldId) {
        area.innerHTML = '<div class="empty-state"><div style="font-size: 48px;">ðŸŒ</div><div>Select a world</div></div>';
        return;
      }
      const world = worldData[currentWorldId];
      if (!world.entities) world.entities = { monsters: {}, items: {}, npcs: {}, locations: {}, dungeons: {}, raids: {}, worldBosses: {}, quests: {} };
      let html = '<div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">';
      html += '<h3 style="color: #f59e0b; margin: 0;">' + world.name + ' (Tier ' + (world.tier || 1) + ')</h3>';
      html += '<button class="small" onclick="worldEdit(\\'' + currentWorldId + '\\')" style="background: #f59e0b;">âœï¸ Edit World</button>';
      html += '</div>';
      html += '<div class="entity-type-tabs">';
      ['monsters', 'items', 'npcs', 'locations', 'dungeons', 'raids', 'worldBosses', 'quests'].forEach(type => {
        const cfg = entityConfig[type];
        html += '<div class="entity-type-tab ' + (currentEntityType === type ? 'active' : '') + '" onclick="switchEntityType(\\'' + type + '\\')">' + cfg.icon + ' ' + cfg.title + '</div>';
      });
      html += '</div>';
      const entities = world.entities[currentEntityType] || {};
      const cfg = entityConfig[currentEntityType];
      html += '<div class="entity-list-tabs"><button class="small" onclick="createEntity()" style="background: #9146ff;">+ New ' + cfg.title.slice(0, -1) + '</button>';
      Object.keys(entities).forEach(id => {
        const e = entities[id];
        html += '<div class="entity-list-tab ' + (currentEntityId === id ? 'active' : '') + '" onclick="selectEntity(\\'' + id + '\\')">' +
                (e.name || 'Unnamed').substring(0, 10) + ' <span onclick="event.stopPropagation(); deleteEntity(\\'' + id + '\\')">âœ•</span></div>';
      });
      html += '</div>';
      if (currentEntityId && entities[currentEntityId]) {
        const entity = entities[currentEntityId];
        html += '<div class="editor-panel"><h4 style="color: #f59e0b;">' + cfg.title.slice(0, -1) + '</h4><div class="form-grid">';
        cfg.fields.forEach(field => {
          let input = '';
          if (field.type === 'checkbox') input = '<label><input type="checkbox" id="entity_' + field.name + '" ' + (entity[field.name] ? 'checked' : '') + '> ' + field.label + '</label>';
          else if (field.type === 'textarea') input = '<textarea id="entity_' + field.name + '">' + (entity[field.name] || '') + '</textarea>';
          else if (field.type === 'number') input = '<input type="number" id="entity_' + field.name + '" value="' + (entity[field.name] || 0) + '">';
          else input = '<input type="text" id="entity_' + field.name + '" value="' + (entity[field.name] || '') + '">';
          html += '<div class="form-group"><label>' + field.label + '</label>' + input + '</div>';
        });
        html += '</div><button class="small" onclick="saveEntity()" style="margin-top: 12px; background: #28a745;">ðŸ’¾ Save</button></div>';
      } else {
        html += '<div class="empty-state" style="margin-top: 20px;"><div style="font-size: 36px;">' + cfg.icon + '</div></div>';
      }
      area.innerHTML = html;
    }

    function switchEntityType(type) {
      currentEntityType = type;
      currentEntityId = null;
      renderEntityEditor();
    }

    function createEntity() {
      const world = worldData[currentWorldId];
      if (!world.entities[currentEntityType]) world.entities[currentEntityType] = {};
      const id = 'e_' + Date.now();
      world.entities[currentEntityType][id] = { id, name: 'New ' + entityConfig[currentEntityType].title.slice(0, -1) };
      selectEntity(id);
    }

    function selectEntity(id) {
      currentEntityId = id;
      renderEntityEditor();
    }

    function deleteEntity(id) {
      if (!confirm('Delete?')) return;
      const world = worldData[currentWorldId];
      delete world.entities[currentEntityType][id];
      if (currentEntityId === id) currentEntityId = null;
      renderEntityEditor();
    }

    function saveEntity() {
      const world = worldData[currentWorldId];
      const entity = world.entities[currentEntityType][currentEntityId];
      const cfg = entityConfig[currentEntityType];
      cfg.fields.forEach(field => {
        const el = document.getElementById('entity_' + field.name);
        if (el) entity[field.name] = el.type === 'checkbox' ? el.checked : el.value;
      });
      fetch('/api/rpg/worlds/' + currentWorldId, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(world)
      }).then(r => r.json()).then(data => {
        if (data.success && typeof showNotification === 'function') showNotification('âœ… Saved!');
      });
    }

    // Load worlds on page load
    worldLoad();
  </script>
  `;
}


function renderRPGQuestsTab() {
  return `
<div class="card">
  <h2>âš”ï¸ RPG Quests Editor</h2>
  <p style="color:#b0b0b0">Create and manage RPG quests with branching outcomes</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:15px">
    <div>
      <h3 style="color:#9146ff">Create New Quest</h3>
      <input id="quest-title" placeholder="Quest title" style="margin-bottom:8px">
      <textarea id="quest-description" placeholder="Quest description" style="margin-bottom:8px;height:80px"></textarea>
      <input id="quest-rewards" placeholder="Rewards (e.g., 100 gold, 10 XP)" style="margin-bottom:8px">
      <button onclick="createQuest()" style="margin-top:8px">âš”ï¸ Create Quest</button>
    </div>
    <div>
      <h3 style="color:#9146ff">Existing Quests</h3>
      <div id="quests-list" style="max-height:300px;overflow-y:auto;background:#1a1a1d;padding:10px;border-radius:4px;border:1px solid #3a3a42">
        <p style="color:#999">Loading quests...</p>
      </div>
    </div>
  </div>
</div>

<script>
function loadQuests() {
  fetch('/api/rpg/quests')
    .then(r => r.json())
    .then(data => {
      const list = document.getElementById('quests-list');
      if (!data.quests || data.quests.length === 0) {
        list.innerHTML = '<p style="color:#999;font-style:italic">No quests created yet</p>';
      } else {
        list.innerHTML = data.quests.map(q => \`
          <div style="padding:10px;background:#2a2f3a;border-radius:4px;margin-bottom:8px">
            <div style="font-weight:bold;color:#e0e0e0">\${q.title}</div>
            <div style="font-size:12px;color:#999">\${q.description.substring(0, 50)}...</div>
            <button class="small" style="margin-top:6px;width:auto" onclick="editQuest('\${q.id}')">âœï¸ Edit</button>
            <button class="small danger" style="margin-top:6px;width:auto;margin-left:4px" onclick="deleteQuest('\${q.id}')">ðŸ—‘ï¸ Delete</button>
          </div>
        \`).join('');
      }
    })
    .catch(err => {
      document.getElementById('quests-list').innerHTML = '<p style="color:#ef5350">Error loading quests</p>';
    });
}

function createQuest() {
  const title = document.getElementById('quest-title').value;
  const description = document.getElementById('quest-description').value;
  const rewards = document.getElementById('quest-rewards').value;
  
  if (!title || !description) {
    alert('âŒ Please fill title and description');
    return;
  }
  
  fetch('/api/rpg/quests', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title, description, rewards })
  })
  .then(r => r.json())
  .then(data => {
    if (data.success) {
      alert('âœ… Quest created!');
      document.getElementById('quest-title').value = '';
      document.getElementById('quest-description').value = '';
      document.getElementById('quest-rewards').value = '';
      loadQuests();
    } else {
      alert('âŒ Error: ' + (data.error || 'Unknown'));
    }
  })
  .catch(err => alert('âŒ Error: ' + err.message));
}

function deleteQuest(id) {
  if (!confirm('Delete this quest?')) return;
  fetch('/api/rpg/quests/' + id, { method: 'DELETE' })
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        alert('âœ… Quest deleted');
        loadQuests();
      } else {
        alert('âŒ Error: ' + (data.error || 'Unknown'));
      }
    })
    .catch(err => alert('âŒ Error: ' + err.message));
}

function editQuest(id) {
  alert('âœï¸ Edit feature coming soon!');
}

loadQuests();
</script>
`;
}

function renderRPGValidatorsTab() {
  return `
<div class="card">
  <h2>âœ… RPG Content Validation</h2>
  <p style="color:#b0b0b0">Validate all RPG content and detect issues</p>
  <div style="margin-top:15px">
    <button onclick="runValidation()" style="margin-right:8px">ðŸ” Run Full Validation</button>
    <button onclick="checkDependencies()">ðŸ”— Check Dependencies</button>
    <button onclick="checkForCycles()">ðŸ”„ Detect Cycles</button>
  </div>
  <div id="validation-results" style="margin-top:15px;padding:15px;background:#1a1a1d;border:1px solid #3a3a42;border-radius:4px;display:none">
    <h3 id="validation-status" style="color:#9146ff;margin-top:0"></h3>
    <div id="validation-output" style="max-height:400px;overflow-y:auto">
      <p style="color:#999">Results will appear here...</p>
    </div>
  </div>
</div>

<script>
function runValidation() {
  const results = document.getElementById('validation-results');
  const status = document.getElementById('validation-status');
  const output = document.getElementById('validation-output');
  
  status.textContent = 'â³ Validating...';
  results.style.display = 'block';
  output.innerHTML = '<p style="color:#999">Validating content...</p>';
  
  fetch('/api/rpg/validate')
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        const issues = data.issues || [];
        const hasErrors = issues.some(i => i.severity === 'error');
        status.textContent = hasErrors ? 'âŒ Validation Failed' : 'âœ… Validation Passed';
        status.style.color = hasErrors ? '#ef5350' : '#4caf50';
        
        if (issues.length === 0) {
          output.innerHTML = '<p style="color:#4caf50"><b>âœ… All content is valid!</b></p>';
        } else {
          output.innerHTML = '<div>' + issues.map(i => \`
            <div style="padding:10px;margin-bottom:8px;background:\${i.severity === 'error' ? '#2f1a1a' : '#2a2f1f'};border-left:3px solid \${i.severity === 'error' ? '#ef5350' : '#ffca28'};border-radius:4px">
              <div style="font-weight:bold;color:\${i.severity === 'error' ? '#ef5350' : '#ffca28'}">\${i.severity.toUpperCase()}: \${i.message}</div>
              <div style="font-size:12px;color:#999;margin-top:4px">\${i.details || ''}</div>
            </div>
          \`).join('') + '</div>';
        }
      } else {
        status.textContent = 'âŒ Validation Error';
        status.style.color = '#ef5350';
        output.innerHTML = '<p style="color:#ef5350">Error: ' + (data.error || 'Unknown') + '</p>';
      }
    })
    .catch(err => {
      status.textContent = 'âŒ Error';
      status.style.color = '#ef5350';
      output.innerHTML = '<p style="color:#ef5350">Error: ' + err.message + '</p>';
    });
}

function checkDependencies() {
  alert('ðŸ”— Dependency check feature coming soon!');
}

function checkForCycles() {
  alert('ðŸ”„ Cycle detection feature coming soon!');
}
</script>
`;
}

function renderRPGSimulatorsTab() {
  return `
<div class="card">
  <h2>ðŸŽ² RPG Simulators & Testing</h2>
  <p style="color:#b0b0b0">Test quests, combat, and world scenarios</p>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-top:15px">
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">âš”ï¸ Combat Simulator</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Simulate turn-based combat between characters</p>
      <button class="small" onclick="simulateCombat()" style="width:100%;margin-top:8px">ðŸŽ² Simulate Combat</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">âš”ï¸ Quest Simulator</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Preview quest outcomes and branching</p>
      <button class="small" onclick="simulateQuest()" style="width:100%;margin-top:8px">ðŸŽ² Simulate Quest</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸŒ World State Simulator</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Generate and preview daily world states</p>
      <button class="small" onclick="simulateWorldState()" style="width:100%;margin-top:8px">ðŸŽ² Simulate World</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸš© Flag Tester</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Test flag conditions and cascades</p>
      <button class="small" onclick="testFlags()" style="width:100%;margin-top:8px">ðŸŽ² Test Flags</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸ“Š Level Analysis</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Analyze player stats at any level</p>
      <button class="small" onclick="openLevelAnalyzer()" style="width:100%;margin-top:8px">ðŸ“Š Analyze Level</button>
    </div>
  </div>

  <div id="level-analyzer" style="margin-top:20px;padding:15px;background:#1a1a1d;border:1px solid #3a3a42;border-radius:4px;display:none">
    <h3 style="color:#9146ff;margin-top:0">ðŸ“Š Level Analysis Tool</h3>
    <p style="color:#b0b0b0;font-size:13px;margin:8px 0">Includes stats from all quests below this level + weapon bonuses</p>
    <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:15px;margin-top:15px">
      <div>
        <label style="color:#b0b0b0;display:block;margin-bottom:6px;font-weight:500">Player Level</label>
        <input type="number" id="analysisLevel" min="1" max="999" value="50" style="width:100%;padding:10px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0">
      </div>
      <div>
        <label style="color:#b0b0b0;display:block;margin-bottom:6px;font-weight:500">Select Quest</label>
        <select id="analysisQuest" style="width:100%;padding:10px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0">
          <option value="">Loading quests...</option>
        </select>
      </div>
      <div>
        <label style="color:#b0b0b0;display:block;margin-bottom:6px;font-weight:500">Weapon (Optional)</label>
        <select id="analysisWeapon" style="width:100%;padding:10px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0">
          <option value="">None</option>
          <option value="iron_sword">Iron Sword</option>
          <option value="steel_sword">Steel Sword</option>
          <option value="wooden_staff">Wooden Staff</option>
          <option value="iron_axe">Iron Axe</option>
        </select>
      </div>
    </div>
    <button onclick="analyzeLevel()" style="width:100%;margin-top:15px;padding:12px;background:#9146ff;border:none;border-radius:4px;color:white;font-weight:bold;cursor:pointer">
      ðŸ” Analyze Level & Quest Difficulty
    </button>
    <div id="analysis-results" style="margin-top:15px;display:none">
      <div style="background:#0a0a0c;padding:15px;border-radius:4px;border:1px solid #3a3a42">
        <h4 style="color:#9146ff;margin-top:0">Analysis Results</h4>
        <div id="analysis-content" style="color:#e0e0e0;line-height:1.6"></div>
      </div>
    </div>
  </div>
  
  <div id="simulator-results" style="margin-top:20px;padding:15px;background:#1a1a1d;border:1px solid #3a3a42;border-radius:4px;display:none">
    <h3 id="simulator-title" style="color:#9146ff;margin-top:0">Simulation Results</h3>
    <div id="simulator-output" style="max-height:500px;overflow-y:auto">
      <p style="color:#999">Results will appear here...</p>
    </div>
  </div>
</div>

<script>
function showResults(title, content) {
  const results = document.getElementById('simulator-results');
  document.getElementById('simulator-title').textContent = title;
  document.getElementById('simulator-output').innerHTML = content;
  results.style.display = 'block';
  results.scrollIntoView({ behavior: 'smooth' });
}

function simulateCombat() {
  fetch('/api/rpg/simulators/combat')
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        const html = '<pre style="background:#0a0a0c;padding:12px;border-radius:4px;overflow-x:auto;color:#6ab7ff">' + 
          JSON.stringify(data.result, null, 2) + '</pre>';
        showResults('âš”ï¸ Combat Simulation', html);
      } else {
        showResults('âŒ Error', '<p style="color:#ef5350">' + (data.error || 'Unknown error') + '</p>');
      }
    })
    .catch(err => showResults('âŒ Error', '<p style="color:#ef5350">' + err.message + '</p>'));
}

function simulateQuest() {
  fetch('/api/rpg/simulators/quest')
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        const html = '<pre style="background:#0a0a0c;padding:12px;border-radius:4px;overflow-x:auto;color:#6ab7ff">' + 
          JSON.stringify(data.result, null, 2) + '</pre>';
        showResults('âš”ï¸ Quest Simulation', html);
      } else {
        showResults('âŒ Error', '<p style="color:#ef5350">' + (data.error || 'Unknown error') + '</p>');
      }
    })
    .catch(err => showResults('âŒ Error', '<p style="color:#ef5350">' + err.message + '</p>'));
}

function simulateWorldState() {
  fetch('/api/rpg/simulators/world')
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        const html = '<pre style="background:#0a0a0c;padding:12px;border-radius:4px;overflow-x:auto;color:#6ab7ff">' + 
          JSON.stringify(data.result, null, 2) + '</pre>';
        showResults('ðŸŒ World State Simulation', html);
      } else {
        showResults('âŒ Error', '<p style="color:#ef5350">' + (data.error || 'Unknown error') + '</p>');
      }
    })
    .catch(err => showResults('âŒ Error', '<p style="color:#ef5350">' + err.message + '</p>'));
}

function testFlags() {
  fetch('/api/rpg/simulators/flags')
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        const html = '<pre style="background:#0a0a0c;padding:12px;border-radius:4px;overflow-x:auto;color:#6ab7ff">' + 
          JSON.stringify(data.result, null, 2) + '</pre>';
        showResults('ðŸš© Flag Test Results', html);
      } else {
        showResults('âŒ Error', '<p style="color:#ef5350">' + (data.error || 'Unknown error') + '</p>');
      }
    })
    .catch(err => showResults('âŒ Error', '<p style="color:#ef5350">' + err.message + '</p>'));
}

function openLevelAnalyzer() {
  const analyzer = document.getElementById('level-analyzer');
  analyzer.style.display = 'block';
  analyzer.scrollIntoView({ behavior: 'smooth' });
  
  // Load quests
  fetch('/api/rpg/quests')
    .then(r => r.json())
    .then(data => {
      if (data.quests && data.quests.length > 0) {
        const select = document.getElementById('analysisQuest');
        select.innerHTML = '<option value="">Choose a quest...</option>';
        data.quests.forEach(quest => {
          const option = document.createElement('option');
          option.value = JSON.stringify(quest);
          option.textContent = quest.name + ' (Lvl ' + quest.minLevel + ')';
          select.appendChild(option);
        });
      } else {
        const select = document.getElementById('analysisQuest');
        select.innerHTML = '<option value="">No quests found</option>';
        console.error('No quests loaded from API', data);
      }
    })
    .catch(err => {
      console.error('Failed to load quests:', err);
      const select = document.getElementById('analysisQuest');
      select.innerHTML = '<option value="">Error loading quests</option>';
    });
}

function analyzeLevel() {
  const level = parseInt(document.getElementById('analysisLevel').value);
  const questData = document.getElementById('analysisQuest').value;
  const weaponId = document.getElementById('analysisWeapon').value;
  
  if (!questData) {
    alert('Please select a quest');
    return;
  }
  
  const quest = JSON.parse(questData);
  
  fetch('/api/rpg/analyze-level', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ level, quest, weaponId: weaponId || null })
  })
    .then(r => r.json())
    .then(data => {
      if (data.success) {
        displayAnalysisResults(data.analysis);
      } else {
        alert('Error: ' + (data.error || 'Unknown error'));
      }
    })
    .catch(err => alert('Error: ' + err.message));
}

function displayAnalysisResults(analysis) {
  const content = document.getElementById('analysis-content');
  const results = document.getElementById('analysis-results');
  
  let html = '<table style="width:100%;border-collapse:collapse">';
  html += '<tr style="background:#2a2f3a"><td style="padding:8px;border:1px solid #3a3a42;color:#9146ff"><strong>Stat</strong></td><td style="padding:8px;border:1px solid #3a3a42;color:#9146ff"><strong>Value</strong></td></tr>';
  
  // Player stats
  html += '<tr><td colspan="2" style="padding:10px;border:1px solid #3a3a42;background:#1f2a1f;color:#b0b0b0"><strong>ðŸ“Š Player Stats at Level ' + analysis.playerLevel + '</strong></td></tr>';
  html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Health</td><td style="padding:8px;border:1px solid #3a3a42;color:#57f287">' + analysis.playerStats.health + '</td></tr>';
  html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Attack Power</td><td style="padding:8px;border:1px solid #3a3a42;color:#57f287">' + analysis.playerStats.attackPower + '</td></tr>';
  html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Defense</td><td style="padding:8px;border:1px solid #3a3a42;color:#57f287">' + analysis.playerStats.defense + '</td></tr>';
  html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Critical Chance</td><td style="padding:8px;border:1px solid #3a3a42;color:#57f287">' + (analysis.playerStats.critChance * 100).toFixed(1) + '%</td></tr>';
  
  // Quest stat rewards
  if (analysis.completedQuestsBelow && analysis.completedQuestsBelow > 0) {
    html += '<tr><td colspan="2" style="padding:10px;border:1px solid #3a3a42;background:#1f2a1f;color:#b0b0b0"><strong>ðŸŽ Bonuses from ' + analysis.completedQuestsBelow + ' Quest(s) Below This Level</strong></td></tr>';
    if (Object.keys(analysis.questStatRewards).length > 0) {
      Object.entries(analysis.questStatRewards).forEach(([stat, value]) => {
        if (value > 0) {
          html += '<tr><td style="padding:8px;border:1px solid #3a3a42">' + stat.charAt(0).toUpperCase() + stat.slice(1) + '</td><td style="padding:8px;border:1px solid #3a3a42;color:#57f287">+' + value + '</td></tr>';
        }
      });
    } else {
      html += '<tr><td colspan="2" style="padding:8px;border:1px solid #3a3a42">No stat rewards from quests</td></tr>';
    }
  }
  
  // Enemy stats
  html += '<tr><td colspan="2" style="padding:10px;border:1px solid #3a3a42;background:#2a1a1a;color:#b0b0b0"><strong>âš”ï¸ Quest Requirements</strong></td></tr>';
  html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Quest Name</td><td style="padding:8px;border:1px solid #3a3a42;color:#9aa4ff"><strong>' + analysis.quest.name + '</strong></td></tr>';
  html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Recommended Level</td><td style="padding:8px;border:1px solid #3a3a42;color:#ffca28">' + analysis.quest.minLevel + '</td></tr>';
  if (analysis.quest.type === 'combat' && analysis.enemyStats) {
    html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Enemy Health</td><td style="padding:8px;border:1px solid #3a3a42;color:#ef5350">' + analysis.enemyStats.health + '</td></tr>';
    html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Enemy Attack</td><td style="padding:8px;border:1px solid #3a3a42;color:#ef5350">' + analysis.enemyStats.attackPower + '</td></tr>';
    html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Enemy Defense</td><td style="padding:8px;border:1px solid #3a3a42;color:#ef5350">' + analysis.enemyStats.defense + '</td></tr>';
  }
  
  // Difficulty assessment
  html += '<tr><td colspan="2" style="padding:10px;border:1px solid #3a3a42;background:#1a1f2a;color:#b0b0b0"><strong>ðŸ“ˆ Difficulty Assessment</strong></td></tr>';
  const difficulty = analysis.difficulty;
  const diffColor = difficulty === 'Too Easy' ? '#57f287' : (difficulty === 'Moderate' ? '#ffca28' : '#ef5350');
  html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Difficulty</td><td style="padding:8px;border:1px solid #3a3a42;color:' + diffColor + '"><strong>' + difficulty + '</strong></td></tr>';
  html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Expected Outcome</td><td style="padding:8px;border:1px solid #3a3a42;color:#6ab7ff">' + analysis.outcome + '</td></tr>';
  
  if (analysis.damageComparison) {
    html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Player DPS</td><td style="padding:8px;border:1px solid #3a3a42;color:#57f287">' + analysis.damageComparison.playerDPS.toFixed(2) + '</td></tr>';
    if (analysis.enemyStats) {
      html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Enemy DPS</td><td style="padding:8px;border:1px solid #3a3a42;color:#ef5350">' + analysis.damageComparison.enemyDPS.toFixed(2) + '</td></tr>';
      html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Estimated Turns to Win</td><td style="padding:8px;border:1px solid #3a3a42;color:#9aa4ff">' + Math.ceil(analysis.damageComparison.turnsToWin) + '</td></tr>';
    }
  }
  
  // Rewards section
  if (analysis.questRewards) {
    html += '<tr><td colspan="2" style="padding:10px;border:1px solid #3a3a42;background:#1a2a1f;color:#b0b0b0"><strong>ðŸŽ Rewards</strong></td></tr>';
    html += '<tr><td style="padding:8px;border:1px solid #3a3a42">XP Reward</td><td style="padding:8px;border:1px solid #3a3a42;color:#6ab7ff">ðŸ’› ' + analysis.questRewards.xp + ' XP</td></tr>';
    html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Gold Reward</td><td style="padding:8px;border:1px solid #3a3a42;color:#ffd700">ðŸª™ ' + analysis.questRewards.gold + ' Gold</td></tr>';
    if (analysis.questRewards.items && analysis.questRewards.items.length > 0) {
      html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Items</td><td style="padding:8px;border:1px solid #3a3a42;color:#9aa4ff">ðŸ“¦ ' + analysis.questRewards.items.length + ' item(s)</td></tr>';
    }
  }
  
  // Value assessment
  if (analysis.rewardEfficiency !== undefined) {
    html += '<tr><td colspan="2" style="padding:10px;border:1px solid #3a3a42;background:#2a1f1a;color:#b0b0b0"><strong>ðŸ’° Value Assessment</strong></td></tr>';
    html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Reward Efficiency</td><td style="padding:8px;border:1px solid #3a3a42;color:#ffca28">' + analysis.rewardEfficiency + '</td></tr>';
    html += '<tr><td style="padding:8px;border:1px solid #3a3a42">Overall Value</td><td style="padding:8px;border:1px solid #3a3a42;color:#ffca28"><strong>' + analysis.valueAssessment + '</strong></td></tr>';
  }
  
  html += '</table>';
  
  content.innerHTML = html;
  results.style.display = 'block';
}
</script>
`;
}

function renderRPGEntitiesTab() {
  return `
<div class="card">
  <h2>ðŸ‘¥ Entities Editor</h2>
  <p style="color:#b0b0b0">Create and manage Classes, Skills, Items, and Professions</p>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-top:15px">
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸ“š Classes</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Define playable character classes</p>
      <button class="small" onclick="manageClasses()" style="width:100%;margin-top:8px">âœï¸ Manage Classes</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">âš¡ Skills</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Define skills and abilities</p>
      <button class="small" onclick="manageSkills()" style="width:100%;margin-top:8px">âœï¸ Manage Skills</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸŽ Items</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Create equipment and inventory items</p>
      <button class="small" onclick="manageItems()" style="width:100%;margin-top:8px">âœï¸ Manage Items</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸ’¼ Professions</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Define character professions and trades</p>
      <button class="small" onclick="manageProfessions()" style="width:100%;margin-top:8px">âœï¸ Manage Professions</button>
    </div>
  </div>
</div>

<script>
function manageClasses() { alert('ðŸ“š Classes management coming soon!'); }
function manageSkills() { alert('âš¡ Skills management coming soon!'); }
function manageItems() { alert('ðŸŽ Items management coming soon!'); }
function manageProfessions() { alert('ðŸ’¼ Professions management coming soon!'); }
</script>
`;
}

function renderRPGSystemsTab() {
  return `
<div class="card">
  <h2>âš™ï¸ Game Systems</h2>
  <p style="color:#b0b0b0">Configure core game systems and mechanics</p>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(250px,1fr));gap:12px;margin-top:15px">
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸ† Leveling System</div>
      <p style="font-size:13px;color:#999;margin:8px 0">EXP curves, level caps, progression</p>
      <button class="small" onclick="configureLeveling()" style="width:100%;margin-top:8px">âš™ï¸ Configure</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸ’° Economy</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Currency, prices, shops, vendors</p>
      <button class="small" onclick="configureEconomy()" style="width:100%;margin-top:8px">âš™ï¸ Configure</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸŽ¯ Combat Mechanics</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Damage, resistance, critical hits</p>
      <button class="small" onclick="configureCombat()" style="width:100%;margin-top:8px">âš™ï¸ Configure</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸŽ’ Inventory</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Slots, weight, stacking rules</p>
      <button class="small" onclick="configureInventory()" style="width:100%;margin-top:8px">âš™ï¸ Configure</button>
    </div>
  </div>
</div>

<script>
function configureLeveling() { alert('ðŸ† Leveling configuration coming soon!'); }
function configureEconomy() { alert('ðŸ’° Economy configuration coming soon!'); }
function configureCombat() { alert('ðŸŽ¯ Combat configuration coming soon!'); }
function configureInventory() { alert('ðŸŽ’ Inventory configuration coming soon!'); }
</script>
`;
}

function renderRPGAITab() {
  return `
<div class="card">
  <h2>ðŸ¤– AI & Combat Editor</h2>
  <p style="color:#b0b0b0">Configure AI behavior profiles and combat settings</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:15px">
    <div>
      <h3 style="color:#9146ff">AI Behavior Profiles</h3>
      <div style="background:#1a1a1d;padding:10px;border:1px solid #3a3a42;border-radius:4px;margin-bottom:8px">
        <div style="padding:10px;background:#2a2f3a;border-radius:4px;margin-bottom:6px">
          <div style="font-weight:bold;color:#e0e0e0">âš”ï¸ Aggressive</div>
          <div style="font-size:12px;color:#999">High risk, offensive tactics</div>
        </div>
        <div style="padding:10px;background:#2a2f3a;border-radius:4px;margin-bottom:6px">
          <div style="font-weight:bold;color:#e0e0e0">ðŸ›¡ï¸ Defensive</div>
          <div style="font-size:12px;color:#999">Low risk, protective stance</div>
        </div>
        <div style="padding:10px;background:#2a2f3a;border-radius:4px;margin-bottom:6px">
          <div style="font-weight:bold;color:#e0e0e0">ðŸŽ¯ Balanced</div>
          <div style="font-size:12px;color:#999">Mixed offense and defense</div>
        </div>
        <div style="padding:10px;background:#2a2f3a;border-radius:4px;margin-bottom:6px">
          <div style="font-weight:bold;color:#e0e0e0">ðŸ’š Healer</div>
          <div style="font-size:12px;color:#999">Support and healing priority</div>
        </div>
        <div style="padding:10px;background:#2a2f3a;border-radius:4px;">
          <div style="font-weight:bold;color:#e0e0e0">ðŸ’¨ Evasive</div>
          <div style="font-size:12px;color:#999">Speed and avoidance focused</div>
        </div>
      </div>
    </div>
    <div>
      <h3 style="color:#9146ff">Combat Settings</h3>
      <div style="background:#1a1a1d;padding:12px;border:1px solid #3a3a42;border-radius:4px">
        <label style="display:block;margin-bottom:10px;color:#b0b0b0">
          <input type="checkbox" style="margin-right:8px">Crit Damage Enabled
        </label>
        <label style="display:block;margin-bottom:10px;color:#b0b0b0">
          <input type="checkbox" style="margin-right:8px">Elemental Effects
        </label>
        <label style="display:block;margin-bottom:10px;color:#b0b0b0">
          <input type="checkbox" style="margin-right:8px">Status Effects
        </label>
        <label style="display:block;margin-bottom:10px;color:#b0b0b0">
          <input type="checkbox" style="margin-right:8px">Skill Synergies
        </label>
        <button class="small" style="width:100%;margin-top:8px">ðŸ’¾ Save AI Settings</button>
      </div>
    </div>
  </div>
</div>
`;
}

function renderRPGFlagsTab() {
  return `
<div class="card">
  <h2>ðŸš© Flags & Modifiers</h2>
  <p style="color:#b0b0b0">Manage global flags and modifier stacks</p>
  <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:15px">
    <div>
      <h3 style="color:#9146ff">ðŸ“‹ Global Flags</h3>
      <div style="background:#1a1a1d;padding:12px;border:1px solid #3a3a42;border-radius:4px;max-height:400px;overflow-y:auto">
        <div id="flags-list">
          <p style="color:#999">Loading flags...</p>
        </div>
      </div>
      <button class="small" style="width:100%;margin-top:8px;background:#4caf50" onclick="createFlag()">âž• Create Flag</button>
    </div>
    <div>
      <h3 style="color:#9146ff">ðŸ“Š Modifier Stacks</h3>
      <div style="background:#1a1a1d;padding:12px;border:1px solid #3a3a42;border-radius:4px;max-height:400px;overflow-y:auto">
        <div id="modifiers-list">
          <p style="color:#999">Loading modifiers...</p>
        </div>
      </div>
      <button class="small" style="width:100%;margin-top:8px;background:#4caf50" onclick="createModifier()">âž• Create Modifier</button>
    </div>
  </div>
</div>

<script>
function loadFlags() {
  fetch('/api/rpg/flags')
    .then(r => r.json())
    .then(data => {
      const list = document.getElementById('flags-list');
      if (!data.flags || data.flags.length === 0) {
        list.innerHTML = '<p style="color:#999">No custom flags yet</p>';
      } else {
        list.innerHTML = data.flags.map(f => \`
          <div style="padding:8px;background:#2a2f3a;border-radius:4px;margin-bottom:6px;font-size:12px">
            <div style="font-weight:bold;color:#e0e0e0">\${f.name}</div>
            <div style="color:#999">\${f.description || 'No description'}</div>
          </div>
        \`).join('');
      }
    })
    .catch(() => {
      document.getElementById('flags-list').innerHTML = '<p style="color:#ef5350">Error loading flags</p>';
    });
}

function createFlag() { alert('ðŸš© Create flag feature coming soon!'); }
function createModifier() { alert('ðŸ“Š Create modifier feature coming soon!'); }

loadFlags();
</script>
`;
}

function renderRPGGuildTab() {
  return `
<div class="card">
  <h2>ðŸ›ï¸ Adventurers Guild Management</h2>
  <p style="color:#b0b0b0">Manage daily, weekly, and limited quests, bounties, and guild ranks</p>
  <button class="primary" onclick="showQuestScheduleCalendar()" style="margin-top:10px">ðŸ“… View Quest Schedule</button>
</div>

<div class="card">
  <h3>ðŸ“… Daily Quests</h3>
  <p style="color:#888;font-size:13px">Reset every 24 hours â€¢ Available to all guild members</p>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:8px;margin:10px 0">
    <button class="small" onclick="quickAddQuest('daily', 'kill')" title="Quick: Kill enemies">âš”ï¸ Kill Quest</button>
    <button class="small" onclick="quickAddQuest('daily', 'gather')" title="Quick: Gather resources">ðŸŒ¿ Gather Quest</button>
    <button class="small" onclick="quickAddQuest('daily', 'craft')" title="Quick: Craft items">ðŸ”¨ Craft Quest</button>
    <button class="small" onclick="quickAddQuest('daily', 'explore')" title="Quick: Explore">ðŸ—ºï¸ Explore Quest</button>
  </div>
  <div id="dailyQuestsList" style="margin-top:15px"></div>
  <button class="primary" onclick="showAddQuestModal('daily')" style="margin-top:15px">âž• Add Daily Quest (Custom)</button>
</div>

<div class="card">
  <h3>ðŸ“† Weekly Quests</h3>
  <p style="color:#888;font-size:13px">Reset every 7 days â€¢ Higher rewards and difficulty</p>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:8px;margin:10px 0">
    <button class="small" onclick="quickAddQuest('weekly', 'kill')" title="Quick: Kill enemies">âš”ï¸ Boss Hunt</button>
    <button class="small" onclick="quickAddQuest('weekly', 'gather')" title="Quick: Gather resources">ðŸ”ï¸ Ore Run</button>
    <button class="small" onclick="quickAddQuest('weekly', 'explore')" title="Quick: Explore">ðŸŒ Expedition</button>
    <button class="small" onclick="showAddQuestModal('weekly')" title="Custom quest">âœï¸ Custom</button>
  </div>
  <div id="weeklyQuestsList" style="margin-top:15px"></div>
  <button class="primary" onclick="showAddQuestModal('weekly')" style="margin-top:15px">âž• Add Weekly Quest (Custom)</button>
</div>

<div class="card">
  <h3>â³ Limited Quests</h3>
  <p style="color:#888;font-size:13px">First-come first-served â€¢ Limited number of claims</p>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:8px;margin:10px 0">
    <button class="small" onclick="quickAddQuest('limited', 'kill')" title="Quick: Limited boss">ðŸ’€ Boss Raid</button>
    <button class="small" onclick="quickAddQuest('limited', 'gather')" title="Quick: Limited gather">ðŸ’Ž Treasure Hunt</button>
    <button class="small" onclick="showAddQuestModal('limited')" title="Custom quest">âœï¸ Custom</button>
  </div>
  <div id="limitedQuestsList" style="margin-top:15px"></div>
  <button class="primary" onclick="showAddQuestModal('limited')" style="margin-top:15px">âž• Add Limited Quest (Custom)</button>
</div>

<div class="card">
  <h3>ðŸ’° Bounty Board</h3>
  <p style="color:#888;font-size:13px">Player and NPC bounties</p>
  <div id="bountiesList" style="margin-top:15px"></div>
  <button class="primary" onclick="showAddBountyModal()" style="margin-top:15px">âž• Add Bounty</button>
</div>

<!-- Quest Modal -->
<div id="questModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:1000;align-items:center;justify-content:center">
  <div style="background:#1e1e1e;padding:30px;border-radius:8px;width:90%;max-width:600px;max-height:90vh;overflow-y:auto">
    <h3 id="questModalTitle">Add Quest</h3>
    <form id="questForm" onsubmit="saveQuest(event)">
      <input type="hidden" id="questType">
      <input type="hidden" id="questId">
      
      <label>Quest ID:</label>
      <input type="text" id="questIdInput" required style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
      
      <label>Title:</label>
      <input type="text" id="questTitle" required style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
      
      <label>Description:</label>
      <textarea id="questDescription" required rows="3" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px"></textarea>
      
      <label>Objective Type:</label>
      <select id="questObjectiveType" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
        <option value="kill">Kill Enemies</option>
        <option value="gather">Gather Resources</option>
        <option value="explore">Explore Locations</option>
        <option value="craft">Craft Items</option>
        <option value="deliver">Deliver Items</option>
      </select>
      
      <label>Target:</label>
      <input type="text" id="questTarget" required placeholder="e.g., goblin, iron_ore, ancient_ruins" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
      
      <label>Count Required:</label>
      <input type="number" id="questCount" required min="1" value="1" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
      
      <label>Minimum Rank:</label>
      <select id="questMinRank" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
        <option value="F">F Rank</option>
        <option value="E">E Rank</option>
        <option value="D">D Rank</option>
        <option value="C">C Rank</option>
        <option value="B">B Rank</option>
        <option value="A">A Rank</option>
        <option value="S">S Rank</option>
      </select>
      
      <label>Gold Reward:</label>
      <input type="number" id="questGoldReward" required min="0" value="100" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
      
      <label>Guild XP Reward:</label>
      <input type="number" id="questXPReward" required min="0" value="50" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
      
      <label>Item Rewards (comma-separated item IDs, optional):</label>
      <input type="text" id="questItemRewards" placeholder="e.g., iron_sword, health_potion, rare_gem" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
      <small style="color:#aaa;display:block;margin-top:-10px;margin-bottom:15px">Format: item_id:quantity, item_id:quantity (e.g., iron_sword:1, health_potion:5)</small>
      
      <div id="limitedQuestFields" style="display:none">
        <label>Max Claims:</label>
        <input type="number" id="questMaxClaims" min="1" value="10" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
        
        <label>Available Until (optional):</label>
        <input type="datetime-local" id="questExpiresAt" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
      </div>
      
      <div style="display:flex;gap:10px;margin-top:20px">
        <button type="submit" class="primary" style="flex:1">ðŸ’¾ Save Quest</button>
        <button type="button" class="secondary" onclick="closeQuestModal()" style="flex:1">âŒ Cancel</button>
      </div>
    </form>
  </div>
</div>

<!-- Bounty Modal -->
<div id="bountyModal" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:1000;align-items:center;justify-content:center">
  <div style="background:#1e1e1e;padding:30px;border-radius:8px;width:90%;max-width:600px;max-height:90vh;overflow-y:auto">
    <h3>Add Bounty</h3>
    <form id="bountyForm" onsubmit="saveBounty(event)">
      <input type="hidden" id="bountyId">
      
      <label>Bounty Type:</label>
      <select id="bountyType" onchange="toggleBountyFields()" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
        <option value="npc">NPC Bounty</option>
        <option value="player">Player Bounty</option>
      </select>
      
      <div id="npcBountyFields">
        <label>Target Name:</label>
        <input type="text" id="bountyTargetName" required placeholder="e.g., Bandit Leader" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
        
        <label>Description:</label>
        <textarea id="bountyDescription" required rows="3" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px"></textarea>
        
        <label>Minimum Rank:</label>
        <select id="bountyMinRank" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
          <option value="F">F Rank</option>
          <option value="E">E Rank</option>
          <option value="D">D Rank</option>
          <option value="C">C Rank</option>
          <option value="B">B Rank</option>
          <option value="A">A Rank</option>
          <option value="S">S Rank</option>
        </select>
        
        <label>Gold Reward:</label>
        <input type="number" id="bountyReward" required min="0" value="500" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
      </div>
      
      <div id="playerBountyFields" style="display:none">
        <label>Target Player ID:</label>
        <input type="text" id="bountyTargetId" placeholder="Discord User ID" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px">
        
        <label>Reason:</label>
        <textarea id="bountyReason" rows="2" style="width:100%;padding:8px;margin-bottom:15px;background:#2a2a2a;border:1px solid #444;color:#fff;border-radius:4px"></textarea>
      </div>
      
      <div style="display:flex;gap:10px;margin-top:20px">
        <button type="submit" class="primary" style="flex:1">ðŸ’¾ Save Bounty</button>
        <button type="button" class="secondary" onclick="closeBountyModal()" style="flex:1">âŒ Cancel</button>
      </div>
    </form>
  </div>
</div>

<script>
let guildQuests = { daily: [], weekly: [], limited: [] };
let guildBounties = [];

// Load guild data
async function loadGuildData() {
  try {
    const [questsRes, bountiesRes] = await Promise.all([
      fetch('/api/rpg/guild/quests'),
      fetch('/api/rpg/guild/bounties')
    ]);
    
    if (questsRes.ok) guildQuests = await questsRes.json();
    if (bountiesRes.ok) guildBounties = await bountiesRes.json();
    
    renderDailyQuests();
    renderWeeklyQuests();
    renderLimitedQuests();
    renderBounties();
  } catch (error) {
    console.error('Error loading guild data:', error);
  }
}

function renderDailyQuests() {
  const container = document.getElementById('dailyQuestsList');
  if (!guildQuests.daily || guildQuests.daily.length === 0) {
    container.innerHTML = '<p style="color:#888">No daily quests configured</p>';
    return;
  }
  
  container.innerHTML = guildQuests.daily.map(quest => \`
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42;margin-bottom:10px">
      <div style="display:flex;justify-content:space-between;align-items:start">
        <div style="flex:1">
          <div style="font-weight:bold;color:#4da6ff;margin-bottom:5px">\${quest.title}</div>
          <div style="color:#999;font-size:13px;margin-bottom:8px">\${quest.description}</div>
          <div style="display:flex;gap:15px;font-size:12px;color:#b0b0b0">
            <span>ðŸ“‹ \${quest.objective.type}: \${quest.objective.target} (\${quest.objective.count})</span>
            <span>ðŸŽ–ï¸ Min Rank: \${quest.minRank}</span>
            <span>ðŸ’° \${quest.rewards.gold}g</span>
            <span>â­ \${quest.rewards.guildXP} XP</span>
          </div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="small" onclick="editQuest('daily', '\${quest.id}')">âœï¸</button>
          <button class="small danger" onclick="deleteQuest('daily', '\${quest.id}')">ðŸ—‘ï¸</button>
        </div>
      </div>
    </div>
  \`).join('');
}

function renderWeeklyQuests() {
  const container = document.getElementById('weeklyQuestsList');
  if (!guildQuests.weekly || guildQuests.weekly.length === 0) {
    container.innerHTML = '<p style="color:#888">No weekly quests configured</p>';
    return;
  }
  
  container.innerHTML = guildQuests.weekly.map(quest => \`
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42;margin-bottom:10px">
      <div style="display:flex;justify-content:space-between;align-items:start">
        <div style="flex:1">
          <div style="font-weight:bold;color:#9d4edd;margin-bottom:5px">\${quest.title}</div>
          <div style="color:#999;font-size:13px;margin-bottom:8px">\${quest.description}</div>
          <div style="display:flex;gap:15px;font-size:12px;color:#b0b0b0">
            <span>ðŸ“‹ \${quest.objective.type}: \${quest.objective.target} (\${quest.objective.count})</span>
            <span>ðŸŽ–ï¸ Min Rank: \${quest.minRank}</span>
            <span>ðŸ’° \${quest.rewards.gold}g</span>
            <span>â­ \${quest.rewards.guildXP} XP</span>
          </div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="small" onclick="editQuest('weekly', '\${quest.id}')">âœï¸</button>
          <button class="small danger" onclick="deleteQuest('weekly', '\${quest.id}')">ðŸ—‘ï¸</button>
        </div>
      </div>
    </div>
  \`).join('');
}

function renderLimitedQuests() {
  const container = document.getElementById('limitedQuestsList');
  if (!guildQuests.limited || guildQuests.limited.length === 0) {
    container.innerHTML = '<p style="color:#888">No limited quests configured</p>';
    return;
  }
  
  container.innerHTML = guildQuests.limited.map(quest => {
    const claimProgress = \`\${quest.claimedCount || 0}/\${quest.maxClaims}\`;
    const isExpired = quest.expiresAt && new Date(quest.expiresAt) < new Date();
    const expiryText = quest.expiresAt ? \`Expires: \${new Date(quest.expiresAt).toLocaleDateString()}\` : 'No expiry';
    
    return \`
      <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42;margin-bottom:10px">
        <div style="display:flex;justify-content:space-between;align-items:start">
          <div style="flex:1">
            <div style="font-weight:bold;color:#f72585;margin-bottom:5px">\${quest.title} \${isExpired ? '<span style="color:#ff6b6b">(EXPIRED)</span>' : ''}</div>
            <div style="color:#999;font-size:13px;margin-bottom:8px">\${quest.description}</div>
            <div style="display:flex;gap:15px;font-size:12px;color:#b0b0b0">
              <span>ðŸ“‹ \${quest.objective.type}: \${quest.objective.target} (\${quest.objective.count})</span>
              <span>ðŸŽ–ï¸ Min Rank: \${quest.minRank}</span>
              <span>ðŸ’° \${quest.rewards.gold}g</span>
              <span>â­ \${quest.rewards.guildXP} XP</span>
            </div>
            <div style="margin-top:8px;font-size:12px;color:#b0b0b0">
              <span>ðŸ“Š Claims: \${claimProgress}</span> â€¢ <span>\${expiryText}</span>
            </div>
          </div>
          <div style="display:flex;gap:8px">
            <button class="small" onclick="editQuest('limited', '\${quest.id}')">âœï¸</button>
            <button class="small danger" onclick="deleteQuest('limited', '\${quest.id}')">ðŸ—‘ï¸</button>
          </div>
        </div>
      </div>
    \`;
  }).join('');
}

function renderBounties() {
  const container = document.getElementById('bountiesList');
  if (!guildBounties || guildBounties.length === 0) {
    container.innerHTML = '<p style="color:#888">No bounties available</p>';
    return;
  }
  
  container.innerHTML = guildBounties.map(bounty => {
    const isPlayerBounty = bounty.type === 'player';
    const statusColor = bounty.status === 'active' ? '#4ade80' : bounty.status === 'claimed' ? '#fbbf24' : '#999';
    
    return \`
      <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42;margin-bottom:10px">
        <div style="display:flex;justify-content:space-between;align-items:start">
          <div style="flex:1">
            <div style="display:flex;align-items:center;gap:10px;margin-bottom:5px">
              <span style="font-weight:bold;color:#ffd700">\${isPlayerBounty ? 'ðŸ‘¤ Player' : 'ðŸ’€ NPC'}: \${bounty.targetName || bounty.targetId}</span>
              <span style="color:\${statusColor};font-size:12px;text-transform:uppercase">\${bounty.status}</span>
            </div>
            <div style="color:#999;font-size:13px;margin-bottom:8px">\${bounty.description || bounty.reason || 'No description'}</div>
            <div style="display:flex;gap:15px;font-size:12px;color:#b0b0b0">
              \${!isPlayerBounty ? \`<span>ðŸŽ–ï¸ Min Rank: \${bounty.minRank}</span>\` : ''}
              <span>ðŸ’° Reward: \${bounty.reward}g</span>
              \${bounty.claimedBy ? \`<span>ðŸ‘¤ Claimed by: \${bounty.claimedBy}</span>\` : ''}
            </div>
          </div>
          <div style="display:flex;gap:8px">
            <button class="small" onclick="editBounty('\${bounty.id}')">âœï¸</button>
            <button class="small danger" onclick="deleteBounty('\${bounty.id}')">ðŸ—‘ï¸</button>
          </div>
        </div>
      </div>
    \`;
  }).join('');
}

// Quest Modal Functions
function showAddQuestModal(type) {
  document.getElementById('questModalTitle').textContent = \`Add \${type.charAt(0).toUpperCase() + type.slice(1)} Quest\`;
  document.getElementById('questType').value = type;
  document.getElementById('questId').value = '';
  document.getElementById('questForm').reset();
  document.getElementById('limitedQuestFields').style.display = type === 'limited' ? 'block' : 'none';
  document.getElementById('questModal').style.display = 'flex';
}

// Helper to parse item rewards from input string
function parseItemRewards(itemString) {
  if (!itemString || !itemString.trim()) return [];
  
  const items = itemString.split(',').map(str => str.trim()).filter(Boolean);
  return items.map(item => {
    const [id, qty] = item.split(':');
    return {
      id: id.trim(),
      quantity: qty ? parseInt(qty.trim()) : 1
    };
  });
}

// Helper to format item rewards for display
function formatItemRewards(items) {
  if (!items || items.length === 0) return '';
  return items.map(item => \`\${item.id}:\${item.quantity || 1}\`).join(', ');
}

function editQuest(type, questId) {
  const quest = guildQuests[type].find(q => q.id === questId);
  if (!quest) return;
  
  document.getElementById('questModalTitle').textContent = \`Edit \${type.charAt(0).toUpperCase() + type.slice(1)} Quest\`;
  document.getElementById('questType').value = type;
  document.getElementById('questId').value = questId;
  document.getElementById('questIdInput').value = quest.id;
  document.getElementById('questTitle').value = quest.title;
  document.getElementById('questDescription').value = quest.description;
  document.getElementById('questObjectiveType').value = quest.objective.type;
  document.getElementById('questTarget').value = quest.objective.target;
  document.getElementById('questCount').value = quest.objective.count;
  document.getElementById('questMinRank').value = quest.minRank;
  document.getElementById('questGoldReward').value = quest.rewards.gold;
  document.getElementById('questXPReward').value = quest.rewards.guildXP;
  document.getElementById('questItemRewards').value = formatItemRewards(quest.rewards.items || []);
  
  if (type === 'limited') {
    document.getElementById('questMaxClaims').value = quest.maxClaims;
    if (quest.expiresAt) {
      const date = new Date(quest.expiresAt);
      document.getElementById('questExpiresAt').value = date.toISOString().slice(0, 16);
    }
  }
  
  document.getElementById('limitedQuestFields').style.display = type === 'limited' ? 'block' : 'none';
  document.getElementById('questModal').style.display = 'flex';
}

function closeQuestModal() {
  document.getElementById('questModal').style.display = 'none';
  document.getElementById('questForm').reset();
}

async function saveQuest(event) {
  event.preventDefault();
  
  const type = document.getElementById('questType').value;
  const questId = document.getElementById('questId').value;
  const isEditing = !!questId;
  
  const questData = {
    id: document.getElementById('questIdInput').value,
    title: document.getElementById('questTitle').value,
    description: document.getElementById('questDescription').value,
    objective: {
      type: document.getElementById('questObjectiveType').value,
      target: document.getElementById('questTarget').value,
      count: parseInt(document.getElementById('questCount').value)
    },
    minRank: document.getElementById('questMinRank').value,
    rewards: {
      gold: parseInt(document.getElementById('questGoldReward').value),
      guildXP: parseInt(document.getElementById('questXPReward').value),
      items: parseItemRewards(document.getElementById('questItemRewards').value)
    }
  };
  
  if (type === 'limited') {
    questData.maxClaims = parseInt(document.getElementById('questMaxClaims').value);
    questData.claimedCount = 0;
    const expiresAt = document.getElementById('questExpiresAt').value;
    if (expiresAt) {
      questData.expiresAt = new Date(expiresAt).toISOString();
    }
  }
  
  try {
    const url = isEditing 
      ? \`/api/rpg/guild/quests/\${type}/\${questId}\`
      : \`/api/rpg/guild/quests/\${type}\`;
    
    const method = isEditing ? 'PUT' : 'POST';
    
    const response = await fetch(url, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(questData)
    });
    
    if (response.ok) {
      closeQuestModal();
      await loadGuildData();
    } else {
      const error = await response.json();
      alert('Error: ' + (error.message || 'Failed to save quest'));
    }
  } catch (error) {
    console.error('Error saving quest:', error);
    alert('Error: ' + error.message);
  }
}

async function deleteQuest(type, questId) {
  if (!confirm(\`Delete this \${type} quest?\`)) return;
  
  try {
    const response = await fetch(\`/api/rpg/guild/quests/\${type}/\${questId}\`, {
      method: 'DELETE'
    });
    
    if (response.ok) {
      await loadGuildData();
    } else {
      alert('Failed to delete quest');
    }
  } catch (error) {
    console.error('Error deleting quest:', error);
    alert('Error: ' + error.message);
  }
}

// Rank Buff Visualization
function showRankVisualization() {
  const ranks = ['F', 'E', 'D', 'C', 'B', 'A', 'S'];
  const rankData = {
    'F': { xp: 0, marketTax: 30, shopDiscount: 0, questXP: 0 },
    'E': { xp: 500, marketTax: 25, shopDiscount: 5, questXP: 10 },
    'D': { xp: 1500, marketTax: 20, shopDiscount: 10, questXP: 20 },
    'C': { xp: 3500, marketTax: 15, shopDiscount: 15, questXP: 30 },
    'B': { xp: 7000, marketTax: 10, shopDiscount: 20, questXP: 40 },
    'A': { xp: 12000, marketTax: 5, shopDiscount: 25, questXP: 50 },
    'S': { xp: 20000, marketTax: 0, shopDiscount: 30, questXP: 50 }
  };

  const rankCards = ranks.map(rank => {
    const data = rankData[rank];
    const colors = { 'F': '#999', 'E': '#4db8ff', 'D': '#66ff66', 'C': '#ffff33', 'B': '#ff6633', 'A': '#ff33ff', 'S': '#ffaa00' };
    const color = colors[rank];
    
    return \`
      <div style="background:linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0));padding:20px;border-radius:8px;border-left:4px solid \${color};margin-bottom:15px">
        <div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:15px">
          <h3 style="margin:0;color:\${color};font-size:1.2em">Rank \${rank}</h3>
          <span style="background:\${color};color:#000;padding:4px 12px;border-radius:20px;font-weight:bold">XP: \${data.xp}</span>
        </div>
        <div style="display:grid;grid-template-columns:repeat(3, 1fr);gap:12px">
          <div style="background:rgba(255,255,255,0.05);padding:12px;border-radius:6px">
            <div style="font-size:12px;color:#aaa">Market Tax</div>
            <div style="font-size:20px;color:#4caf50;font-weight:bold">-\${data.marketTax}%</div>
          </div>
          <div style="background:rgba(255,255,255,0.05);padding:12px;border-radius:6px">
            <div style="font-size:12px;color:#aaa">Shop Discount</div>
            <div style="font-size:20px;color:#2196f3;font-weight:bold">-\${data.shopDiscount}%</div>
          </div>
          <div style="background:rgba(255,255,255,0.05);padding:12px;border-radius:6px">
            <div style="font-size:12px;color:#aaa">Quest XP Bonus</div>
            <div style="font-size:20px;color:#ff9800;font-weight:bold">+\${data.questXP}%</div>
          </div>
        </div>
        <div style="margin-top:12px;font-size:13px;color:#aaa">
          <strong>Passive Effects:</strong> \${rank === 'S' ? 'Max rank - All bonuses capped!' : rank === 'A' ? 'Elite member status' : rank === 'B' ? 'Strong reputation' : 'Progressing...'}
        </div>
      </div>
    \`;
  }).join('');

  const modal = \`
    <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:2000;display:flex;align-items:center;justify-content:center;padding:20px">
      <div style="background:#1e1e1e;padding:30px;border-radius:8px;max-width:700px;width:100%;max-height:80vh;overflow-y:auto">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
          <h2 style="margin:0">ðŸŽ–ï¸ Guild Rank System</h2>
          <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">âœ•</button>
        </div>
        
        <div style="background:#2a2f3a;padding:15px;border-radius:6px;margin-bottom:20px">
          <p style="margin:0;color:#aaa;font-size:14px">
            <strong>Rank Progression:</strong> Complete quests and earn Guild XP to rank up. Each rank grants passive bonuses to market taxes, shop discounts, and quest rewards. S-rank is the ultimate achievement with all bonuses maxed!
          </p>
        </div>

        \${rankCards}

        <button onclick="this.parentElement.parentElement.remove()" style="width:100%;padding:12px;background:#2196f3;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold;margin-top:20px">Close</button>
      </div>
    </div>
  \`;
  
  document.body.insertAdjacentHTML('beforeend', modal);
}

// Bounty Modal Functions
function showAddBountyModal() {
  document.getElementById('bountyId').value = '';
  document.getElementById('bountyForm').reset();
  document.getElementById('npcBountyFields').style.display = 'block';
  document.getElementById('playerBountyFields').style.display = 'none';
  document.getElementById('bountyModal').style.display = 'flex';
}

function toggleBountyFields() {
  const type = document.getElementById('bountyType').value;
  document.getElementById('npcBountyFields').style.display = type === 'npc' ? 'block' : 'none';
  document.getElementById('playerBountyFields').style.display = type === 'player' ? 'block' : 'none';
}

function editBounty(bountyId) {
  const bounty = guildBounties.find(b => b.id === bountyId);
  if (!bounty) return;
  
  document.getElementById('bountyId').value = bountyId;
  document.getElementById('bountyType').value = bounty.type;
  toggleBountyFields();
  
  if (bounty.type === 'npc') {
    document.getElementById('bountyTargetName').value = bounty.targetName;
    document.getElementById('bountyDescription').value = bounty.description;
    document.getElementById('bountyMinRank').value = bounty.minRank;
    document.getElementById('bountyReward').value = bounty.reward;
  } else {
    document.getElementById('bountyTargetId').value = bounty.targetId;
    document.getElementById('bountyReason').value = bounty.reason || '';
  }
  
  document.getElementById('bountyModal').style.display = 'flex';
}

function closeBountyModal() {
  document.getElementById('bountyModal').style.display = 'none';
  document.getElementById('bountyForm').reset();
}

async function saveBounty(event) {
  event.preventDefault();
  
  const bountyId = document.getElementById('bountyId').value;
  const isEditing = !!bountyId;
  const type = document.getElementById('bountyType').value;
  
  const bountyData = {
    type,
    status: 'active'
  };
  
  if (type === 'npc') {
    bountyData.targetName = document.getElementById('bountyTargetName').value;
    bountyData.description = document.getElementById('bountyDescription').value;
    bountyData.minRank = document.getElementById('bountyMinRank').value;
    bountyData.reward = parseInt(document.getElementById('bountyReward').value);
  } else {
    bountyData.targetId = document.getElementById('bountyTargetId').value;
    bountyData.reason = document.getElementById('bountyReason').value;
    bountyData.reward = 0; // Player bounties set reward when created
  }
  
  try {
    const url = isEditing 
      ? \`/api/rpg/guild/bounties/\${bountyId}\`
      : '/api/rpg/guild/bounties';
    
    const method = isEditing ? 'PUT' : 'POST';
    
    const response = await fetch(url, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(bountyData)
    });
    
    if (response.ok) {
      closeBountyModal();
      await loadGuildData();
    } else {
      const error = await response.json();
      alert('Error: ' + (error.message || 'Failed to save bounty'));
    }
  } catch (error) {
    console.error('Error saving bounty:', error);
    alert('Error: ' + error.message);
  }
}

async function deleteBounty(bountyId) {
  if (!confirm('Delete this bounty?')) return;
  
  try {
    const response = await fetch(\`/api/rpg/guild/bounties/\${bountyId}\`, {
      method: 'DELETE'
    });
    
    if (response.ok) {
      await loadGuildData();
    } else {
      alert('Failed to delete bounty');
    }
  } catch (error) {
    console.error('Error deleting bounty:', error);
    alert('Error: ' + error.message);
  }
}

// Load data on page load
loadGuildData();

// Quest Schedule Calendar
function showQuestScheduleCalendar() {
  const dailyReset = new Date();
  dailyReset.setHours(24, 0, 0, 0);
  const dailyMs = dailyReset.getTime() - Date.now();
  const dailyHours = Math.floor(dailyMs / (1000 * 60 * 60));
  const dailyMins = Math.floor((dailyMs % (1000 * 60 * 60)) / (1000 * 60));

  const weeklyReset = new Date();
  weeklyReset.setDate(weeklyReset.getDate() + (7 - weeklyReset.getDay()));
  weeklyReset.setHours(0, 0, 0, 0);
  const weeklyMs = weeklyReset.getTime() - Date.now();
  const weeklyDays = Math.floor(weeklyMs / (1000 * 60 * 60 * 24));
  const weeklyHours = Math.floor((weeklyMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));

  const calendar = \`
    <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);z-index:2000;display:flex;align-items:center;justify-content:center;padding:20px">
      <div style="background:#1e1e1e;padding:30px;border-radius:8px;max-width:600px;width:100%;max-height:80vh;overflow-y:auto">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
          <h2 style="margin:0">ðŸ“… Quest Schedule</h2>
          <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">âœ•</button>
        </div>
        
        <div style="background:#2a2f3a;padding:20px;border-radius:6px;border-left:4px solid #3498db;margin-bottom:20px">
          <h3 style="margin-top:0;color:#3498db">ðŸ“… Daily Quests</h3>
          <div style="font-size:14px;color:#b0b0b0">
            <div style="margin:10px 0"><strong>Next Reset:</strong> \${dailyHours}h \${dailyMins}m</div>
            <div style="margin:10px 0"><strong>Frequency:</strong> Every 24 hours</div>
            <div style="margin:10px 0"><strong>Status:</strong> <span style="color:#4ade80">Active</span></div>
          </div>
        </div>
        
        <div style="background:#2a2f3a;padding:20px;border-radius:6px;border-left:4px solid #9b59b6;margin-bottom:20px">
          <h3 style="margin-top:0;color:#9b59b6">ðŸ“† Weekly Quests</h3>
          <div style="font-size:14px;color:#b0b0b0">
            <div style="margin:10px 0"><strong>Next Reset:</strong> \${weeklyDays}d \${weeklyHours}h</div>
            <div style="margin:10px 0"><strong>Frequency:</strong> Every 7 days</div>
            <div style="margin:10px 0"><strong>Status:</strong> <span style="color:#4ade80">Active</span></div>
          </div>
        </div>
        
        <div style="background:#2a2f3a;padding:20px;border-radius:6px;border-left:4px solid #f39c12;margin-bottom:20px">
          <h3 style="margin-top:0;color:#f39c12">â³ Limited Quests</h3>
          <div style="font-size:14px;color:#b0b0b0">
            <div style="margin:10px 0"><strong>Status:</strong> <span style="color:#f39c12">First-come first-served</span></div>
            <div style="margin:10px 0"><strong>Max Claims:</strong> Configurable per quest</div>
            <div id="limitedQuestTimers"></div>
          </div>
        </div>
        
        <button onclick="this.parentElement.parentElement.remove()" style="width:100%;padding:12px;background:#2196f3;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold;margin-top:20px">Close</button>
      </div>
    </div>
  \`;
  
  document.body.insertAdjacentHTML('beforeend', calendar);
  
  // Load limited quest timers
  const limitedTimers = [];
  if (guildQuests.limited) {
    guildQuests.limited.slice(0, 5).forEach(q => {
      if (q.expiresAt) {
        const expiryTime = new Date(q.expiresAt);
        const timeLeft = expiryTime.getTime() - Date.now();
        if (timeLeft > 0) {
          const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
          const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
          limitedTimers.push(\`<div style="margin:8px 0">â€¢ \${q.title}: <span style="color:#f39c12">\${days}d \${hours}h</span></div>\`);
        }
      } else {
        limitedTimers.push(\`<div style="margin:8px 0">â€¢ \${q.title}: <span style="color:#4ade80">No expiry</span></div>\`);
      }
    });
  }
  document.getElementById('limitedQuestTimers').innerHTML = limitedTimers.join('') || '<div style="color:#888">No limited quests</div>';
}

// Quick Add Templates
async function quickAddQuest(type, questType) {
  const templates = {
    daily: {
      kill: { description: 'Defeat 5 enemies', objective: { type: 'kill', target: 'enemy', count: 5 }, rewards: { gold: 100, guildXP: 50 } },
      gather: { description: 'Collect 10 materials', objective: { type: 'gather', target: 'material', count: 10 }, rewards: { gold: 80, guildXP: 40 } },
      craft: { description: 'Craft 3 items', objective: { type: 'craft', target: 'item', count: 3 }, rewards: { gold: 90, guildXP: 45 } },
      explore: { description: 'Explore 2 locations', objective: { type: 'explore', target: 'location', count: 2 }, rewards: { gold: 70, guildXP: 35 } }
    },
    weekly: {
      kill: { description: 'Defeat 25 enemies', objective: { type: 'kill', target: 'boss', count: 1 }, rewards: { gold: 500, guildXP: 100 } },
      gather: { description: 'Collect 50 rare materials', objective: { type: 'gather', target: 'material', count: 50 }, rewards: { gold: 400, guildXP: 80 } },
      explore: { description: 'Complete 5 dungeons', objective: { type: 'explore', target: 'dungeon', count: 5 }, rewards: { gold: 600, guildXP: 120 } }
    },
    limited: {
      kill: { description: 'Rare boss spawned! Quick, defeat it!', objective: { type: 'kill', target: 'rare_boss', count: 1 }, rewards: { gold: 1000, guildXP: 200 }, maxClaims: 5 },
      gather: { description: 'Treasure discovered! Limited time only!', objective: { type: 'gather', target: 'treasure', count: 1 }, rewards: { gold: 800, guildXP: 150 }, maxClaims: 10 }
    }
  };

  const template = templates[type]?.[questType];
  if (!template) return;

  const questId = \`quest_\${type}_\${questType}_\${Date.now()}\`;
  const title = \`\${type === 'daily' ? 'ðŸ“…' : type === 'weekly' ? 'ðŸ“†' : 'â³'} \${questType.charAt(0).toUpperCase() + questType.slice(1)} Quest\`;

  const questData = {
    id: questId,
    title,
    description: template.description,
    objective: template.objective,
    minRank: 'F',
    rewards: template.rewards
  };

  if (type === 'limited') {
    questData.maxClaims = template.maxClaims;
    questData.claimedCount = 0;
  }

  try {
    const response = await fetch(\`/api/rpg/guild/quests/\${type}\`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(questData)
    });

    if (response.ok) {
      alert(\`âœ… \${title} created!\`);
      await loadGuildData();
    } else {
      alert('Error creating quest');
    }
  } catch (error) {
    console.error('Error:', error);
    alert('Error: ' + error.message);
  }
}
</script>
`;
}

function renderRPGAdminTab() {
  const rpgAccess = getRpgSettings();
  const rpgAccessChannels = Array.isArray(rpgAccess.allowedChannelIds)
    ? rpgAccess.allowedChannelIds.join(', ')
    : '';
  return `
<div class="card">
  <h2>ðŸ”‘ RPG Admin Panel</h2>
  <p style="color:#b0b0b0">Backup, restore, and manage RPG content</p>
  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-top:15px">
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸ’¾ Backup</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Create content backup</p>
      <button class="small" onclick="backupContent()" style="width:100%;margin-top:8px">ðŸ’¾ Backup Now</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">â™»ï¸ Restore</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Restore from backup</p>
      <button class="small" onclick="restoreContent()" style="width:100%;margin-top:8px">â™»ï¸ Restore</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">â¬‡ï¸ Export</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Export all content to JSON</p>
      <button class="small" onclick="exportContent()" style="width:100%;margin-top:8px">â¬‡ï¸ Export</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">â¬†ï¸ Import</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Import content from JSON</p>
      <button class="small" onclick="importContent()" style="width:100%;margin-top:8px">â¬†ï¸ Import</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸ“Š Statistics</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Content statistics</p>
      <button class="small" onclick="viewStats()" style="width:100%;margin-top:8px">ðŸ“Š View Stats</button>
    </div>
    <div style="background:#2a2f3a;padding:15px;border-radius:6px;border:1px solid #3a3a42">
      <div style="font-weight:bold;color:#e0e0e0">ðŸ§¹ Cleanup</div>
      <p style="font-size:13px;color:#999;margin:8px 0">Remove orphaned content</p>
      <button class="small danger" onclick="cleanupContent()" style="width:100%;margin-top:8px">ðŸ§¹ Cleanup</button>
    </div>
  </div>
</div>

<div class="card">
  <h2>ðŸ”’ RPG Channel Access</h2>
  <p style="color:#b0b0b0">Restrict RPG commands and interactions to specific channels</p>

  <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;margin-top:10px">
    <div style="background:#2a2f3a;padding:12px;border-radius:6px;border:1px solid #3a3a42">
      <label style="display:flex;align-items:center;gap:10px">
        <input type="checkbox" id="rpgAccessEnabled" ${rpgAccess.channelRestrictionEnabled ? 'checked' : ''}>
        <span style="font-weight:600;color:#e0e0e0">Enable channel restriction</span>
      </label>
      <p style="font-size:12px;color:#999;margin:8px 0 0">When enabled, RPG works only in the allowed channels.</p>
    </div>
    <div style="background:#2a2f3a;padding:12px;border-radius:6px;border:1px solid #3a3a42">
      <label style="font-weight:600;color:#e0e0e0">Allowed Channel IDs</label>
      <input type="text" id="rpgAccessChannels" value="${rpgAccessChannels}" placeholder="123..., 456..." style="width:100%;margin-top:8px;padding:10px;background:#1a1f2e;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0" oninput="updateRpgAccessPreview()">
      <div id="rpgAccessPreview" style="margin-top:8px;color:#8fd18f;font-size:12px"></div>
    </div>
  </div>

  <div style="margin-top:12px">
    <button class="small" onclick="saveRpgAccessSettings()" style="background:#4caf50">ðŸ’¾ Save Access Settings</button>
  </div>
</div>

<div class="card">
  <h2>ðŸ‘¥ Player Management</h2>
  <p style="color:#b0b0b0">View and manage player data</p>
  
  <div style="display:flex;gap:10px;margin:15px 0;flex-wrap:wrap">
    <button class="small" onclick="loadAllPlayers()" style="background:#4caf50">ðŸ‘¥ Load All Players</button>
    <button class="small" onclick="backupPlayers()" style="background:#2196f3">ðŸ’¾ Backup Players</button>
    <button class="small danger" onclick="resetAllPlayers()" style="background:#ff9800">ðŸ”„ Reset All Players</button>
    <button class="small danger" onclick="deleteAllPlayers()">ðŸ—‘ï¸ Delete All Players</button>
  </div>

  <div id="playerStats" style="background:#2a2f3a;padding:15px;border-radius:6px;margin:15px 0;display:none">
    <h3 style="margin-top:0;color:#9146ff">ðŸ“Š Player Statistics</h3>
    <div id="playerStatsContent"></div>
  </div>

  <div style="margin:15px 0">
    <input type="text" id="playerSearch" placeholder="Search by User ID or Username..." 
      oninput="filterPlayers(this.value)" 
      style="width:100%;padding:10px;background:#2a2f3a;border:1px solid #3a3a42;border-radius:4px;color:#e0e0e0">
  </div>

  <div id="playersList" style="max-height:600px;overflow-y:auto"></div>
</div>

<script>
let allPlayers = {};

function splitIdTokens(value) {
  const out = [];
  let buf = '';
  const text = value || '';
  for (let i = 0; i < text.length; i++) {
    const ch = text[i];
    if (ch === ',' || ch === ' ' || ch === '\\n' || ch === '\\t' || ch === '\\r') {
      const trimmed = buf.trim();
      if (trimmed) out.push(trimmed);
      buf = '';
      continue;
    }
    buf += ch;
  }
  const last = buf.trim();
  if (last) out.push(last);
  return out;
}

function updateRpgAccessPreview() {
  const input = document.getElementById('rpgAccessChannels');
  const preview = document.getElementById('rpgAccessPreview');
  if (!input || !preview) return;
  const ids = splitIdTokens(input.value);
  if (!ids.length) {
    preview.textContent = 'No channels set';
    preview.style.color = '#999';
    return;
  }
  preview.textContent = 'Checking channels...';
  preview.style.color = '#9ad0ff';

  const checks = ids.slice(0, 5).map(id =>
    fetch('/channel/info/' + encodeURIComponent(id))
      .then(r => r.json())
      .then(data => data && data.name ? '#' + data.name : id)
      .catch(() => id)
  );

  Promise.all(checks).then(names => {
    preview.textContent = 'Allowed: ' + names.join(', ') + (ids.length > 5 ? ' +' + (ids.length - 5) + ' more' : '');
    preview.style.color = '#8fd18f';
  });
}

function saveRpgAccessSettings() {
  const enabled = document.getElementById('rpgAccessEnabled').checked;
  const channelIds = splitIdTokens(document.getElementById('rpgAccessChannels').value);
  fetch('/api/rpg/settings/access', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      channelRestrictionEnabled: enabled,
      allowedChannelIds: channelIds
    })
  })
  .then(r => r.json())
  .then(data => {
    if (data && data.success) {
      alert('âœ… RPG access settings saved');
      updateRpgAccessPreview();
    } else {
      alert('âŒ Error: ' + (data.error || 'Unknown error'));
    }
  })
  .catch(err => alert('âŒ Error: ' + err.message));
}

function saveRpgAccessSettings() {
  const enabled = document.getElementById('rpgAccessEnabled').checked;
  const channelIds = splitIdTokens(document.getElementById('rpgAccessChannels').value);
  fetch('/api/rpg/settings/access', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      channelRestrictionEnabled: enabled,
      allowedChannelIds: channelIds
    })
  })
  .then(r => r.json())
  .then(data => {
    if (data && data.success) {
      alert('âœ… RPG access settings saved');
      updateRpgAccessPreview();
    } else {
      alert('âŒ Error: ' + (data.error || 'Unknown error'));
    }
  })
  .catch(err => alert('âŒ Error: ' + err.message));
}

document.addEventListener('DOMContentLoaded', function() {
  updateRpgAccessPreview();
});

async function loadAllPlayers() {
  try {
    const response = await fetch('/api/rpg/players/list');
    const data = await response.json();
    
    if (data.success) {
      allPlayers = data.players;
      displayPlayerStats(data.stats);
      displayPlayers(allPlayers);
      document.getElementById('playerStats').style.display = 'block';
    } else {
      alert('âŒ Error: ' + data.message);
    }
  } catch (err) {
    alert('âŒ Error loading players: ' + err.message);
  }
}
window.loadAllPlayers = loadAllPlayers;

function displayPlayerStats(stats) {
  const content = document.getElementById('playerStatsContent');
  const totalGold = stats.totalGold != null ? stats.totalGold.toLocaleString() : '0';
  content.innerHTML = [
    '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px">',
    '  <div style="background:#1a1f2e;padding:12px;border-radius:4px">',
    '    <div style="color:#999;font-size:12px">Total Players</div>',
    '    <div style="font-size:24px;font-weight:bold;color:#4caf50">' + stats.totalPlayers + '</div>',
    '  </div>',
    '  <div style="background:#1a1f2e;padding:12px;border-radius:4px">',
    '    <div style="color:#999;font-size:12px">Avg Level</div>',
    '    <div style="font-size:24px;font-weight:bold;color:#2196f3">' + stats.avgLevel + '</div>',
    '  </div>',
    '  <div style="background:#1a1f2e;padding:12px;border-radius:4px">',
    '    <div style="color:#999;font-size:12px">Max Level</div>',
    '    <div style="font-size:24px;font-weight:bold;color:#ff9800">' + stats.maxLevel + '</div>',
    '  </div>',
    '  <div style="background:#1a1f2e;padding:12px;border-radius:4px">',
    '    <div style="color:#999;font-size:12px">Total Gold</div>',
    '    <div style="font-size:24px;font-weight:bold;color:#ffd700">' + totalGold + '</div>',
    '  </div>',
    '</div>'
  ].join('');
}

function displayPlayers(players) {
  const list = document.getElementById('playersList');
  const playerArray = Object.entries(players);
  
  if (playerArray.length === 0) {
    list.innerHTML = '<p style="text-align:center;color:#999;padding:20px">No players found</p>';
    return;
  }

  let html = '';
  playerArray.forEach(([userId, player]) => {
    const level = player.level || 1;
    const gold = player.gold || 0;
    const className = player.class || 'None';
    const hp = player.hp || 0;
    const maxHp = player.maxHp || 100;
    
    html += '<div class="player-card" data-user-id="' + userId + '" style="background:#2a2f3a;padding:15px;margin:10px 0;border-radius:6px;border:1px solid #3a3a42">' +
      '<div style="display:flex;justify-content:space-between;align-items:start;margin-bottom:10px">' +
      '<div>' +
      '<div style="font-weight:bold;color:#9146ff;font-size:16px">' + (player.username || 'Unknown') + '</div>' +
      '<div style="color:#999;font-size:12px">ID: ' + userId + '</div>' +
      '</div>' +
      '<div style="display:flex;gap:6px">' +
      '<button class="small" data-action="view" data-user-id="' + userId + '" style="background:#2196f3;margin:0">ðŸ‘ï¸ View</button>' +
      '<button class="small" data-action="reset" data-user-id="' + userId + '" style="background:#ff9800;margin:0">ðŸ”„ Reset</button>' +
      '<button class="small danger" data-action="delete" data-user-id="' + userId + '" style="margin:0">ðŸ—‘ï¸</button>' +
      '</div>' +
      '</div>' +
      '<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:8px;font-size:13px">' +
      '<div><span style="color:#999">Level:</span> <span style="color:#4caf50;font-weight:bold">' + level + '</span></div>' +
      '<div><span style="color:#999">Class:</span> <span style="color:#2196f3">' + className + '</span></div>' +
      '<div><span style="color:#999">Gold:</span> <span style="color:#ffd700">' + gold.toLocaleString() + '</span></div>' +
      '<div><span style="color:#999">HP:</span> <span style="color:#ef5350">' + hp + '/' + maxHp + '</span></div>' +
      '</div>' +
      '</div>';
  });
  
  list.innerHTML = html;
  
  // Add event delegation for player action buttons
  list.querySelectorAll('[data-action]').forEach(btn => {
    btn.addEventListener('click', function() {
      const action = this.getAttribute('data-action');
      const userId = this.getAttribute('data-user-id');
      if (action === 'view') viewPlayer(userId);
      else if (action === 'reset') resetPlayer(userId);
      else if (action === 'delete') deletePlayer(userId);
    });
  });
}

function filterPlayers(searchTerm) {
  const cards = document.querySelectorAll('.player-card');
  const term = searchTerm.toLowerCase();
  
  cards.forEach(card => {
    const userId = card.getAttribute('data-user-id');
    const username = card.querySelector('.player-card > div > div > div').textContent.toLowerCase();
    const matches = userId.includes(term) || username.includes(term);
    card.style.display = matches ? 'block' : 'none';
  });
}

async function viewPlayer(userId) {
  try {
    const response = await fetch('/api/rpg/players/' + userId);
    const data = await response.json();
    
    if (data.success) {
      const player = data.player;
      const json = JSON.stringify(player, null, 2);
      alert('Player Data:\\n\\n' + json.substring(0, 1000) + (json.length > 1000 ? '\\n\\n...truncated' : ''));
    } else {
      alert('âŒ Error: ' + data.message);
    }
  } catch (err) {
    alert('âŒ Error: ' + err.message);
  }
}

async function resetPlayer(userId) {
  if (!confirm('âš ï¸ Are you sure you want to reset this player? This cannot be undone!')) return;
  
  try {
    const response = await fetch('/api/rpg/players/' + userId + '/reset', { method: 'POST' });
    const data = await response.json();
    
    if (data.success) {
      alert('âœ… Player reset successfully!');
      loadAllPlayers();
    } else {
      alert('âŒ Error: ' + data.message);
    }
  } catch (err) {
    alert('âŒ Error: ' + err.message);
  }
}

async function deletePlayer(userId) {
  if (!confirm('âš ï¸ Are you sure you want to DELETE this player? This cannot be undone!')) return;
  
  try {
    const response = await fetch('/api/rpg/players/' + userId, { method: 'DELETE' });
    const data = await response.json();
    
    if (data.success) {
      alert('âœ… Player deleted successfully!');
      loadAllPlayers();
    } else {
      alert('âŒ Error: ' + data.message);
    }
  } catch (err) {
    alert('âŒ Error: ' + err.message);
  }
}

async function backupPlayers() {
  try {
    const response = await fetch('/api/rpg/players/backup', { method: 'POST' });
    const data = await response.json();
    
    if (data.success) {
      alert('âœ… Players backup created: ' + data.backupPath);
    } else {
      alert('âŒ Error: ' + data.message);
    }
  } catch (err) {
    alert('âŒ Error: ' + err.message);
  }
}

async function resetAllPlayers() {
  const confirmation = prompt('âš ï¸ TYPE "RESET ALL" TO CONFIRM. This will reset ALL player data!');
  if (confirmation !== 'RESET ALL') return;
  
  try {
    const response = await fetch('/api/rpg/players/reset-all', { method: 'POST' });
    const data = await response.json();
    
    if (data.success) {
      alert('âœ… All players reset! ' + data.count + ' players affected.');
      loadAllPlayers();
    } else {
      alert('âŒ Error: ' + data.message);
    }
  } catch (err) {
    alert('âŒ Error: ' + err.message);
  }
}

async function deleteAllPlayers() {
  const confirmation = prompt('âš ï¸ TYPE "DELETE ALL" TO CONFIRM. This will DELETE ALL player data permanently!');
  if (confirmation !== 'DELETE ALL') return;
  
  try {
    const response = await fetch('/api/rpg/players/delete-all', { method: 'POST' });
    const data = await response.json();
    
    if (data.success) {
      alert('âœ… All players deleted! ' + data.count + ' players removed.');
      allPlayers = {};
      document.getElementById('playersList').innerHTML = '<p style="text-align:center;color:#999;padding:20px">No players found</p>';
      document.getElementById('playerStats').style.display = 'none';
    } else {
      alert('âŒ Error: ' + data.message);
    }
  } catch (err) {
    alert('âŒ Error: ' + err.message);
  }
}

function backupContent() { alert('ðŸ’¾ Backup feature coming soon!'); }
function restoreContent() { alert('â™»ï¸ Restore feature coming soon!'); }
function exportContent() { alert('â¬‡ï¸ Export feature coming soon!'); }
function importContent() { alert('â¬†ï¸ Import feature coming soon!'); }
function viewStats() { alert('ðŸ“Š Statistics feature coming soon!'); }
function cleanupContent() { alert('ðŸ§¹ Cleanup feature coming soon!'); }

// Expose functions to global window object for onclick handlers
window.updateRpgAccessPreview = updateRpgAccessPreview;
window.saveRpgAccessSettings = saveRpgAccessSettings;
window.viewPlayer = viewPlayer;
window.resetPlayer = resetPlayer;
window.deletePlayer = deletePlayer;
window.backupPlayers = backupPlayers;
window.resetAllPlayers = resetAllPlayers;
window.deleteAllPlayers = deleteAllPlayers;
window.backupContent = backupContent;
window.restoreContent = restoreContent;
window.exportContent = exportContent;
window.importContent = importContent;
window.viewStats = viewStats;
window.cleanupContent = cleanupContent;
</script>
`;
}

function renderRPGEditorTab() {
  return `
<!-- v2.1 -->
<style>
  .editor-tabs { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
  .editor-tabs button { padding: 10px 16px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); color: #e0e0e0; cursor: pointer; border-radius: 6px; font-weight: bold; transition: all 0.3s; }
  .editor-tabs button:hover, .editor-tabs button.active { background: rgba(255,255,255,0.2); border-color: #9146ff; }
  .editor-section { display: none; }
  .editor-section.active { display: block; }
  .items-grid { display: grid; gap: 12px; margin-top: 15px; }
  .item-card { background: #2a2f3a; border: 1px solid #3a3f4a; border-radius: 6px; padding: 15px; cursor: pointer; transition: all 0.2s; }
  .item-card:hover { border-color: #9146ff; background: #2f3440; }
  .item-card.selected { border-color: #9146ff; background: #35394a; box-shadow: 0 0 10px rgba(145,70,255,0.3); }
  .item-card h3 { color: #9146ff; margin-bottom: 8px; font-size: 1.1em; }
  .item-card p { opacity: 0.8; margin: 4px 0; font-size: 0.9em; }
  .item-actions { display: flex; gap: 8px; margin-top: 12px; }
  .btn-edit { padding: 6px 12px; background: #2196f3; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em; }
  .btn-delete { padding: 6px 12px; background: #ef5350; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em; }
  .btn-create { padding: 10px 20px; background: #9146ff; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; margin-bottom: 15px; }
  .btn-view { padding: 6px 12px; background: #4caf50; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 0.85em; }
  .quest-types { display: flex; gap: 8px; margin-bottom: 15px; }
  .quest-types button { padding: 8px 14px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); color: #b0b0b0; cursor: pointer; border-radius: 4px; font-size: 0.9em; }
  .quest-types button.active { background: rgba(145,70,255,0.3); border-color: #9146ff; color: #fff; }
  .world-content { margin-top: 20px; padding: 20px; background: #1f2329; border-radius: 8px; border: 2px solid #9146ff; }
  .world-content h3 { color: #9146ff; margin-bottom: 15px; }
  .content-tabs { display: flex; gap: 8px; margin-bottom: 15px; border-bottom: 1px solid rgba(145,70,255,0.3); }
  .content-tabs button { padding: 8px 16px; background: transparent; border: none; border-bottom: 3px solid transparent; color: #b0b0b0; cursor: pointer; font-weight: bold; }
  .content-tabs button.active { color: #9146ff; border-bottom-color: #9146ff; }
  .content-section-inner { display: none; }
  .content-section-inner.active { display: block; }
  .back-btn { padding: 8px 16px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #e0e0e0; border-radius: 4px; cursor: pointer; margin-bottom: 15px; }
  .modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: flex-start; overflow-y: auto; padding: 20px; }
  .modal.active { display: flex; }
  .modal-content { background: #1a1d23; border-radius: 8px; padding: 25px; width: 90%; max-width: 600px; border: 2px solid #9146ff; margin: 20px auto; max-height: none !important; }
  .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid rgba(145,70,255,0.3); }
  .modal-header h3 { color: #9146ff; margin: 0; }
  .close-modal { background: none; border: none; color: #e0e0e0; font-size: 24px; cursor: pointer; }
  .form-group { margin-bottom: 15px; }
  .form-group label { display: block; margin-bottom: 5px; color: #9146ff; font-weight: bold; font-size: 0.9em; }
  .form-group input, .form-group textarea, .form-group select { width: 100%; padding: 8px 12px; background: #2a2f3a; border: 1px solid #3a3f4a; border-radius: 4px; color: #e0e0e0; font-family: inherit; }
  .form-group textarea { min-height: 80px; resize: vertical; }
  .reward-selector { background: #2a2f3a; border: 1px solid #3a3f4a; border-radius: 4px; padding: 15px; max-height: 300px; overflow-y: auto; }
  .reward-item { display: flex; align-items: center; gap: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; margin-bottom: 8px; }
  .reward-item input[type="checkbox"] { width: auto; }
  .reward-item label { flex: 1; margin: 0; font-weight: normal; color: #e0e0e0; }
  .reward-item input[type="number"] { width: 80px; padding: 4px 8px; }
  .btn-submit { padding: 10px 20px; background: #9146ff; color: #fff; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; width: 100%; margin-top: 10px; }
  .btn-cancel { padding: 10px 20px; background: rgba(255,255,255,0.1); color: #e0e0e0; border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; cursor: pointer; width: 100%; margin-top: 10px; }
</style>

<div class="card">
  <h2>âœï¸ RPG Content Editor</h2>
  <p style="color:#b0b0b0;margin-bottom:20px">Select a world to manage its content, or create standalone rewards</p>
  
  <div class="editor-tabs">
    <button class="active" onclick="switchEditorTab('worlds')">ðŸŒ Worlds</button>
    <button onclick="switchEditorTab('npcs')">ðŸ§™ NPCs</button>
    <button onclick="switchEditorTab('items')">ðŸ“¦ Items</button>
    <button onclick="switchEditorTab('materials')">ðŸ§± Materials</button>
    <button onclick="switchEditorTab('rewards')">ðŸŽ Rewards (Global)</button>
  </div>
  
  <!-- WORLDS TAB -->
  <div id="editor-worlds" class="editor-section active">
    <button class="btn-create" onclick="createWorld()">+ New World</button>
    <div class="items-grid" id="worlds-list">Loading...</div>
    
    <!-- World Content Management (shown when world is selected) -->
    <div id="world-content-panel" class="world-content" style="display:none">
      <button class="back-btn" onclick="closeWorldContent()">â† Back to Worlds</button>
      <h3 id="world-content-title">World Content</h3>
      
      <div class="content-tabs">
        <button class="active" onclick="switchContentTab('quests')">ðŸ“œ Quests</button>
        <button onclick="switchContentTab('town-defence')">ðŸ›¡ï¸ Town Defence</button>
        <button onclick="switchContentTab('bosses')">ðŸ‘¹ Bosses</button>
        <button onclick="switchContentTab('dungeons')">ðŸ° Dungeons</button>
        <button onclick="switchContentTab('raids')">âš¡ Raids</button>
      </div>
      
      <div id="world-quests" class="content-section-inner active">
        <div class="quest-types">
          <button class="active" onclick="switchQuestType('side', this)">Side</button>
          <button onclick="switchQuestType('main', this)">Main</button>
          <button onclick="switchQuestType('daily', this)">Daily</button>
        </div>
        <button class="btn-create" onclick="createWorldQuest()">+ New Quest</button>
        <div class="items-grid" id="world-quests-list">No quests yet</div>
      </div>
      
      <div id="world-town-defence" class="content-section-inner">
        <button class="btn-create" onclick="createTownDefenceQuest()">+ New Town Defence Quest</button>
        <div class="items-grid" id="town-defence-list">Loading town defence quests...</div>
      </div>
      
      <div id="world-bosses" class="content-section-inner">
        <button class="btn-create" onclick="createWorldBoss()">+ New Boss</button>
        <div class="items-grid" id="world-bosses-list">No bosses yet</div>
      </div>
      
      <div id="world-dungeons" class="content-section-inner">
        <button class="btn-create" onclick="createWorldDungeon()">+ New Dungeon</button>
        <div class="items-grid" id="world-dungeons-list">No dungeons yet</div>
      </div>
      
      <div id="world-raids" class="content-section-inner">
        <button class="btn-create" onclick="createWorldRaid()">+ New Raid</button>
        <div class="items-grid" id="world-raids-list">No raids yet</div>
      </div>
    </div>
  </div>
  
  <!-- NPCs TAB -->
  <div id="editor-npcs" class="editor-section">
    <button class="btn-create" onclick="createNPC()">+ New NPC</button>
    <div style="margin-bottom:15px">
      <label>Filter by World:</label>
      <select id="npc-world-filter" onchange="loadNPCs()" style="padding:8px 12px;background:#2a2f3a;border:1px solid #3a3f4a;border-radius:4px;color:#e0e0e0">
        <option value="">All Worlds</option>
      </select>
    </div>
    <div class="items-grid" id="npcs-list">Loading...</div>
  </div>
  
  <!-- ITEMS TAB -->
  <div id="editor-items" class="editor-section">
    <button class="btn-create" onclick="createItem()">+ New Item</button>
    <div style="display:flex;gap:15px;margin-bottom:15px;flex-wrap:wrap">
      <div>
        <label>Category:</label>
        <select id="item-category-filter" onchange="loadItems()" style="padding:8px 12px;background:#2a2f3a;border:1px solid #3a3f4a;border-radius:4px;color:#e0e0e0">
          <option value="">All Categories</option>
          <option value="weapon">Weapon</option>
          <option value="armor">Armor</option>
          <option value="consumable">Consumable</option>
          <option value="equipment">Equipment</option>
          <option value="gathering">Gathering</option>
          <option value="talent">Talent</option>
          <option value="misc">Miscellaneous</option>
        </select>
      </div>
      <div>
        <label>Rarity:</label>
        <select id="item-rarity-filter" onchange="loadItems()" style="padding:8px 12px;background:#2a2f3a;border:1px solid #3a3f4a;border-radius:4px;color:#e0e0e0">
          <option value="">All Rarities</option>
          <option value="common" style="color:#9d9d9d">Common</option>
          <option value="uncommon" style="color:#1eff00">Uncommon</option>
          <option value="rare" style="color:#0070dd">Rare</option>
          <option value="epic" style="color:#a335ee">Epic</option>
          <option value="legendary" style="color:#ff8000">Legendary</option>
        </select>
      </div>
      <div>
        <label>Class:</label>
        <select id="item-class-filter" onchange="loadItems()" style="padding:8px 12px;background:#2a2f3a;border:1px solid #3a3f4a;border-radius:4px;color:#e0e0e0">
          <option value="">All Classes</option>
          <option value="none">No Restriction</option>
          <option value="warrior">Warrior</option>
          <option value="mage">Mage</option>
          <option value="rogue">Rogue</option>
          <option value="paladin">Paladin</option>
          <option value="ranger">Ranger</option>
          <option value="druid">Druid</option>
        </select>
      </div>
      <div>
        <label>Type:</label>
        <select id="item-type-filter" onchange="loadItems()" style="padding:8px 12px;background:#2a2f3a;border:1px solid #3a3f4a;border-radius:4px;color:#e0e0e0">
          <option value="">All Types</option>
          <optgroup label="Weapons">
            <option value="fist">Fist</option>
            <option value="sword">Sword</option>
            <option value="axe">Axe</option>
            <option value="bow">Bow</option>
            <option value="staff">Staff</option>
            <option value="dagger">Dagger</option>
            <option value="hammer">Hammer</option>
            <option value="spear">Spear</option>
            <option value="wand">Wand</option>
          </optgroup>
          <optgroup label="Armor">
            <option value="helm">Helm</option>
            <option value="chest">Chest</option>
            <option value="legs">Legs</option>
            <option value="boots">Boots</option>
            <option value="gloves">Gloves</option>
            <option value="shield">Shield</option>
            <option value="cloak">Cloak</option>
            <option value="ring">Ring</option>
            <option value="amulet">Amulet</option>
          </optgroup>
        </select>
      </div>
    </div>
    <div class="items-grid" id="items-list">Loading...</div>
  </div>

  <!-- MATERIALS TAB -->
  <div id="editor-materials" class="editor-section">
    <button class="btn-create" onclick="createMaterial()">+ New Material</button>
    <div style="display:flex;gap:8px;margin:15px 0;flex-wrap:wrap;align-items:center">
      <select id="material-source-filter" onchange="loadMaterials()" style="padding:8px 12px;background:#2a2f3a;border:1px solid #3a3f4a;border-radius:4px;color:#e0e0e0">
        <option value="">All Sources</option>
        <option value="adventure">Adventure</option>
        <option value="high_level_adventure">High Level Adventure</option>
        <option value="dungeons">Dungeons</option>
        <option value="raids">Raids</option>
        <option value="bosses">Bosses</option>
        <option value="gathering">Gathering</option>
        <option value="quests">Quests</option>
        <option value="vendor">Vendor</option>
      </select>
      <select id="material-rarity-filter" onchange="loadMaterials()" style="padding:8px 12px;background:#2a2f3a;border:1px solid #3a3f4a;border-radius:4px;color:#e0e0e0">
        <option value="">All Rarities</option>
        <option value="common">Common</option>
        <option value="uncommon">Uncommon</option>
        <option value="rare">Rare</option>
        <option value="epic">Epic</option>
        <option value="legendary">Legendary</option>
      </select>
    </div>
    <div class="items-grid" id="materials-list">Loading...</div>
  </div>
  
  <!-- REWARDS TAB -->
  <div id="editor-rewards" class="editor-section">
    <button class="btn-create" onclick="createReward()">+ New Reward</button>
    <div class="items-grid" id="rewards-list">Loading...</div>
  </div>
</div>

<!-- MODALS -->
<div id="worldModal" class="modal" style="align-items: flex-start !important; overflow-y: visible !important;">
  <div class="modal-content" style="max-height: none !important;">
    <div class="modal-header">
      <h3>Create World</h3>
      <button class="close-modal" onclick="closeWorldModal()">&times;</button>
    </div>
    <div class="form-group">
      <label>World Name *</label>
      <input type="text" id="worldName" required>
    </div>
    <div class="form-group">
      <label>Tier *</label>
      <input type="number" id="worldTier" value="1" min="1" required>
      <small style="color:#999;display:block;margin-top:4px">World tier determines unlock order (Tier 1 is the starting world)</small>
    </div>
    <div class="form-group">
      <label>Description</label>
      <textarea id="worldDescription"></textarea>
    </div>
    <div class="form-group">
      <label>Min Level</label>
      <input type="number" id="worldMinLevel" value="1" min="1">
    </div>
    <div class="form-group">
      <label>Max Level</label>
      <input type="number" id="worldMaxLevel" value="50" min="1">
    </div>
    <div class="form-group">
      <label>World Boss (Optional)</label>
      <select id="worldBossSelect">
        <option value="">No Boss</option>
      </select>
    </div>
    <div class="form-group">
      <label>Next World After Boss Defeat (Optional)</label>
      <select id="worldNextWorldSelect">
        <option value="">None</option>
      </select>
    </div>
    <button class="btn-submit" onclick="submitWorld()">Create World</button>
    <button class="btn-cancel" onclick="closeWorldModal()">Cancel</button>
  </div>
</div>

<div id="bossModal" class="modal" style="align-items: flex-start !important; overflow-y: visible !important;">
  <div class="modal-content" style="max-height: none !important;">
    <div class="modal-header">
      <h3>Create Boss</h3>
      <button class="close-modal" onclick="closeBossModal()">&times;</button>
    </div>
    <div class="form-group">
      <label>Boss Name *</label>
      <input type="text" id="bossName" required>
    </div>
    <div class="form-group">
      <label>Description</label>
      <textarea id="bossDescription"></textarea>
    </div>
    <div class="form-group">
      <label>HP (exact value) *</label>
      <input type="number" id="bossHP" value="100" required>
    </div>
    <div class="form-group">
      <label>Level *</label>
      <input type="number" id="bossLevel" value="10" required>
    </div>
    <div class="form-group">
      <label>Select Rewards (with drop chance %)</label>
      <div class="reward-selector" id="bossRewardSelector">Loading rewards...</div>
    </div>
    <button class="btn-submit" onclick="submitBoss()">Create Boss</button>
    <button class="btn-cancel" onclick="closeBossModal()">Cancel</button>
  </div>
</div>

<div id="questModal" class="modal" style="align-items: flex-start !important; overflow-y: visible !important;">
  <div class="modal-content" style="max-height: none !important;">
    <div class="modal-header">
      <h3>Create Quest</h3>
      <button class="close-modal" onclick="closeQuestModal()">&times;</button>
    </div>
    <div class="form-group">
      <label>Quest Title *</label>
      <input type="text" id="questTitle" required>
    </div>
    <div class="form-group">
      <label>Description</label>
      <textarea id="questDescription"></textarea>
    </div>
    <div class="form-group">
      <label>Quest Type</label>
      <select id="questType" onchange="toggleQuestTypeFields()">
        <option value="side">Side Quest (Standard)</option>
        <option value="main">Main Quest (Story)</option>
        <option value="choice">Choice Quest (Multiple Branches)</option>
        <option value="daily">Daily Quest</option>
        <option value="repeatable">Repeatable Quest</option>
        <option value="class-unlock">Class Unlock Quest</option>
      </select>
    </div>
    <div class="form-group">
      <label>Min Level</label>
      <input type="number" id="questMinLevel" value="1" min="1">
    </div>
    <div class="form-group">
      <label>Unlocks Quest (optional)</label>
      <input type="text" id="questUnlocks" placeholder="Quest ID that completes this quest to unlock">
    </div>
    
    <!-- Standard Quest Fields -->
    <div id="standardQuestFields">
      <div class="form-group">
        <label>Objectives (comma-separated)</label>
        <textarea id="questObjectives" placeholder="Kill 10 goblins, Collect 5 items"></textarea>
      </div>
      <div class="form-group">
        <label>Select Tasks</label>
        <div class="task-selector" id="questTaskSelector">Loading tasks...</div>
      </div>
      <div class="form-group">
        <label>Select Rewards (with drop chance %)</label>
        <div class="reward-selector" id="questRewardSelector">Loading rewards...</div>
      </div>
    </div>
    
    <!-- Choice Quest Fields -->
    <div id="choiceQuestFields" style="display:none;">
      <div class="form-group">
        <label>Quest Branches</label>
        <p style="color:#888;font-size:12px;margin-bottom:10px">Define the choices players can make</p>
        <div id="questBranchesContainer"></div>
        <button type="button" class="small" onclick="addQuestBranch()" style="margin-top:10px;background:#4a4f5a">+ Add Branch</button>
      </div>
    </div>
    
    <button class="btn-submit" onclick="submitQuest()">Create Quest</button>
    <button class="btn-cancel" onclick="closeQuestModal()">Cancel</button>
  </div>
</div>

<div id="dungeonModal" class="modal" style="align-items: flex-start !important; overflow-y: visible !important;">
  <div class="modal-content" style="max-height: none !important;">
    <div class="modal-header">
      <h3>Create Dungeon</h3>
      <button class="close-modal" onclick="closeDungeonModal()">&times;</button>
    </div>
    <div class="form-group">
      <label>Dungeon Name *</label>
      <input type="text" id="dungeonName" required>
    </div>
    <div class="form-group">
      <label>Description</label>
      <textarea id="dungeonDescription"></textarea>
    </div>
    <div class="form-group">
      <label>Difficulty</label>
      <select id="dungeonDifficulty">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
      </select>
    </div>
    <div class="form-group">
      <label>Min Level</label>
      <input type="number" id="dungeonMinLevel" value="10">
    </div>
    <div class="form-group">
      <label>Bosses in Dungeon</label>
      <div id="dungeonBossSelector" style="background: #2a2f3a; border: 1px solid #3a3f4a; border-radius: 4px; padding: 10px; margin-bottom: 10px; max-height: 200px; overflow-y: auto;">
        <p style="opacity:0.6;margin:0">Loading bosses...</p>
      </div>
      <button type="button" style="width: 100%; padding: 8px; background: #3a3f4a; border: 1px solid #4a5f5a; border-radius: 4px; color: #e0e0e0; cursor: pointer; margin-top: 8px;" onclick="addBossToDungeon()">+ Add Boss</button>
    </div>
    <div class="form-group">
      <label>Select Rewards (with drop chance %)</label>
      <div class="reward-selector" id="dungeonRewardSelector">Loading rewards...</div>
    </div>
    <button class="btn-submit" onclick="submitDungeon()">Create Dungeon</button>
    <button class="btn-cancel" onclick="closeDungeonModal()">Cancel</button>
  </div>
</div>

<div id="raidModal" class="modal" style="align-items: flex-start !important; overflow-y: visible !important;">
  <div class="modal-content" style="max-height: none !important;">
    <div class="modal-header">
      <h3>Create Multi-Layer Raid</h3>
      <button class="close-modal" onclick="closeRaidModal()">&times;</button>
    </div>
    <div class="form-group">
      <label>Raid Name *</label>
      <input type="text" id="raidName" required>
    </div>
    <div class="form-group">
      <label>Description</label>
      <textarea id="raidDescription"></textarea>
    </div>
    <div class="form-group">
      <label>Number of Layers (Common â†’ Legendary)</label>
      <input type="number" id="raidLayers" value="1" min="1" max="5">
    </div>
    <div class="form-group">
      <label>Max Team Size</label>
      <input type="number" id="raidTeamSize" value="4" min="1" max="10">
    </div>
    <div class="form-group">
      <label>Min Level</label>
      <input type="number" id="raidMinLevel" value="20">
    </div>
    <div class="form-group">
      <label>Bosses in Raid</label>
      <div id="raidBossSelector" style="background: #2a2f3a; border: 1px solid #3a3f4a; border-radius: 4px; padding: 10px; margin-bottom: 10px; max-height: 200px; overflow-y: auto;">
        <p style="opacity:0.6;margin:0">Loading bosses...</p>
      </div>
      <button type="button" style="width: 100%; padding: 8px; background: #3a3f4a; border: 1px solid #4a5f5a; border-radius: 4px; color: #e0e0e0; cursor: pointer; margin-top: 8px;" onclick="addBossToRaid()">+ Add Boss</button>
    </div>
    <div id="raidLayerRewards" style="border: 1px solid #3a3f4a; border-radius: 4px; padding: 15px; margin: 15px 0; background: #25282f;">
      <h4 style="margin-top: 0; color: #4ac1ff;">Layer Reward Packages</h4>
      <div id="raidLayerRewardsList"></div>
    </div>
    <button class="btn-submit" onclick="submitRaid()">Create Raid</button>
    <button class="btn-cancel" onclick="closeRaidModal()">Cancel</button>
  </div>
</div>

<div id="defenseQuestModal" class="modal" style="align-items: flex-start !important; overflow-y: visible !important;">
  <div class="modal-content" style="max-height: none !important;">
    <div class="modal-header">
      <h3>Town Defence Quest</h3>
      <button class="close-modal" onclick="closeDefenseQuestModal()">&times;</button>
    </div>
    <div class="form-group">
      <label>Quest Name *</label>
      <input type="text" id="defenseQuestTitle" required>
    </div>
    <div class="form-group">
      <label>Description</label>
      <textarea id="defenseQuestDescription"></textarea>
    </div>
    <div class="form-group">
      <label>Quest Type</label>
      <select id="defenseQuestType" onchange="toggleDefenseQuestTypeFields()">
        <option value="combat">Combat Quest</option>
        <option value="choice">Choice Quest</option>
      </select>
    </div>
    <div class="form-group">
      <label>Min Level</label>
      <input type="number" id="defenseQuestMinLevel" value="1" min="1">
    </div>
    <div class="form-group">
      <label>Unlocks Quest ID (optional)</label>
      <input type="text" id="defenseQuestUnlocks" placeholder="defense_shadowport">
    </div>
    
    <!-- Combat Quest Fields -->
    <div id="defenseQuestCombatFields">
      <h4 style="color:#9146ff;margin-top:15px">Enemy Details</h4>
      <div class="form-group">
        <label>Enemy Name *</label>
        <input type="text" id="defenseEnemyName" required>
      </div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <div class="form-group">
          <label>Enemy Level</label>
          <input type="number" id="defenseEnemyLevel" value="1" min="1">
        </div>
        <div class="form-group">
          <label>Enemy HP</label>
          <input type="number" id="defenseEnemyHP" value="100" min="1">
        </div>
      </div>
      <h4 style="color:#9146ff;margin-top:15px">Enemy Stats</h4>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
        <div class="form-group">
          <label>Strength</label>
          <input type="number" id="defenseEnemyStr" value="5" min="0">
        </div>
        <div class="form-group">
          <label>Defense</label>
          <input type="number" id="defenseEnemyDef" value="5" min="0">
        </div>
        <div class="form-group">
          <label>Intelligence</label>
          <input type="number" id="defenseEnemyInt" value="5" min="0">
        </div>
        <div class="form-group">
          <label>Agility</label>
          <input type="number" id="defenseEnemyAgi" value="5" min="0">
        </div>
      </div>
      <div class="form-group">
        <label>Skills (comma-separated)</label>
        <input type="text" id="defenseEnemySkills" placeholder="slash, shield_bash, fireball">
      </div>
    </div>
    
    <!-- Choice Quest Fields -->
    <div id="defenseQuestChoiceFields" style="display:none;">
      <p style="color:#888;font-size:12px;margin:10px 0">Choice quests with branches and outcomes should be created in the code file for now.</p>
    </div>
    
    <h4 style="color:#9146ff;margin-top:15px">Rewards</h4>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
      <div class="form-group">
        <label>XP Reward</label>
        <input type="number" id="defenseRewardXP" value="100" min="0">
      </div>
      <div class="form-group">
        <label>Gold Reward</label>
        <input type="number" id="defenseRewardGold" value="50" min="0">
      </div>
    </div>
    <div class="form-group">
      <label style="display:flex;align-items:center;gap:8px;cursor:pointer">
        <input type="checkbox" id="defenseRewardUnlockClass" style="width:auto;margin:0">
        <span>Unlock Class on Completion</span>
      </label>
    </div>
    <div class="form-group">
      <label>Items (comma-separated: item_id x quantity)</label>
      <input type="text" id="defenseRewardItems" placeholder="health_potion x3, steel_sword x1">
    </div>
    
    <button class="btn-submit" onclick="submitDefenseQuest()">Save Town Defence Quest</button>
    <button class="btn-cancel" onclick="closeDefenseQuestModal()">Cancel</button>
  </div>
</div>

<div id="npcModal" class="modal" style="align-items: flex-start !important; overflow-y: visible !important;">
  <div class="modal-content" style="max-height: none !important;">
    <div class="modal-header">
      <h3>Create NPC</h3>
      <button class="close-modal" onclick="closeNPCModal()">&times;</button>
    </div>
    <div class="form-group">
      <label>NPC Name *</label>
      <input type="text" id="npcName" required>
    </div>
    <div class="form-group">
      <label>Description</label>
      <textarea id="npcDescription" placeholder="A brief description of the NPC"></textarea>
    </div>
    <div class="form-group">
      <label>NPC Type *</label>
      <select id="npcType" required>
        <option value="">-- Select Type --</option>
        <option value="merchant">Merchant (Sells Items)</option>
        <option value="questgiver">Quest Giver</option>
        <option value="innkeeper">Innkeeper</option>
        <option value="trainer">Trainer</option>
        <option value="generic">Generic NPC</option>
      </select>
    </div>
    <div class="form-group">
      <label>World *</label>
      <select id="npcWorld" required>
        <option value="">-- Select World --</option>
      </select>
    </div>
    <div class="form-group">
      <label>Location Description</label>
      <input type="text" id="npcLocation" placeholder="e.g., 'Tavern in the town center'">
    </div>
    <div class="form-group">
      <label>Dialogue Text</label>
      <textarea id="npcDialogue" placeholder="What the NPC says when interacted with"></textarea>
    </div>
    <div id="npcMerchantItems" class="form-group" style="display:none">
      <label>Items for Sale (comma-separated item IDs)</label>
      <input type="text" id="npcItems" placeholder="sword,shield,potion">
    </div>
    <div id="npcQuestGiverQuests" class="form-group" style="display:none">
      <label>Quests Offered</label>
      <div class="reward-selector" id="npcQuestSelector" style="max-height:200px;overflow-y:auto">
        <p style="opacity:0.6;margin:0">Loading quests...</p>
      </div>
    </div>
    <button class="btn-submit" onclick="submitNPC()">Create NPC</button>
    <button class="btn-cancel" onclick="closeNPCModal()">Cancel</button>
  </div>
</div>

<div id="itemModal" class="modal" style="align-items: flex-start !important; overflow-y: visible !important;">
  <div class="modal-content" style="max-height: none !important;">
    <div class="modal-header">
      <h3>Create Item</h3>
      <button class="close-modal" onclick="closeItemModal()">&times;</button>
    </div>
    <div class="form-group">
      <label>Item Name *</label>
      <input type="text" id="itemName" required>
    </div>
    <div class="form-group">
      <label>Description</label>
      <textarea id="itemDescription" placeholder="What is this item used for?"></textarea>
    </div>
    <div class="form-group">
      <label>Category *</label>
      <select id="itemCategory" required onchange="updateItemFormFields()">
        <option value="">-- Select Category --</option>
        <option value="weapon">Weapon</option>
        <option value="armor">Armor</option>
        <option value="consumable">Consumable</option>
        <option value="equipment">Equipment</option>
        <option value="gathering">Gathering</option>
        <option value="talent">Talent</option>
        <option value="misc">Miscellaneous</option>
      </select>
    </div>
    <div class="form-group" id="itemTypeGroup" style="display:none">
      <label>Item Type</label>
      <select id="itemType">
        <option value="">-- Select Type --</option>
      </select>
    </div>
    <div class="form-group">
      <label>Rarity *</label>
      <select id="itemRarity" required onchange="updateRarityColor()">
        <option value="">-- Select Rarity --</option>
        <option value="common">Common (Gray)</option>
        <option value="uncommon">Uncommon (Green)</option>
        <option value="rare">Rare (Blue)</option>
        <option value="epic">Epic (Purple)</option>
        <option value="legendary">Legendary (Orange)</option>
      </select>
      <div id="rarityPreview" style="margin-top:8px;padding:8px;border-radius:4px;background:#2a2f3a;color:#e0e0e0"></div>
    </div>
    <div class="form-group">
      <label>Value (Gold)</label>
      <input type="number" id="itemValue" value="10" min="0">
    </div>
    <div id="itemCombatStats" style="display:none">
      <div class="form-group">
        <label>Damage</label>
        <input type="number" id="itemDamage" value="0" min="0">
      </div>
      <div class="form-group">
        <label>Defense</label>
        <input type="number" id="itemDefense" value="0" min="0">
      </div>
    </div>
    <div id="itemHealingStats" style="display:none">
      <div class="form-group">
        <label>Heals HP</label>
        <input type="number" id="itemHeals" value="0" min="0">
      </div>
      <div class="form-group">
        <label>Restores Mana</label>
        <input type="number" id="itemRestoresMana" value="0" min="0">
      </div>
    </div>
    <div style="background:#3a3f4a;padding:12px;border-radius:4px;margin:15px 0">
      <h4 style="margin-top:0">Stat Bonuses</h4>
      <div class="form-group">
        <label>Strength Bonus</label>
        <input type="number" id="itemStrength" value="0" min="0">
      </div>
      <div class="form-group">
        <label>Intelligence Bonus</label>
        <input type="number" id="itemIntelligence" value="0" min="0">
      </div>
      <div class="form-group">
        <label>Wisdom Bonus</label>
        <input type="number" id="itemWisdom" value="0" min="0">
      </div>
      <div class="form-group">
        <label>Agility Bonus</label>
        <input type="number" id="itemAgility" value="0" min="0">
      </div>
      <div class="form-group">
        <label>Luck Bonus</label>
        <input type="number" id="itemLuck" value="0" min="0">
      </div>
      <div class="form-group">
        <label>HP Bonus</label>
        <input type="number" id="itemHP" value="0" min="0">
      </div>
      <div class="form-group">
        <label>Mana Bonus</label>
        <input type="number" id="itemMana" value="0" min="0">
      </div>
    </div>
    <div class="form-group">
      <label>Class Restriction (Optional - leave empty for all classes)</label>
      <select id="itemClassRestriction">
        <option value="">All Classes</option>
        <option value="warrior">Warrior</option>
        <option value="mage">Mage</option>
        <option value="rogue">Rogue</option>
        <option value="paladin">Paladin</option>
        <option value="ranger">Ranger</option>
        <option value="druid">Druid</option>
      </select>
    </div>
    <div class="form-group">
      <label>Level Requirement</label>
      <input type="number" id="itemLevelRequirement" value="1" min="1">
    </div>
    <div style="background:#3a3f4a;padding:12px;border-radius:4px;margin:15px 0">
      <h4 style="margin-top:0;color:#00d4ff;">âš™ï¸ Recipe Materials (Resources needed to craft this item)</h4>
      <div class="form-group">
        <label>Add Material</label>
        <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <select id="recipeMaterialSelect" style="flex:1;min-width:220px"></select>
          <input type="number" id="recipeMaterialQty" value="1" min="1" style="width:110px">
          <button type="button" class="btn-create" onclick="addMaterialToRecipe()" style="width:auto;padding:8px 14px">Add</button>
        </div>
      </div>
      <div class="form-group">
        <label>Selected Materials</label>
        <div id="recipeMaterialsList" class="reward-selector" style="max-height:220px"></div>
        <textarea id="itemRecipeMaterials" style="display:none"></textarea>
        <small style="color: #888;">Materials are saved automatically. Use the dropdown above to add materials.</small>
      </div>
      <div class="form-group">
        <label>Recipe Level Required</label>
        <input type="number" id="itemRecipeLevel" value="1" min="1">
      </div>
      <div class="form-group">
        <label>Craft Time (seconds)</label>
        <input type="number" id="itemCraftTime" value="5" min="1">
      </div>
    </div>
    <button class="btn-submit" onclick="submitItem()">Create Item</button>
    <button class="btn-cancel" onclick="closeItemModal()">Cancel</button>
  </div>
</div>

<!-- MATERIAL MODAL -->
<div id="materialModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3 id="materialModalTitle">Create Material</h3>
      <button class="close-modal" onclick="closeMaterialModal()">&times;</button>
    </div>
    <div class="form-group">
      <label>Material Name *</label>
      <input type="text" id="materialName" placeholder="Copper Ore">
    </div>
    <div class="form-group">
      <label>Material ID (optional)</label>
      <input type="text" id="materialId" placeholder="copper_ore">
    </div>
    <div class="form-group">
      <label>Rarity</label>
      <select id="materialRarity">
        <option value="common">Common</option>
        <option value="uncommon">Uncommon</option>
        <option value="rare">Rare</option>
        <option value="epic">Epic</option>
        <option value="legendary">Legendary</option>
      </select>
    </div>
    <div class="form-group">
      <label>Value (Gold)</label>
      <input type="number" id="materialValue" value="1" min="0">
    </div>
    <div class="form-group">
      <label>Drop Chance (%)</label>
      <input type="number" id="materialDropChance" value="100" min="0" max="100" placeholder="100">
    </div>
    <div class="form-group">
      <label>Gathering Level Required</label>
      <input type="number" id="materialAdventureLevel" value="1" min="1" placeholder="1" title="Minimum level needed to gather/obtain this material (Mining, Fishing, etc.)">
      <small style="color:#999;display:block;margin-top:4px">The gathering level (Mining=5, Fishing=3, etc.) player needs to obtain this material</small>
    </div>
    <div class="form-group">
      <label>Where to get it (select multiple)</label>
      <div style="background:#2a2f3a;padding:10px;border-radius:4px;max-height:150px;overflow-y:auto">
        <label style="display:block;margin-bottom:8px"><input type="checkbox" name="materialSource" value="adventure"> Adventure</label>
        <label style="display:block;margin-bottom:8px"><input type="checkbox" name="materialSource" value="high_level_adventure"> High Level Adventure</label>
        <label style="display:block;margin-bottom:8px"><input type="checkbox" name="materialSource" value="dungeons"> Dungeons</label>
        <label style="display:block;margin-bottom:8px"><input type="checkbox" name="materialSource" value="raids"> Raids</label>
        <label style="display:block;margin-bottom:8px"><input type="checkbox" name="materialSource" value="bosses"> Bosses</label>
        <label style="display:block;margin-bottom:8px"><input type="checkbox" name="materialSource" value="gathering"> Gathering</label>
        <label style="display:block;margin-bottom:8px"><input type="checkbox" name="materialSource" value="quests"> Quests</label>
        <label style="display:block;margin-bottom:0"><input type="checkbox" name="materialSource" value="vendor"> Vendor</label>
      </div>
    </div>
    <div id="gatheringCustomField" class="form-group" style="display:none">
      <label>Gathering Type</label>
      <select id="materialGatheringType">
        <option value="">-- Select Type --</option>
        <option value="Mining">Mining</option>
        <option value="Chopping">Chopping</option>
        <option value="Fishing">Fishing</option>
        <option value="Wildcrafting">Wildcrafting</option>
        <option value="Foraging">Foraging</option>
        <option value="Hunting">Hunting</option>
        <option value="Farming">Farming</option>
        <option value="Herbing">Herbing</option>
      </select>
    </div>
    <button class="btn-submit" onclick="submitMaterial()">Save Material</button>
    <button class="btn-cancel" onclick="closeMaterialModal()">Cancel</button>
  </div>
</div>

<div id="rewardPackageModal" class="modal" style="align-items: flex-start !important; overflow-y: visible !important;">
  <div class="modal-content" style="max-height: none !important;">
    <div class="modal-header">
      <h3 id="rewardPackageModalTitle">Create Reward Package</h3>
      <button class="close-modal" onclick="closeRewardPackageModal()">&times;</button>
    </div>
    <div class="form-group">
      <label>Reward ID *</label>
      <input type="text" id="rewardPackageId" required placeholder="reward_dungeon_1">
    </div>
    <div class="form-group">
      <label>Display Name *</label>
      <input type="text" id="rewardPackageName" required placeholder="Dungeon Clear Reward">
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px">
      <div class="form-group">
        <label>XP Reward</label>
        <input type="number" id="rewardPackageXP" value="0" min="0">
      </div>
      <div class="form-group">
        <label>Gold Reward</label>
        <input type="number" id="rewardPackageGold" value="0" min="0">
      </div>
    </div>
    <div class="form-group">
      <label>Select Items</label>
      <div style="margin-bottom:8px">
        <input type="text" id="rewardItemSearch" placeholder="ðŸ” Search items..." style="width:100%;padding:8px;background:#1a1f2e;border:1px solid #3a3f4a;border-radius:4px;color:#e0e0e0" oninput="filterRewardItems()">
      </div>
      <div id="rewardItemSelector" style="background:#2a2f3a;border:1px solid #3a3f4a;border-radius:4px;padding:10px;max-height:200px;overflow-y:auto">
        <p style="opacity:0.6;margin:0">Loading items...</p>
      </div>
    </div>
    <div class="form-group">
      <label>Select Materials</label>
      <div style="margin-bottom:8px">
        <input type="text" id="rewardMaterialSearch" placeholder="ðŸ” Search materials..." style="width:100%;padding:8px;background:#1a1f2e;border:1px solid #3a3f4a;border-radius:4px;color:#e0e0e0" oninput="filterRewardMaterials()">
      </div>
      <div id="rewardMaterialSelector" style="background:#2a2f3a;border:1px solid #3a3f4a;border-radius:4px;padding:10px;max-height:200px;overflow-y:auto">
        <p style="opacity:0.6;margin:0">Loading materials...</p>
      </div>
    </div>
    <button class="btn-submit" onclick="submitRewardPackage()" id="rewardPackageSubmitBtn">Create Reward Package</button>
    <button class="btn-cancel" onclick="closeRewardPackageModal()">Cancel</button>
  </div>
</div>

<script>
let currentEditorTab = 'worlds';
let currentQuestType = 'side';
let selectedWorldId = null;
let currentContentTab = 'quests';
let availableRewards = {};
let editingId = null; // Track if we're editing (vs creating)
let materialsCache = {};
let currentRecipeMaterials = {};
let editingMaterialId = null;

// Load all rewards for selectors
function loadAvailableRewards() {
  return fetch('/api/rewards', { credentials: 'include' })
    .then(r => r.json())
    .then(rewards => {
      availableRewards = rewards;
      return rewards;
    })
    .catch(err => {
      console.error('Error loading rewards:', err);
      return {};
    });
}

function renderRewardSelector(containerId, selectedRewards = {}) {
  const container = document.getElementById(containerId);
  const rewards = Object.entries(availableRewards);
  
  if (!rewards.length) {
    container.innerHTML = '<p style="opacity:0.6">No rewards available. Create rewards first!</p>';
    return;
  }
  
  const rewardsList = rewards.map(([id, reward]) => ({
    id,
    name: reward.name || id,
    xp: reward.xp || 0,
    gold: reward.gold || 0
  }));
  
  // Create search bar
  const searchHTML = '<div style="margin-bottom: 12px;"><input type="text" id="rewardSearch" placeholder="Search rewards..." style="width: 100%; padding: 8px 12px; background: #1a1f2e; border: 1px solid #3a3f4a; border-radius: 4px; color: #e0e0e0; font-size: 14px;" oninput="filterRewardsList(this.value, ' + "'" + containerId + "'" + ')"></div>';
  
  // Create rewards grid with click-to-select
  const rewardsHTML = rewardsList.map(reward => {
    const isSelected = selectedRewards[reward.id] !== undefined;
    const dropChance = selectedRewards[reward.id] || 100;
    const bgColor = isSelected ? '#2a3f3a' : '#1a1f2e';
    const borderColor = isSelected ? '#00aa00' : '#3a3f4a';
    const textColor = isSelected ? '#00ff00' : '#e0e0e0';
    const checkColor = isSelected ? '#00ff00' : '#666';
    const displayInput = isSelected ? 'block' : 'none';
    const checkMark = isSelected ? 'âœ“' : '+';
    
    let html = '<div class="reward-card" onclick="toggleReward(this, ' + "'" + reward.id + "'" + ')" data-reward-id="' + reward.id + '" data-selected="' + isSelected + '" style="padding: 12px; margin: 8px 0; background: ' + bgColor + '; border: 2px solid ' + borderColor + '; border-radius: 6px; cursor: pointer; transition: all 0.2s; user-select: none;">';
    html += '<div style="display: flex; justify-content: space-between; align-items: start;">';
    html += '<div>';
    html += '<div style="font-weight: bold; color: ' + textColor + '">' + reward.name + '</div>';
    html += '<div style="font-size: 12px; color: #999; margin-top: 4px;">XP: ' + reward.xp + ' | Gold: ' + reward.gold + '</div>';
    html += '</div>';
    html += '<div style="color: ' + checkColor + '; font-size: 18px; font-weight: bold;">' + checkMark + '</div>';
    html += '</div>';
    html += '<input type="number" class="chance-input" min="1" max="100" value="' + dropChance + '" placeholder="%" data-reward-id="' + reward.id + '" style="width: 100%; margin-top: 8px; padding: 6px; background: #0a0f1e; border: 1px solid #3a3f4a; border-radius: 4px; color: #e0e0e0; display: ' + displayInput + ';">';
    html += '</div>';
    return html;
  }).join('');
  
  container.innerHTML = searchHTML + '<div id="rewardsGrid">' + rewardsHTML + '</div>';
}

function toggleReward(element, rewardId) {
  const isSelected = element.getAttribute('data-selected') === 'true';
  const chanceInput = element.querySelector('.chance-input');
  
  if (isSelected) {
    // Deselect
    element.setAttribute('data-selected', 'false');
    element.style.background = '#1a1f2e';
    element.style.borderColor = '#3a3f4a';
    element.querySelector('div:last-child').textContent = '+';
    element.querySelector('div:last-child').style.color = '#666';
    chanceInput.style.display = 'none';
  } else {
    // Select
    element.setAttribute('data-selected', 'true');
    element.style.background = '#2a3f3a';
    element.style.borderColor = '#00aa00';
    element.querySelector('div:last-child').textContent = 'âœ“';
    element.querySelector('div:last-child').style.color = '#00ff00';
    chanceInput.style.display = 'block';
  }
}

function filterRewardsList(searchTerm, containerId) {
  const container = document.getElementById(containerId);
  const grid = container.querySelector('#rewardsGrid');
  const cards = grid.querySelectorAll('.reward-card');
  
  cards.forEach(card => {
    const rewardName = card.querySelector('div > div:first-child').textContent.toLowerCase();
    const matches = rewardName.includes(searchTerm.toLowerCase());
    card.style.display = matches ? 'block' : 'none';
  });
}

function toggleRewardChance(checkbox) {
  const rewardId = checkbox.getAttribute('data-reward-id');
  const chanceInput = document.getElementById('chance_' + rewardId);
  chanceInput.style.display = checkbox.checked ? 'block' : 'none';
}

function getSelectedRewards(containerId) {
  const container = document.getElementById(containerId);
  const selectedCards = container.querySelectorAll('.reward-card[data-selected="true"]');
  const selectedRewards = {};
  
  selectedCards.forEach(card => {
    const rewardId = card.getAttribute('data-reward-id');
    const chanceInput = card.querySelector('.chance-input');
    const chance = parseInt(chanceInput.value) || 100;
    selectedRewards[rewardId] = chance;
  });
  
  return selectedRewards;
}

// Predefined task options for quest creation
const availableTasks = [
  { id: 'kill_goblins', name: 'Kill Goblins', description: 'Eliminate goblin threats', hasCount: true, defaultCount: 10 },
  { id: 'kill_wolves', name: 'Kill Wolves', description: 'Hunt wild beasts', hasCount: true, defaultCount: 15 },
  { id: 'kill_bandits', name: 'Kill Bandits', description: 'Clear bandit camps', hasCount: true, defaultCount: 8 },
  { id: 'kill_undead', name: 'Kill Undead', description: 'Destroy undead creatures', hasCount: true, defaultCount: 20 },
  { id: 'kill_dragons', name: 'Kill Dragons', description: 'Slay mighty dragons', hasCount: true, defaultCount: 1 },
  { id: 'collect_herbs', name: 'Collect Healing Herbs', description: 'Gather medicinal plants', hasCount: true, defaultCount: 5 },
  { id: 'collect_ore', name: 'Collect Iron Ore', description: 'Mine resources', hasCount: true, defaultCount: 10 },
  { id: 'gather_wood', name: 'Gather Wood', description: 'Collect timber', hasCount: true, defaultCount: 20 },
  { id: 'collect_crystals', name: 'Collect Magic Crystals', description: 'Find rare crystals', hasCount: true, defaultCount: 3 },
  { id: 'collect_pelts', name: 'Collect Animal Pelts', description: 'Hunt and skin animals', hasCount: true, defaultCount: 12 },
  { id: 'defeat_boss', name: 'Defeat Boss', description: 'Eliminate the boss', hasCount: false },
  { id: 'explore_cave', name: 'Explore Dark Cave', description: 'Venture into the cave', hasCount: false },
  { id: 'explore_ruins', name: 'Explore Ancient Ruins', description: 'Discover lost ruins', hasCount: false },
  { id: 'craft_weapon', name: 'Craft Weapon', description: 'Forge a weapon', hasCount: true, defaultCount: 1 },
  { id: 'craft_armor', name: 'Craft Armor', description: 'Create armor pieces', hasCount: true, defaultCount: 1 },
  { id: 'craft_potions', name: 'Craft Potions', description: 'Brew healing potions', hasCount: true, defaultCount: 5 },
  { id: 'reach_level', name: 'Reach Level', description: 'Gain experience', hasCount: true, defaultCount: 10 },
  { id: 'earn_gold', name: 'Earn Gold', description: 'Accumulate wealth', hasCount: true, defaultCount: 1000 },
  { id: 'spend_gold', name: 'Spend Gold', description: 'Purchase items', hasCount: true, defaultCount: 500 },
  { id: 'complete_dungeon', name: 'Complete Dungeon', description: 'Finish dungeons', hasCount: true, defaultCount: 3 },
  { id: 'complete_raids', name: 'Complete Raids', description: 'Finish raid encounters', hasCount: true, defaultCount: 1 },
  { id: 'talk_npc', name: 'Talk to NPC', description: 'Speak with NPC', hasCount: false },
  { id: 'find_artifact', name: 'Find Ancient Artifact', description: 'Discover rare item', hasCount: false },
  { id: 'escort_npc', name: 'Escort Traveler', description: 'Protect NPC during travel', hasCount: false },
  { id: 'defend_village', name: 'Defend Village', description: 'Protect settlement from attack', hasCount: false },
  { id: 'hunt_rare_creature', name: 'Hunt Rare Creature', description: 'Track and defeat', hasCount: false },
  { id: 'deliver_package', name: 'Deliver Package', description: 'Complete delivery mission', hasCount: false },
  { id: 'learn_skill', name: 'Learn New Skill', description: 'Train with master', hasCount: false },
  { id: 'win_tournament', name: 'Win Arena Tournament', description: 'Defeat all challengers', hasCount: false },
  { id: 'solve_puzzle', name: 'Solve Ancient Puzzle', description: 'Unlock secrets', hasCount: false },
  { id: 'deal_damage', name: 'Deal Damage', description: 'Deal total damage in combat', hasCount: true, defaultCount: 10000 },
  { id: 'use_abilities', name: 'Use Abilities', description: 'Cast spells or use skills', hasCount: true, defaultCount: 20 },
  { id: 'heal_allies', name: 'Heal Allies', description: 'Restore ally health', hasCount: true, defaultCount: 10 },
  { id: 'critical_hits', name: 'Land Critical Hits', description: 'Score critical strikes', hasCount: true, defaultCount: 15 },
  { id: 'block_attacks', name: 'Block Attacks', description: 'Successfully block enemy hits', hasCount: true, defaultCount: 25 },
  { id: 'dodge_attacks', name: 'Dodge Attacks', description: 'Evade enemy attacks', hasCount: true, defaultCount: 30 },
  { id: 'upgrade_equipment', name: 'Upgrade Equipment', description: 'Enhance your gear', hasCount: true, defaultCount: 3 },
  { id: 'trade_items', name: 'Trade Items', description: 'Buy or sell with vendors', hasCount: true, defaultCount: 10 }
];

function renderTaskSelector(selectedTasks = []) {
  const container = document.getElementById('questTaskSelector');
  
  // Create search bar
  const searchHTML = '<div style="margin-bottom: 12px;"><input type="text" id="taskSearch" placeholder="Search tasks..." style="width: 100%; padding: 8px 12px; background: #1a1f2e; border: 1px solid #3a3f4a; border-radius: 4px; color: #e0e0e0; font-size: 14px;" oninput="filterTasksList(this.value)"></div>';
  
  // Create tasks grid with click-to-select (no checkboxes)
  const tasksHTML = availableTasks.map(task => {
    const isSelected = selectedTasks.includes(task.id);
    const bgColor = isSelected ? '#2a3f3a' : '#1a1f2e';
    const borderColor = isSelected ? '#00aa00' : '#3a3f4a';
    const textColor = isSelected ? '#00ff00' : '#e0e0e0';
    const checkColor = isSelected ? '#00ff00' : '#666';
    const checkMark = isSelected ? 'âœ“' : '+';
    const displayInput = isSelected && task.hasCount ? 'block' : 'none';
    
    let html = '<div class="task-card" onclick="toggleTask(this, ' + "'" + task.id + "'" + ')" data-task-id="' + task.id + '" data-selected="' + isSelected + '" data-has-count="' + task.hasCount + '" style="padding: 12px; margin: 8px 0; background: ' + bgColor + '; border: 2px solid ' + borderColor + '; border-radius: 6px; cursor: pointer; transition: all 0.2s; user-select: none;">';
    html += '<div style="display: flex; justify-content: space-between; align-items: start;">';
    html += '<div style="flex: 1;">';
    html += '<div style="font-weight: bold; color: ' + textColor + '">' + task.name + '</div>';
    html += '<div style="font-size: 12px; color: #999; margin-top: 4px;">' + task.description + '</div>';
    html += '</div>';
    html += '<div style="color: ' + checkColor + '; font-size: 18px; font-weight: bold; margin-left: 10px;">' + checkMark + '</div>';
    html += '</div>';
    if (task.hasCount) {
      html += '<input type="number" class="count-input" min="1" value="' + (task.defaultCount || 1) + '" placeholder="Count" onclick="event.stopPropagation()" data-task-id="' + task.id + '" style="width: 100%; margin-top: 8px; padding: 6px; background: #0a0f1e; border: 1px solid #3a3f4a; border-radius: 4px; color: #e0e0e0; display: ' + displayInput + ';">';
    }
    html += '</div>';
    return html;
  }).join('');
  
  container.innerHTML = searchHTML + '<div id="tasksGrid" style="max-height: 300px; overflow-y: auto;">' + tasksHTML + '</div>';
}

function toggleTask(element, taskId) {
  const isSelected = element.getAttribute('data-selected') === 'true';
  const hasCount = element.getAttribute('data-has-count') === 'true';
  const nameDiv = element.querySelector('div > div > div:first-child');
  const checkMark = element.querySelector('div > div:last-child');
  const countInput = element.querySelector('.count-input');
  
  if (isSelected) {
    // Deselect
    element.setAttribute('data-selected', 'false');
    element.style.background = '#1a1f2e';
    element.style.borderColor = '#3a3f4a';
    nameDiv.style.color = '#e0e0e0';
    checkMark.textContent = '+';
    checkMark.style.color = '#666';
    if (countInput) countInput.style.display = 'none';
  } else {
    // Select
    element.setAttribute('data-selected', 'true');
    element.style.background = '#2a3f3a';
    element.style.borderColor = '#00aa00';
    nameDiv.style.color = '#00ff00';
    checkMark.textContent = 'âœ“';
    checkMark.style.color = '#00ff00';
    if (countInput) countInput.style.display = 'block';
  }
}

function filterTasksList(searchTerm) {
  const grid = document.getElementById('tasksGrid');
  const cards = grid.querySelectorAll('.task-card');
  
  cards.forEach(card => {
    const taskName = card.querySelector('div > div > div:first-child').textContent.toLowerCase();
    const taskDesc = card.querySelector('div > div > div:nth-child(2)').textContent.toLowerCase();
    const matches = taskName.includes(searchTerm.toLowerCase()) || taskDesc.includes(searchTerm.toLowerCase());
    card.style.display = matches ? 'block' : 'none';
  });
}

function getSelectedTasks() {
  const container = document.getElementById('questTaskSelector');
  const selectedCards = container.querySelectorAll('.task-card[data-selected="true"]');
  const selectedTasks = [];
  
  selectedCards.forEach(card => {
    const taskId = card.getAttribute('data-task-id');
    const taskData = availableTasks.find(t => t.id === taskId);
    if (taskData) {
      let taskName = taskData.name;
      if (taskData.hasCount) {
        const countInput = card.querySelector('.count-input');
        const count = countInput ? (parseInt(countInput.value) || taskData.defaultCount) : taskData.defaultCount;
        taskName = taskName + ' (' + count + ')';
      }
      selectedTasks.push(taskName);
    }
  });
  
  return selectedTasks;
}

function switchEditorTab(tab) {
  currentEditorTab = tab;
  document.querySelectorAll('.editor-section').forEach(e => e.classList.remove('active'));
  document.getElementById('editor-' + tab).classList.add('active');
  document.querySelectorAll('.editor-tabs button').forEach(b => {
    b.classList.toggle('active', b.textContent.toLowerCase().includes(tab));
  });
  
  if (tab === 'worlds') loadWorlds();
  if (tab === 'npcs') loadNPCs();
  if (tab === 'items') loadItems();
  if (tab === 'materials') loadMaterials();
  if (tab === 'rewards') loadRewards();
}

function switchQuestType(type, el) {
  currentQuestType = type;
  document.querySelectorAll('.quest-types button').forEach(b => b.classList.remove('active'));
  if (el && el.classList) el.classList.add('active');
  if (selectedWorldId) loadWorldQuests(selectedWorldId, type);
}

function switchContentTab(tab) {
  currentContentTab = tab;
  document.querySelectorAll('.content-section-inner').forEach(e => e.classList.remove('active'));
  document.getElementById('world-' + tab).classList.add('active');
  document.querySelectorAll('.content-tabs button').forEach(b => {
    b.classList.toggle('active', b.textContent.toLowerCase().includes(tab));
  });
  
  if (selectedWorldId) {
    if (tab === 'quests') loadWorldQuests(selectedWorldId, currentQuestType);
    if (tab === 'town-defence') loadTownDefenceQuests();
    if (tab === 'bosses') loadWorldBosses(selectedWorldId);
    if (tab === 'dungeons') loadWorldDungeons(selectedWorldId);
    if (tab === 'raids') loadWorldRaids(selectedWorldId);
  }
}

function loadWorlds() {
  fetch('/api/editor/worlds', { credentials: 'include' })
    .then(r => {
      if (!r.ok) throw new Error('Failed to load worlds');
      return r.json();
    })
    .then(worlds => {
      const container = document.getElementById('worlds-list');
      if (!worlds || !worlds.length) {
        container.innerHTML = '<p style="text-align:center;opacity:0.6">No worlds yet. Create your first world!</p>';
        return;
      }
      container.innerHTML = worlds.map(w => \`
        <div class="item-card" onclick="selectWorld('\${w.id}', '\${w.name}')">
          <h3>\${w.name}</h3>
          <p>\${w.description || 'No description'}</p>
          <p><strong>Level:</strong> \${w.minLevel || 1} - \${w.maxLevel || 50}</p>
          <div class="item-actions" onclick="event.stopPropagation()">
            <button class="btn-view" onclick="selectWorld('\${w.id}', '\${w.name}')">Manage Content</button>
            <button class="btn-edit" onclick="editWorld('\${w.id}')">Edit</button>
          </div>
        </div>
      \`).join('');
    })
    .catch(err => {
      const container = document.getElementById('worlds-list');
      container.innerHTML = '<p style="color: #ff6b6b; text-align:center;">Error loading worlds: ' + err.message + '</p>';
      console.error('Error loading worlds:', err);
    });
}

function selectWorld(worldId, worldName) {
  selectedWorldId = worldId;
  document.getElementById('world-content-title').textContent = worldName + ' - Content';
  document.getElementById('world-content-panel').style.display = 'block';
  document.getElementById('worlds-list').style.display = 'none';
  document.querySelector('.btn-create').style.display = 'none';
  
  // Load initial content
  loadWorldQuests(worldId, currentQuestType);
}

function closeWorldContent() {
  selectedWorldId = null;
  document.getElementById('world-content-panel').style.display = 'none';
  document.getElementById('worlds-list').style.display = 'grid';
  document.querySelector('.btn-create').style.display = 'block';
}

// Helper function to format reward display
function formatRewardsDisplay(rewards) {
  if (!rewards || Object.keys(rewards).length === 0) return '';
  const rewardParts = [];
  for (const [rewardId, dropChance] of Object.entries(rewards)) {
    const reward = availableRewards[rewardId];
    const rewardName = reward?.name || rewardId;
    rewardParts.push(rewardName + ' (' + (dropChance || 100) + '%)');
  }
  return rewardParts.length > 0 ? '<p><strong>Rewards:</strong> ' + rewardParts.join(', ') + '</p>' : '';
}

function loadWorldQuests(worldId, type) {
  loadAvailableRewards().then(() => {
    fetch('/api/editor/quests?worldId=' + worldId, { credentials: 'include' })
      .then(r => {
        if (!r.ok) throw new Error('Server returned ' + r.status);
        return r.json();
      })
      .then(data => {
        // Filter out NPC-exclusive quests and town defence quests (starting with defense_)
        const quests = (data[type] || []).filter(q => !q.npcId && (!q.id || !q.id.startsWith('defense_')));
        const container = document.getElementById('world-quests-list');
        if (!quests.length) {
          container.innerHTML = '<p style="opacity:0.6">No ' + type + ' quests for this world yet</p>';
          return;
        }
        container.innerHTML = quests.map(q => \`
          <div class="item-card">
            <h3>\${q.title || q.name}</h3>
            <p style="opacity:0.7;font-size:0.85em">ID: <code>\${q.id}</code></p>
            <p>\${q.description || 'No description'}</p>
            \${q.objectives ? '<p><strong>Objectives:</strong> ' + q.objectives.join(', ') + '</p>' : ''}
            \${formatRewardsDisplay(q.rewards || {})}
            <div class="item-actions">
              <button class="btn-edit" onclick="editQuest('\${q.id}')">Edit</button>
              <button class="btn-delete" onclick="deleteQuest('\${q.id}')">Delete</button>
            </div>
          </div>
        \`).join('');
      })
      .catch(err => {
        console.error('Error loading quests:', err);
        const container = document.getElementById('world-quests-list');
        container.innerHTML = '<p style="color:#ff6b6b">Error loading quests: ' + err.message + '</p>';
      });
  });
}

function loadWorldBosses(worldId) {
  loadAvailableRewards().then(() => {
    fetch('/api/editor/bosses?worldId=' + worldId, { credentials: 'include' })
      .then(r => r.json())
      .then(bosses => {
        const container = document.getElementById('world-bosses-list');
        if (!bosses.length) {
          container.innerHTML = '<p style="opacity:0.6">No bosses for this world yet</p>';
          return;
        }
        container.innerHTML = bosses.map(b => \`
          <div class="item-card">
            <h3>\${b.name}</h3>
            <p>\${b.description || 'No description'}</p>
            <p><strong>HP:</strong> \${b.hp} | <strong>Level:</strong> \${b.level}</p>
            \${formatRewardsDisplay(b.rewards || {})}
            <div class="item-actions">
              <button class="btn-edit" onclick="editBoss('\${b.id}')">Edit</button>
              <button class="btn-delete" onclick="deleteBoss('\${b.id}')">Delete</button>
            </div>
          </div>
        \`).join('');
      });
  });
}

function loadWorldDungeons(worldId) {
  loadAvailableRewards().then(() => {
    fetch('/api/editor/dungeons?worldId=' + worldId, { credentials: 'include' })
      .then(r => r.json())
      .then(dungeons => {
        const container = document.getElementById('world-dungeons-list');
        if (!dungeons.length) {
          container.innerHTML = '<p style="opacity:0.6">No dungeons for this world yet</p>';
          return;
        }
        
        // Load boss names for each dungeon
        Promise.all(dungeons.map(d => {
          if (!d.bosses || d.bosses.length === 0) return Promise.resolve({ ...d, bossNames: [] });
          return Promise.all(d.bosses.map(bossId => fetch('/api/editor/bosses/' + bossId, { credentials: 'include' }).then(r => r.json()).catch(() => null)))
            .then(bosses => ({ ...d, bossNames: bosses.filter(b => b).map(b => b.name) }));
        })).then(dungeonsWithBosses => {
          container.innerHTML = dungeonsWithBosses.map(d => {
            const bossesDisplay = d.bossNames && d.bossNames.length > 0 ? '<p><strong>Bosses:</strong> ' + d.bossNames.join(', ') + '</p>' : '';
            return '<div class="item-card"><h3>' + d.name + '</h3><p>' + (d.description || 'No description') + '</p><p><strong>Difficulty:</strong> ' + (d.difficulty || 'normal') + '</p>' + bossesDisplay + formatRewardsDisplay(d.rewards || {}) + '<div class="item-actions"><button class="btn-edit dungeon-edit" data-id="' + d.id + '">Edit</button><button class="btn-delete dungeon-delete" data-id="' + d.id + '">Delete</button></div></div>';
          }).join('');
          document.querySelectorAll('.dungeon-edit').forEach(btn => btn.addEventListener('click', function() { editDungeon(this.getAttribute('data-id')); }));
          document.querySelectorAll('.dungeon-delete').forEach(btn => btn.addEventListener('click', function() { deleteDungeon(this.getAttribute('data-id')); }));
        });
      });
  });
}

function loadWorldRaids(worldId) {
  loadAvailableRewards().then(() => {
    fetch('/api/editor/raids?worldId=' + worldId, { credentials: 'include' })
      .then(r => r.json())
      .then(raids => {
        const container = document.getElementById('world-raids-list');
        if (!raids.length) {
          container.innerHTML = '<p style="opacity:0.6">No raids for this world yet</p>';
          return;
        }
        
        // Load boss names for each raid
        Promise.all(raids.map(r => {
          if (!r.bosses || r.bosses.length === 0) return Promise.resolve({ ...r, bossNames: [] });
          return Promise.all(r.bosses.map(bossId => fetch('/api/editor/bosses/' + bossId, { credentials: 'include' }).then(res => res.json()).catch(() => null)))
            .then(bosses => ({ ...r, bossNames: bosses.filter(b => b).map(b => b.name) }));
        })).then(raidsWithBosses => {
          container.innerHTML = raidsWithBosses.map(r => {
            const bossesDisplay = r.bossNames && r.bossNames.length > 0 ? '<p><strong>Bosses:</strong> ' + r.bossNames.join(', ') + '</p>' : '';
            return '<div class="item-card"><h3>' + r.name + '</h3><p>' + (r.description || 'No description') + '</p><p><strong>Floors:</strong> ' + (r.floors?.length || 1) + ' | <strong>Min Level:</strong> ' + r.minLevel + '</p>' + bossesDisplay + formatRewardsDisplay(r.rewards || {}) + '<div class="item-actions"><button class="btn-edit raid-edit" data-id="' + r.id + '">Edit</button><button class="btn-delete raid-delete" data-id="' + r.id + '">Delete</button></div></div>';
          }).join('');
          document.querySelectorAll('.raid-edit').forEach(btn => btn.addEventListener('click', function() { editRaid(this.getAttribute('data-id')); }));
          document.querySelectorAll('.raid-delete').forEach(btn => btn.addEventListener('click', function() { deleteRaid(this.getAttribute('data-id')); }));
        });
      });
  });
}

// Town Defence Quest Management
function loadTownDefenceQuests() {
  fetch('/api/defense-quests', { credentials: 'include' })
    .then(r => r.json())
    .then(quests => {
      const container = document.getElementById('town-defence-list');
      if (!quests || !quests.length) {
        container.innerHTML = '<p style="opacity:0.6">No town defence quests found</p>';
        return;
      }
      
      container.innerHTML = quests.map(q => \`
        <div class="item-card">
          <h3>\${q.name}</h3>
          <p style="opacity:0.7;font-size:0.85em">ID: <code>\${q.id}</code></p>
          <p>\${q.description || 'No description'}</p>
          <p><strong>Type:</strong> \${q.type} | <strong>Min Level:</strong> \${q.minLevel}</p>
          \${q.unlocks ? '<p><strong>Unlocks:</strong> ' + q.unlocks + '</p>' : ''}
          \${q.type === 'combat' && q.enemy ? '<p><strong>Enemy:</strong> ' + q.enemy.name + ' (Lvl ' + q.enemy.level + ', ' + q.enemy.hp + ' HP)</p>' : ''}
          \${q.type === 'choice' && q.branches ? '<p><strong>Choices:</strong> ' + q.branches.length + ' branches</p>' : ''}
          \${q.reward ? '<p><strong>Reward:</strong> ' + q.reward.xp + ' XP, ' + q.reward.gold + ' Gold' + (q.reward.unlockClass ? ', <strong>ðŸŽ“ Class Unlock</strong>' : '') + '</p>' : ''}
          <div class="item-actions">
            <button class="btn-view" onclick="viewTownDefenceQuest('\${q.id}')">View Details</button>
            <button class="btn-edit" onclick="editTownDefenceQuest('\${q.id}')">Edit</button>
            <button class="btn-delete" onclick="deleteTownDefenceQuest('\${q.id}')">Delete</button>
          </div>
        </div>
      \`).join('');
    })
    .catch(err => {
      console.error('Error loading town defence quests:', err);
      document.getElementById('town-defence-list').innerHTML = '<p style="color:#ff6b6b">Error loading town defence quests</p>';
    });
}

function createTownDefenceQuest() {
  editingDefenseQuestId = null;
  
  // Reset form
  document.getElementById('defenseQuestTitle').value = '';
  document.getElementById('defenseQuestDescription').value = '';
  document.getElementById('defenseQuestType').value = 'combat';
  document.getElementById('defenseQuestMinLevel').value = '1';
  document.getElementById('defenseQuestUnlocks').value = '';
  document.getElementById('defenseEnemyName').value = '';
  document.getElementById('defenseEnemyLevel').value = '1';
  document.getElementById('defenseEnemyHP').value = '100';
  document.getElementById('defenseEnemyStr').value = '5';
  document.getElementById('defenseEnemyDef').value = '5';
  document.getElementById('defenseEnemyInt').value = '5';
  document.getElementById('defenseEnemyAgi').value = '5';
  document.getElementById('defenseEnemySkills').value = '';
  document.getElementById('defenseRewardXP').value = '100';
  document.getElementById('defenseRewardGold').value = '50';
  document.getElementById('defenseRewardUnlockClass').checked = false;
  document.getElementById('defenseRewardItems').value = '';
  
  toggleDefenseQuestTypeFields();
  document.getElementById('defenseQuestModal').classList.add('active');
}

function viewTownDefenceQuest(questId) {
  fetch('/api/defense-quests/' + questId, { credentials: 'include' })
    .then(r => r.json())
    .then(quest => {
      let detailsHTML = '<div style="background:#1a1d23;padding:20px;border-radius:8px;border:2px solid #9146ff">';
      detailsHTML += '<h2 style="color:#9146ff;margin-bottom:15px">' + quest.name + '</h2>';
      detailsHTML += '<p style="margin-bottom:10px">' + quest.description + '</p>';
      detailsHTML += '<p><strong>Type:</strong> ' + quest.type + '</p>';
      detailsHTML += '<p><strong>Min Level:</strong> ' + quest.minLevel + '</p>';
      
      if (quest.unlocks) {
        detailsHTML += '<p><strong>Unlocks:</strong> ' + quest.unlocks + '</p>';
      }
      
      if (quest.type === 'combat' && quest.enemy) {
        detailsHTML += '<h3 style="color:#9146ff;margin-top:15px">Enemy</h3>';
        detailsHTML += '<p><strong>Name:</strong> ' + quest.enemy.name + '</p>';
        detailsHTML += '<p><strong>Level:</strong> ' + quest.enemy.level + '</p>';
        detailsHTML += '<p><strong>HP:</strong> ' + quest.enemy.hp + '</p>';
        detailsHTML += '<p><strong>Stats:</strong> STR ' + quest.enemy.stats.strength + ', DEF ' + quest.enemy.stats.defense + ', INT ' + quest.enemy.stats.intelligence + ', AGI ' + quest.enemy.stats.agility + '</p>';
        if (quest.enemy.skills) {
          detailsHTML += '<p><strong>Skills:</strong> ' + quest.enemy.skills.join(', ') + '</p>';
        }
      }
      
      if (quest.type === 'choice' && quest.branches) {
        detailsHTML += '<h3 style="color:#9146ff;margin-top:15px">Choices</h3>';
        quest.branches.forEach((branch, idx) => {
          detailsHTML += '<div style="background:rgba(255,255,255,0.05);padding:10px;border-radius:4px;margin-bottom:10px">';
          detailsHTML += '<p><strong>' + (idx + 1) + '. ' + branch.title + '</strong></p>';
          detailsHTML += '<p style="font-size:0.9em;opacity:0.8">' + branch.description + '</p>';
          detailsHTML += '</div>';
        });
        
        if (quest.outcomes) {
          detailsHTML += '<h3 style="color:#9146ff;margin-top:15px">Outcomes</h3>';
          quest.outcomes.forEach((outcome, idx) => {
            detailsHTML += '<div style="background:rgba(255,255,255,0.05);padding:10px;border-radius:4px;margin-bottom:10px">';
            detailsHTML += '<p><strong>' + outcome.title + '</strong> ' + (outcome.isNegative ? 'âŒ' : 'âœ…') + '</p>';
            detailsHTML += '<p style="font-size:0.9em;opacity:0.8">' + outcome.description + '</p>';
            if (outcome.reward) {
              detailsHTML += '<p style="font-size:0.85em"><strong>Reward:</strong> ' + outcome.reward.xp + ' XP, ' + outcome.reward.gold + ' Gold</p>';
            }
            detailsHTML += '</div>';
          });
        }
      }
      
      if (quest.reward) {
        detailsHTML += '<h3 style="color:#9146ff;margin-top:15px">Rewards</h3>';
        detailsHTML += '<p><strong>XP:</strong> ' + quest.reward.xp + '</p>';
        detailsHTML += '<p><strong>Gold:</strong> ' + quest.reward.gold + '</p>';
        if (quest.reward.unlockClass) {
          detailsHTML += '<p style="color:#ffa500"><strong>ðŸŽ“ Class Unlock: Enabled</strong></p>';
        }
        if (quest.reward.items && quest.reward.items.length > 0) {
          detailsHTML += '<p><strong>Items:</strong></p><ul>';
          quest.reward.items.forEach(item => {
            detailsHTML += '<li>' + item.id + ' x' + (item.quantity || 1) + '</li>';
          });
          detailsHTML += '</ul>';
        }
      }
      
      detailsHTML += '<button onclick="closeTownDefenceDetails()" style="margin-top:20px;padding:10px 20px;background:#9146ff;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold">Close</button>';
      detailsHTML += '</div>';
      
      const modal = document.createElement('div');
      modal.id = 'townDefenceDetailsModal';
      modal.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.8);z-index:10000;display:flex;justify-content:center;align-items:flex-start;overflow-y:auto;padding:20px';
      modal.innerHTML = '<div style="width:90%;max-width:800px;margin:20px auto">' + detailsHTML + '</div>';
      document.body.appendChild(modal);
    })
    .catch(err => {
      console.error('Error loading quest details:', err);
      alert('Failed to load quest details');
    });
}

function closeTownDefenceDetails() {
  const modal = document.getElementById('townDefenceDetailsModal');
  if (modal) modal.remove();
}

function editTownDefenceQuest(questId) {
  fetch('/api/defense-quests/' + questId, { credentials: 'include' })
    .then(r => r.json())
    .then(quest => {
      editingDefenseQuestId = questId;
      
      // Populate the defense quest modal
      document.getElementById('defenseQuestTitle').value = quest.name || '';
      document.getElementById('defenseQuestDescription').value = quest.description || '';
      document.getElementById('defenseQuestType').value = quest.type || 'combat';
      document.getElementById('defenseQuestMinLevel').value = quest.minLevel || 1;
      document.getElementById('defenseQuestUnlocks').value = quest.unlocks || '';
      
      // Enemy details for combat quests
      if (quest.type === 'combat' && quest.enemy) {
        document.getElementById('defenseEnemyName').value = quest.enemy.name || '';
        document.getElementById('defenseEnemyLevel').value = quest.enemy.level || 1;
        document.getElementById('defenseEnemyHP').value = quest.enemy.hp || 100;
        document.getElementById('defenseEnemyStr').value = quest.enemy.stats?.strength || 0;
        document.getElementById('defenseEnemyDef').value = quest.enemy.stats?.defense || 0;
        document.getElementById('defenseEnemyInt').value = quest.enemy.stats?.intelligence || 0;
        document.getElementById('defenseEnemyAgi').value = quest.enemy.stats?.agility || 0;
        document.getElementById('defenseEnemySkills').value = quest.enemy.skills?.join(', ') || '';
      }
      
      // Reward details
      if (quest.reward) {
        document.getElementById('defenseRewardXP').value = quest.reward.xp || 0;
        document.getElementById('defenseRewardGold').value = quest.reward.gold || 0;
        document.getElementById('defenseRewardUnlockClass').checked = quest.reward.unlockClass || false;
        document.getElementById('defenseRewardItems').value = quest.reward.items?.map(i => i.id + ' x' + (i.quantity || 1)).join(', ') || '';
      }
      
      toggleDefenseQuestTypeFields();
      document.getElementById('defenseQuestModal').classList.add('active');
    })
    .catch(err => {
      console.error('Error loading defense quest:', err);
      alert('Failed to load quest for editing');
    });
}

function deleteTownDefenceQuest(questId) {
  if (!confirm('Are you sure you want to delete this town defence quest?')) return;
  
  fetch('/api/defense-quests/' + questId, {
    method: 'DELETE',
    credentials: 'include'
  })
    .then(r => r.json())
    .then(() => {
      loadTownDefenceQuests();
    })
    .catch(err => {
      console.error('Error deleting defense quest:', err);
      alert('Failed to delete quest');
    });
}

function toggleDefenseQuestTypeFields() {
  const type = document.getElementById('defenseQuestType').value;
  document.getElementById('defenseQuestCombatFields').style.display = type === 'combat' ? 'block' : 'none';
  document.getElementById('defenseQuestChoiceFields').style.display = type === 'choice' ? 'block' : 'none';
}

function closeDefenseQuestModal() {
  document.getElementById('defenseQuestModal').classList.remove('active');
  editingDefenseQuestId = null;
}

let editingDefenseQuestId = null;

function submitDefenseQuest() {
  const name = document.getElementById('defenseQuestTitle').value;
  if (!name) {
    alert('Please enter a quest name');
    return;
  }
  
  const type = document.getElementById('defenseQuestType').value;
  const questData = {
    id: editingDefenseQuestId || 'defense_' + Date.now(),
    name: name,
    description: document.getElementById('defenseQuestDescription').value,
    type: type,
    minLevel: parseInt(document.getElementById('defenseQuestMinLevel').value) || 1,
    unlocks: document.getElementById('defenseQuestUnlocks').value || null
  };
  
  // Add enemy for combat quests
  if (type === 'combat') {
    const enemyName = document.getElementById('defenseEnemyName').value;
    if (!enemyName) {
      alert('Please enter an enemy name for combat quests');
      return;
    }
    
    questData.enemy = {
      name: enemyName,
      level: parseInt(document.getElementById('defenseEnemyLevel').value) || 1,
      hp: parseInt(document.getElementById('defenseEnemyHP').value) || 100,
      stats: {
        strength: parseInt(document.getElementById('defenseEnemyStr').value) || 5,
        defense: parseInt(document.getElementById('defenseEnemyDef').value) || 5,
        intelligence: parseInt(document.getElementById('defenseEnemyInt').value) || 5,
        agility: parseInt(document.getElementById('defenseEnemyAgi').value) || 5
      },
      skills: document.getElementById('defenseEnemySkills').value.split(',').map(s => s.trim()).filter(s => s)
    };
  }
  
  // Add rewards
  const itemsStr = document.getElementById('defenseRewardItems').value;
  const items = [];
  if (itemsStr) {
    itemsStr.split(',').forEach(itemStr => {
      const parts = itemStr.trim().split(/\s*x\s*/);
      if (parts.length === 2) {
        items.push({ id: parts[0].trim(), quantity: parseInt(parts[1]) || 1 });
      } else if (parts.length === 1 && parts[0]) {
        items.push({ id: parts[0].trim(), quantity: 1 });
      }
    });
  }
  
  questData.reward = {
    xp: parseInt(document.getElementById('defenseRewardXP').value) || 0,
    gold: parseInt(document.getElementById('defenseRewardGold').value) || 0,
    unlockClass: document.getElementById('defenseRewardUnlockClass').checked,
    items: items
  };
  
  const method = editingDefenseQuestId ? 'PUT' : 'POST';
  const url = editingDefenseQuestId ? '/api/defense-quests/' + editingDefenseQuestId : '/api/defense-quests';
  
  fetch(url, {
    method: method,
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(questData)
  })
    .then(r => {
      if (!r.ok) {
        return r.json().then(err => {
          throw new Error(err?.error || 'Failed to save quest');
        });
      }
      return r.json();
    })
    .then(() => {
      closeDefenseQuestModal();
      loadTownDefenceQuests();
    })
    .catch(err => {
      console.error('Error saving defense quest:', err);
      alert('Error saving quest: ' + err.message);
    });
}

// Create functions
function createWorld() {
  loadWorldBossesForWorldModal();
  loadAvailableWorlds();
  document.getElementById('worldModal').classList.add('active');
}

function closeWorldModal() {
  document.getElementById('worldModal').classList.remove('active');
  document.getElementById('worldName').value = '';
  document.getElementById('worldTier').value = '1';
  document.getElementById('worldDescription').value = '';
  document.getElementById('worldMinLevel').value = '1';
  document.getElementById('worldMaxLevel').value = '50';
  document.getElementById('worldBossSelect').value = '';
  document.getElementById('worldNextWorldSelect').value = '';
}

function loadWorldBossesForWorldModal() {
  // Load all bosses for the world boss selector
  fetch('/api/editor/bosses', { credentials: 'include' })
    .then(r => r.json())
    .then(bosses => {
      const select = document.getElementById('worldBossSelect');
      const currentValue = select.value;
      select.innerHTML = '<option value="">No Boss</option>';
      if (Array.isArray(bosses)) {
        bosses.forEach(boss => {
          select.innerHTML += '<option value="' + (boss.id || '') + '">' + (boss.name || 'Unknown') + ' (HP: ' + (boss.hp || 0) + ', Lvl: ' + (boss.level || 1) + ')</option>';
        });
      }
      select.value = currentValue;
    })
    .catch(err => console.error('Error loading bosses:', err));
}

function loadAvailableWorlds() {
  return fetch('/api/editor/worlds', { credentials: 'include' })
    .then(r => r.json())
    .then(worlds => {
      const select = document.getElementById('worldNextWorldSelect');
      if (select) {
        const currentValue = select.value;
        select.innerHTML = '<option value="">None</option>';
        if (Array.isArray(worlds)) {
          worlds.forEach(world => {
            select.innerHTML += '<option value="' + (world.id || '') + '">' + (world.name || 'Unknown') + '</option>';
          });
        }
        select.value = currentValue;
      }
      return worlds || [];
    });
}

function submitWorld() {
  const name = document.getElementById('worldName').value;
  if (!name) {
    alert('Please enter a world name');
    return;
  }
  
  const method = editingId ? 'PUT' : 'POST';
  const url = editingId ? '/api/editor/worlds/' + editingId : '/api/editor/worlds';
  
  fetch(url, {
    method: method,
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      id: editingId,
      name,
      tier: parseInt(document.getElementById('worldTier').value) || 1,
      description: document.getElementById('worldDescription').value,
      minLevel: parseInt(document.getElementById('worldMinLevel').value) || 1,
      maxLevel: parseInt(document.getElementById('worldMaxLevel').value) || 50,
      worldBoss: document.getElementById('worldBossSelect').value || null,
      nextWorldId: document.getElementById('worldNextWorldSelect').value || null
    })
  }).then(r => r.json()).then(() => {
    editingId = null;
    closeWorldModal();
    loadWorlds();
  }).catch(err => alert('Error saving world: ' + err.message));
}

function toggleQuestCondition(type) {
  const checkbox = document.getElementById('questCond' + type.charAt(0).toUpperCase() + type.slice(1));
  const fields = document.getElementById('questCond' + type.charAt(0).toUpperCase() + type.slice(1) + 'Fields');
  if (fields) fields.style.display = checkbox && checkbox.checked ? 'block' : 'none';
}

function toggleQuestTypeFields() {
  const questType = document.getElementById('questType').value;
  const standardFields = document.getElementById('standardQuestFields');
  const choiceFields = document.getElementById('choiceQuestFields');
  
  if (questType === 'choice') {
    standardFields.style.display = 'none';
    choiceFields.style.display = 'block';
    // Initialize with one empty branch if none exist
    if (document.querySelectorAll('.quest-branch-card').length === 0) {
      addQuestBranch();
    }
  } else {
    standardFields.style.display = 'block';
    choiceFields.style.display = 'none';
  }
}

let branchCounter = 0;

function addQuestBranch() {
  branchCounter++;
  const container = document.getElementById('questBranchesContainer');
  const branchId = 'branch_' + branchCounter;
  
  const branchHtml = \`<div class="quest-branch-card" data-branch-id="\${branchId}" style="background:#2a2f3a;border:1px solid #3a3f4a;border-radius:8px;padding:15px;margin-bottom:15px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
    <h4 style="margin:0;color:#9146ff">Branch \${branchCounter}</h4>
    <button type="button" class="small danger" onclick="removeQuestBranch('\${branchId}')" style="padding:4px 8px">âœ•</button>
    </div>
    <div class="form-group" style="margin-bottom:10px">
    <label style="font-size:12px">Branch Title *</label>
    <input type="text" class="branch-title" placeholder="e.g. âš¡ Use the Artifact" style="width:100%">
    </div>
    <div class="form-group" style="margin-bottom:10px">
    <label style="font-size:12px">Branch Description</label>
    <textarea class="branch-description" placeholder="What happens when player chooses this" style="width:100%;min-height:60px"></textarea>
    </div>
    <div style="border-top:1px solid #4a4f5a;padding-top:10px;margin-top:10px">
    <h5 style="margin:0 0 10px 0;color:#ffca28">Outcome</h5>
    <div class="form-group" style="margin-bottom:10px">
    <label style="font-size:12px">Outcome Title</label>
    <input type="text" class="outcome-title" placeholder="e.g. Corrupted Power">
    </div>
    <div class="form-group" style="margin-bottom:10px">
    <label style="font-size:12px">Outcome Description</label>
    <textarea class="outcome-description" placeholder="Describe what happens after this choice" style="min-height:60px"></textarea>
    </div>
    <div class="form-group" style="margin-bottom:10px">
    <label><input type="checkbox" class="outcome-negative"> Negative Outcome (bad for player)</label>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
    <div class="form-group">
    <label style="font-size:12px">XP Reward</label>
    <input type="number" class="outcome-xp" value="500" min="0">
    </div>
    <div class="form-group">
    <label style="font-size:12px">Gold Reward</label>
    <input type="number" class="outcome-gold" value="250" min="0">
    </div>
    </div>
    <div class="form-group" style="margin-bottom:10px">
    <label style="font-size:12px">Item Rewards (comma-separated item IDs)</label>
    <input type="text" class="outcome-items" placeholder="e.g. cursed_amulet, ancient_fang">
    </div>
    <div class="form-group" style="margin-bottom:10px">
    <label style="font-size:12px">Flags to Set (comma-separated)</label>
    <input type="text" class="outcome-flags" placeholder="e.g. quest_artifact_used, cursed_player">
    </div>
    <div class="form-group">
    <label style="font-size:12px">Permanent Buff/Debuff Name (optional)</label>
    <input type="text" class="outcome-buff-name" placeholder="e.g. Cursed, Blessed">
    </div>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px">
    <div class="form-group">
    <label style="font-size:11px">STR</label>
    <input type="number" class="buff-str" value="0">
    </div>
    <div class="form-group">
    <label style="font-size:11px">INT</label>
    <input type="number" class="buff-int" value="0">
    </div>
    <div class="form-group">
    <label style="font-size:11px">WIS</label>
    <input type="number" class="buff-wis" value="0">
    </div>
    <div class="form-group">
    <label style="font-size:11px">AGI</label>
    <input type="number" class="buff-agi" value="0">
    </div>
    <div class="form-group">
    <label style="font-size:11px">DEF</label>
    <input type="number" class="buff-def" value="0">
    </div>
    <div class="form-group">
    <label style="font-size:11px">HP</label>
    <input type="number" class="buff-hp" value="0">
    </div>
    </div>
    </div>
    </div>\`;
  
  container.insertAdjacentHTML('beforeend', branchHtml);
}

function removeQuestBranch(branchId) {
  const card = document.querySelector('[data-branch-id="' + branchId + '"]');
  if (card) card.remove();
}

function getQuestBranches() {
  const branches = [];
  const outcomes = [];
  
  document.querySelectorAll('.quest-branch-card').forEach((card, index) => {
    const branchId = 'branch_' + (index + 1);
    const title = card.querySelector('.branch-title').value;
    const description = card.querySelector('.branch-description').value;
    
    if (!title) return;
    
    branches.push({
      id: branchId,
      title: title,
      description: description
    });
    
    const outcomeTitle = card.querySelector('.outcome-title').value;
    const outcomeDesc = card.querySelector('.outcome-description').value;
    const isNegative = card.querySelector('.outcome-negative').checked;
    const xp = parseInt(card.querySelector('.outcome-xp').value) || 0;
    const gold = parseInt(card.querySelector('.outcome-gold').value) || 0;
    const itemsStr = card.querySelector('.outcome-items').value;
    const flagsStr = card.querySelector('.outcome-flags').value;
    const buffName = card.querySelector('.outcome-buff-name').value;
    
    const items = itemsStr ? itemsStr.split(',').map(s => ({ id: s.trim(), quantity: 1 })).filter(i => i.id) : [];
    const flags = flagsStr ? flagsStr.split(',').map(s => s.trim()).filter(f => f) : [];
    
    const outcome = {
      id: 'outcome_' + (index + 1),
      branchId: branchId,
      title: outcomeTitle || title + ' Result',
      description: outcomeDesc,
      isNegative: isNegative,
      reward: { xp, gold, items },
      flagsSet: flags
    };
    
    // Add buff/debuff if specified
    if (buffName) {
      const buff = {
        name: buffName,
        effect: {
          strength: parseInt(card.querySelector('.buff-str').value) || 0,
          intelligence: parseInt(card.querySelector('.buff-int').value) || 0,
          wisdom: parseInt(card.querySelector('.buff-wis').value) || 0,
          agility: parseInt(card.querySelector('.buff-agi').value) || 0,
          defense: parseInt(card.querySelector('.buff-def').value) || 0,
          hp: parseInt(card.querySelector('.buff-hp').value) || 0
        }
      };
      
      if (isNegative) {
        outcome.consequences = { permanentDebuff: buff };
      } else {
        outcome.bonuses = { permanentBuff: buff };
      }
    }
    
    outcomes.push(outcome);
  });
  
  return { branches, outcomes };
}

function createWorldQuest() {
  branchCounter = 0;
  editingId = null;
  
  // Reset form
  document.getElementById('questTitle').value = '';
  document.getElementById('questDescription').value = '';
  document.getElementById('questType').value = 'side';
  document.getElementById('questMinLevel').value = '1';
  document.getElementById('questUnlocks').value = '';
  document.getElementById('questObjectives').value = '';
  document.getElementById('questBranchesContainer').innerHTML = '';
  
  // Show standard fields by default
  toggleQuestTypeFields();

  // Render tasks immediately so selector doesn't stay in loading state
  renderTaskSelector();
  document.getElementById('questModal').classList.add('active');

  loadAvailableRewards()
    .then(() => {
      renderRewardSelector('questRewardSelector');
    })
    .catch(() => {
      // Keep modal usable even if rewards fail to load
      const rewardContainer = document.getElementById('questRewardSelector');
      if (rewardContainer) rewardContainer.innerHTML = '<p style="opacity:0.6">Rewards failed to load</p>';
    });
}

function closeQuestModal() {
  document.getElementById('questModal').classList.remove('active');
  document.getElementById('questTitle').value = '';
  document.getElementById('questDescription').value = '';
  document.getElementById('questObjectives').value = '';
  document.getElementById('questBranchesContainer').innerHTML = '';
  branchCounter = 0;
}

function submitQuest() {
  const title = document.getElementById('questTitle').value;
  if (!title) {
    alert('Please enter a quest title');
    return;
  }
  if (!selectedWorldId) {
    alert('Please select a world before creating a quest');
    return;
  }
  
  const questType = document.getElementById('questType').value;
  const minLevel = parseInt(document.getElementById('questMinLevel').value) || 1;
  const unlocks = document.getElementById('questUnlocks').value || null;
  const description = document.getElementById('questDescription').value;
  
  let questData = {
    id: editingId,
    title,
    name: title,
    description,
    type: questType,
    minLevel,
    unlocks,
    worldId: selectedWorldId
  };
  
  if (questType === 'choice') {
    // Choice quest - get branches and outcomes
    const { branches, outcomes } = getQuestBranches();
    
    if (branches.length === 0) {
      alert('Please add at least one branch for a choice quest');
      return;
    }
    
    questData.branches = branches;
    questData.outcomes = outcomes;
  } else {
    // Standard quest - get objectives, tasks, and rewards
    const objectives = document.getElementById('questObjectives').value;
    const rewards = getSelectedRewards('questRewardSelector');
    const selectedTasks = getSelectedTasks();
    
    let allObjectives = [];
    if (objectives) {
      allObjectives = objectives.split(',').map(o => o.trim()).filter(o => o);
    }
    allObjectives = allObjectives.concat(selectedTasks);
    
    questData.objectives = allObjectives;
    questData.rewards = rewards;
    
    // Add class unlock flag for class-unlock type quests
    if (questType === 'class-unlock') {
      questData.rewards = questData.rewards || {};
      questData.rewards.unlockClass = true;
    }
  }
  
  const method = editingId ? 'PUT' : 'POST';
  const url = editingId ? '/api/editor/quests/' + editingId : '/api/editor/quests';
  
  fetch(url, {
    method: method,
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(questData)
  }).then(r => {
    if (!r.ok) {
      return r.json().then(err => {
        throw new Error(err?.error || 'Failed to save quest');
      });
    }
    return r.json();
  }).then(() => {
    editingId = null;
    closeQuestModal();
    loadWorldQuests(selectedWorldId, currentQuestType);
  }).catch(err => alert('Error saving quest: ' + err.message));
}

function createWorldBoss() {
  loadAvailableRewards().then(() => {
    renderRewardSelector('bossRewardSelector');
    document.getElementById('bossModal').classList.add('active');
  });
}

function closeBossModal() {
  document.getElementById('bossModal').classList.remove('active');
  document.getElementById('bossName').value = '';
  document.getElementById('bossDescription').value = '';
  document.getElementById('bossHP').value = '100';
  document.getElementById('bossLevel').value = '10';
}

function submitBoss() {
  const name = document.getElementById('bossName').value;
  if (!name) {
    alert('Please enter a boss name');
    return;
  }
  
  const rewards = getSelectedRewards('bossRewardSelector');
  const method = editingId ? 'PUT' : 'POST';
  const url = editingId ? '/api/editor/bosses/' + editingId : '/api/editor/bosses';
  
  fetch(url, {
    method: method,
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      id: editingId,
      name,
      description: document.getElementById('bossDescription').value,
      worldId: selectedWorldId,
      hp: parseInt(document.getElementById('bossHP').value) || 100,
      level: parseInt(document.getElementById('bossLevel').value) || 10,
      rewards: rewards
    })
  }).then(r => r.json()).then(() => {
    editingId = null;
    closeBossModal();
    loadWorldBosses(selectedWorldId);
  }).catch(err => alert('Error saving boss: ' + err.message));
}

// Boss selection for dungeons and raids
let selectedBossesForDungeon = [];
let selectedBossesForRaid = [];

function loadWorldBossesForModal(containerId, selectedList) {
  fetch('/api/editor/bosses?worldId=' + selectedWorldId, { credentials: 'include' })
    .then(r => r.json())
    .then(bosses => {
      if (!Array.isArray(bosses)) bosses = [];
      const container = document.getElementById(containerId);
      
      if (bosses.length === 0) {
        container.innerHTML = '<p style="opacity:0.6;margin:0">No bosses created yet. Create one first!</p>';
        return;
      }
      
      container.innerHTML = bosses.map(boss => {
        const bossIdEscaped = (boss.id || '').replace(/"/g, '&quot;');
        return '<div style="display: flex; align-items: center; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; margin-bottom: 8px;">' +
          '<input type="checkbox" data-boss-id="' + bossIdEscaped + '" data-container="' + containerId + '" data-list="' + selectedList + '" onchange="toggleBossForModal(this)" data-boss-id="' + bossIdEscaped + '">' +
          '<label style="margin: 0 0 0 8px; flex: 1; cursor: pointer;">' + (boss.name || 'Unknown') + ' (HP: ' + (boss.hp || 0) + ', Lvl: ' + (boss.level || 1) + ')</label>' +
          '</div>';
      }).join('');
      
      // Check previously selected bosses
      const list = selectedList === 'dungeon' ? selectedBossesForDungeon : selectedBossesForRaid;
      list.forEach(bossId => {
        const checkbox = container.querySelector('input[data-boss-id="' + (bossId || '').replace(/"/g, '&quot;') + '"]');
        if (checkbox) checkbox.checked = true;
      });
    })
    .catch(err => {
      const container = document.getElementById(containerId);
      container.innerHTML = '<p style="color:#ff6b6b;margin:0">Error loading bosses: ' + err.message + '</p>';
    });
}

function toggleBossForModal(checkbox) {
  const bossId = checkbox.getAttribute('data-boss-id');
  const selectedList = checkbox.getAttribute('data-list');
  const list = selectedList === 'dungeon' ? selectedBossesForDungeon : selectedBossesForRaid;
  
  if (checkbox.checked) {
    if (!list.includes(bossId)) list.push(bossId);
  } else {
    const idx = list.indexOf(bossId);
    if (idx > -1) list.splice(idx, 1);
  }
}

function addBossToDungeon() {
  alert('Bosses selected: ' + selectedBossesForDungeon.join(', ') || 'None');
}

function addBossToRaid() {
  alert('Bosses selected: ' + selectedBossesForRaid.join(', ') || 'None');
}

function createWorldDungeon() {
  selectedBossesForDungeon = [];
  loadAvailableRewards().then(() => {
    renderRewardSelector('dungeonRewardSelector');
    loadWorldBossesForModal('dungeonBossSelector', 'dungeon');
    document.getElementById('dungeonModal').classList.add('active');
  });
}

function closeDungeonModal() {
  document.getElementById('dungeonModal').classList.remove('active');
  document.getElementById('dungeonName').value = '';
  document.getElementById('dungeonDescription').value = '';
}

function submitDungeon() {
  const name = document.getElementById('dungeonName').value;
  if (!name) {
    alert('Please enter a dungeon name');
    return;
  }
  
  const rewards = getSelectedRewards('dungeonRewardSelector');
  const method = editingId ? 'PUT' : 'POST';
  const url = editingId ? '/api/editor/dungeons/' + editingId : '/api/editor/dungeons';
  
  fetch(url, {
    method: method,
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ 
      id: editingId,
      name,
      description: document.getElementById('dungeonDescription').value,
      worldId: selectedWorldId,
      difficulty: document.getElementById('dungeonDifficulty').value,
      minLevel: parseInt(document.getElementById('dungeonMinLevel').value) || 10,
      bosses: selectedBossesForDungeon,
      rewards: rewards
    })
  }).then(r => r.json()).then(() => {
    editingId = null;
    closeDungeonModal();
    loadWorldDungeons(selectedWorldId);
  }).catch(err => alert('Error saving dungeon: ' + err.message));
}

function createWorldRaid() {
  selectedBossesForRaid = [];
  loadAvailableRewards().then(() => {
    renderRaidLayerRewards();
    loadWorldBossesForModal('raidBossSelector', 'raid');
    document.getElementById('raidModal').classList.add('active');
  });
}

function closeRaidModal() {
  document.getElementById('raidModal').classList.remove('active');
  document.getElementById('raidName').value = '';
  document.getElementById('raidDescription').value = '';
  document.getElementById('raidLayers').value = '1';
  document.getElementById('raidTeamSize').value = '4';
  document.getElementById('raidLayerRewardsList').innerHTML = '';
}

function renderRaidLayerRewards() {
  const numLayers = parseInt(document.getElementById('raidLayers')?.value) || 1;
  const container = document.getElementById('raidLayerRewardsList');
  const rarities = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
  
  let html = '';
  for (let i = 0; i < numLayers; i++) {
    const rarity = rarities[Math.min(i, rarities.length - 1)];
    const rarityColor = {
      'common': '#95a5a6',
      'uncommon': '#27ae60',
      'rare': '#3498db',
      'epic': '#9b59b6',
      'legendary': '#f39c12'
    }[rarity] || '#95a5a6';
    
    html += '<div style="background: #1f2229; border-left: 4px solid ' + rarityColor + '; padding: 12px; margin: 10px 0; border-radius: 4px;">';
    html += '<h5 style="margin: 0 0 10px 0; color: ' + rarityColor + ';">Layer ' + (i + 1) + ' - ' + rarity.toUpperCase() + '</h5>';
    html += '<input type="text" id="raidLayer' + i + 'Name" placeholder="Display Name (optional)" style="width: 100%; margin-bottom: 8px; padding: 6px; background: #2a2f3a; border: 1px solid #3a3f4a; color: #e0e0e0;">';
    html += '<label style="font-size: 12px; opacity: 0.8;">Base XP Reward</label>';
    html += '<input type="number" id="raidLayer' + i + 'XP" value="' + (500 * (i + 1)) + '" style="width: 100%; margin-bottom: 8px; padding: 6px; background: #2a2f3a; border: 1px solid #3a3f4a; color: #e0e0e0;">';
    html += '<label style="font-size: 12px; opacity: 0.8;">Base Gold Reward</label>';
    html += '<input type="number" id="raidLayer' + i + 'Gold" value="' + (250 * (i + 1)) + '" style="width: 100%; margin-bottom: 8px; padding: 6px; background: #2a2f3a; border: 1px solid #3a3f4a; color: #e0e0e0;">';
    
    html += '<label style="font-size: 12px; opacity: 0.8; margin-top: 8px; display: block;">Items (with quantities)</label>';
    html += '<input type="text" id="raidLayer' + i + 'ItemSearch" placeholder="Search items..." style="width: 100%; margin-bottom: 4px; padding: 4px; background: #2a2f3a; border: 1px solid #3a3f4a; color: #e0e0e0; font-size: 12px;" oninput="filterLayerItems(' + i + ')">';
    html += '<div id="raidLayer' + i + 'Items" style="background: #25282f; border: 1px solid #2a3f4a; border-radius: 4px; padding: 8px; max-height: 150px; overflow-y: auto; margin-bottom: 8px;">Loading...</div>';
    
    html += '<label style="font-size: 12px; opacity: 0.8; display: block;">Materials (with quantities)</label>';
    html += '<input type="text" id="raidLayer' + i + 'MaterialSearch" placeholder="Search materials..." style="width: 100%; margin-bottom: 4px; padding: 4px; background: #2a2f3a; border: 1px solid #3a3f4a; color: #e0e0e0; font-size: 12px;" oninput="filterLayerMaterials(' + i + ')">';
    html += '<div id="raidLayer' + i + 'Materials" style="background: #25282f; border: 1px solid #2a3f4a; border-radius: 4px; padding: 8px; max-height: 150px; overflow-y: auto;">Loading...</div>';
    html += '</div>';
  }
  
  container.innerHTML = html;
  
  // Load items and materials for each layer
  Promise.all([
    fetch('/api/items', { credentials: 'include' }).then(r => r.json()),
    fetch('/api/materials', { credentials: 'include' }).then(r => r.json())
  ]).then(([items, materials]) => {
    for (let i = 0; i < numLayers; i++) {
      renderLayerItemSelector(i, items, []);
      renderLayerMaterialSelector(i, materials, []);
    }
  });
}

// Update rewards when layer count changes
document.addEventListener('DOMContentLoaded', () => {
  const layersInput = document.getElementById('raidLayers');
  if (layersInput) {
    layersInput.addEventListener('change', renderRaidLayerRewards);
  }
});

function renderLayerItemSelector(layerIndex, items, selectedItems) {
  const container = document.getElementById('raidLayer' + layerIndex + 'Items');
  if (!items || items.length === 0) {
    container.innerHTML = '<p style="opacity:0.6;margin:0;font-size:12px">No items available</p>';
    return;
  }
  
  container.innerHTML = items.map(item => {
    const itemData = selectedItems.find(i => typeof i === 'object' ? i.id === item.id : i === item.id);
    const isChecked = !!itemData;
    const quantity = (itemData && typeof itemData === 'object') ? itemData.quantity : 1;
    const bgColor = isChecked ? '#2a3f3a' : 'rgba(255,255,255,0.03)';
    
    return '<div style="display:block;padding:6px;margin-bottom:3px;background:' + bgColor + ';border-radius:3px" class="layer-item-option" data-layer="' + layerIndex + '">' +
      '<label style="display:flex;align-items:center;cursor:pointer;margin-bottom:4px;font-size:12px">' +
      '<input type="checkbox" value="' + item.id + '" ' + (isChecked ? 'checked' : '') + ' style="margin-right:6px" onchange="toggleLayerItem(' + layerIndex + ', this)">' +
      item.name + ' <span style="opacity:0.5;font-size:11px;margin-left:auto">(' + item.id + ')</span>' +
      '</label>' +
      (isChecked ? '<input type="number" class="layer-item-qty" data-item-id="' + item.id + '" value="' + quantity + '" min="1" max="999" style="width:100%;padding:3px;background:#0a0f1e;border:1px solid #3a3f4a;border-radius:2px;color:#e0e0e0;font-size:11px" placeholder="Qty">' : '') +
      '</div>';
  }).join('');
}

function renderLayerMaterialSelector(layerIndex, materials, selectedMaterials) {
  const container = document.getElementById('raidLayer' + layerIndex + 'Materials');
  const matArray = Object.entries(materials).map(([id, mat]) => ({ id, ...mat }));
  
  if (matArray.length === 0) {
    container.innerHTML = '<p style="opacity:0.6;margin:0;font-size:12px">No materials available</p>';
    return;
  }
  
  container.innerHTML = matArray.map(mat => {
    const matData = selectedMaterials.find(m => typeof m === 'object' ? m.id === mat.id : m === mat.id);
    const isChecked = !!matData;
    const quantity = (matData && typeof matData === 'object') ? matData.quantity : 1;
    const bgColor = isChecked ? '#2a3f3a' : 'rgba(255,255,255,0.03)';
    
    return '<div style="display:block;padding:6px;margin-bottom:3px;background:' + bgColor + ';border-radius:3px" class="layer-material-option" data-layer="' + layerIndex + '">' +
      '<label style="display:flex;align-items:center;cursor:pointer;margin-bottom:4px;font-size:12px">' +
      '<input type="checkbox" value="' + mat.id + '" ' + (isChecked ? 'checked' : '') + ' style="margin-right:6px" onchange="toggleLayerMaterial(' + layerIndex + ', this)">' +
      mat.name + ' <span style="opacity:0.5;font-size:11px;margin-left:auto">(' + mat.id + ')</span>' +
      '</label>' +
      (isChecked ? '<input type="number" class="layer-material-qty" data-material-id="' + mat.id + '" value="' + quantity + '" min="1" max="999" style="width:100%;padding:3px;background:#0a0f1e;border:1px solid #3a3f4a;border-radius:2px;color:#e0e0e0;font-size:11px" placeholder="Qty">' : '') +
      '</div>';
  }).join('');
}

function toggleLayerItem(layerIndex, checkbox) {
  const itemDiv = checkbox.closest('.layer-item-option');
  const itemId = checkbox.value;
  const qtyInput = itemDiv.querySelector('.layer-item-qty');
  
  if (checkbox.checked) {
    if (!qtyInput) {
      const qtyHtml = '<input type="number" class="layer-item-qty" data-item-id="' + itemId + '" value="1" min="1" max="999" style="width:100%;padding:3px;background:#0a0f1e;border:1px solid #3a3f4a;border-radius:2px;color:#e0e0e0;font-size:11px" placeholder="Qty">';
      itemDiv.innerHTML += qtyHtml;
    }
    itemDiv.style.background = '#2a3f3a';
  } else {
    if (qtyInput) qtyInput.remove();
    itemDiv.style.background = 'rgba(255,255,255,0.03)';
  }
}

function toggleLayerMaterial(layerIndex, checkbox) {
  const matDiv = checkbox.closest('.layer-material-option');
  const matId = checkbox.value;
  const qtyInput = matDiv.querySelector('.layer-material-qty');
  
  if (checkbox.checked) {
    if (!qtyInput) {
      const qtyHtml = '<input type="number" class="layer-material-qty" data-material-id="' + matId + '" value="1" min="1" max="999" style="width:100%;padding:3px;background:#0a0f1e;border:1px solid #3a3f4a;border-radius:2px;color:#e0e0e0;font-size:11px" placeholder="Qty">';
      matDiv.innerHTML += qtyHtml;
    }
    matDiv.style.background = '#2a3f3a';
  } else {
    if (qtyInput) qtyInput.remove();
    matDiv.style.background = 'rgba(255,255,255,0.03)';
  }
}

function filterLayerItems(layerIndex) {
  const search = document.getElementById('raidLayer' + layerIndex + 'ItemSearch').value.toLowerCase();
  const options = document.querySelectorAll('#raidLayer' + layerIndex + 'Items .layer-item-option');
  options.forEach(opt => {
    const text = opt.textContent.toLowerCase();
    opt.style.display = text.includes(search) ? 'block' : 'none';
  });
}

function filterLayerMaterials(layerIndex) {
  const search = document.getElementById('raidLayer' + layerIndex + 'MaterialSearch').value.toLowerCase();
  const options = document.querySelectorAll('#raidLayer' + layerIndex + 'Materials .layer-material-option');
  options.forEach(opt => {
    const text = opt.textContent.toLowerCase();
    opt.style.display = text.includes(search) ? 'block' : 'none';
  });
}

function submitRaid() {
  const name = document.getElementById('raidName').value;
  if (!name) {
    alert('Please enter a raid name');
    return;
  }
  
  const numLayers = parseInt(document.getElementById('raidLayers')?.value) || 1;
  
  // Build layers with rarity-based packages
  const rarities = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
  const layers = [];
  
  for (let i = 0; i < numLayers; i++) {
    const rarity = rarities[Math.min(i, rarities.length - 1)];
    const baseXP = parseInt(document.getElementById('raidLayer' + i + 'XP')?.value) || 500;
    const baseGold = parseInt(document.getElementById('raidLayer' + i + 'Gold')?.value) || 250;
    const layerName = document.getElementById('raidLayer' + i + 'Name')?.value.trim() || ('Layer ' + (i + 1) + ' - ' + (rarity.charAt(0).toUpperCase() + rarity.slice(1)));
    
    // Collect items with quantities
    const layerItems = [];
    document.querySelectorAll('#raidLayer' + i + 'Items input[type="checkbox"]:checked').forEach(function(cb) {
      const qtyInput = cb.closest('.layer-item-option').querySelector('.layer-item-qty');
      const quantity = qtyInput ? parseInt(qtyInput.value) || 1 : 1;
      layerItems.push({ id: cb.value, quantity: quantity });
    });
    
    // Collect materials with quantities
    const layerMaterials = [];
    document.querySelectorAll('#raidLayer' + i + 'Materials input[type="checkbox"]:checked').forEach(function(cb) {
      const qtyInput = cb.closest('.layer-material-option').querySelector('.layer-material-qty');
      const quantity = qtyInput ? parseInt(qtyInput.value) || 1 : 1;
      layerMaterials.push({ id: cb.value, quantity: quantity });
    });
    
    layers.push({
      id: 'layer_' + (i + 1),
      name: layerName,
      level: i + 1,
      bosses: selectedBossesForRaid.slice(0, Math.ceil(selectedBossesForRaid.length * (i + 1) / numLayers)) || [],
      rewardPackages: [
        {
          id: 'pkg_' + Date.now() + '_' + i + '_' + rarity,
          name: (rarity.charAt(0).toUpperCase() + rarity.slice(1)) + ' Rewards',
          rarity: rarity,
          dropChance: 100,
          items: layerItems,
          materials: layerMaterials,
          xp: baseXP,
          gold: baseGold,
        },
      ],
    });
  }
  
  const method = editingId ? 'PUT' : 'POST';
  const url = editingId ? '/api/editor/raids/' + editingId : '/api/editor/raids';
  
  fetch(url, {
    method: method,
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      id: editingId,
      name: name,
      description: document.getElementById('raidDescription').value,
      worldId: selectedWorldId,
      minLevel: parseInt(document.getElementById('raidMinLevel').value) || 20,
      maxPartySize: parseInt(document.getElementById('raidTeamSize')?.value) || 4,
      bosses: selectedBossesForRaid,
      layers: layers,
      floors: Array.from({length: numLayers}, function(_, i) {
        return {
          id: 'floor_' + (i + 1),
          name: 'Floor ' + (i + 1),
          bosses: [],
          rewards: {}
        };
      }),
    })
  }).then(r => r.json()).then(() => {
    editingId = null;
    closeRaidModal();
    loadWorldRaids(selectedWorldId);
  }).catch(err => alert('Error saving raid: ' + err.message));
}

// Edit/Delete functions
function editWorld(id) {
  editingId = id;
  fetch('/api/editor/worlds/' + id, { credentials: 'include' })
    .then(r => r.json())
    .then(world => {
      document.getElementById('worldName').value = world.name || '';
      document.getElementById('worldTier').value = world.tier || '1';
      document.getElementById('worldDescription').value = world.description || '';
      document.getElementById('worldMinLevel').value = world.minLevel || '1';
      document.getElementById('worldMaxLevel').value = world.maxLevel || '50';
      document.getElementById('worldBossSelect').value = world.worldBoss || '';
      document.getElementById('worldNextWorldSelect').value = world.nextWorldId || '';
      
      loadWorldBossesForWorldModal();
      loadAvailableWorlds();
      document.getElementById('worldModal').classList.add('active');
    })
    .catch(err => console.error('Error loading world:', err));
}

function editQuest(id) {
  editingId = id;
  fetch('/api/editor/quests/' + id, { credentials: 'include' })
    .then(r => r.json())
    .then(quest => {
      document.getElementById('questTitle').value = quest.title || '';
      document.getElementById('questDescription').value = quest.description || '';
      document.getElementById('questObjectives').value = quest.objectives || '';
      
      loadAvailableRewards().then(() => {
        renderRewardSelector('questRewardSelector', quest.rewards || {});
        document.getElementById('questModal').classList.add('active');
      });
    })
    .catch(err => console.error('Error loading quest:', err));
}

function editBoss(id) {
  editingId = id;
  fetch('/api/editor/bosses/' + id, { credentials: 'include' })
    .then(r => r.json())
    .then(boss => {
      document.getElementById('bossName').value = boss.name || '';
      document.getElementById('bossDescription').value = boss.description || '';
      document.getElementById('bossHP').value = boss.hp || '100';
      document.getElementById('bossLevel').value = boss.level || '10';
      
      loadAvailableRewards().then(() => {
        renderRewardSelector('bossRewardSelector', boss.rewards || {});
        document.getElementById('bossModal').classList.add('active');
      });
    })
    .catch(err => console.error('Error loading boss:', err));
}

function editDungeon(id) {
  editingId = id;
  fetch('/api/editor/dungeons/' + id, { credentials: 'include' })
    .then(r => r.json())
    .then(dungeon => {
      document.getElementById('dungeonName').value = dungeon.name || '';
      document.getElementById('dungeonDescription').value = dungeon.description || '';
      document.getElementById('dungeonDifficulty').value = dungeon.difficulty || 'normal';
      document.getElementById('dungeonMinLevel').value = dungeon.minLevel || '1';
      
      // Load bosses for selection
      selectedBossesForDungeon = dungeon.bosses || [];
      loadWorldBossesForModal('dungeonBossSelector', selectedBossesForDungeon, 'dungeonBossSelector');
      
      loadAvailableRewards().then(() => {
        renderRewardSelector('dungeonRewardSelector', dungeon.rewards || {});
        document.getElementById('dungeonModal').classList.add('active');
      });
    })
    .catch(err => console.error('Error loading dungeon:', err));
}

function editRaid(id) {
  editingId = id;
  fetch('/api/editor/raids/' + id, { credentials: 'include' })
    .then(r => r.json())
    .then(raid => {
      document.getElementById('raidName').value = raid.name || '';
      document.getElementById('raidDescription').value = raid.description || '';
      document.getElementById('raidTeamSize').value = raid.maxPartySize || '4';
      document.getElementById('raidMinLevel').value = raid.minLevel || '1';
      
      // Set layer count from layers array or floors array (legacy)
      const numLayers = (raid.layers || raid.floors || []).length;
      document.getElementById('raidLayers').value = numLayers || '1';
      
      // Load bosses for selection
      selectedBossesForRaid = raid.bosses || [];
      loadWorldBossesForModal('raidBossSelector', selectedBossesForRaid, 'raidBossSelector');
      
      // Load items and materials then render layers
      Promise.all([
        fetch('/api/items', { credentials: 'include' }).then(r => r.json()),
        fetch('/api/materials', { credentials: 'include' }).then(r => r.json())
      ]).then(([items, materials]) => {
        // Render layers with their reward packages
        renderRaidLayerRewards();
        
        // Load existing layer reward packages if they exist
        if (raid.layers && Array.isArray(raid.layers)) {
          setTimeout(function() {
            raid.layers.forEach(function(layer, layerIdx) {
              // Set layer name
              const nameInput = document.getElementById('raidLayer' + layerIdx + 'Name');
              if (nameInput && layer.name) nameInput.value = layer.name;
              
              // Set XP and Gold
              const xpInput = document.getElementById('raidLayer' + layerIdx + 'XP');
              const goldInput = document.getElementById('raidLayer' + layerIdx + 'Gold');
              
              if (layer.rewardPackages && layer.rewardPackages.length > 0) {
                const pkg = layer.rewardPackages[0];
                if (xpInput) xpInput.value = pkg.xp || 0;
                if (goldInput) goldInput.value = pkg.gold || 0;
                
                // Load items with quantities
                if (pkg.items) {
                  renderLayerItemSelector(layerIdx, items, pkg.items);
                }
                
                // Load materials with quantities
                if (pkg.materials) {
                  renderLayerMaterialSelector(layerIdx, materials, pkg.materials);
                }
              }
            });
          }, 100);
        }
        
        document.getElementById('raidModal').classList.add('active');
      });
    })
    .catch(err => console.error('Error loading raid:', err));
}

function deleteQuest(id) {
  if (!confirm('Delete this quest?')) return;
  fetch('/api/editor/quests/' + id, { method: 'DELETE', credentials: 'include' })
    .then(() => loadWorldQuests(selectedWorldId, currentQuestType));
}

function deleteBoss(id) {
  if (!confirm('Delete this boss?')) return;
  fetch('/api/editor/bosses/' + id, { method: 'DELETE', credentials: 'include' })
    .then(() => loadWorldBosses(selectedWorldId));
}

function deleteDungeon(id) {
  if (!confirm('Delete this dungeon?')) return;
  fetch('/api/editor/dungeons/' + id, { method: 'DELETE', credentials: 'include' })
    .then(() => loadWorldDungeons(selectedWorldId));
}

function deleteRaid(id) {
  if (!confirm('Delete this raid?')) return;
  fetch('/api/editor/raids/' + id, { method: 'DELETE', credentials: 'include' })
    .then(() => loadWorldRaids(selectedWorldId));
}

// Rewards (global)
function loadRewards() {
  fetch('/api/rewards', { credentials: 'include' })
    .then(r => r.json())
    .then(rewards => {
      const container = document.getElementById('rewards-list');
      const items = Object.entries(rewards).map(([id, r]) => ({ id, ...r }));
      if (!items.length) {
        container.innerHTML = '<p style="text-align:center;opacity:0.6">No rewards yet. Create your first reward!</p>';
        return;
      }
      container.innerHTML = items.map(r => {
        const itemsDisplay = r.items?.map(item => {
          if (typeof item === 'object') return item.id + ' x' + (item.quantity || 1);
          return item;
        }).join(', ');
        const materialsDisplay = r.materials?.map(mat => {
          if (typeof mat === 'object') return mat.id + ' x' + (mat.quantity || 1);
          return mat;
        }).join(', ');
        
        return \`
        <div class="item-card">
          <h3>\${r.name || r.id}</h3>
          <p><strong>ID:</strong> \${r.id}</p>
          <p>XP: \${r.xp || 0} | Gold: \${r.gold || 0}</p>
          \${itemsDisplay ? '<p><strong>Items:</strong> ' + itemsDisplay + '</p>' : ''}
          \${materialsDisplay ? '<p><strong>Materials:</strong> ' + materialsDisplay + '</p>' : ''}
          <div class="item-actions">
            <button class="btn-edit" onclick="editReward('\${r.id}')">Edit</button>
            <button class="btn-delete" onclick="deleteReward('\${r.id}')">Delete</button>
          </div>
        </div>
      \`;
      }).join('');
    });
}

function createReward() {
  editingId = null;
  document.getElementById('rewardPackageModalTitle').textContent = 'Create Reward Package';
  document.getElementById('rewardPackageId').value = '';
  document.getElementById('rewardPackageId').readOnly = false;
  document.getElementById('rewardPackageName').value = '';
  document.getElementById('rewardPackageXP').value = '0';
  document.getElementById('rewardPackageGold').value = '0';
  
  // Load items and materials for selection
  Promise.all([
    fetch('/api/items', { credentials: 'include' }).then(r => r.json()),
    fetch('/api/materials', { credentials: 'include' }).then(r => r.json())
  ]).then(([items, materials]) => {
    renderRewardItemSelector(items, []);
    renderRewardMaterialSelector(materials, []);
    document.getElementById('rewardPackageSubmitBtn').textContent = 'Create Reward Package';
    document.getElementById('rewardPackageModal').classList.add('active');
  });
}

function renderRewardItemSelector(items, selectedItems = []) {
  const container = document.getElementById('rewardItemSelector');
  if (!items || items.length === 0) {
    container.innerHTML = '<p style="opacity:0.6;margin:0">No items available</p>';
    return;
  }
  
  container.innerHTML = items.map(item => {
    const itemData = selectedItems.find(i => typeof i === 'object' ? i.id === item.id : i === item.id);
    const isChecked = !!itemData;
    const quantity = (itemData && typeof itemData === 'object') ? itemData.quantity : 1;
    const bgColor = isChecked ? '#2a3f3a' : 'rgba(255,255,255,0.05)';
    
    return '<div style="display:block;padding:8px;margin-bottom:4px;background:' + bgColor + ';border-radius:4px" class="reward-item-option">' +
      '<label style="display:flex;align-items:center;cursor:pointer;margin-bottom:6px">' +
      '<input type="checkbox" value="' + item.id + '" ' + (isChecked ? 'checked' : '') + ' style="margin-right:8px" onchange="toggleRewardItem(this)">' +
      item.name + ' <span style="opacity:0.6;font-size:12px;margin-left:auto">(' + item.id + ')</span>' +
      '</label>' +
      (isChecked ? '<input type="number" class="item-qty" data-item-id="' + item.id + '" value="' + quantity + '" min="1" max="999" style="width:100%;padding:4px;background:#0a0f1e;border:1px solid #3a3f4a;border-radius:3px;color:#e0e0e0;font-size:12px" placeholder="Qty">' : '') +
      '</div>';
  }).join('');
}

function renderRewardMaterialSelector(materials, selectedMaterials = []) {
  const container = document.getElementById('rewardMaterialSelector');
  const matArray = Object.entries(materials).map(([id, mat]) => ({ id, ...mat }));
  
  if (matArray.length === 0) {
    container.innerHTML = '<p style="opacity:0.6;margin:0">No materials available</p>';
    return;
  }
  
  container.innerHTML = matArray.map(mat => {
    const matData = selectedMaterials.find(m => typeof m === 'object' ? m.id === mat.id : m === mat.id);
    const isChecked = !!matData;
    const quantity = (matData && typeof matData === 'object') ? matData.quantity : 1;
    const bgColor = isChecked ? '#2a3f3a' : 'rgba(255,255,255,0.05)';
    
    return '<div style="display:block;padding:8px;margin-bottom:4px;background:' + bgColor + ';border-radius:4px" class="reward-material-option">' +
      '<label style="display:flex;align-items:center;cursor:pointer;margin-bottom:6px">' +
      '<input type="checkbox" value="' + mat.id + '" ' + (isChecked ? 'checked' : '') + ' style="margin-right:8px" onchange="toggleRewardMaterial(this)">' +
      mat.name + ' <span style="opacity:0.6;font-size:12px;margin-left:auto">(' + mat.id + ')</span>' +
      '</label>' +
      (isChecked ? '<input type="number" class="material-qty" data-material-id="' + mat.id + '" value="' + quantity + '" min="1" max="999" style="width:100%;padding:4px;background:#0a0f1e;border:1px solid #3a3f4a;border-radius:3px;color:#e0e0e0;font-size:12px" placeholder="Qty">' : '') +
      '</div>';
  }).join('');
}

function toggleRewardItem(checkbox) {
  const itemDiv = checkbox.closest('.reward-item-option');
  const itemId = checkbox.value;
  const qtyInput = itemDiv.querySelector('.item-qty');
  
  if (checkbox.checked) {
    if (!qtyInput) {
      // Create quantity input
      const qtyHtml = '<input type="number" class="item-qty" data-item-id="' + itemId + '" value="1" min="1" max="999" style="width:100%;padding:4px;background:#0a0f1e;border:1px solid #3a3f4a;border-radius:3px;color:#e0e0e0;font-size:12px" placeholder="Qty">';
      itemDiv.innerHTML += qtyHtml;
    }
    itemDiv.style.background = '#2a3f3a';
  } else {
    if (qtyInput) qtyInput.remove();
    itemDiv.style.background = 'rgba(255,255,255,0.05)';
  }
}

function toggleRewardMaterial(checkbox) {
  const matDiv = checkbox.closest('.reward-material-option');
  const matId = checkbox.value;
  const qtyInput = matDiv.querySelector('.material-qty');
  
  if (checkbox.checked) {
    if (!qtyInput) {
      // Create quantity input
      const qtyHtml = '<input type="number" class="material-qty" data-material-id="' + matId + '" value="1" min="1" max="999" style="width:100%;padding:4px;background:#0a0f1e;border:1px solid #3a3f4a;border-radius:3px;color:#e0e0e0;font-size:12px" placeholder="Qty">';
      matDiv.innerHTML += qtyHtml;
    }
    matDiv.style.background = '#2a3f3a';
  } else {
    if (qtyInput) qtyInput.remove();
    matDiv.style.background = 'rgba(255,255,255,0.05)';
  }
}

function filterRewardItems() {
  const search = document.getElementById('rewardItemSearch').value.toLowerCase();
  const options = document.querySelectorAll('.reward-item-option');
  options.forEach(opt => {
    const text = opt.textContent.toLowerCase();
    opt.style.display = text.includes(search) ? 'block' : 'none';
  });
}

function filterRewardMaterials() {
  const search = document.getElementById('rewardMaterialSearch').value.toLowerCase();
  const options = document.querySelectorAll('.reward-material-option');
  options.forEach(opt => {
    const text = opt.textContent.toLowerCase();
    opt.style.display = text.includes(search) ? 'block' : 'none';
  });
}

function submitRewardPackage() {
  const id = document.getElementById('rewardPackageId').value.trim();
  const name = document.getElementById('rewardPackageName').value.trim();
  
  if (!id || !name) {
    alert('Please provide both Reward ID and Name');
    return;
  }
  
  const xp = parseInt(document.getElementById('rewardPackageXP').value) || 0;
  const gold = parseInt(document.getElementById('rewardPackageGold').value) || 0;
  
  // Collect items with quantities
  const selectedItems = [];
  document.querySelectorAll('#rewardItemSelector input[type="checkbox"]:checked').forEach(cb => {
    const qtyInput = cb.closest('.reward-item-option').querySelector('.item-qty');
    const quantity = qtyInput ? parseInt(qtyInput.value) || 1 : 1;
    selectedItems.push({
      id: cb.value,
      quantity: quantity
    });
  });
  
  // Collect materials with quantities
  const selectedMaterials = [];
  document.querySelectorAll('#rewardMaterialSelector input[type="checkbox"]:checked').forEach(cb => {
    const qtyInput = cb.closest('.reward-material-option').querySelector('.material-qty');
    const quantity = qtyInput ? parseInt(qtyInput.value) || 1 : 1;
    selectedMaterials.push({
      id: cb.value,
      quantity: quantity
    });
  });
  
  fetch('/api/rewards', {
    method: 'POST',
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      id,
      name,
      xp,
      gold,
      items: selectedItems,
      materials: selectedMaterials
    })
  })
  .then(r => r.json())
  .then(() => {
    closeRewardPackageModal();
    loadRewards();
  })
  .catch(err => alert('Error saving reward: ' + err.message));
}

function closeRewardPackageModal() {
  document.getElementById('rewardPackageModal').classList.remove('active');
  editingId = null;
  
  // Clear form
  document.getElementById('rewardPackageId').value = '';
  document.getElementById('rewardPackageId').readOnly = false;
  document.getElementById('rewardPackageName').value = '';
  document.getElementById('rewardPackageXP').value = '0';
  document.getElementById('rewardPackageGold').value = '0';
  
  // Clear search fields
  const itemSearch = document.getElementById('rewardItemSearch');
  const matSearch = document.getElementById('rewardMaterialSearch');
  if (itemSearch) itemSearch.value = '';
  if (matSearch) matSearch.value = '';
  
  // Clear selectors
  document.getElementById('rewardItemSelector').innerHTML = '<p style="opacity:0.6;margin:0">Loading items...</p>';
  document.getElementById('rewardMaterialSelector').innerHTML = '<p style="opacity:0.6;margin:0">Loading materials...</p>';
  
  // Reset title
  document.getElementById('rewardPackageModalTitle').textContent = 'Create Reward Package';
}

function editReward(id) {
  editingId = id;
  
  // Set modal title
  document.getElementById('rewardPackageModalTitle').textContent = 'Edit Reward Package';
  
  fetch('/api/rewards', { credentials: 'include' })
    .then(r => r.json())
    .then(rewards => {
      const reward = rewards[id];
      if (!reward) {
        alert('Reward not found');
        return;
      }
      
      document.getElementById('rewardPackageId').value = id;
      document.getElementById('rewardPackageId').readOnly = true;
      document.getElementById('rewardPackageName').value = reward.name || '';
      document.getElementById('rewardPackageXP').value = reward.xp || 0;
      document.getElementById('rewardPackageGold').value = reward.gold || 0;
      
      // Load items and materials for selection
      Promise.all([
        fetch('/api/items', { credentials: 'include' }).then(r => r.json()),
        fetch('/api/materials', { credentials: 'include' }).then(r => r.json())
      ]).then(([items, materials]) => {
        renderRewardItemSelector(items, reward.items || []);
        renderRewardMaterialSelector(materials, reward.materials || []);
        document.getElementById('rewardPackageSubmitBtn').textContent = 'Save Reward Package';
        document.getElementById('rewardPackageModal').classList.add('active');
      });
    })
    .catch(err => alert('Error loading reward: ' + err.message));
}

function deleteReward(id) {
  if (!confirm('Delete this reward?')) return;
  fetch('/api/rewards/' + id, { method: 'DELETE', credentials: 'include' }).then(() => loadRewards());
}

// ========== NPC FUNCTIONS ==========

function loadNPCs() {
  const worldFilter = document.getElementById('npc-world-filter')?.value || '';
  const url = '/api/npcs' + (worldFilter ? '?worldId=' + worldFilter : '');
  
  fetch(url, { method: 'GET', credentials: 'include' })
    .then(res => res.json())
    .then(npcs => {
      const container = document.getElementById('npcs-list');
      if (!npcs || npcs.length === 0) {
        container.innerHTML = '<p style="opacity:0.6">No NPCs yet. Create one to get started!</p>';
        return;
      }
      
      container.innerHTML = npcs.map(npc => {
        let html = '<div class="item-card" style="position:relative">' +
          '<h3>' + npc.name + '</h3>' +
          '<p style="opacity:0.7">Type: <strong>' + npc.type + '</strong></p>' +
          '<p>' + (npc.description || '(No description)') + '</p>';
        
        if (npc.location) {
          html += '<p style="opacity:0.7">ðŸ“ ' + npc.location + '</p>';
        }
        
        html += '<div class="item-actions">' +
          '<button class="btn-edit npc-edit" data-npc-id="' + npc.id + '">Edit</button>' +
          '<button class="btn-delete npc-delete" data-npc-id="' + npc.id + '">Delete</button>' +
          '</div></div>';
        return html;
      }).join('');
      
      // Attach event listeners for NPCs
      document.querySelectorAll('.npc-edit').forEach(btn => btn.addEventListener('click', function() { editNPC(this.getAttribute('data-npc-id')); }));
      document.querySelectorAll('.npc-delete').forEach(btn => btn.addEventListener('click', function() { deleteNPC(this.getAttribute('data-npc-id')); }));
    })
    .catch(err => {
      console.error('Error loading NPCs:', err);
      document.getElementById('npcs-list').innerHTML = '<p style="color:#ff6b6b">Error loading NPCs</p>';
    });
  
  // Load world filter options
  loadAvailableWorlds().then(worlds => {
    const filter = document.getElementById('npc-world-filter');
    if (filter) {
      const currentValue = filter.value;
      filter.innerHTML = '<option value="">All Worlds</option>' + 
        worlds.map(w => '<option value="' + w.id + '">' + w.name + '</option>').join('');
      filter.value = currentValue;
    }
  });
}

function loadNPCQuestSelector(selectedQuests = []) {
  if (!selectedWorldId) {
    const container = document.getElementById('npcQuestSelector');
    if (container) container.innerHTML = '<p style="opacity:0.6;margin:0">Select a world first to see available quests.</p>';
    return;
  }
  fetch('/api/editor/quests?worldId=' + selectedWorldId, { credentials: 'include' })
    .then(r => {
      if (!r.ok) throw new Error('Failed to load quests: ' + r.status);
      return r.json();
    })
    .then(data => {
      const container = document.getElementById('npcQuestSelector');
      if (!container) return;
      
      // Flatten all quest types into a single array
      const allQuests = [];
      if (data.main) allQuests.push(...data.main);
      if (data.side) allQuests.push(...data.side);
      if (data.daily) allQuests.push(...data.daily);
      
      if (!allQuests.length) {
        container.innerHTML = '<p style="opacity:0.6;margin:0">No quests available. Create quests first!</p>';
        return;
      }
      
      container.innerHTML = allQuests.map(quest => {
        const isSelected = selectedQuests.includes(quest.id);
        return '<div class="reward-item" style="margin-bottom:8px">' +
          '<input type="checkbox" id="quest_' + quest.id + '" ' + (isSelected ? 'checked' : '') + '>' +
          '<label for="quest_' + quest.id + '" style="flex:1;margin:0">' + quest.title + ' <code style="opacity:0.6">(' + quest.id + ')</code></label>' +
          '</div>';
      }).join('');
    })
    .catch(err => console.error('Error loading quests for selector:', err));
}

function getSelectedNPCQuests() {
  const container = document.getElementById('npcQuestSelector');
  if (!container) return [];
  const checkboxes = container.querySelectorAll('input[type="checkbox"]:checked');
  return Array.from(checkboxes).map(cb => cb.id.replace('quest_', ''));
}

function createNPC() {
  editingId = null;
  document.getElementById('npcModal').querySelector('.modal-header h3').textContent = 'Create NPC';
  document.getElementById('npcName').value = '';
  document.getElementById('npcDescription').value = '';
  document.getElementById('npcType').value = '';
  document.getElementById('npcWorld').value = '';
  document.getElementById('npcLocation').value = '';
  document.getElementById('npcDialogue').value = '';
  document.getElementById('npcItems').value = '';
  
  // Load world options
  loadAvailableWorlds().then(worlds => {
    const select = document.getElementById('npcWorld');
    select.innerHTML = '<option value="">-- Select World --</option>' + 
      worlds.map(w => '<option value="' + w.id + '">' + w.name + '</option>').join('');
  });
  
  // Load quest selector
  loadNPCQuestSelector([]);
  
  document.getElementById('npcModal').classList.add('active');
}

function editNPC(npcId) {
  editingId = npcId;
  document.getElementById('npcModal').querySelector('.modal-header h3').textContent = 'Edit NPC';
  
  fetch('/api/npcs/' + npcId, { method: 'GET', credentials: 'include' })
    .then(res => res.json())
    .then(npc => {
      document.getElementById('npcName').value = npc.name || '';
      document.getElementById('npcDescription').value = npc.description || '';
      document.getElementById('npcType').value = npc.type || '';
      document.getElementById('npcLocation').value = npc.location || '';
      document.getElementById('npcDialogue').value = npc.dialogueText || '';
      document.getElementById('npcItems').value = (npc.inventory || []).join(',');
      
      // Load world options
      loadAvailableWorlds().then(worlds => {
        const select = document.getElementById('npcWorld');
        select.innerHTML = '<option value="">-- Select World --</option>' + 
          worlds.map(w => '<option value="' + w.id + '">' + w.name + '</option>').join('');
        select.value = npc.worldId || '';
        updateNPCTypeFields();
      });
      
      // Load quest selector with pre-selected quests
      loadNPCQuestSelector(npc.quests || []);
      // Load world options
      loadAvailableWorlds().then(worlds => {
        const select = document.getElementById('npcWorld');
        select.innerHTML = '<option value="">-- Select World --</option>' + 
          worlds.map(w => '<option value="' + w.id + '">' + w.name + '</option>').join('');
        select.value = npc.worldId || '';
        updateNPCTypeFields();
      });
      
      document.getElementById('npcModal').classList.add('active');
    })
    .catch(err => console.error('Error loading NPC:', err));
}

function closeNPCModal() {
  editingId = null;
  document.getElementById('npcModal').classList.remove('active');
}

function submitNPC() {
  const npcData = {
    name: document.getElementById('npcName').value?.trim(),
    description: document.getElementById('npcDescription').value?.trim(),
    type: document.getElementById('npcType').value,
    worldId: document.getElementById('npcWorld').value,
    location: document.getElementById('npcLocation').value?.trim(),
    dialogueText: document.getElementById('npcDialogue').value?.trim(),
    inventory: document.getElementById('npcItems').value?.split(',').filter(x => x.trim()),
    quests: getSelectedNPCQuests(),
  };
  
  if (!npcData.name || !npcData.type || !npcData.worldId) {
    alert('Please fill in Name, Type, and World fields');
    return;
  }
  
  const method = editingId ? 'PUT' : 'POST';
  const url = '/api/npcs' + (editingId ? '/' + editingId : '');
  
  fetch(url, {
    method,
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(npcData)
  })
    .then(res => res.json())
    .then(result => {
      if (result.success || result.npc) {
        closeNPCModal();
        loadNPCs();
      } else {
        alert('Error saving NPC');
      }
    })
    .catch(err => {
      console.error('Error submitting NPC:', err);
      alert('Error saving NPC: ' + err.message);
    });
}

function deleteNPC(npcId) {
  if (!confirm('Delete this NPC? This action cannot be undone.')) return;
  
  fetch('/api/npcs/' + npcId, { method: 'DELETE', credentials: 'include' })
    .then(res => res.json())
    .then(result => {
      if (result.success) {
        loadNPCs();
      } else {
        alert('Error deleting NPC');
      }
    })
    .catch(err => {
      console.error('Error deleting NPC:', err);
      alert('Error deleting NPC');
    });
}

function updateNPCTypeFields() {
  const type = document.getElementById('npcType').value;
  document.getElementById('npcMerchantItems').style.display = type === 'merchant' ? 'block' : 'none';
  document.getElementById('npcQuestGiverQuests').style.display = type === 'questgiver' ? 'block' : 'none';
}

// Attach the type change handler
const npcTypeSelect = document.getElementById('npcType');
if (npcTypeSelect) {
  npcTypeSelect.addEventListener('change', updateNPCTypeFields);
}

// ========== ITEM MANAGEMENT ==========

function loadItems() {
  const categoryFilter = document.getElementById('item-category-filter').value;
  const rarityFilter = document.getElementById('item-rarity-filter').value;
  const classFilter = document.getElementById('item-class-filter').value;
  const typeFilter = document.getElementById('item-type-filter').value;
  
  // Rarity order (worst to best)
  const rarityOrder = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4 };
  
  fetch('/api/items', { credentials: 'include' })
    .then(res => res.json())
    .then(items => {
      const container = document.getElementById('items-list');
      
      // Apply client-side filters
      let filteredItems = items;
      
      if (categoryFilter) {
        filteredItems = filteredItems.filter(item => item.category === categoryFilter);
      }
      
      if (rarityFilter) {
        filteredItems = filteredItems.filter(item => item.rarity === rarityFilter);
      }
      
      if (classFilter) {
        if (classFilter === 'none') {
          filteredItems = filteredItems.filter(item => !item.classRestriction);
        } else {
          filteredItems = filteredItems.filter(item => item.classRestriction === classFilter);
        }
      }
      
      if (typeFilter) {
        filteredItems = filteredItems.filter(item => item.itemType === typeFilter);
      }
      
      // Sort by rarity (worst to best)
      filteredItems.sort((a, b) => {
        const rarityA = rarityOrder[a.rarity] ?? -1;
        const rarityB = rarityOrder[b.rarity] ?? -1;
        return rarityA - rarityB;
      });
      
      if (!filteredItems || filteredItems.length === 0) {
        container.innerHTML = '<p style="opacity:0.6">No items match the selected filters.</p>';
        return;
      }
      
      const rarityColors = {
        common: '#9d9d9d',
        uncommon: '#1eff00',
        rare: '#0070dd',
        epic: '#a335ee',
        legendary: '#ff8000'
      };
      
      container.innerHTML = filteredItems.map(item => {
        const color = rarityColors[item.rarity] || '#9d9d9d';
        const stats = [];
        if (item.damage > 0) stats.push('ðŸ—¡ï¸ ' + item.damage);
        if (item.defense > 0) stats.push('ðŸ›¡ï¸ ' + item.defense);
        if (item.heals > 0) stats.push('â¤ï¸ +' + item.heals);
        if (item.restoresMana > 0) stats.push('ðŸ’§ +' + item.restoresMana);
        
        return '<div class="item-card" data-item-id="' + item.id + '">' +
          '<h4 style="color:' + color + '">' + item.name + '</h4>' +
          '<p class="item-category">' + (item.category || 'misc').toUpperCase() + '</p>' +
          '<p class="item-description">' + (item.description || '') + '</p>' +
          (stats.length ? '<p class="item-stats">' + stats.join(' | ') + '</p>' : '') +
          '<p class="item-value">ðŸ’° ' + (item.value || 0) + ' gold</p>' +
          (item.classRestriction ? '<p class="item-class">Class: ' + item.classRestriction + '</p>' : '') +
          '<div class="item-actions">' +
            '<button class="btn-edit item-edit">Edit</button> ' +
            '<button class="btn-delete item-delete">Delete</button>' +
          '</div>' +
        '</div>';
      }).join('');
      
      // Attach event listeners
      document.querySelectorAll('.item-edit').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const itemId = e.target.closest('.item-card').dataset.itemId;
          editItem(itemId);
        });
      });
      
      document.querySelectorAll('.item-delete').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const itemId = e.target.closest('.item-card').dataset.itemId;
          deleteItem(itemId);
        });
      });
    })
    .catch(err => {
      console.error('Error loading items:', err);
      document.getElementById('items-list').innerHTML = '<p style="color:#ff4444">Error loading items</p>';
    });
}

function loadMaterials() {
  const sourceFilter = document.getElementById('material-source-filter')?.value || '';
  const rarityFilter = document.getElementById('material-rarity-filter')?.value || '';
  
  // Rarity order (worst to best)
  const rarityOrder = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4 };
  
  fetch('/api/materials', { credentials: 'include' })
    .then(r => r.json())
    .then(data => {
      const materials = data.materials || data || {};
      materialsCache = materials;
      const container = document.getElementById('materials-list');
      let entries = Object.entries(materials);
      
      // Apply filters
      if (sourceFilter) {
        entries = entries.filter(([id, m]) => {
          const sources = Array.isArray(m.source) ? m.source : [m.source];
          return sources.includes(sourceFilter);
        });
      }
      
      if (rarityFilter) {
        entries = entries.filter(([id, m]) => m.rarity === rarityFilter);
      }
      
      // Sort by rarity (worst to best)
      entries.sort((a, b) => {
        const rarityA = rarityOrder[a[1].rarity] ?? -1;
        const rarityB = rarityOrder[b[1].rarity] ?? -1;
        return rarityA - rarityB;
      });
      
      if (!entries.length) {
        container.innerHTML = '<p style="text-align:center;opacity:0.6">No materials match filters</p>';
        return;
      }
      container.innerHTML = entries.map(([id, m]) => {
        const sources = Array.isArray(m.source) ? m.source : [m.source];
        
        // Build sources display with gathering type if applicable
        let sourcesDisplay = sources.map(source => {
          if (source === 'gathering' && m.gatheringType) {
            return source + ' (' + m.gatheringType + ')';
          }
          return source;
        }).join(', ');
        
        let info = '<p><strong>Rarity:</strong> ' + (m.rarity || 'common') + '</p>' +
          '<p><strong>Value:</strong> ' + (m.value || 1) + ' gold</p>' +
          '<p><strong>Drop Chance:</strong> ' + (m.dropChance || 100) + '%</p>' +
          '<p><strong>Adventure Lvl:</strong> ' + (m.adventureLevel || 1) + '</p>' +
          '<p><strong>Sources:</strong> ' + sourcesDisplay + '</p>';
        
        return '<div class="item-card" data-material-id="' + id + '">' +
          '<h4>' + (m.name || id) + '</h4>' +
          '<p><strong>ID:</strong> ' + id + '</p>' +
          info +
          '<div class="item-actions">' +
            '<button class="btn-edit" data-material-id="' + id + '" onclick="editMaterialFromCard(this)">Edit</button>' +
            '<button class="btn-delete" data-material-id="' + id + '" onclick="deleteMaterialFromCard(this)">Delete</button>' +
          '</div>' +
        '</div>';
      }).join('');
    })
    .catch(err => {
      console.error('Error loading materials:', err);
      document.getElementById('materials-list').innerHTML = '<p style="color:#ff4444">Error loading materials</p>';
    });
}

function editMaterialFromCard(button) {
  const id = button.getAttribute('data-material-id');
  editMaterial(id);
}

function deleteMaterialFromCard(button) {
  const id = button.getAttribute('data-material-id');
  deleteMaterial(id);
}

function createMaterial() {
  editingMaterialId = null;
  document.getElementById('materialModalTitle').textContent = 'Create Material';
  document.getElementById('materialName').value = '';
  document.getElementById('materialId').value = '';
  document.getElementById('materialRarity').value = 'common';
  document.getElementById('materialValue').value = '1';
  document.getElementById('materialDropChance').value = '100';
  document.getElementById('materialAdventureLevel').value = '1';
  document.getElementById('materialGatheringType').value = '';
  // Uncheck all source checkboxes
  document.querySelectorAll('input[name="materialSource"]').forEach(cb => {
    cb.checked = false;
    cb.onchange = updateMaterialSourceFields;
  });
  // Check adventure by default
  document.querySelector('input[name="materialSource"][value="adventure"]').checked = true;
  updateMaterialSourceFields();
  document.getElementById('materialModal').classList.add('active');
}

function editMaterial(materialId) {
  editingMaterialId = materialId;
  document.getElementById('materialModalTitle').textContent = 'Edit Material';
  const material = materialsCache[materialId];
  if (material) {
    document.getElementById('materialName').value = material.name || '';
    document.getElementById('materialId').value = materialId;
    document.getElementById('materialRarity').value = material.rarity || 'common';
    document.getElementById('materialValue').value = material.value || 1;
    document.getElementById('materialDropChance').value = material.dropChance || 100;
    document.getElementById('materialAdventureLevel').value = material.adventureLevel || 1;
    document.getElementById('materialGatheringType').value = material.gatheringType || '';
    
    // Set multiple sources
    const sources = Array.isArray(material.source) ? material.source : (material.source ? [material.source] : []);
    document.querySelectorAll('input[name="materialSource"]').forEach(cb => {
      cb.checked = sources.includes(cb.value);
      cb.onchange = updateMaterialSourceFields;
    });
    
    updateMaterialSourceFields();
    document.getElementById('materialModal').classList.add('active');
  } else {
    loadMaterials();
  }
}

function updateMaterialSourceFields() {
  const sourceCheckboxes = document.querySelectorAll('input[name="materialSource"]:checked');
  const gatheringField = document.getElementById('gatheringCustomField');
  let hasGathering = false;
  sourceCheckboxes.forEach(cb => {
    if (cb.value === 'gathering') hasGathering = true;
  });
  gatheringField.style.display = hasGathering ? 'block' : 'none';
}

function closeMaterialModal() {
  editingMaterialId = null;
  document.getElementById('materialModal').classList.remove('active');
}

function submitMaterial() {
  const name = document.getElementById('materialName').value.trim();
  const customId = document.getElementById('materialId').value.trim();
  if (!name) {
    alert('Please enter a material name');
    return;
  }

  // Get all selected sources
  const sources = [];
  document.querySelectorAll('input[name="materialSource"]:checked').forEach(cb => {
    sources.push(cb.value);
  });
  
  if (sources.length === 0) {
    alert('Please select at least one source');
    return;
  }

  const payload = {
    id: customId || undefined,
    name,
    rarity: document.getElementById('materialRarity').value,
    value: parseInt(document.getElementById('materialValue').value) || 1,
    dropChance: parseInt(document.getElementById('materialDropChance').value) || 100,
    adventureLevel: parseInt(document.getElementById('materialAdventureLevel').value) || 1,
    source: sources
  };
  
  // Add custom gathering type if gathering source is selected
  if (sources.includes('gathering')) {
    const gatheringType = document.getElementById('materialGatheringType').value.trim();
    if (gatheringType) {
      payload.gatheringType = gatheringType;
    }
  }

  const method = editingMaterialId ? 'PUT' : 'POST';
  const url = editingMaterialId ? '/api/materials/' + editingMaterialId : '/api/materials';

  fetch(url, {
    method,
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  })
    .then(res => {
      if (!res.ok) {
        return res.text().then(text => {
          console.error('API Error Response:', res.status, res.statusText, text);
          throw new Error('HTTP ' + res.status + ': ' + res.statusText);
        });
      }
      return res.json();
    })
    .then(result => {
      if (result.success || result.material) {
        closeMaterialModal();
        loadMaterials();
        loadMaterialsForSelector();
      } else {
        alert('Error saving material: ' + (result.error || 'Unknown error'));
      }
    })
    .catch(err => {
      console.error('Error saving material:', err);
      alert('Error saving material: ' + err.message);
    });
}

function deleteMaterial(materialId) {
  if (!confirm('Delete this material?')) return;
  fetch('/api/materials/' + materialId, { method: 'DELETE', credentials: 'include' })
    .then(res => {
      if (!res.ok) {
        return res.text().then(text => {
          console.error('API Error Response:', res.status, res.statusText, text);
          throw new Error('HTTP ' + res.status + ': ' + res.statusText);
        });
      }
      return res.json();
    })
    .then(result => {
      if (result.success) {
        loadMaterials();
        loadMaterialsForSelector();
      } else {
        alert('Error deleting material: ' + (result.error || 'Unknown error'));
      }
    })
    .catch(err => {
      console.error('Error deleting material:', err);
      alert('Error deleting material: ' + err.message);
    });
}

function loadMaterialsForSelector() {
  const select = document.getElementById('recipeMaterialSelect');
  if (!select) return;
  fetch('/api/materials', { credentials: 'include' })
    .then(r => {
      if (!r.ok) {
        return r.text().then(text => {
          console.error('API Error:', r.status, r.statusText, text);
          throw new Error('HTTP ' + r.status + ': ' + r.statusText);
        });
      }
      return r.json();
    })
    .then(data => {
      // Handle both formats: direct materials object or wrapped in { materials: ... }
      const materials = (data && data.materials) ? data.materials : (data || {});
      console.log('Loaded materials:', Object.keys(materials).length, materials);
      materialsCache = materials;
      const entries = Object.entries(materials);
      select.innerHTML = entries.length
        ? entries.map(([id, m]) => '<option value="' + id + '">' + (m.name || id) + ' (' + id + ')</option>').join('')
        : '<option value="">No materials available</option>';
    })
    .catch(err => {
      console.error('Error loading materials for selector:', err);
      select.innerHTML = '<option value="">Error loading materials</option>';
    });
}

function addMaterialToRecipe() {
  const select = document.getElementById('recipeMaterialSelect');
  const qtyInput = document.getElementById('recipeMaterialQty');
  if (!select || !qtyInput) return;
  const id = select.value;
  const qty = Math.max(1, parseInt(qtyInput.value) || 1);
  if (!id) return;
  currentRecipeMaterials[id] = qty;
  renderRecipeMaterialsList();
}

function removeMaterialFromRecipe(button) {
  const id = button.getAttribute('data-material-id');
  delete currentRecipeMaterials[id];
  renderRecipeMaterialsList();
}

function renderRecipeMaterialsList() {
  const list = document.getElementById('recipeMaterialsList');
  if (!list) return;
  const entries = Object.entries(currentRecipeMaterials);
  if (!entries.length) {
    list.innerHTML = '<p style="opacity:0.6">No materials selected</p>';
    syncRecipeMaterialsTextarea();
    return;
  }
  list.innerHTML = entries.map(([id, qty]) => {
    const name = materialsCache[id]?.name || id;
    return '<div class="reward-item" style="justify-content:space-between">' +
      '<label>' + name + ' (' + id + ')</label>' +
      '<input type="number" min="1" value="' + qty + '" data-material-id="' + id + '" onchange="updateMaterialQuantity(this)" style="width:80px">' +
      '<button type="button" class="btn-cancel" style="width:auto;padding:6px 10px" data-material-id="' + id + '" onclick="removeMaterialFromRecipe(this)">Remove</button>' +
      '</div>';
  }).join('');
  syncRecipeMaterialsTextarea();
}

function updateMaterialQuantity(input) {
  const id = input.getAttribute('data-material-id');
  currentRecipeMaterials[id] = parseInt(input.value) || 1;
  syncRecipeMaterialsTextarea();
}

function syncRecipeMaterialsTextarea() {
  const textarea = document.getElementById('itemRecipeMaterials');
  if (textarea) textarea.value = JSON.stringify(currentRecipeMaterials);
}

function setRecipeMaterialsFromObject(materials) {
  currentRecipeMaterials = materials && typeof materials === 'object' ? { ...materials } : {};
  renderRecipeMaterialsList();
}

function createItem() {
  editingId = null;
  document.getElementById('itemModal').querySelector('.modal-header h3').textContent = 'Create Item';
  document.getElementById('itemName').value = '';
  document.getElementById('itemDescription').value = '';
  document.getElementById('itemCategory').value = '';
  document.getElementById('itemType').value = '';
  document.getElementById('itemRarity').value = '';
  document.getElementById('itemValue').value = '10';
  document.getElementById('itemDamage').value = '0';
  document.getElementById('itemDefense').value = '0';
  document.getElementById('itemHeals').value = '0';
  document.getElementById('itemRestoresMana').value = '0';
  document.getElementById('itemStrength').value = '0';
  document.getElementById('itemIntelligence').value = '0';
  document.getElementById('itemWisdom').value = '0';
  document.getElementById('itemAgility').value = '0';
  document.getElementById('itemLuck').value = '0';
  document.getElementById('itemHP').value = '0';
  document.getElementById('itemMana').value = '0';
  document.getElementById('itemClassRestriction').value = '';
  document.getElementById('itemLevelRequirement').value = '1';
  document.getElementById('itemRecipeLevel').value = '1';
  document.getElementById('itemCraftTime').value = '5';
  setRecipeMaterialsFromObject({});
  loadMaterialsForSelector();
  
  updateItemFormFields();
  updateRarityColor();
  
  document.getElementById('itemModal').classList.add('active');
}

function editItem(itemId) {
  editingId = itemId;
  document.getElementById('itemModal').querySelector('.modal-header h3').textContent = 'Edit Item';
  
  fetch('/api/items/' + itemId, { method: 'GET', credentials: 'include' })
    .then(res => res.json())
    .then(item => {
      document.getElementById('itemName').value = item.name || '';
      document.getElementById('itemDescription').value = item.description || '';
      document.getElementById('itemCategory').value = item.category || '';
      document.getElementById('itemType').value = item.itemType || '';
      document.getElementById('itemRarity').value = item.rarity || '';
      document.getElementById('itemValue').value = item.value || 10;
      document.getElementById('itemDamage').value = item.damage || 0;
      document.getElementById('itemDefense').value = item.defense || 0;
      document.getElementById('itemHeals').value = item.heals || 0;
      document.getElementById('itemRestoresMana').value = item.restoresMana || 0;
      document.getElementById('itemStrength').value = item.strength || 0;
      document.getElementById('itemIntelligence').value = item.intelligence || 0;
      document.getElementById('itemWisdom').value = item.wisdom || 0;
      document.getElementById('itemAgility').value = item.agility || 0;
      document.getElementById('itemLuck').value = item.luck || 0;
      document.getElementById('itemHP').value = item.hp || 0;
      document.getElementById('itemMana').value = item.mana || 0;
      document.getElementById('itemClassRestriction').value = item.classRestriction || '';
      document.getElementById('itemLevelRequirement').value = item.levelRequirement || 1;
      loadMaterialsForSelector();
      setRecipeMaterialsFromObject({});
      fetch('/api/recipes/by-item/' + itemId, { credentials: 'include' })
        .then(res => res.ok ? res.json() : null)
        .then(recipe => {
          if (recipe && recipe.materials) {
            setRecipeMaterialsFromObject(recipe.materials);
            document.getElementById('itemRecipeLevel').value = recipe.level || 1;
            document.getElementById('itemCraftTime').value = recipe.craftTime || 5;
          } else {
            document.getElementById('itemRecipeLevel').value = 1;
            document.getElementById('itemCraftTime').value = 5;
          }
        })
        .catch(() => {
          document.getElementById('itemRecipeLevel').value = 1;
          document.getElementById('itemCraftTime').value = 5;
        });
      
      updateItemFormFields();
      updateRarityColor();
      
      document.getElementById('itemModal').classList.add('active');
    })
    .catch(err => console.error('Error loading item:', err));
}

function closeItemModal() {
  editingId = null;
  document.getElementById('itemModal').classList.remove('active');
}

function submitItem() {
  const itemData = {
    name: document.getElementById('itemName').value?.trim(),
    description: document.getElementById('itemDescription').value?.trim(),
    category: document.getElementById('itemCategory').value,
    itemType: document.getElementById('itemType').value || null,
    rarity: document.getElementById('itemRarity').value,
    value: parseInt(document.getElementById('itemValue').value) || 0,
    damage: parseInt(document.getElementById('itemDamage').value) || 0,
    defense: parseInt(document.getElementById('itemDefense').value) || 0,
    heals: parseInt(document.getElementById('itemHeals').value) || 0,
    restoresMana: parseInt(document.getElementById('itemRestoresMana').value) || 0,
    strength: parseInt(document.getElementById('itemStrength').value) || 0,
    intelligence: parseInt(document.getElementById('itemIntelligence').value) || 0,
    wisdom: parseInt(document.getElementById('itemWisdom').value) || 0,
    agility: parseInt(document.getElementById('itemAgility').value) || 0,
    luck: parseInt(document.getElementById('itemLuck').value) || 0,
    hp: parseInt(document.getElementById('itemHP').value) || 0,
    mana: parseInt(document.getElementById('itemMana').value) || 0,
    classRestriction: document.getElementById('itemClassRestriction').value || null,
    levelRequirement: parseInt(document.getElementById('itemLevelRequirement').value) || 1,
  };
  
  if (!itemData.name || !itemData.category || !itemData.rarity) {
    alert('Please fill in Name, Category, and Rarity fields');
    return;
  }
  
  const method = editingId ? 'PUT' : 'POST';
  const url = '/api/items' + (editingId ? '/' + editingId : '');
  
  fetch(url, {
    method,
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(itemData)
  })
    .then(res => res.json())
    .then(async result => {
      if (result.success || result.item) {
        // Get the item ID (from result or from editingId)
        const itemId = result.item?.id || editingId;
        
        // Try to create recipe with materials if provided
        const materials = currentRecipeMaterials || {};
        if (itemId && Object.keys(materials).length) {
          const recipeData = {
            id: 'recipe_' + itemId,
            name: 'Craft ' + itemData.name,
            profession: 'blacksmith',
            level: parseInt(document.getElementById('itemRecipeLevel').value) || 1,
            craftTime: parseInt(document.getElementById('itemCraftTime').value) || 5,
            materials: materials,
            output: {
              item: itemId,
              quantity: 1
            }
          };

          await fetch('/api/recipes', {
            method: 'POST',
            credentials: 'include',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(recipeData)
          });
          // Recipe creation success is optional, don't block item save
        }
        
        closeItemModal();
        loadItems();
      } else {
        alert('Error saving item');
      }
    })
    .catch(err => {
      console.error('Error submitting item:', err);
      alert('Error saving item: ' + err.message);
    });
}

function deleteItem(itemId) {
  if (!confirm('Delete this item? This action cannot be undone.')) return;
  
  fetch('/api/items/' + itemId, { method: 'DELETE', credentials: 'include' })
    .then(res => res.json())
    .then(result => {
      if (result.success) {
        loadItems();
      } else {
        alert('Error deleting item');
      }
    })
    .catch(err => {
      console.error('Error deleting item:', err);
      alert('Error deleting item');
    });
}

function updateItemFormFields() {
  const category = document.getElementById('itemCategory').value;
  
  // Show/hide item type selector based on category
  const typeGroup = document.getElementById('itemTypeGroup');
  const typeSelect = document.getElementById('itemType');
  
  if (category === 'weapon') {
    typeGroup.style.display = 'block';
    typeSelect.innerHTML = '<option value="">-- Select Type --</option>' +
      '<option value="fist">Fist</option>' +
      '<option value="sword">Sword</option>' +
      '<option value="axe">Axe</option>' +
      '<option value="bow">Bow</option>' +
      '<option value="staff">Staff</option>' +
      '<option value="dagger">Dagger</option>' +
      '<option value="hammer">Hammer</option>' +
      '<option value="spear">Spear</option>' +
      '<option value="wand">Wand</option>';
  } else if (category === 'armor') {
    typeGroup.style.display = 'block';
    typeSelect.innerHTML = '<option value="">-- Select Type --</option>' +
      '<option value="helm">Helm</option>' +
      '<option value="chest">Chest</option>' +
      '<option value="legs">Legs</option>' +
      '<option value="boots">Boots</option>' +
      '<option value="gloves">Gloves</option>' +
      '<option value="shield">Shield</option>' +
      '<option value="cloak">Cloak</option>' +
      '<option value="ring">Ring</option>' +
      '<option value="amulet">Amulet</option>';
  } else {
    typeGroup.style.display = 'none';
    typeSelect.value = '';
  }
  
  // Show/hide combat stats for weapons and armor
  const combatStats = document.getElementById('itemCombatStats');
  combatStats.style.display = (category === 'weapon' || category === 'armor' || category === 'equipment') ? 'block' : 'none';
  
  // Show/hide healing stats for consumables
  const healingStats = document.getElementById('itemHealingStats');
  healingStats.style.display = (category === 'consumable') ? 'block' : 'none';
}

function updateRarityColor() {
  const rarity = document.getElementById('itemRarity').value;
  const preview = document.getElementById('rarityPreview');
  
  const rarityColors = {
    common: { color: '#9d9d9d', text: 'Common (Gray)' },
    uncommon: { color: '#1eff00', text: 'Uncommon (Green)' },
    rare: { color: '#0070dd', text: 'Rare (Blue)' },
    epic: { color: '#a335ee', text: 'Epic (Purple)' },
    legendary: { color: '#ff8000', text: 'Legendary (Orange)' }
  };
  
  if (rarity && rarityColors[rarity]) {
    preview.innerHTML = '<strong style="color:' + rarityColors[rarity].color + '">' + rarityColors[rarity].text + '</strong>';
  } else {
    preview.innerHTML = '';
  }
}

// Load initial content
loadWorlds();
</script>
`;
}

/* ======================
   EXPRESS ROUTES
====================== */
app.get('/', requireAuth, (req,res)=>{
  const tier = getUserTier(req);
  if (tier === 'viewer') return res.redirect('/pets');
  res.send(renderPage('overview', req));
});
app.get('/commands', requireAuth, requireTier('moderator'), (req,res)=>{ const tab = req.query.tab || 'config-commands'; res.send(renderPage(tab, req)); });
app.get('/logs', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('logs', req)));
app.get('/config', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('config-commands', req)));
app.get('/options', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('config-commands', req)));
app.get('/stats', requireAuth, (req,res)=>{ const tab = req.query.tab || 'stats'; res.send(renderPage(tab, req)); });
app.get('/suggestions', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('suggestions', req)));
app.get('/rpg', requireAuth, requireTier('moderator'), (req,res)=>{ 
  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.setHeader('Pragma', 'no-cache');
  res.setHeader('Expires', '0');
  const tab = req.query.tab || 'rpg-worlds'; 
  res.send(renderPage(tab, req)); 
});
app.get('/gathering-areas', requireAuth, requireTier('moderator'), (req, res) => {
  res.setHeader('Cache-Control', 'no-store');
  res.sendFile(path.join(__dirname, 'rpg/dashboard/gathering-areas-editor.html'));
});
app.get('/settings', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('config-commands', req)));
app.get('/favicon.ico', (_req, res) => res.status(204).end());
app.get('/dashboard-actions.js', (_req, res) => {
  res.set('Cache-Control', 'no-store');
  res.type('application/javascript');
  res.sendFile(path.join(__dirname, 'web', 'dashboard-actions.js'));
});
app.get('/leveling', requireAuth, requireTier('moderator'), async (req,res)=>{
  // Pre-fetch all user names to avoid displaying IDs
  const allIds = Object.keys(leveling);
  
  // Fetch names in parallel (in batches to avoid rate limits)
  const batchSize = 50;
  for (let i = 0; i < allIds.length; i += batchSize) {
    const batch = allIds.slice(i, i + batchSize);
    await Promise.all(batch.map(id => fetchUserName(id)));
  }
  
  res.send(renderPage('leveling', req));
});
app.get('/welcome', requireAuth, requireTier('moderator'), (req,res)=>{
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.set('Pragma', 'no-cache');
  res.set('Expires', '0');
  res.send(renderPage('welcome', req));
});
function buildRenderHealthStatus() {
  const now = Date.now();
  const uptimeMs = Math.floor(process.uptime() * 1000);
  const startupGraceMs = 5 * 60 * 1000;
  const streamCheckStaleMs = 6 * 60 * 1000;
  const inStartupGrace = uptimeMs < startupGraceMs;

  const discordReady = client.isReady();
  const twitchConfigured = Boolean(process.env.TWITCH_CLIENT_ID && process.env.STREAMER_LOGIN);
  const twitchTokenPresent = Boolean(TWITCH_ACCESS_TOKEN);

  let lastStreamCheckAgeMs = null;
  if (lastStreamCheckAt) {
    const parsed = Date.parse(lastStreamCheckAt);
    if (!Number.isNaN(parsed)) {
      lastStreamCheckAgeMs = now - parsed;
    }
  }

  const reasons = [];

  if (!discordReady && !inStartupGrace) {
    reasons.push('discord_not_ready');
  }

  if (twitchConfigured && !twitchTokenPresent && !inStartupGrace) {
    reasons.push('twitch_token_missing');
  }

  if (twitchConfigured && twitchTokenPresent && !inStartupGrace) {
    if (lastStreamCheckAgeMs === null || lastStreamCheckAgeMs > streamCheckStaleMs) {
      reasons.push('stream_check_stale');
    }
  }

  return {
    ok: reasons.length === 0,
    status: reasons.length === 0 ? 'ok' : 'degraded',
    timestamp: new Date(now).toISOString(),
    uptimeSec: Math.floor(uptimeMs / 1000),
    checks: {
      discordReady,
      twitchConfigured,
      twitchTokenPresent,
      lastStreamCheckAt,
      lastStreamCheckAgeMs,
      startupGrace: inStartupGrace
    },
    reasons
  };
}

app.get('/healthz', (req, res) => {
  const health = buildRenderHealthStatus();
  res.status(health.ok ? 200 : 503).json(health);
});

app.get('/health', requireAuth, requireTier('moderator'), (req,res)=>{
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.set('Pragma', 'no-cache');
  res.set('Expires', '0');
  res.send(renderPage('health', req));
});
app.get('/audit', requireAuth, requireTier('moderator'), (req,res)=>{
  res.set('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
  res.set('Pragma', 'no-cache');
  res.set('Expires', '0');
  res.send(renderPage('audit', req));
});
app.get('/embeds', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('embeds', req)));
app.get('/customcmds', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('customcmds', req)));
app.get('/accounts', requireAuth, requireTier('owner'), (req,res)=>res.send(renderPage('accounts', req)));

// Pets SSE (Server-Sent Events) for instant updates
const petSSEClients = new Set();
function notifyPetsChange() {
  for (const client of petSSEClients) {
    try { client.write('data: update\n\n'); } catch (e) { petSSEClients.delete(client); }
  }
}
app.get('/api/pets/stream', requireAuth, requireTier('viewer'), (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });
  res.write('data: connected\n\n');
  petSSEClients.add(res);
  req.on('close', () => { petSSEClients.delete(res); });
});

// Pets routes
app.get('/pets', requireAuth, requireTier('viewer'), (req,res)=>res.send(renderPage('pets', req)));
app.get('/pet-giveaways', requireAuth, requireTier('viewer'), (req,res)=>res.send(renderPage('pet-giveaways', req)));
app.get('/pet-stats', requireAuth, requireTier('viewer'), (req,res)=>res.send(renderPage('pet-stats', req)));
app.get('/api/pets', requireAuth, requireTier('viewer'), (req, res) => {
  const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
  const giveawaysData = loadJSON(GIVEAWAYS_PATH, { history: [] });
  const pending = (giveawaysData.history || []).filter(g => !g.confirmed).map(g => ({ petId: g.petId, winner: g.winner, giver: g.giver }));
  res.json({ ...petsData, pendingGiveaways: pending });
});
app.post('/api/pets/add', requireAuth, requireTier('moderator'), (req, res) => {
  try {
    const { petId, givenBy } = req.body;
    if (!petId) return res.json({ success: false, error: 'Missing petId' });
    const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
    const catalogEntry = (petsData.catalog || []).find(c => c.id === petId);
    if (!catalogEntry) return res.json({ success: false, error: 'Pet not found in catalog' });
    const newPet = {
      id: `pet-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      petId,
      addedBy: req.userName || 'Dashboard',
      addedByName: req.userName || 'Dashboard',
      addedAt: new Date().toISOString(),
      ...(givenBy ? { givenBy } : {})
    };
    petsData.pets = petsData.pets || [];
    petsData.pets.push(newPet);
    saveJSON(PETS_PATH, petsData);
    const ownedCount = petsData.pets.filter(p => p.petId === petId).length;
    addLog('info', `Pet "${catalogEntry.name}" added by ${req.userName || 'Dashboard'} (now x${ownedCount})`);
    notifyPetsChange();
    res.json({ success: true, pet: newPet });
  } catch (err) {
    console.error('[Pets] Error adding pet:', err);
    res.status(500).json({ success: false, error: 'Server error: ' + err.message });
  }
});
app.delete('/api/pets/:id', requireAuth, requireTier('moderator'), (req, res) => {
  try {
    const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
    const idx = (petsData.pets || []).findIndex(p => p.id === req.params.id);
    if (idx === -1) return res.json({ success: false, error: 'Pet not found' });
    const removed = petsData.pets.splice(idx, 1)[0];
    saveJSON(PETS_PATH, petsData);
    const catEntry = (petsData.catalog || []).find(c => c.id === removed.petId);
    addLog('info', `Pet "${catEntry?.name || removed.petId}" removed by ${req.userName || 'Dashboard'}`);
    notifyPetsChange();
    res.json({ success: true });
  } catch (err) {
    console.error('[Pets] Error removing pet:', err);
    res.status(500).json({ success: false, error: 'Server error: ' + err.message });
  }
});
app.post('/api/pets/catalog', requireAuth, requireTier('admin'), (req, res) => {
  const { id, name, emoji, description, imageUrl, animatedUrl, rarity, bonus, hidden } = req.body;
  if (!id || !name) return res.json({ success: false, error: 'Missing id or name' });
  const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
  petsData.catalog = petsData.catalog || [];
  const existing = petsData.catalog.findIndex(c => c.id === id);
  const entry = { id, name, emoji: emoji || 'ðŸ¾', description: description || '', imageUrl: imageUrl || '', animatedUrl: animatedUrl || '', rarity: rarity || 'common', bonus: bonus || '', hidden: !!hidden };
  if (existing >= 0) {
    petsData.catalog[existing] = entry;
  } else {
    petsData.catalog.push(entry);
  }
  saveJSON(PETS_PATH, petsData);
  notifyPetsChange();
  res.json({ success: true });
});
// Edit individual pet catalog fields (rarity, description, bonus, imageUrl, hidden etc.)
app.post('/api/pets/catalog/edit', requireAuth, requireTier('moderator'), (req, res) => {
  const { id } = req.body;
  if (!id) return res.json({ success: false, error: 'Missing pet id' });
  const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
  const idx = (petsData.catalog || []).findIndex(c => c.id === id);
  if (idx === -1) return res.json({ success: false, error: 'Pet not found in catalog' });
  const allowed = ['rarity', 'description', 'bonus', 'imageUrl', 'animatedUrl', 'hidden', 'tier', 'tierPoints'];
  for (const key of allowed) {
    if (req.body[key] !== undefined) {
      petsData.catalog[idx][key] = req.body[key];
    }
  }
  saveJSON(PETS_PATH, petsData);
  addLog('info', `Pet "${petsData.catalog[idx].name}" edited by ${req.userName || 'Dashboard'}: ${allowed.filter(k => req.body[k] !== undefined).join(', ')}`);
  notifyPetsChange();
  res.json({ success: true, pet: petsData.catalog[idx] });
});

// Clear all owned pets
app.post('/api/pets/clear-all', requireAuth, requireTier('admin'), (req, res) => {
  try {
    const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
    const count = (petsData.pets || []).length;
    petsData.pets = [];
    saveJSON(PETS_PATH, petsData);
    addLog('info', `All pets cleared (${count} removed) by ${req.userName || 'Dashboard'}`);
    notifyPetsChange();
    res.json({ success: true, removed: count });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

// Pet giveaway routes
const GIVEAWAYS_PATH = path.join(DATA_DIR, 'pet-giveaways.json');
app.post('/api/pets/giveaway', requireAuth, requireTier('moderator'), (req, res) => {
  try {
    const { petId, winner, giver, notes, expirationTime, pingGiver, pingReceiver } = req.body;
    if (!petId || !winner || !giver) return res.json({ success: false, error: 'Missing required fields' });
    
    // Check if giver is banned
    const bannedGivers = loadJSON(path.join(DATA_DIR, 'pet-giveaway-bans.json'), { banned: [] });
    if ((bannedGivers.banned || []).some(b => b.userId === giver)) {
      return res.json({ success: false, error: 'This user is banned from giving out pets' });
    }
    
    const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
    const catEntry = (petsData.catalog || []).find(c => c.id === petId);
    if (!catEntry) return res.json({ success: false, error: 'Pet not found' });

    const giveaways = loadJSON(GIVEAWAYS_PATH, { history: [] });
    giveaways.history = giveaways.history || [];
    const now = Date.now();
    const expiresAt = expirationTime ? now + (expirationTime * 60 * 1000) : null;
    
    giveaways.history.unshift({
      id: `giveaway-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      petId, petName: catEntry.name, petEmoji: catEntry.emoji, petRarity: catEntry.rarity,
      winner, giver, notes: notes || '',
      submittedBy: req.userName || 'Dashboard',
      submittedAt: new Date().toISOString(),
      confirmed: false, confirmedBy: null, confirmedAt: null,
      expiresAt: expiresAt,
      pingGiver: !!pingGiver,
      pingReceiver: !!pingReceiver,
      comments: [],
      warningPingSent: false
    });
    saveJSON(GIVEAWAYS_PATH, giveaways);
    addLog('info', `Pet giveaway submitted: ${catEntry.name} â†’ ${winner} (by ${giver})`);
    notifyPetsChange();
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

app.get('/api/pets/giveaways', requireAuth, requireTier('moderator'), (req, res) => {
  const giveaways = loadJSON(GIVEAWAYS_PATH, { history: [] });
  res.json(giveaways);
});

app.post('/api/pets/giveaway/confirm', requireAuth, requireTier('admin'), (req, res) => {
  try {
    const { id } = req.body;
    const giveaways = loadJSON(GIVEAWAYS_PATH, { history: [] });
    const entry = (giveaways.history || []).find(g => g.id === id);
    if (!entry) return res.json({ success: false, error: 'Giveaway not found' });
    entry.confirmed = true;
    entry.confirmedBy = req.userName || 'Dashboard';
    entry.confirmedAt = new Date().toISOString();
    saveJSON(GIVEAWAYS_PATH, giveaways);

    // Auto-remove 1 instance of this pet from the giver's owned collection
    const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
    petsData.pets = petsData.pets || [];
    let ownedIdx = petsData.pets.findIndex(p => p.petId === entry.petId && p.givenBy && p.givenBy.trim() === entry.giver);
    if (ownedIdx === -1) ownedIdx = petsData.pets.findIndex(p => p.petId === entry.petId);
    if (ownedIdx !== -1) {
      petsData.pets.splice(ownedIdx, 1);
      saveJSON(PETS_PATH, petsData);
      addLog('info', `Pet "${entry.petName}" auto-removed from collection (giveaway confirmed to ${entry.winner})`);
    }

    addLog('info', `Pet giveaway confirmed: ${entry.petName} â†’ ${entry.winner} (confirmed by ${req.userName})`);
    notifyPetsChange();
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

app.post('/api/pets/giveaway/delete', requireAuth, requireTier('admin'), (req, res) => {
  try {
    const { id } = req.body;
    const giveaways = loadJSON(GIVEAWAYS_PATH, { history: [] });
    giveaways.history = (giveaways.history || []).filter(g => g.id !== id);
    saveJSON(GIVEAWAYS_PATH, giveaways);
    notifyPetsChange();
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

// ========== PET GIVEAWAY COMMENTS ==========

app.post('/api/pets/giveaway/:id/comment', requireAuth, (req, res) => {
  try {
    const { comment } = req.body;
    if (!comment || !comment.trim()) return res.json({ success: false, error: 'Comment cannot be empty' });
    
    const giveaways = loadJSON(GIVEAWAYS_PATH, { history: [] });
    const entry = (giveaways.history || []).find(g => g.id === req.params.id);
    if (!entry) return res.json({ success: false, error: 'Giveaway not found' });
    
    if (!entry.comments) entry.comments = [];
    entry.comments.push({
      id: `comment-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      author: req.userName || 'User',
      text: comment.trim(),
      timestamp: new Date().toISOString()
    });
    
    saveJSON(GIVEAWAYS_PATH, giveaways);
    addLog('info', `Comment added to giveaway ${req.params.id} by ${req.userName}`);
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

app.delete('/api/pets/giveaway/:id/comment/:commentId', requireAuth, (req, res) => {
  try {
    const giveaways = loadJSON(GIVEAWAYS_PATH, { history: [] });
    const entry = (giveaways.history || []).find(g => g.id === req.params.id);
    if (!entry) return res.json({ success: false, error: 'Giveaway not found' });
    
    if (!entry.comments) entry.comments = [];
    const idx = entry.comments.findIndex(c => c.id === req.params.commentId);
    if (idx === -1) return res.json({ success: false, error: 'Comment not found' });
    
    entry.comments.splice(idx, 1);
    saveJSON(GIVEAWAYS_PATH, giveaways);
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

// ========== PET GIVEAWAY BAN SYSTEM ==========

app.post('/api/pets/giveaway/ban/add', requireAuth, requireTier('admin'), (req, res) => {
  try {
    const { userId, reason } = req.body;
    if (!userId) return res.json({ success: false, error: 'User ID required' });
    
    const bans = loadJSON(path.join(DATA_DIR, 'pet-giveaway-bans.json'), { banned: [] });
    bans.banned = bans.banned || [];
    
    if (bans.banned.some(b => b.userId === userId)) {
      return res.json({ success: false, error: 'User already banned' });
    }
    
    bans.banned.push({
      userId,
      reason: reason || 'No reason provided',
      bannedAt: new Date().toISOString(),
      bannedBy: req.userName || 'Admin'
    });
    
    saveJSON(path.join(DATA_DIR, 'pet-giveaway-bans.json'), bans);
    addLog('info', `User ${userId} banned from giving pets by ${req.userName}`);
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

app.post('/api/pets/giveaway/ban/remove', requireAuth, requireTier('admin'), (req, res) => {
  try {
    const { userId } = req.body;
    if (!userId) return res.json({ success: false, error: 'User ID required' });
    
    const bans = loadJSON(path.join(DATA_DIR, 'pet-giveaway-bans.json'), { banned: [] });
    bans.banned = (bans.banned || []).filter(b => b.userId !== userId);
    
    saveJSON(path.join(DATA_DIR, 'pet-giveaway-bans.json'), bans);
    addLog('info', `User ${userId} unbanned from giving pets by ${req.userName}`);
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

app.get('/api/pets/giveaway/bans', requireAuth, requireTier('moderator'), (req, res) => {
  const bans = loadJSON(path.join(DATA_DIR, 'pet-giveaway-bans.json'), { banned: [] });
  res.json(bans);
});

// ========== PET GIVEAWAY STATS ==========

app.get('/api/pets/giveaway/stats', requireAuth, requireTier('moderator'), (req, res) => {
  try {
    const giveaways = loadJSON(GIVEAWAYS_PATH, { history: [] });
    const history = giveaways.history || [];
    
    const giverStats = {};
    const petStats = {};
    const rarityStats = {};
    let totalGiveaways = 0;
    let confirmedGiveaways = 0;
    
    history.forEach(g => {
      totalGiveaways++;
      if (g.confirmed) confirmedGiveaways++;
      
      giverStats[g.giver] = (giverStats[g.giver] || 0) + 1;
      petStats[g.petName] = (petStats[g.petName] || 0) + 1;
      rarityStats[g.petRarity] = (rarityStats[g.petRarity] || 0) + 1;
    });
    
    const topGivers = Object.entries(giverStats)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([name, count]) => ({ name, count }));
    
    const topPets = Object.entries(petStats)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([name, count]) => ({ name, count }));
    
    const rarityBreakdown = Object.entries(rarityStats)
      .map(([rarity, count]) => ({ rarity, count }));
    
    res.json({
      totalGiveaways,
      confirmedGiveaways,
      pendingGiveaways: totalGiveaways - confirmedGiveaways,
      confirmationRate: totalGiveaways > 0 ? Math.round((confirmedGiveaways / totalGiveaways) * 100) : 0,
      topGivers,
      topPets,
      rarityBreakdown
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// ========== PET GIVEAWAY WARNINGS & AUTO-CANCEL ==========
// Check for expiring giveaways every 5 minutes
setInterval(async () => {
  try {
    const giveaways = loadJSON(GIVEAWAYS_PATH, { history: [] });
    const history = giveaways.history || [];
    const now = Date.now();
    const fifteenMinutes = 15 * 60 * 1000;
    
    let changed = false;
    const toRemove = [];
    
    for (const g of history) {
      // Skip confirmed giveaways
      if (g.confirmed) continue;
      
      // Auto-cancel expired giveaways
      if (g.expiresAt && g.expiresAt <= now) {
        toRemove.push(g.id);
        changed = true;
        
        const cancelMsg = `âŒ **Pet Giveaway Expired!** The ${g.petName} giveaway from **${g.giver}** to **${g.winner}** has expired and been automatically cancelled.`;
        
        if (g.pingReceiver) {
          try {
            const user = await client.users.fetch(g.winner).catch(() => null);
            if (user) await user.send(cancelMsg);
          } catch {}
        }
        
        if (g.pingGiver) {
          try {
            const user = await client.users.fetch(g.giver).catch(() => null);
            if (user) await user.send(`âŒ Your pet giveaway of **${g.petName}** to **${g.winner}** has expired and been cancelled.`);
          } catch {}
        }
        
        addLog('info', `Pet giveaway auto-cancelled (expired): ${g.petName} from ${g.giver} to ${g.winner}`);
        continue;
      }
      
      // Send warning 15 minutes before expiration
      if (g.expiresAt && !g.warningPingSent && g.expiresAt - now <= fifteenMinutes && g.expiresAt - now > 0) {
        g.warningPingSent = true;
        changed = true;
        
        const timeLeft = Math.round((g.expiresAt - now) / 60000);
        const warningMsg = `â° **Pet Giveaway Expiring Soon!** The ${g.petName} giveaway from **${g.giver}** to **${g.winner}** expires in ${timeLeft} minutes. Please claim it soon!`;
        
        if (g.pingReceiver) {
          try {
            const user = await client.users.fetch(g.winner).catch(() => null);
            if (user) await user.send(warningMsg);
          } catch {}
        }
        
        if (g.pingGiver) {
          try {
            const user = await client.users.fetch(g.giver).catch(() => null);
            if (user) await user.send(`â° Your pet giveaway of **${g.petName}** to **${g.winner}** expires in ${timeLeft} minutes!`);
          } catch {}
        }
      }
    }
    
    // Remove expired giveaways
    if (toRemove.length > 0) {
      giveaways.history = history.filter(g => !toRemove.includes(g.id));
      changed = true;
    }
    
    if (changed) saveJSON(GIVEAWAYS_PATH, giveaways);
  } catch (err) {
    console.error('[PetGiveaway] Warning/Auto-cancel check error:', err.message);
  }
}, 5 * 60 * 1000);

// NEW: Twitch OAuth route
function getTwitchRedirectUri(req) {
  const forwardedProto = (req.headers['x-forwarded-proto'] || '').toString().split(',')[0].trim();
  const protocol = forwardedProto || req.protocol || 'http';
  const host = req.get('host');
  const computed = `${protocol}://${host}/auth/twitch/callback`;
  const configured = (process.env.TWITCH_REDIRECT_URI || '').trim();
  const renderExternalUrl = (process.env.RENDER_EXTERNAL_URL || '').trim();

  const normalizeUrl = (baseUrl) => {
    const trimmed = (baseUrl || '').trim();
    if (!trimmed) return '';
    return trimmed.replace(/\/+$/, '');
  };

  const isLocalOrInternal = (value) => {
    const lower = (value || '').toLowerCase();
    return !lower || lower.includes('localhost') || lower.includes('127.0.0.1') || lower.includes('0.0.0.0') || lower.includes('.internal');
  };

  const renderBase = normalizeUrl(renderExternalUrl);
  const fallbackRedirect = renderBase ? `${renderBase}/auth/twitch/callback` : computed;

  if (configured) {
    if (isLocalOrInternal(configured)) {
      addLog('warn', `Ignoring local/internal TWITCH_REDIRECT_URI (${configured}); using ${fallbackRedirect}`);
      return fallbackRedirect;
    }
    return configured;
  }

  if (isLocalOrInternal(host) && renderBase) {
    addLog('warn', `Host ${host || 'unknown'} appears internal; using ${fallbackRedirect} for OAuth redirect`);
    return fallbackRedirect;
  }

  return fallbackRedirect;
}

app.get('/auth/twitch', (req, res) => {
  const clientId = process.env.TWITCH_CLIENT_ID;
  const redirectUri = getTwitchRedirectUri(req);
  const scopes = ['user:read:email', 'channel:read:stream_key', 'channel:read:vips', 'moderator:read:chatters'];
  
  addLog('info', `OAuth redirect URI: ${redirectUri}`);
  
  const authUrl = `https://id.twitch.tv/oauth2/authorize?client_id=${clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=${encodeURIComponent(scopes.join(' '))}`;
  
  res.redirect(authUrl);
});

// NEW: Twitch OAuth callback
app.get('/auth/twitch/callback', async (req, res) => {
  const code = req.query.code;
  const error = req.query.error;
  const errorDesc = req.query.error_description;
  const expectedRedirectUri = getTwitchRedirectUri(req);
  
  if (error) {
    addLog('error', `OAuth error: ${error} - ${errorDesc}`);
    return res.send(`
      <h1>âŒ Authorization Failed</h1>
      <p><b>Error:</b> ${error}</p>
      <p><b>Details:</b> ${decodeURIComponent(errorDesc || 'Unknown')}</p>
      <p><b>Fix:</b> Make sure the redirect URI in your Twitch app settings matches exactly:</p>
      <pre>${expectedRedirectUri}</pre>
      <p><a href="/">Back to Dashboard</a></p>
    `);
  }
  
  if (!code) {
    return res.send('<h1>No authorization code received</h1><a href="/">Back</a>');
  }
  
  try {
    const redirectUri = expectedRedirectUri;
    const tokenRes = await fetch('https://id.twitch.tv/oauth2/token', {
      method: 'POST',
      body: new URLSearchParams({
        client_id: process.env.TWITCH_CLIENT_ID,
        client_secret: process.env.TWITCH_CLIENT_SECRET,
        code,
        grant_type: 'authorization_code',
        redirect_uri: redirectUri
      })
    });
    
    const tokenData = await tokenRes.json();
    
    if (!tokenData.access_token) {
      throw new Error(tokenData.message || 'Failed to get token');
    }
    
    // Store tokens with expiration time
    const expiresAt = Date.now() + (tokenData.expires_in * 1000);
    twitchTokens.access_token = tokenData.access_token;
    twitchTokens.refresh_token = tokenData.refresh_token;
    twitchTokens.expires_at = expiresAt;

    TWITCH_ACCESS_TOKEN = tokenData.access_token;
    
    // Update .env file if it exists (not on Render)
    try {
      if (fs.existsSync('.env')) {
        let envContent = fs.readFileSync('.env', 'utf-8');
        envContent = envContent.replace(/TWITCH_ACCESS_TOKEN=.*/, `TWITCH_ACCESS_TOKEN=${tokenData.access_token}`);
        fs.writeFileSync('.env', envContent);
      }
    } catch { /* .env not available â€” tokens persisted in state.json instead */ }
    
    // Save to state.json (primary persistence on Render)
    saveState();
    
    addLog('info', 'Twitch token obtained via OAuth2');
    addLog('info', `Token expires at: ${new Date(expiresAt).toLocaleString()}`);

    // If Discord is already ready, immediately re-initialize Twitch checks
    // (This fixes the case where startup failed due to an expired token.)
    if (client?.isReady?.()) {
      try {
        await ensureTwitchInitialized({ reloadFromEnv: false, forceBroadcasterRefresh: true });
        addLog('info', 'Twitch re-initialized after OAuth token update');
      } catch (e) {
        addLog('error', 'Failed to re-initialize Twitch after OAuth: ' + (e?.message || e));
      }
    }
    
    res.send(`
      <h1>âœ… Authorization Successful!</h1>
      <p>Your Twitch token has been generated and saved.</p>
      <p>Token: <code>${tokenData.access_token.substring(0, 20)}...</code></p>
      <p><strong>Expires at:</strong> ${new Date(expiresAt).toLocaleString()}</p>
      <p style="color: #4caf50;"><strong>âœ… Automatic Refresh Enabled:</strong> Your token will automatically refresh before expiring.</p>
      <p><strong>Add this to your .env file to make it permanent:</strong></p>
      <pre>TWITCH_ACCESS_TOKEN=${tokenData.access_token}</pre>
      <p><a href="/">Back to Dashboard</a></p>
    `);
  } catch (err) {
    addLog('error', 'OAuth callback error: ' + err.message);
    res.send(`<h1>âŒ Error: ${err.message}</h1><p><a href="/">Back to Dashboard</a></p>`);
  }
});

app.post('/twitch/reload', async (_req, res) => {
  try {
    await ensureTwitchInitialized({ reloadFromEnv: true, forceBroadcasterRefresh: true });
    return res.json({ success: true });
  } catch (err) {
    addLog('error', 'Twitch reload failed: ' + err.message);
    return res.status(500).json({ success: false, error: err.message });
  }
});

app.post('/twitch/refresh', async (_req, res) => {
  try {
    const success = await refreshTwitchToken();
    if (success) {
      return res.json({ success: true, message: 'âœ… Token refreshed successfully!' });
    } else {
      return res.status(500).json({ success: false, message: 'âŒ Failed to refresh token. Check logs for details.' });
    }
  } catch (err) {
    addLog('error', 'Twitch token refresh failed: ' + err.message);
    return res.status(500).json({ success: false, message: `âŒ Refresh error: ${err.message}` });
  }
});

app.post('/logs/clear', (_,res)=>{ logs=[]; fs.writeFileSync(LOG_FILE,'[]'); addLog('info','Logs cleared'); res.sendStatus(200); });
app.post('/reset-live', async (_,res)=>{ isLive=false; lastStreamId=null; announcementMessageId=null; suppressNextAnnounce=true; saveState(); addLog('info','Live state reset manually'); await checkStream(); res.sendStatus(200); });
app.post('/test-live', async (_,res)=>{ await announceLive(true,true); res.sendStatus(200); });
app.post('/test-end', async (_,res)=>{
  if(!announcementMessageId) return res.sendStatus(400);
  try{
    const channel = await client.channels.fetch(process.env.DISCORD_CHANNEL_ID);
    const msg = await channel.messages.fetch(announcementMessageId);
    await msg.edit({content:'âš« Stream ended *(test)*', embeds:[buildOfflineEmbed()]});
    addLog('test','Fake stream end triggered');
    setTimeout(()=>msg.delete().catch(()=>{}),60000);
    res.sendStatus(200);
  }catch{ addLog('error','Fake stream end failed'); res.sendStatus(500);}
});
app.post('/reset-schedule', (_, res) => {
  schedule.noStreamToday = false;
  schedule.streamDelayed = false;
  schedule.alertsSent = { oneHour: false, tenMin: false };

  computeNextScheduledStream(true); // force recompute
  saveState();

  addLog('info', 'Schedule reset manually (testing)');
  res.sendStatus(200);
});

app.post('/reset-delay-mark', (_, res) => {
  schedule.streamDelayed = false;
  schedule.lastDelayedAlertFor = null;
  saveState();
  addLog('info', 'Delay mark reset manually');
  res.sendStatus(200);
});

app.get('/api/vips', requireAuth, async (req, res) => {
  try {
    const vips = await getChannelVIPs();
    res.json({ vips });
  } catch (err) {
    res.json({ error: err.message, vips: [] });
  }
});

app.get('/vips', requireAuth, async (req, res) => {
  try {
    const vips = await getChannelVIPs();
    
    res.send(`<!DOCTYPE html>
<html>
<head>
  <title>Channel VIPs</title>
  <style>
    body { background: #1a1a1f; color: #e0e0e0; font-family: 'Segoe UI', Tahoma, sans-serif; padding: 20px; }
    .container { max-width: 800px; margin: 0 auto; background: #26262c; padding: 30px; border-radius: 8px; }
    h1 { color: #9146ff; margin-top: 0; }
    .vip-list { list-style: none; padding: 0; }
    .vip-item { background: #1a1a1f; padding: 15px; margin: 10px 0; border-radius: 4px; display: flex; align-items: center; }
    .vip-name { font-size: 18px; font-weight: bold; color: #e0e0e0; }
    .vip-id { font-size: 12px; color: #999; margin-left: 10px; }
    .badge { background: #9146ff; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; margin-left: auto; }
    .back-link { display: inline-block; margin-top: 20px; color: #9146ff; text-decoration: none; }
    .back-link:hover { text-decoration: underline; }
    .no-vips { color: #999; font-style: italic; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸ‘‘ Channel VIPs</h1>
    ${vips.length > 0 ? `
      <ul class="vip-list">
        ${vips.map(vip => `
          <li class="vip-item">
            <div>
              <span class="vip-name">${vip.user_name}</span>
              <span class="vip-id">ID: ${vip.user_id}</span>
            </div>
            <span class="badge">VIP</span>
          </li>
        `).join('')}
      </ul>
      <p style="color: #999; margin-top: 20px;">Total VIPs: ${vips.length}</p>
    ` : `
      <p class="no-vips">No VIPs found for this channel.</p>
    `}
    <a href="/" class="back-link">â† Back to Dashboard</a>
  </div>
</body>
</html>`);
  } catch (err) {
    res.status(500).send(`
      <h1>Error</h1>
      <p>${err.message}</p>
      <p><a href="/">Back to Dashboard</a></p>
    `);
  }
});

app.post('/api/test-alert/:type', async (req, res) => {
  console.log('TEST ALERT ROUTE HIT', req.params.type);

  const { type } = req.params;

  if (type !== '1h' && type !== '10m') {
    return res.status(400).json({ error: 'Invalid test type' });
  }

  try {
    addLog('info', `Test alert triggered: ${type}`);

    await sendScheduleAlert(
      type === '1h' ? 'oneHour' : 'tenMin',
      true
    );

    res.json({ ok: true });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/engagement-settings', requireAuth, (req, res) => {
  try {
    const {
      autoDeleteTitleChange,
      autoDeleteGameChange,
      autoDeleteVod,
      autoDeleteRaid,
      autoDeleteClip,
      autoDeleteFollowerMilestone,
      autoDeleteViewerMilestone,
      autoDeleteDelay,
      excludedChannels,
      excludedRoles
    } = req.body;
    
    if (autoDeleteTitleChange !== undefined) engagementSettings.autoDeleteTitleChange = autoDeleteTitleChange;
    if (autoDeleteGameChange !== undefined) engagementSettings.autoDeleteGameChange = autoDeleteGameChange;
    if (autoDeleteVod !== undefined) engagementSettings.autoDeleteVod = autoDeleteVod;
    if (autoDeleteRaid !== undefined) engagementSettings.autoDeleteRaid = autoDeleteRaid;
    if (autoDeleteClip !== undefined) engagementSettings.autoDeleteClip = autoDeleteClip;
    if (autoDeleteFollowerMilestone !== undefined) engagementSettings.autoDeleteFollowerMilestone = autoDeleteFollowerMilestone;
    if (autoDeleteViewerMilestone !== undefined) engagementSettings.autoDeleteViewerMilestone = autoDeleteViewerMilestone;
    if (autoDeleteDelay !== undefined) {
      const delay = parseInt(autoDeleteDelay);
      if (isNaN(delay) || delay < 5000 || delay > 3600000) {
        return res.status(400).json({ success: false, error: 'Invalid delay (must be 5000-3600000ms)' });
      }
      engagementSettings.autoDeleteDelay = delay;
    }
    
    saveState();
    addLog('info', 'Auto-delete settings updated');
    res.json({ success: true });
  } catch (err) {
    addLog('error', 'Failed to save engagement settings: ' + err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});

// ========== RPG Events API ==========
app.post('/api/rpg-events/toggle', requireAuth, (req, res) => {
  try {
    const { index, enabled } = req.body;
    if (index < 0 || index >= rpgEvents.milestoneEvents.length) return res.json({ success: false, error: 'Invalid index' });
    rpgEvents.milestoneEvents[index].enabled = !!enabled;
    debouncedSaveState();
    addLog('info', `RPG Event "${rpgEvents.milestoneEvents[index].name}" ${enabled ? 'enabled' : 'disabled'}`);
    res.json({ success: true });
  } catch(e) { res.status(500).json({ success: false, error: e.message }); }
});

app.post('/api/rpg-events/add', requireAuth, (req, res) => {
  try {
    const { name, threshold, type, duration, description, emoji } = req.body;
    if (!name || !threshold || !duration) return res.json({ success: false, error: 'Missing required fields' });
    const typeEmojis = { xp_boost: 'âš¡', gold_rain: 'ðŸ’°', loot_boost: 'ðŸŽ', secret_dungeon: 'ðŸ°', boss_spawn: 'ðŸ‰' };
    const newEvent = {
      id: 'custom_' + Date.now(),
      viewerThreshold: parseInt(threshold),
      type: type || 'xp_boost',
      duration: parseInt(duration),
      name: name,
      description: description || '',
      emoji: emoji || typeEmojis[type] || 'ðŸŽ®',
      enabled: true,
      multiplier: type === 'xp_boost' ? 2 : type === 'loot_boost' ? 3 : 1,
      goldAmount: type === 'gold_rain' ? 5000 : 0,
      bossName: type === 'boss_spawn' ? name : '',
      dungeonId: type === 'secret_dungeon' ? 'custom_dungeon_' + Date.now() : ''
    };
    rpgEvents.milestoneEvents.push(newEvent);
    rpgEvents.milestoneEvents.sort((a, b) => a.viewerThreshold - b.viewerThreshold);
    debouncedSaveState();
    addLog('info', `New RPG Event added: ${newEvent.emoji} ${newEvent.name} (${newEvent.viewerThreshold} viewers)`);
    res.json({ success: true });
  } catch(e) { res.status(500).json({ success: false, error: e.message }); }
});

app.post('/api/rpg-events/trigger', requireAuth, (req, res) => {
  try {
    const { eventId } = req.body;
    const milestone = rpgEvents.milestoneEvents.find(m => m.id === eventId);
    if (!milestone) return res.json({ success: false, error: 'Event not found' });
    const currentViewers = stats.currentViewers || 0;
    triggerRPGEvent(milestone, currentViewers);
    res.json({ success: true });
  } catch(e) { res.status(500).json({ success: false, error: e.message }); }
});

app.post('/api/rpg-events/delete', requireAuth, (req, res) => {
  try {
    const { eventId } = req.body;
    rpgEvents.milestoneEvents = rpgEvents.milestoneEvents.filter(m => m.id !== eventId);
    debouncedSaveState();
    addLog('info', `RPG Event deleted: ${eventId}`);
    res.json({ success: true });
  } catch(e) { res.status(500).json({ success: false, error: e.message }); }
});
// ========== END RPG Events API ==========

// Stream Goals API
app.post('/api/stream-goals', requireAuth, (req, res) => {
  try {
    const { monthlyStreams, monthlyHours, monthlyFollowers, monthlyPeakViewers } = req.body;
    streamGoals.monthlyStreams = parseInt(monthlyStreams) || 0;
    streamGoals.monthlyHours = parseInt(monthlyHours) || 0;
    streamGoals.monthlyFollowers = parseInt(monthlyFollowers) || 0;
    streamGoals.monthlyPeakViewers = parseInt(monthlyPeakViewers) || 0;
    debouncedSaveState();
    invalidateAnalyticsCache();
    addLog('info', 'Stream goals updated');
    res.json({ success: true });
  } catch(e) { res.status(500).json({ success: false, error: e.message }); }
});

app.post('/api/welcome-settings', requireAuth, (req, res) => {
  try {
    const {
      enabled, channelId, message, useEmbed, embedTitle, embedDescription,
      embedColor, embedThumbnail, embedThumbnailUrl, embedImage, embedFooter,
      embedFields, messageMode, messages, dmEnabled, dmMessage, dmUseEmbed,
      antiSpamEnabled, antiSpamRoles,
      goodbyeEnabled, goodbyeChannelId, goodbyeMessage, goodbyeUseEmbed,
      goodbyeEmbedTitle, goodbyeEmbedDescription, goodbyeEmbedColor,
      goodbyeEmbedThumbnail, goodbyeEmbedThumbnailUrl, goodbyeEmbedImage,
      goodbyeEmbedFooter, goodbyeMessageMode, goodbyeMessages
    } = req.body;
    
    // Welcome settings
    if (enabled !== undefined) welcomeSettings.enabled = enabled;
    if (channelId !== undefined) welcomeSettings.channelId = channelId;
    if (message !== undefined) welcomeSettings.message = message;
    if (useEmbed !== undefined) welcomeSettings.useEmbed = useEmbed;
    if (embedTitle !== undefined) welcomeSettings.embedTitle = embedTitle;
    if (embedDescription !== undefined) welcomeSettings.embedDescription = embedDescription;
    if (embedColor !== undefined) welcomeSettings.embedColor = embedColor;
    if (embedThumbnail !== undefined) welcomeSettings.embedThumbnail = embedThumbnail;
    if (embedThumbnailUrl !== undefined) welcomeSettings.embedThumbnailUrl = embedThumbnailUrl;
    if (embedImage !== undefined) welcomeSettings.embedImage = embedImage;
    if (embedFooter !== undefined) welcomeSettings.embedFooter = embedFooter;
    if (embedFields !== undefined) welcomeSettings.embedFields = embedFields;
    if (messageMode !== undefined) welcomeSettings.messageMode = messageMode;
    if (messages !== undefined) welcomeSettings.messages = messages;
    if (dmEnabled !== undefined) welcomeSettings.dmEnabled = dmEnabled;
    if (dmMessage !== undefined) welcomeSettings.dmMessage = dmMessage;
    if (dmUseEmbed !== undefined) welcomeSettings.dmUseEmbed = dmUseEmbed;
    if (antiSpamEnabled !== undefined) welcomeSettings.antiSpamEnabled = antiSpamEnabled;
    if (antiSpamRoles !== undefined) welcomeSettings.antiSpamRoles = antiSpamRoles;
    
    // Goodbye settings
    if (goodbyeEnabled !== undefined) welcomeSettings.goodbyeEnabled = goodbyeEnabled;
    if (goodbyeChannelId !== undefined) welcomeSettings.goodbyeChannelId = goodbyeChannelId;
    if (goodbyeMessage !== undefined) welcomeSettings.goodbyeMessage = goodbyeMessage;
    if (goodbyeUseEmbed !== undefined) welcomeSettings.goodbyeUseEmbed = goodbyeUseEmbed;
    if (goodbyeEmbedTitle !== undefined) welcomeSettings.goodbyeEmbedTitle = goodbyeEmbedTitle;
    if (goodbyeEmbedDescription !== undefined) welcomeSettings.goodbyeEmbedDescription = goodbyeEmbedDescription;
    if (goodbyeEmbedColor !== undefined) welcomeSettings.goodbyeEmbedColor = goodbyeEmbedColor;
    if (goodbyeEmbedThumbnail !== undefined) welcomeSettings.goodbyeEmbedThumbnail = goodbyeEmbedThumbnail;
    if (goodbyeEmbedThumbnailUrl !== undefined) welcomeSettings.goodbyeEmbedThumbnailUrl = goodbyeEmbedThumbnailUrl;
    if (goodbyeEmbedImage !== undefined) welcomeSettings.goodbyeEmbedImage = goodbyeEmbedImage;
    if (goodbyeEmbedFooter !== undefined) welcomeSettings.goodbyeEmbedFooter = goodbyeEmbedFooter;
    if (goodbyeMessageMode !== undefined) welcomeSettings.goodbyeMessageMode = goodbyeMessageMode;
    if (goodbyeMessages !== undefined) welcomeSettings.goodbyeMessages = goodbyeMessages;
    
    saveState();
    addLog('info', 'Welcome settings updated');
    res.json({ success: true });
  } catch (err) {
    addLog('error', 'Failed to save welcome settings: ' + err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});

app.post('/api/welcome-settings/add-role', requireAuth, (req, res) => {
  try {
    const { roleId, condition, minAccountAge } = req.body;
    
    if (!roleId) {
      return res.status(400).json({ success: false, error: 'Role ID required' });
    }
    
    // Initialize arrays if needed
    if (!welcomeSettings.autoRoleConditions) welcomeSettings.autoRoleConditions = [];
    if (!welcomeSettings.autoRoles) welcomeSettings.autoRoles = [];
    
    // Check if role already exists
    const existing = welcomeSettings.autoRoleConditions.find(r => r.roleId === roleId);
    if (existing) {
      return res.status(400).json({ success: false, error: 'Role already added' });
    }
    
    // Add to conditions array
    welcomeSettings.autoRoleConditions.push({
      roleId,
      condition: condition || 'always',
      minAccountAge: minAccountAge || 7
    });
    
    // Also add to legacy autoRoles array for backwards compat
    if (!welcomeSettings.autoRoles.includes(roleId)) {
      welcomeSettings.autoRoles.push(roleId);
    }
    
    saveState();
    addLog('info', `Added auto-role: ${roleId} (${condition || 'always'})`);
    res.json({ success: true });
  } catch (err) {
    addLog('error', 'Failed to add auto-role: ' + err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});

app.post('/api/welcome-settings/remove-role', requireAuth, (req, res) => {
  try {
    const { roleId } = req.body;
    
    if (!roleId) {
      return res.status(400).json({ success: false, error: 'Role ID required' });
    }
    
    // Remove from conditions array
    if (welcomeSettings.autoRoleConditions) {
      welcomeSettings.autoRoleConditions = welcomeSettings.autoRoleConditions.filter(r => r.roleId !== roleId);
    }
    
    // Remove from legacy array
    const index = welcomeSettings.autoRoles.indexOf(roleId);
    if (index > -1) {
      welcomeSettings.autoRoles.splice(index, 1);
    }
    
    saveState();
    addLog('info', `Removed auto-role: ${roleId}`);
    res.json({ success: true });
  } catch (err) {
    addLog('error', 'Failed to remove auto-role: ' + err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});

app.post('/api/welcome-settings/bulk-add-roles', requireAuth, (req, res) => {
  try {
    const { roleIds } = req.body;
    
    if (!roleIds || !Array.isArray(roleIds) || roleIds.length === 0) {
      return res.status(400).json({ success: false, error: 'Role IDs array required' });
    }
    
    if (!welcomeSettings.autoRoleConditions) welcomeSettings.autoRoleConditions = [];
    if (!welcomeSettings.autoRoles) welcomeSettings.autoRoles = [];
    
    let added = 0;
    for (const roleId of roleIds) {
      if (!welcomeSettings.autoRoleConditions.find(r => r.roleId === roleId)) {
        welcomeSettings.autoRoleConditions.push({ roleId, condition: 'always', minAccountAge: 7 });
        if (!welcomeSettings.autoRoles.includes(roleId)) {
          welcomeSettings.autoRoles.push(roleId);
        }
        added++;
      }
    }
    
    saveState();
    addLog('info', `Bulk added ${added} auto-roles`);
    res.json({ success: true, added });
  } catch (err) {
    addLog('error', 'Failed to bulk add auto-roles: ' + err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});

app.post('/api/welcome-settings/test-roles', requireAuth, async (req, res) => {
  try {
    const results = [];
    const guild = client.guilds.cache.first();
    
    if (!guild) {
      return res.json({ success: false, error: 'No guild found' });
    }
    
    const botMember = await guild.members.fetchMe().catch(() => null);
    if (!botMember) {
      return res.json({ success: false, error: 'Could not fetch bot member' });
    }
    
    const roles = welcomeSettings.autoRoleConditions || welcomeSettings.autoRoles?.map(id => ({ roleId: id })) || [];
    
    for (const roleConfig of roles) {
      const roleId = roleConfig.roleId || roleConfig;
      try {
        const role = await guild.roles.fetch(roleId);
        if (!role) {
          results.push(`âŒ ${roleId}: Role not found`);
        } else if (role.position >= botMember.roles.highest.position) {
          results.push(`âš ï¸ ${role.name}: Role is higher than bot's highest role`);
        } else {
          results.push(`âœ… ${role.name}: Can be assigned`);
        }
      } catch (e) {
        results.push(`âŒ ${roleId}: ${e.message}`);
      }
    }
    
    res.json({ success: true, results });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

app.post('/api/audit-log-settings', requireAuth, (req, res) => {
  try {
    const {
      enabled,
      channelId,
      logLevel,
      logMessageEdits,
      logMessageDeletes,
      logMessageBulkDeletes,
      logMessagePins,
      logUsernameChanges,
      logAvatarChanges,
      logNicknameChanges,
      logRoleChanges,
      logMemberJoins,
      logMemberLeaves,
      logMemberBans,
      logMemberUnbans,
      logMemberTimeouts,
      logMemberMutes,
      logMemberBoosts,
      logJoinPosition,
      logServerUpdates,
      logIntegrations,
      warnNewAccounts,
      newAccountThresholdDays,
      excludedChannels,
      excludedRoles,
      excludedUsers,
      muteRoleIds,
      perEventChannels,
      perEventExclusions,
      perEventPings,
      // New settings
      logRetentionDays,
      autoCleanupEnabled,
      eventColors,
      alertKeywords,
      alertUserId,
      alertEnabled,
      dmNotificationsEnabled,
      dmNotifyUserId,
      dmNotifyEvents,
      webhookUrl,
      webhookEnabled,
      autoDetectMuteRole
    } = req.body;

    if (enabled !== undefined) auditLogSettings.enabled = enabled;
    if (channelId !== undefined) auditLogSettings.channelId = channelId;
    if (logLevel !== undefined && ['all', 'important', 'minimal'].includes(logLevel)) auditLogSettings.logLevel = logLevel;
    if (logMessageEdits !== undefined) auditLogSettings.logMessageEdits = logMessageEdits;
    if (logMessageDeletes !== undefined) auditLogSettings.logMessageDeletes = logMessageDeletes;
    if (logMessageBulkDeletes !== undefined) auditLogSettings.logMessageBulkDeletes = logMessageBulkDeletes;
    if (logMessagePins !== undefined) auditLogSettings.logMessagePins = logMessagePins;
    if (logUsernameChanges !== undefined) auditLogSettings.logUsernameChanges = logUsernameChanges;
    if (logAvatarChanges !== undefined) auditLogSettings.logAvatarChanges = logAvatarChanges;
    if (logNicknameChanges !== undefined) auditLogSettings.logNicknameChanges = logNicknameChanges;
    if (logRoleChanges !== undefined) auditLogSettings.logRoleChanges = logRoleChanges;
    if (logMemberJoins !== undefined) auditLogSettings.logMemberJoins = logMemberJoins;
    if (logMemberLeaves !== undefined) auditLogSettings.logMemberLeaves = logMemberLeaves;
    if (logMemberBans !== undefined) auditLogSettings.logMemberBans = logMemberBans;
    if (logMemberUnbans !== undefined) auditLogSettings.logMemberUnbans = logMemberUnbans;
    if (logMemberTimeouts !== undefined) auditLogSettings.logMemberTimeouts = logMemberTimeouts;
    if (logMemberMutes !== undefined) auditLogSettings.logMemberMutes = logMemberMutes;
    if (logMemberBoosts !== undefined) auditLogSettings.logMemberBoosts = logMemberBoosts;
    if (logJoinPosition !== undefined) auditLogSettings.logJoinPosition = logJoinPosition;
    if (logServerUpdates !== undefined) auditLogSettings.logServerUpdates = logServerUpdates;
    if (logIntegrations !== undefined) auditLogSettings.logIntegrations = logIntegrations;
    if (warnNewAccounts !== undefined) auditLogSettings.warnNewAccounts = warnNewAccounts;
    if (newAccountThresholdDays !== undefined) {
      const days = parseInt(newAccountThresholdDays, 10);
      if (!isNaN(days) && days >= 1 && days <= 365) {
        auditLogSettings.newAccountThresholdDays = days;
      }
    }

    // New settings handling
    if (logRetentionDays !== undefined) {
      const days = parseInt(logRetentionDays, 10);
      if (!isNaN(days) && days >= 1 && days <= 365) {
        auditLogSettings.logRetentionDays = days;
      }
    }
    if (autoCleanupEnabled !== undefined) auditLogSettings.autoCleanupEnabled = autoCleanupEnabled;
    if (eventColors !== undefined && typeof eventColors === 'object') auditLogSettings.eventColors = { ...auditLogSettings.eventColors, ...eventColors };
    if (alertKeywords !== undefined) {
      if (Array.isArray(alertKeywords)) auditLogSettings.alertKeywords = alertKeywords;
      else if (typeof alertKeywords === 'string') auditLogSettings.alertKeywords = alertKeywords.split(',').map(s => s.trim()).filter(Boolean);
    }
    if (alertUserId !== undefined) auditLogSettings.alertUserId = alertUserId || null;
    if (alertEnabled !== undefined) auditLogSettings.alertEnabled = alertEnabled;
    if (dmNotificationsEnabled !== undefined) auditLogSettings.dmNotificationsEnabled = dmNotificationsEnabled;
    if (dmNotifyUserId !== undefined) auditLogSettings.dmNotifyUserId = dmNotifyUserId || null;
    if (dmNotifyEvents !== undefined && typeof dmNotifyEvents === 'object') auditLogSettings.dmNotifyEvents = { ...auditLogSettings.dmNotifyEvents, ...dmNotifyEvents };
    if (webhookUrl !== undefined) auditLogSettings.webhookUrl = webhookUrl || null;
    if (webhookEnabled !== undefined) auditLogSettings.webhookEnabled = webhookEnabled;
    if (autoDetectMuteRole !== undefined) auditLogSettings.autoDetectMuteRole = autoDetectMuteRole;

    if (excludedChannels !== undefined) {
      if (Array.isArray(excludedChannels)) auditLogSettings.excludedChannels = excludedChannels;
      else if (typeof excludedChannels === 'string') auditLogSettings.excludedChannels = excludedChannels.split(',').map(s=>s.trim()).filter(Boolean);
    }

    if (excludedRoles !== undefined) {
      if (Array.isArray(excludedRoles)) auditLogSettings.excludedRoles = excludedRoles;
      else if (typeof excludedRoles === 'string') auditLogSettings.excludedRoles = excludedRoles.split(',').map(s=>s.trim()).filter(Boolean);
    }

    if (excludedUsers !== undefined) {
      if (Array.isArray(excludedUsers)) auditLogSettings.excludedUsers = excludedUsers;
      else if (typeof excludedUsers === 'string') auditLogSettings.excludedUsers = excludedUsers.split(',').map(s=>s.trim()).filter(Boolean);
    }

    if (muteRoleIds !== undefined) {
      if (Array.isArray(muteRoleIds)) auditLogSettings.muteRoleIds = muteRoleIds;
      else if (typeof muteRoleIds === 'string') auditLogSettings.muteRoleIds = muteRoleIds.split(',').map(s=>s.trim()).filter(Boolean);
    }

    if (perEventChannels !== undefined && typeof perEventChannels === 'object') auditLogSettings.perEventChannels = perEventChannels;
    if (perEventExclusions !== undefined && typeof perEventExclusions === 'object') auditLogSettings.perEventExclusions = perEventExclusions;
    if (perEventPings !== undefined && typeof perEventPings === 'object') auditLogSettings.perEventPings = perEventPings;

    dashboardSettings.auditLogSettings = { ...auditLogSettings };

    saveState();
    addLog('info', 'Member log settings updated');
    res.json({ success: true });
  } catch (err) {
    addLog('error', 'Failed to save member log settings: ' + err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});

app.get('/api/rpg/settings/access', requireAuth, (req, res) => {
  const settings = getRpgSettings();
  res.json({ success: true, settings });
});

app.post('/api/rpg/settings/access', requireAuth, (req, res) => {
  try {
    const { channelRestrictionEnabled, allowedChannelIds } = req.body;
    const cleaned = Array.isArray(allowedChannelIds)
      ? allowedChannelIds.map(id => String(id || '').trim()).filter(Boolean)
      : [];
    dashboardSettings.rpgSettings = {
      ...defaultDashboardSettings.rpgSettings,
      channelRestrictionEnabled: !!channelRestrictionEnabled,
      allowedChannelIds: cleaned
    };
    saveState();
    addLog('info', `RPG channel restriction updated: enabled=${!!channelRestrictionEnabled}, channels=${cleaned.length}`);
    res.json({ success: true, settings: dashboardSettings.rpgSettings });
  } catch (err) {
    addLog('error', 'Failed to save RPG access settings: ' + err.message);
    res.status(500).json({ success: false, error: err.message });
  }
});

// Audit log history search API
app.get('/api/audit-log-history', requireAuth, (req, res) => {
  try {
    const { userId, eventType, keyword, startDate, endDate, page = 1, limit = 50 } = req.query;
    
    let filtered = [...auditLogHistory];
    
    if (userId) {
      filtered = filtered.filter(e => e.userId === userId || e.userTag?.toLowerCase().includes(userId.toLowerCase()));
    }
    if (eventType) {
      filtered = filtered.filter(e => e.action === eventType);
    }
    if (keyword) {
      const kw = keyword.toLowerCase();
      filtered = filtered.filter(e => 
        JSON.stringify(e).toLowerCase().includes(kw)
      );
    }
    if (startDate) {
      const start = new Date(startDate);
      filtered = filtered.filter(e => new Date(e.timestamp) >= start);
    }
    if (endDate) {
      const end = new Date(endDate);
      end.setHours(23, 59, 59, 999);
      filtered = filtered.filter(e => new Date(e.timestamp) <= end);
    }
    
    const total = filtered.length;
    const pageNum = parseInt(page, 10) || 1;
    const limitNum = Math.min(parseInt(limit, 10) || 50, 100);
    const offset = (pageNum - 1) * limitNum;
    const paginated = filtered.slice(offset, offset + limitNum);
    
    res.json({
      success: true,
      data: paginated,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum)
      }
    });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

// Audit log stats API
app.get('/api/audit-log-stats', requireAuth, (req, res) => {
  try {
    const now = new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const weekLogs = auditLogHistory.filter(e => new Date(e.timestamp) >= weekAgo);
    
    const stats = {
      totalLogs: auditLogHistory.length,
      logsThisWeek: weekLogs.length,
      bansThisWeek: weekLogs.filter(e => e.action === 'member_ban').length,
      timeoutsThisWeek: weekLogs.filter(e => e.action === 'member_timeout').length,
      joinsThisWeek: weekLogs.filter(e => e.action === 'member_join').length,
      leavesThisWeek: weekLogs.filter(e => e.action === 'member_leave').length,
      newAccountWarnings: weekLogs.filter(e => e.action === 'member_join' && e.type === 'warn').length,
      messageDeletes: weekLogs.filter(e => e.action === 'message_delete').length
    };
    
    res.json({ success: true, stats });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

// Export audit logs
app.get('/api/audit-log-export', requireAuth, (req, res) => {
  try {
    const { format = 'json' } = req.query;
    
    if (format === 'json') {
      res.setHeader('Content-Type', 'application/json');
      res.setHeader('Content-Disposition', `attachment; filename=audit-logs-${new Date().toISOString().split('T')[0]}.json`);
      res.send(JSON.stringify(auditLogHistory, null, 2));
    } else {
      res.status(400).json({ success: false, error: 'Invalid format' });
    }
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

// Manual cleanup endpoint
app.post('/api/audit-log-cleanup', requireAuth, (req, res) => {
  try {
    const { days } = req.body;
    const retentionDays = parseInt(days, 10) || auditLogSettings.logRetentionDays || 30;
    
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - retentionDays);
    
    const oldLength = auditLogHistory.length;
    auditLogHistory = auditLogHistory.filter(entry => 
      new Date(entry.timestamp) > cutoffDate
    );
    
    saveAuditLogHistory();
    
    const removed = oldLength - auditLogHistory.length;
    addLog('info', `Manual audit log cleanup: removed ${removed} entries older than ${retentionDays} days`);
    
    res.json({ success: true, removed, remaining: auditLogHistory.length });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});

// Auto-detect mute role endpoint
app.get('/api/detect-mute-role', requireAuth, async (req, res) => {
  try {
    const guild = client.guilds.cache.first();
    if (!guild) return res.json({ success: false, error: 'No guild found' });
    
    const roles = await guild.roles.fetch();
    const muteRoles = roles.filter(r => 
      r.name.toLowerCase().includes('mute') || 
      r.name.toLowerCase().includes('muted') ||
      r.name.toLowerCase().includes('timeout')
    );
    
    res.json({ 
      success: true, 
      roles: muteRoles.map(r => ({ id: r.id, name: r.name }))
    });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
});


app.post('/options/save', (req,res)=>{ 
  const { ROLE_ID, notificationRoles, CUSTOM_CHANNEL_ID, notificationEnabled, notificationPing, notificationChannels } = req.body; 
  if (ROLE_ID !== undefined) config.ROLE_ID = ROLE_ID;
  if (notificationRoles) config.notificationRoles = { ...config.notificationRoles, ...notificationRoles };
  if (CUSTOM_CHANNEL_ID !== undefined) config.CUSTOM_CHANNEL_ID = CUSTOM_CHANNEL_ID;
  if (notificationEnabled) config.notificationEnabled = { ...config.notificationEnabled, ...notificationEnabled };
  if (notificationPing) config.notificationPing = { ...config.notificationPing, ...notificationPing };
  if (notificationChannels) config.notificationChannels = { ...config.notificationChannels, ...notificationChannels };
  saveConfig(); 
  addLog('info',`Configuration updated`); 
  res.sendStatus(200); 
});

app.post('/commands/cooldown', requireAuth, (req, res) => {
  const { command, cooldownSeconds } = req.body || {};
  if (!command) return res.status(400).json({ success: false, error: 'Missing command' });
  const sec = parseInt(cooldownSeconds, 10);
  const ms = !isNaN(sec) && sec > 0 ? sec * 1000 : 0;
  config.commandCooldowns[command] = ms;
  saveConfig();
  addLog('info', `Command cooldown updated: ${command} = ${ms}ms`);
  res.json({ success: true });
});

app.post('/commands/pin', requireAuth, (req, res) => {
  const { command, pinned } = req.body || {};
  if (!command) return res.status(400).json({ success: false, error: 'Missing command' });
  config.commandPinned[command] = !!pinned;
  saveConfig();
  addLog('info', `Command ${command} pinned=${!!pinned}`);
  res.json({ success: true });
});

app.post('/commands/disable', requireAuth, (req, res) => {
  const { command, disabled } = req.body || {};
  if (!command) return res.status(400).json({ success: false, error: 'Missing command' });
  config.commandDisabled[command] = !!disabled;
  saveConfig();
  addLog('info', `Command ${command} disabled=${!!disabled}`);
  res.json({ success: true });
});

app.get('/role/info/:roleId', requireAuth, async (req, res) => {
  const { roleId } = req.params;
  if (!roleId || roleId === '') {
    return res.json({ name: null });
  }
  try {
    const discordGuild = client.guilds.cache.first();
    if (!discordGuild) {
      return res.json({ name: null });
    }
    const role = await discordGuild.roles.fetch(roleId);
    if (role) {
      res.json({ name: role.name, color: role.color, hexColor: role.hexColor });
    } else {
      res.json({ name: null });
    }
  } catch (err) {
    res.json({ name: null, error: err.message });
  }
});

app.get('/api/channels', requireAuth, async (req, res) => {
  try {
    const guild = client.guilds.cache.first();
    if (!guild) return res.json([]);
    const channels = Array.from(guild.channels.cache.values())
      .filter(c => c.isTextBased())
      .map(c => ({ id: c.id, name: c.name, type: c.type }))
      .sort((a, b) => a.name.localeCompare(b.name));
    res.json(channels);
  } catch (err) {
    addLog('error', 'Failed to fetch channels: ' + err.message);
    res.json([]);
  }
});

app.get('/channel/info/:channelId', requireAuth, async (req, res) => {
  const { channelId } = req.params;
  if (!channelId || channelId === '') {
    return res.json({ name: null });
  }
  try {
    const channel = await client.channels.fetch(channelId);
    if (channel) {
      res.json({ name: channel.name, id: channel.id, type: channel.type });
    } else {
      res.json({ name: null });
    }
  } catch (err) {
    res.json({ name: null, error: err.message });
  }
});

app.post('/settings/update', (req, res) => {
  const { key, value } = req.body;
  if (key in engagementSettings) {
    engagementSettings[key] = value;
    saveState();
    addLog('info', `Setting ${key} updated to ${value}`);
    res.sendStatus(200);
  } else {
    res.status(400).json({ error: 'Invalid setting' });
  }
});

// NEW: Suggestions endpoints
app.post('/suggestions/delete', (req, res) => {
  const { id } = req.body;
  if (id >= 0 && id < suggestions.length) {
    const deleted = suggestions[id];
    suggestions.splice(id, 1);
    saveState();
    addLog('info', `Suggestion deleted: "${deleted.suggestion}" from ${deleted.user}`);
    res.json({ success: true });
  } else {
    res.status(400).json({ error: 'Invalid suggestion ID' });
  }
});

app.post('/suggestions/upvote', (req, res) => {
  const { id } = req.body;
  if (id >= 0 && id < suggestions.length) {
    suggestions[id].upvotes = (suggestions[id].upvotes || 0) + 1;
    saveState();
    addLog('info', `Suggestion upvoted: "${suggestions[id].suggestion}"`);
    res.json({ success: true });
  } else {
    res.status(400).json({ error: 'Invalid suggestion ID' });
  }
});

app.post('/suggestions/status', (req, res) => {
  const { id, status } = req.body;
  if (id >= 0 && id < suggestions.length) {
    const validStatuses = ['Pending', 'In Progress', 'Completed', 'Rejected'];
    if (validStatuses.includes(status)) {
      suggestions[id].status = status;
      saveState();
      addLog('info', `Suggestion status updated: "${suggestions[id].suggestion}" â†’ ${status}`);
      res.json({ success: true });
    } else {
      res.status(400).json({ error: 'Invalid status' });
    }
  } else {
    res.status(400).json({ error: 'Invalid suggestion ID' });
  }
});

app.post('/suggestions/notes', (req, res) => {
  const { id, notes } = req.body;
  if (id >= 0 && id < suggestions.length) {
    suggestions[id].notes = notes;
    saveState();
    addLog('info', `Admin notes added to suggestion: "${suggestions[id].suggestion}"`);
    res.json({ success: true });
  } else {
    res.status(400).json({ error: 'Invalid suggestion ID' });
  }
});

app.post('/suggestions/cooldown', requireAuth, (req, res) => {
  const { minutes } = req.body;
  const cooldownMinutes = parseInt(minutes);
  
  if (isNaN(cooldownMinutes) || cooldownMinutes < 0) {
    return res.json({ success: false, error: 'Invalid cooldown value' });
  }
  
  dashboardSettings.suggestionCooldownMinutes = cooldownMinutes;
  saveState();
  addLog('info', `Suggestion cooldown updated to ${cooldownMinutes} minutes`);
  res.json({ success: true });
});

// NEW: Leveling edit endpoint
app.get('/channelname', async (req, res) => {
  const channelId = req.query.id;
  if (!channelId) return res.json({ name: null });
  try {
    const channel = await client.channels.fetch(channelId);
    res.json({ name: channel.name || null });
  } catch (err) {
    res.json({ name: null, error: err.message });
  }
});

app.get('/leveling/users', requireAuth, async (req, res) => {
  try {
    const userNames = {};
    const topUsers = Object.keys(leveling).slice(0, 100); // Get top 100
    
    for (const userId of topUsers) {
      try {
        const user = await client.users.fetch(userId);
        userNames[userId] = user.username;
      } catch (err) {
        userNames[userId] = `Unknown (${userId})`;
      }
    }
    
    res.json({ userNames });
  } catch (err) {
    res.json({ userNames: {}, error: err.message });
  }
});

app.post('/leveling/edit', (req, res) => {
  const { id, level, xp, xpMultiplier } = req.body;
  if (!leveling[id]) leveling[id] = { xp: 0, level: 0, lastMsg: 0 };
  leveling[id].level = Math.max(0, parseInt(level));
  leveling[id].xp = Math.max(0, parseInt(xp));
  leveling[id].xpMultiplier = Math.max(1, parseFloat(xpMultiplier) || 1);
  saveState();
  res.json({ success: true });
});

// Leveling config endpoint
app.post('/leveling/config', (req, res) => {
  const {
    xpPerMessageMin,
    xpPerMessageMax,
    messageCooldownMs,
    xpPerVoiceMinute,
    xpPerReaction,
    levelMilestones,
    roleRewards,
    xpMode,
    baseXp,
    xpIncrement,
    customXpPerLevel,
    prestigeThresholds,
    prestigeBenefits,
    prestigeMinLevel,
    prestigeXpCost,
    ignoreChannels,
    ignoreRoles,
    globalMultiplier,
    roleMultipliers,
    channelMultipliers,
    enableTimeBoost,
    timeBoostMultiplier,
    timeBoostStartDay,
    timeBoostEndDay,
    timeBoostStartHour,
    timeBoostEndHour,
    enableXpDecay,
    xpDecayDays,
    xpDecayPercent,
    customLevelUpMessage,
    milestonesOnly,
    dmOnLevelUp,
    levelUpColor,
    levelUpThumbnail,
    levelUpFooter
  } = req.body || {};

  const min = Number.isFinite(xpPerMessageMin) ? Math.max(0, xpPerMessageMin) : levelingConfig.xpPerMessageMin;
  const max = Number.isFinite(xpPerMessageMax) ? Math.max(min, xpPerMessageMax) : Math.max(min, levelingConfig.xpPerMessageMax);
  const cooldown = Number.isFinite(messageCooldownMs) ? Math.max(0, messageCooldownMs) : levelingConfig.messageCooldownMs;
  const voice = Number.isFinite(xpPerVoiceMinute) ? Math.max(0, xpPerVoiceMinute) : levelingConfig.xpPerVoiceMinute ?? 5;
  const reaction = Number.isFinite(xpPerReaction) ? Math.max(0, xpPerReaction) : levelingConfig.xpPerReaction ?? 2;
  const milestones = Array.isArray(levelMilestones)
    ? levelMilestones.filter(n => Number.isFinite(n) && n > 0).map(n => Math.floor(n)).sort((a, b) => a - b)
    : levelingConfig.levelMilestones || [10, 25, 50, 100];
  const rewards = roleRewards && typeof roleRewards === 'object' ? roleRewards : levelingConfig.roleRewards;
  const mode = xpMode === 'custom' ? 'custom' : 'increment';
  const base = Number.isFinite(baseXp) ? Math.max(0, baseXp) : (levelingConfig.baseXp ?? 100);
  const inc = Number.isFinite(xpIncrement) ? Math.max(0, xpIncrement) : (levelingConfig.xpIncrement ?? 50);
  const custom = (customXpPerLevel && typeof customXpPerLevel === 'object') ? customXpPerLevel : (levelingConfig.customXpPerLevel || {});
  const thresholds = (prestigeThresholds && typeof prestigeThresholds === 'object') ? prestigeThresholds : (levelingConfig.prestigeThresholds || {});
  const benefits = (prestigeBenefits && typeof prestigeBenefits === 'object') ? prestigeBenefits : (levelingConfig.prestigeBenefits || {});
  const minLvl = Number.isFinite(prestigeMinLevel) ? Math.max(0, prestigeMinLevel) : (levelingConfig.prestigeMinLevel ?? 50);
  const xpCost = Number.isFinite(prestigeXpCost) ? Math.max(0, prestigeXpCost) : (levelingConfig.prestigeXpCost ?? 0);
  const ignoreCh = Array.isArray(ignoreChannels) ? ignoreChannels : (levelingConfig.ignoreChannels || []);
  const ignoreRo = Array.isArray(ignoreRoles) ? ignoreRoles : (levelingConfig.ignoreRoles || []);
  const globMult = Number.isFinite(globalMultiplier) ? Math.max(1, globalMultiplier) : (levelingConfig.globalMultiplier ?? 1);
  const roleMult = (roleMultipliers && typeof roleMultipliers === 'object') ? roleMultipliers : (levelingConfig.roleMultipliers || {});
  const chanMult = (channelMultipliers && typeof channelMultipliers === 'object') ? channelMultipliers : (levelingConfig.channelMultipliers || {});
  
  levelingConfig = {
    xpPerMessageMin: min,
    xpPerMessageMax: max,
    messageCooldownMs: cooldown,
    xpPerVoiceMinute: voice,
    xpPerReaction: reaction,
    levelMilestones: milestones,
    roleRewards: rewards,
    xpMode: mode,
    baseXp: base,
    xpIncrement: inc,
    customXpPerLevel: custom,
    prestigeThresholds: thresholds,
    prestigeBenefits: benefits,
    prestigeMinLevel: minLvl,
    prestigeXpCost: xpCost,
    ignoreChannels: ignoreCh,
    ignoreRoles: ignoreRo,
    globalMultiplier: globMult,
    roleMultipliers: roleMult,
    channelMultipliers: chanMult,
    enableTimeBoost: enableTimeBoost === true || enableTimeBoost === 'true',
    timeBoostMultiplier: Number.isFinite(timeBoostMultiplier) ? Math.max(1, timeBoostMultiplier) : 2,
    timeBoostStartDay: Number.isFinite(timeBoostStartDay) ? Math.max(0, Math.min(6, timeBoostStartDay)) : 5,
    timeBoostEndDay: Number.isFinite(timeBoostEndDay) ? Math.max(0, Math.min(6, timeBoostEndDay)) : 0,
    timeBoostStartHour: Number.isFinite(timeBoostStartHour) ? Math.max(0, Math.min(23, timeBoostStartHour)) : 0,
    timeBoostEndHour: Number.isFinite(timeBoostEndHour) ? Math.max(0, Math.min(23, timeBoostEndHour)) : 23,
    enableXpDecay: enableXpDecay === true || enableXpDecay === 'true',
    xpDecayDays: Number.isFinite(xpDecayDays) ? Math.max(1, xpDecayDays) : 14,
    xpDecayPercent: Number.isFinite(xpDecayPercent) ? Math.max(0, Math.min(100, xpDecayPercent)) : 5,
    customLevelUpMessage: customLevelUpMessage || levelingConfig.customLevelUpMessage || 'ðŸŽ‰ {mention} just reached Level {level}!',
    milestonesOnly: milestonesOnly === true || milestonesOnly === 'true' || false,
    dmOnLevelUp: dmOnLevelUp === true || dmOnLevelUp === 'true' || false,
    levelUpColor: levelUpColor || levelingConfig.levelUpColor || '#9146ff',
    levelUpThumbnail: levelUpThumbnail || levelingConfig.levelUpThumbnail || '',
    levelUpFooter: levelUpFooter || levelingConfig.levelUpFooter || 'Keep grinding!',
    xpMultiplier: levelingConfig.xpMultiplier || 1,
    multiplierEndTime: levelingConfig.multiplierEndTime || null
  };

  saveState();
  res.json({ success: true, levelingConfig });
});

app.post('/leveling/import-csv', requireAuth, requireTier('moderator'), (req, res) => {
  const csv = typeof req.body?.csv === 'string' ? req.body.csv : '';
  if (!csv.trim()) {
    return res.status(400).json({ success: false, error: 'CSV content is empty' });
  }

  const parseCsvLine = (line) => {
    const cells = [];
    let current = '';
    let inQuotes = false;
    for (let idx = 0; idx < line.length; idx++) {
      const char = line[idx];
      if (char === '"') {
        if (inQuotes && line[idx + 1] === '"') {
          current += '"';
          idx++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (char === ',' && !inQuotes) {
        cells.push(current);
        current = '';
      } else {
        current += char;
      }
    }
    cells.push(current);
    return cells;
  };

  const normalizeName = (value) => String(value || '').trim().toLowerCase();
  const nameToIds = new Map();
  const upsertName = (name, userId) => {
    const key = normalizeName(name);
    if (!key) return;
    if (!nameToIds.has(key)) nameToIds.set(key, new Set());
    nameToIds.get(key).add(userId);
  };

  for (const [userId, name] of Object.entries(userNameCache || {})) {
    upsertName(name, userId);
  }
  for (const userId of Object.keys(leveling || {})) {
    upsertName(userNameCache[userId] || userId, userId);
  }

  const lines = csv
    .split(/\r?\n/)
    .map(line => line.trim())
    .filter(Boolean);

  let imported = 0;
  let skipped = 0;

  for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
    const rawLine = lines[lineIndex];
    const cols = parseCsvLine(rawLine).map(c => String(c || '').trim());
    if (cols.length < 4) {
      skipped++;
      continue;
    }

    const [nameRaw, levelRaw, xpRaw, prestigeRaw] = cols;
    if (
      lineIndex === 0 &&
      /name|user/i.test(nameRaw) &&
      /lvl|level/i.test(levelRaw) &&
      /xp/i.test(xpRaw)
    ) {
      continue;
    }

    const level = parseInt(levelRaw, 10);
    const xp = parseInt(xpRaw, 10);
    const prestigeLevel = parseInt(prestigeRaw, 10);
    if (!Number.isFinite(level) || !Number.isFinite(xp) || !Number.isFinite(prestigeLevel)) {
      skipped++;
      continue;
    }

    let userId = null;
    if (/^\d{15,22}$/.test(nameRaw)) {
      userId = nameRaw;
    } else {
      const matches = nameToIds.get(normalizeName(nameRaw));
      if (matches && matches.size === 1) {
        userId = Array.from(matches)[0];
      }
    }

    if (!userId) {
      skipped++;
      continue;
    }

    if (!leveling[userId]) leveling[userId] = { xp: 0, level: 0, lastMsg: 0 };
    leveling[userId].level = Math.max(0, level);
    leveling[userId].xp = Math.max(0, xp);
    leveling[userId].lastMsg = Date.now();
    leveling[userId].xpMultiplier = Math.max(1, parseFloat(leveling[userId].xpMultiplier) || 1);

    if (!prestige) prestige = {};
    prestige[userId] = Math.max(0, prestigeLevel);

    if (!userNameCache[userId] && !/^\d{15,22}$/.test(nameRaw)) {
      userNameCache[userId] = nameRaw;
    }

    imported++;
  }

  saveState();
  addLog('info', `Leveling CSV import completed: ${imported} imported, ${skipped} skipped`);
  return res.json({ success: true, imported, skipped });
});

// NEW: Prestige endpoints
app.post('/leveling/prestige', requireAuth, (req, res) => {
  const { userId, prestigeLevel } = req.body || {};
  
  if (!userId || prestigeLevel === undefined) {
    return res.status(400).json({ error: 'Missing userId or prestigeLevel' });
  }
  
  if (!prestige) prestige = {};
  prestige[userId] = Math.max(0, parseInt(prestigeLevel));
  
  if (!leveling[userId]) leveling[userId] = { xp: 0, level: 0, lastMsg: 0 };
  leveling[userId].level = 0;
  leveling[userId].xp = 0;
  
  // Add to prestige history
  if (!prestigeHistory) prestigeHistory = [];
  prestigeHistory.push({
    userId: userId,
    username: userNameCache[userId] || userId,
    prestigeLevel: Math.max(0, parseInt(prestigeLevel)),
    timestamp: Date.now()
  });
  // Keep only last 100 entries
  if (prestigeHistory.length > 100) prestigeHistory = prestigeHistory.slice(-100);
  
  saveState();
  addLog('info', `User ${userId} granted prestige level ${prestigeLevel}`);
  res.json({ success: true });
});

app.post('/leveling/reset-level', requireAuth, (req, res) => {
  const { userId } = req.body || {};
  
  if (!userId) {
    return res.status(400).json({ error: 'Missing userId' });
  }
  
  if (!leveling[userId]) leveling[userId] = { xp: 0, level: 0, lastMsg: 0 };
  leveling[userId].level = 0;
  leveling[userId].xp = 0;
  
  saveState();
  addLog('info', `User ${userId} level reset to 0`);
  res.json({ success: true });
});

app.get('/api/leveling/prestige-history', requireAuth, (_req, res) => {
  res.json(prestigeHistory ? [...prestigeHistory].reverse().slice(0, 50) : []);
});

// NEW: Dashboard level-up channel setting
app.post('/dashboard/levelupchannel', requireAuth, (req, res) => {
  const { levelUpChannelId, levelUpPingPlayer } = req.body || {};
  
  dashboardSettings.levelUpChannelId = levelUpChannelId || null;
  dashboardSettings.levelUpPingPlayer = levelUpPingPlayer !== undefined ? levelUpPingPlayer : true;
  saveState();
  addLog('info', `Level-up channel set to: ${levelUpChannelId || 'channel of origin'}, ping player: ${dashboardSettings.levelUpPingPlayer}`);
  res.json({ success: true, levelUpChannelId: dashboardSettings.levelUpChannelId, levelUpPingPlayer: dashboardSettings.levelUpPingPlayer });
});

// NEW: Notification routes
app.get('/notifications', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('notifications', req)));
app.post('/notifications/save', requireAuth, (req, res) => {
  const { filters } = req.body;
  notificationFilters = Array.isArray(filters) ? filters : [];
  saveState();
  addLog('info', 'Notification filters updated');
  res.json({ success: true });
});

// NEW: Custom Commands routes
app.get('/customcmds', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('customcmds', req)));
app.post('/customcmd/add', requireAuth, (req, res) => {
  const {
    name,
    names,
    response,
    imageUrl,
    autoDeleteAfterUses,
    autoDeleteDelaySeconds,
    cooldownSeconds,
    allowedRoleIds,
    allowedChannelIds,
    category,
    tags,
    sendAsEmbed
  } = req.body;
  if ((!name && !names) || !response) return res.status(400).json({ error: 'Missing fields' });

  const deleteAfterUses = parseInt(autoDeleteAfterUses, 10);
  const deleteDelaySec = parseInt(autoDeleteDelaySeconds, 10);
  const cooldownSec = parseInt(cooldownSeconds, 10);
  const autoDeleteAfterUsesValue = !isNaN(deleteAfterUses) && deleteAfterUses > 0 ? deleteAfterUses : null;
  const autoDeleteDelayMsValue = !isNaN(deleteDelaySec) && deleteDelaySec > 0 ? deleteDelaySec * 1000 : null;
  const cooldownMsValue = !isNaN(cooldownSec) && cooldownSec > 0 ? cooldownSec * 1000 : null;

  const rawNames = Array.isArray(names)
    ? names
    : (typeof name === 'string' ? name.split(/[,\n]+/) : []);

  const normalized = rawNames
    .map(n => (typeof n === 'string' ? n.trim() : ''))
    .filter(Boolean)
    .map(n => (n.startsWith('!') ? n.slice(1) : n).toLowerCase());

  if (normalized.length === 0) return res.status(400).json({ error: 'No valid command names' });

  const skipped = [];
  let added = 0;

  normalized.forEach(cmdName => {
    if (customCommands.find(c => c.name === cmdName)) {
      skipped.push('!' + cmdName);
      return;
    }

    customCommands.push({
      name: cmdName,
      response,
      imageUrl: imageUrl || '',
      uses: 0,
      paused: false,
      autoDeleteAfterUses: autoDeleteAfterUsesValue,
      autoDeleteDelayMs: autoDeleteDelayMsValue,
      cooldownMs: cooldownMsValue,
      allowedRoleIds: Array.isArray(allowedRoleIds) ? allowedRoleIds : [],
      allowedChannelIds: Array.isArray(allowedChannelIds) ? allowedChannelIds : [],
      category: (category || '').trim(),
      tags: Array.isArray(tags) ? tags : (typeof tags === 'string' ? tags.split(',').map(t => t.trim()).filter(Boolean) : []),
      sendAsEmbed: sendAsEmbed !== false,
      createdAt: new Date().toISOString()
    });
    added += 1;
    addLog('info', `Custom command added: !${cmdName}`);
  });

  saveState();
  res.json({ success: true, added, skipped });
});

app.post('/customcmd/toggle', requireAuth, (req, res) => {
  const { id } = req.body;
  if (typeof id !== 'number' || id < 0 || id >= customCommands.length) {
    return res.status(400).json({ error: 'Invalid ID' });
  }
  const cmd = customCommands[id];
  cmd.paused = !cmd.paused;
  saveState();
  addLog('info', `Custom command ${cmd.paused ? 'paused' : 'unpaused'}: ${cmd.name}`);
  res.json({ success: true, paused: cmd.paused });
});

app.get('/customcmd/get/:id', requireAuth, (req, res) => {
  const id = parseInt(req.params.id);
  if (isNaN(id) || id < 0 || id >= customCommands.length) {
    return res.status(400).json({ error: 'Invalid ID' });
  }
  const cmd = customCommands[id];
  res.json({ 
    command: {
      name: cmd.name,
      response: cmd.response,
      imageUrl: cmd.imageUrl || '',
      uses: cmd.uses,
      paused: cmd.paused,
      autoDeleteAfterUses: cmd.autoDeleteAfterUses || null,
      autoDeleteDelayMs: cmd.autoDeleteDelayMs || null,
      cooldownMs: cmd.cooldownMs || null,
      allowedRoleIds: cmd.allowedRoleIds || [],
      allowedChannelIds: cmd.allowedChannelIds || [],
      category: cmd.category || '',
      tags: cmd.tags || [],
      sendAsEmbed: cmd.sendAsEmbed !== false
    },
    usageHistory: (cmd.usageHistory || []).slice(0, 5)
  });
});

app.post('/customcmd/update', requireAuth, (req, res) => {
  const {
    index,
    name,
    response,
    imageUrl,
    autoDeleteAfterUses,
    autoDeleteDelaySeconds,
    cooldownSeconds,
    allowedRoleIds,
    allowedChannelIds,
    category,
    tags,
    sendAsEmbed
  } = req.body;
  if (typeof index !== 'number' || index < 0 || index >= customCommands.length) {
    return res.status(400).json({ error: 'Invalid index' });
  }
  if (!name || !response) {
    return res.status(400).json({ error: 'Missing name or response' });
  }

  const cmd = customCommands[index];
  const oldName = cmd.name;
  
  // Normalize the name (remove ! and make lowercase)
  const normalized = (name.startsWith('!') ? name.slice(1) : name).toLowerCase();
  
  // Check if new name conflicts with other commands (excluding the current one)
  const conflict = customCommands.find((c, i) => i !== index && c.name === normalized);
  if (conflict) {
    return res.status(400).json({ error: 'Command name already exists' });
  }

  cmd.name = normalized;
  cmd.response = response;
  cmd.imageUrl = imageUrl || '';
  const deleteAfterUses = parseInt(autoDeleteAfterUses, 10);
  const deleteDelaySec = parseInt(autoDeleteDelaySeconds, 10);
  const cooldownSec = parseInt(cooldownSeconds, 10);
  cmd.autoDeleteAfterUses = !isNaN(deleteAfterUses) && deleteAfterUses > 0 ? deleteAfterUses : null;
  cmd.autoDeleteDelayMs = !isNaN(deleteDelaySec) && deleteDelaySec > 0 ? deleteDelaySec * 1000 : null;
  cmd.cooldownMs = !isNaN(cooldownSec) && cooldownSec > 0 ? cooldownSec * 1000 : null;
  cmd.allowedRoleIds = Array.isArray(allowedRoleIds) ? allowedRoleIds : [];
  cmd.allowedChannelIds = Array.isArray(allowedChannelIds) ? allowedChannelIds : [];
  cmd.category = (category || '').trim();
  cmd.tags = Array.isArray(tags) ? tags : (typeof tags === 'string' ? tags.split(',').map(t => t.trim()).filter(Boolean) : []);
  cmd.sendAsEmbed = sendAsEmbed !== false;
  saveState();
  addLog('info', `Custom command updated: !${oldName} â†’ !${normalized}`);
  res.json({ success: true });
});

app.post('/customcmd/delete', (req, res) => {
  const { id } = req.body;
  if (id >= 0 && id < customCommands.length) {
    const cmd = customCommands[id];
    customCommands.splice(id, 1);
    saveState();
    addLog('info', `Custom command deleted: ${cmd.name}`);
    res.json({ success: true });
  } else {
    res.status(400).json({ error: 'Invalid ID' });
  }
});

// Image upload endpoint
app.post('/upload/image', requireAuth, upload.single('image'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ success: false, error: 'No file uploaded' });
  }
  
  // Use relative path so images survive hostname changes
  const url = `/uploads/${req.file.filename}`;
  
  res.json({ success: true, url: url });
});

// NEW: Giveaway routes
app.get('/events', requireAuth, requireTier('moderator'), (req,res)=>{ const tab = req.query.tab || 'events-giveaways'; res.send(renderPage(tab, req)); });
app.get('/giveaways', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('events-giveaways', req)));
app.get('/polls', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('events-polls', req)));
app.get('/reminders', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('events-reminders', req)));
app.get('/discord/user/:id', requireAuth, async (req, res) => {
  const userId = req.params.id;
  const guildId = process.env.GUILD_ID || process.env.DISCORD_GUILD_ID;
  if (!guildId) return res.status(400).json({ error: 'GUILD_ID not set' });
  try {
    const guild = await client.guilds.fetch(guildId);
    const member = await guild.members.fetch(userId);
    return res.json({ id: userId, username: member.user.username, displayName: member.displayName });
  } catch (err) {
    return res.status(404).json({ error: 'User not found' });
  }
});
app.post('/giveaway/start', requireAuth, async (req, res) => {
  const {
    prize,
    durationMinutes,
    channelId,
    pingRoleId,
    allowedRoleIds,
    excludedUserIds,
    imageUrl,
    embedColor,
    tag,
    winnersCount,
    minAccountAgeDays,
    minLevel,
    minXp,
    createdBy,
    excludePreviousWinners,
    excludeBots,
    excludeStaffRoleIds
  } = req.body;
  if (!prize || !durationMinutes) return res.status(400).json({ error: 'Missing fields' });

  const targetChannelId = channelId || process.env.DISCORD_CHANNEL_ID;
  if (!targetChannelId) {
    return res.status(400).json({ error: 'DISCORD_CHANNEL_ID not set' });
  }

  try {
    const channel = await client.channels.fetch(targetChannelId);
    if (!channel || !channel.send) {
      return res.status(400).json({ error: 'Giveaway channel not found or not sendable' });
    }

    const giveawayId = `giveaway_${Date.now()}`;
    const endsAt = Date.now() + (durationMinutes * 60 * 1000);
    const resolvedWinnersCount = Math.max(1, parseInt(winnersCount || 1, 10));

    const eligibleRolesText = Array.isArray(allowedRoleIds) && allowedRoleIds.length > 0
      ? allowedRoleIds.map(r => `<@&${r}>`).join(', ')
      : 'Anyone';

    const resolvedColor = (embedColor || config.giveawayDefaultColor || '').replace('#', '').trim();
    const parsedColor = resolvedColor ? parseInt(resolvedColor, 16) : NaN;
    const embedColorInt = Number.isFinite(parsedColor) ? parsedColor : 0xFF6B9D;

    const embed = new EmbedBuilder()
      .setColor(embedColorInt)
      .setTitle('ðŸŽ‰ GIVEAWAY ðŸŽ‰')
      .setDescription(`**Prize:** ${prize}\n**Winners:** ${resolvedWinnersCount}\n**Eligible:** ${eligibleRolesText}\n**Ends:** <t:${Math.floor(endsAt / 1000)}:R>`) 
      .setFooter({ text: `${(allowedRoleIds && allowedRoleIds.length > 0) ? 'Eligible roles only' : 'React with ðŸŽ‰ to enter'} | ID: ${giveawayId}` })
      .setTimestamp(endsAt);

    if (imageUrl) {
      embed.setImage(imageUrl);
    }

    const contentPing = pingRoleId ? `<@&${pingRoleId}>` : undefined;
    const msg = await channel.send({ content: contentPing, embeds: [embed] });
    if (!allowedRoleIds || allowedRoleIds.length === 0) {
      await msg.react('ðŸŽ‰');
    }

    giveaways.push({
      id: giveawayId,
      messageId: msg.id,
      channelId: targetChannelId,
      prize,
      winners: resolvedWinnersCount,
      endTime: endsAt,
      active: true,
      createdBy: 'dashboard',
      entries: [],
      participants: [],
      pingRoleId: pingRoleId || null,
      duration: durationMinutes * 60 * 1000,
      allowedRoleIds: Array.isArray(allowedRoleIds) ? allowedRoleIds : [],
      excludedUserIds: Array.isArray(excludedUserIds) ? excludedUserIds : [],
      imageUrl: imageUrl || null,
      embedColor: embedColor || null,
      tag: tag || null,
      minAccountAgeDays: Number.isFinite(minAccountAgeDays) ? minAccountAgeDays : Number(minAccountAgeDays) || 0,
      minLevel: Number.isFinite(minLevel) ? minLevel : Number(minLevel) || 0,
      minXp: Number.isFinite(minXp) ? minXp : Number(minXp) || 0,
      createdBy: createdBy || 'Dashboard',
      excludePreviousWinners: !!excludePreviousWinners,
      excludeBots: excludeBots !== false,
      excludeStaffRoleIds: Array.isArray(excludeStaffRoleIds) ? excludeStaffRoleIds : []
    });
    saveState();

    if (config.giveawayLogChannelId) {
      try {
        const logChannel = await client.channels.fetch(config.giveawayLogChannelId);
        if (logChannel && logChannel.send) {
          await logChannel.send({ embeds: [new EmbedBuilder()
            .setColor(0x57F287)
            .setTitle('ðŸŽ‰ Giveaway Started')
            .setDescription(`**Prize:** ${prize}\n**ID:** ${giveawayId}\n**Created By:** ${createdBy || 'Dashboard'}`)
            .setTimestamp()
          ] });
        }
      } catch {}
    }

    addLog('info', `Giveaway started: ${prize} (${winnersCount} winners, ${durationMinutes}min)`);
    return res.json({ success: true });
  } catch (err) {
    addLog('error', 'Failed to start giveaway from dashboard: ' + err.message);
    return res.status(500).json({ error: 'Failed to post giveaway to Discord', details: err.message });
  }
});

app.post('/giveaway/end', async (req, res) => {
  const { id } = req.body;
  if (!id) return res.status(400).json({ error: 'Giveaway ID required' });
  const giveaway = giveaways.find(g => g.id === id && g.active);
  if (!giveaway) return res.status(404).json({ error: 'Giveaway not found or already ended' });
  try {
    await endGiveaway(giveaway);
    return res.json({ success: true });
  } catch (err) {
    return res.status(500).json({ error: 'Failed to end giveaway' });
  }
});

app.post('/giveaway/reroll', async (req, res) => {
  const { id } = req.body;
  if (!id) return res.status(400).json({ error: 'Giveaway ID required' });
  const giveaway = giveaways.find(g => g.id === id);
  if (!giveaway) return res.status(404).json({ error: 'Giveaway not found' });
  try {
    const channel = await client.channels.fetch(giveaway.channelId);
    let participants = [];
    const allowedRoles = Array.isArray(giveaway.allowedRoleIds) ? giveaway.allowedRoleIds : [];
    if (allowedRoles.length > 0) {
      participants = await getRoleBasedGiveawayParticipants(giveaway);
    } else {
      const msg = await channel.messages.fetch(giveaway.messageId);
      const reaction = msg.reactions.cache.get('ðŸŽ‰');
      if (!reaction) return res.status(400).json({ error: 'No participants found' });
      const users = await reaction.users.fetch();
      participants = users.filter(u => !u.bot).map(u => u.id);
    }
    giveaway.entryCount = participants.length;
    const eligible = await getEligibleGiveawayParticipants(giveaway, participants);

    // Keep entries snapshot for the latest ended giveaway only
    giveaways.forEach(g => {
      if (g.id !== giveaway.id) {
        delete g.entrySnapshot;
        delete g.entrySnapshotAt;
      }
    });
    giveaway.entrySnapshot = eligible.slice();
    giveaway.entrySnapshotAt = Date.now();
    if (eligible.length === 0) return res.status(400).json({ error: 'No valid participants' });
    const winnerCount = Math.min(giveaway.winners || 1, eligible.length);
    const shuffled = eligible.sort(() => Math.random() - 0.5);
    const rerollWinners = shuffled.slice(0, winnerCount);
    const winnerMentions = rerollWinners.map(id => `<@${id}>`).join(', ');
    await channel.send({ embeds: [new EmbedBuilder().setColor(0x57F287).setTitle('ðŸŽ‰ Giveaway Rerolled!').setDescription(`**Prize:** ${giveaway.prize}\n**New Winner(s):** ${winnerMentions}`)] });
    addLog('info', `Giveaway rerolled: ${giveaway.id}`);
    return res.json({ success: true });
  } catch (err) {
    addLog('error', `Giveaway reroll error: ${err.message}`);
    return res.status(500).json({ error: 'Failed to reroll giveaway' });
  }
});

app.post('/giveaway/exclusions/remove', requireAuth, (req, res) => {
  const { id, userId } = req.body;
  if (!id || !userId) return res.status(400).json({ error: 'Giveaway ID and User ID required' });
  const giveaway = giveaways.find(g => g.id === id);
  if (!giveaway) return res.status(404).json({ error: 'Giveaway not found' });

  if (!Array.isArray(giveaway.excludedUserIds)) giveaway.excludedUserIds = [];
  const before = giveaway.excludedUserIds.length;
  giveaway.excludedUserIds = giveaway.excludedUserIds.filter(u => u !== userId);
  const after = giveaway.excludedUserIds.length;

  saveState();
  return res.json({ success: true, removed: before - after, remaining: after });
});

app.get('/giveaway/info/:id', requireAuth, async (req, res) => {
  const { id } = req.params;
  const giveaway = giveaways.find(g => g.id === id);
  if (!giveaway) return res.status(404).json(null);
  
  // Add excluded user names
  const excludedUsers = [];
  if (Array.isArray(giveaway.excludedUserIds) && giveaway.excludedUserIds.length > 0) {
    const guildId = process.env.GUILD_ID || process.env.DISCORD_GUILD_ID;
    const guild = guildId ? client.guilds.cache.get(guildId) : client.guilds.cache.first();
    
    for (const userId of giveaway.excludedUserIds) {
      try {
        const member = guild.members.cache.get(userId);
        if (member) {
          excludedUsers.push({
            id: userId,
            name: member.displayName || member.user.username
          });
        } else {
          excludedUsers.push({
            id: userId,
            name: 'Unknown User'
          });
        }
      } catch (err) {
        excludedUsers.push({
          id: userId,
          name: 'Unknown User'
        });
      }
    }
  }
  
  res.json({ ...giveaway, excludedUsers });
});

app.get('/giveaway/entries/:id', requireAuth, async (req, res) => {
  const { id } = req.params;
  const giveaway = giveaways.find(g => g.id === id);
  if (!giveaway) return res.status(404).json({ error: 'Giveaway not found' });

  const now = Date.now();
  if (giveaway._entriesCache && (now - giveaway._entriesCache.ts) < 30000) {
    return res.json({ entries: giveaway._entriesCache.entries || [] });
  }

  if (!giveaway.active && Array.isArray(giveaway.entrySnapshot)) {
    return res.json({ entries: giveaway.entrySnapshot.map(id => ({ id, name: id })) });
  }

  try {
    const participants = await getGiveawayParticipants(giveaway);
    const eligible = await getEligibleGiveawayParticipants(giveaway, participants);
    const guildId = process.env.GUILD_ID || process.env.DISCORD_GUILD_ID;
    const guild = guildId ? await client.guilds.fetch(guildId) : client.guilds.cache.first();
    const entries = [];

    for (const userId of eligible) {
      try {
        const member = guild.members.cache.get(userId) || await guild.members.fetch(userId);
        entries.push({
          id: userId,
          name: member?.displayName || member?.user?.username || 'Unknown'
        });
      } catch {
        entries.push({ id: userId, name: 'Unknown' });
      }
    }

    giveaway.entryCount = entries.length;
    giveaway._entriesCache = { ts: now, entries };
    return res.json({ entries });
  } catch (err) {
    return res.status(500).json({ error: 'Failed to load entries' });
  }
});

app.post('/giveaway/ping-winners', requireAuth, async (req, res) => {
  const { id } = req.body;
  const giveaway = giveaways.find(g => g.id === id);
  if (!giveaway) return res.status(404).json({ error: 'Giveaway not found' });
  if (!Array.isArray(giveaway.winners) || giveaway.winners.length === 0) {
    return res.status(400).json({ error: 'No winners found' });
  }

  try {
    const channel = await client.channels.fetch(giveaway.channelId);
    const mentions = giveaway.winners.map(w => `<@${w}>`).join(', ');
    const winText = `ðŸŽ‰ ${mentions} youâ€™ve won **${giveaway.prize}**!`;
    await channel.send({ content: winText, embeds: [new EmbedBuilder().setColor(0x57F287).setTitle('ðŸŽ‰ Giveaway Winners').setDescription(`**Prize:** ${giveaway.prize}\n**Winner(s):** ${mentions}`)] });

    if (config.giveawayLogChannelId) {
      try {
        const logChannel = await client.channels.fetch(config.giveawayLogChannelId);
        if (logChannel && logChannel.send) {
          await logChannel.send({ embeds: [new EmbedBuilder()
            .setColor(0x57F287)
            .setTitle('ðŸ“£ Winners Pinged')
            .setDescription(`**Prize:** ${giveaway.prize}\n**Winners:** ${mentions}\n**ID:** ${giveaway.id}`)
            .setTimestamp()
          ] });
        }
      } catch {}
    }
    return res.json({ success: true });
  } catch (err) {
    return res.status(500).json({ error: 'Failed to ping winners' });
  }
});

app.post('/giveaway/archive', requireAuth, (req, res) => {
  const { id } = req.body;
  const giveaway = giveaways.find(g => g.id === id);
  if (!giveaway) return res.status(404).json({ error: 'Giveaway not found' });
  giveaway.archived = true;
  giveaway.active = false;
  saveState();
  return res.json({ success: true });
});

app.post('/giveaway/pause', requireAuth, (req, res) => {
  const { id } = req.body;
  const giveaway = giveaways.find(g => g.id === id);
  if (!giveaway) return res.status(404).json({ error: 'Giveaway not found' });
  if (!giveaway.active || giveaway.paused) return res.status(400).json({ error: 'Giveaway not active' });

  giveaway.paused = true;
  giveaway.pauseRemainingMs = Math.max(0, giveaway.endTime - Date.now());
  giveaway.pausedAt = Date.now();
  saveState();

  if (config.giveawayLogChannelId) {
    client.channels.fetch(config.giveawayLogChannelId)
      .then(ch => ch?.send && ch.send({ embeds: [new EmbedBuilder()
        .setColor(0xFEE75C)
        .setTitle('â¸ï¸ Giveaway Paused')
        .setDescription(`**Prize:** ${giveaway.prize}\n**ID:** ${giveaway.id}`)
        .setTimestamp()
      ] }))
      .catch(() => {});
  }

  return res.json({ success: true });
});

app.post('/giveaway/resume', requireAuth, (req, res) => {
  const { id } = req.body;
  const giveaway = giveaways.find(g => g.id === id);
  if (!giveaway) return res.status(404).json({ error: 'Giveaway not found' });
  if (!giveaway.paused) return res.status(400).json({ error: 'Giveaway not paused' });

  const remaining = Number(giveaway.pauseRemainingMs) || 0;
  if (remaining <= 0) {
    giveaway.paused = false;
    saveState();
    return res.status(400).json({ error: 'Giveaway already expired' });
  }

  giveaway.paused = false;
  giveaway.endTime = Date.now() + remaining;
  giveaway.pauseRemainingMs = null;
  giveaway.pausedAt = null;
  saveState();

  if (config.giveawayLogChannelId) {
    client.channels.fetch(config.giveawayLogChannelId)
      .then(ch => ch?.send && ch.send({ embeds: [new EmbedBuilder()
        .setColor(0x57F287)
        .setTitle('â–¶ï¸ Giveaway Resumed')
        .setDescription(`**Prize:** ${giveaway.prize}\n**ID:** ${giveaway.id}`)
        .setTimestamp()
      ] }))
      .catch(() => {});
  }

  return res.json({ success: true });
});

app.post('/giveaway/delete', requireAuth, async (req, res) => {
  const { id } = req.body;
  const idx = giveaways.findIndex(g => g.id === id);
  if (idx === -1) return res.status(404).json({ error: 'Giveaway not found' });
  const giveaway = giveaways[idx];
  try {
    if (giveaway.channelId && giveaway.messageId) {
      const channel = await client.channels.fetch(giveaway.channelId);
      const msg = await channel.messages.fetch(giveaway.messageId);
      if (msg) await msg.delete();
    }
  } catch {}
  giveaways.splice(idx, 1);
  saveState();
  return res.json({ success: true });
});

app.post('/giveaway/settings', requireAuth, (req, res) => {
  const { giveawayClaimContact, giveawayDefaultColor, giveawayLogChannelId } = req.body || {};
  config.giveawayClaimContact = (giveawayClaimContact || '').trim();
  config.giveawayDefaultColor = (giveawayDefaultColor || '').trim();
  config.giveawayLogChannelId = (giveawayLogChannelId || '').trim();
  saveConfig();
  return res.json({ success: true });
});

app.get('/giveaway/templates', requireAuth, (req, res) => {
  res.json({ templates: Array.isArray(config.giveawayTemplates) ? config.giveawayTemplates : [] });
});

app.post('/giveaway/templates/save', requireAuth, (req, res) => {
  const { name, template } = req.body || {};
  const trimmed = (name || '').trim();
  if (!trimmed) return res.status(400).json({ error: 'Template name required' });
  if (!Array.isArray(config.giveawayTemplates)) config.giveawayTemplates = [];
  config.giveawayTemplates = config.giveawayTemplates.filter(t => t.name !== trimmed);
  config.giveawayTemplates.push({ name: trimmed, template: template || {} });
  saveConfig();
  return res.json({ success: true });
});

app.post('/giveaway/templates/delete', requireAuth, (req, res) => {
  const { name } = req.body || {};
  const trimmed = (name || '').trim();
  if (!trimmed) return res.status(400).json({ error: 'Template name required' });
  if (!Array.isArray(config.giveawayTemplates)) config.giveawayTemplates = [];
  config.giveawayTemplates = config.giveawayTemplates.filter(t => t.name !== trimmed);
  saveConfig();
  return res.json({ success: true });
});

app.get('/giveaway/export-winners', requireAuth, async (_req, res) => {
  const ended = giveaways.filter(g => Array.isArray(g.winners) && g.winners.length > 0);
  const rows = ['prize,createdBy,winnerIds,winnerNames'];
  for (const g of ended) {
    const prize = String(g.prize || '').replace(/"/g, '""');
    const createdBy = String(g.createdBy || 'Dashboard').replace(/"/g, '""');
    const winnerIds = g.winners.map(w => w).join(' ');
    const winnerNames = [];
    for (const id of g.winners) {
      try {
        const name = await fetchUserName(id);
        winnerNames.push(name);
      } catch {
        winnerNames.push(id);
      }
    }
    const names = winnerNames.join(' | ').replace(/"/g, '""');
    rows.push(`"${prize}","${createdBy}","${winnerIds}","${names}"`);
  }
  res.setHeader('Content-Type', 'text/csv');
  res.setHeader('Content-Disposition', 'attachment; filename="giveaway_winners.csv"');
  res.send(rows.join('\n'));
});

app.post('/giveaway/preview-members', requireAuth, async (req, res) => {
  const { roleIds, excludeIds, excludePreviousWinners, excludeBots, excludeStaffRoleIds, minAccountAgeDays, minLevel, minXp } = req.body;
  
  if (!Array.isArray(roleIds) || roleIds.length === 0) {
    return res.json({ members: [] });
  }
  
  try {
    const guildId = process.env.GUILD_ID || process.env.DISCORD_GUILD_ID;
    const guild = guildId ? client.guilds.cache.get(guildId) : client.guilds.cache.first();
    
    if (!guild) {
      return res.status(500).json({ error: 'Guild not found' });
    }
    
    const excludes = Array.isArray(excludeIds) ? excludeIds : [];
    const staffRoleSet = new Set(Array.isArray(excludeStaffRoleIds) ? excludeStaffRoleIds : []);
    const previousWinnersSet = excludePreviousWinners ? new Set(getAllGiveawayWinnerIds()) : new Set();
    const roleSet = new Set(roleIds);
    const members = [];

    // Use cached members only (no fetch to avoid rate limiting)
    guild.members.cache.forEach(member => {
      if (excludeBots !== false && member.user.bot) return;
      if (previousWinnersSet.has(member.id)) return;
      if (excludes.includes(member.id)) return;
      if (staffRoleSet.size > 0 && member.roles.cache.some(r => staffRoleSet.has(r.id))) return;
      if (minAccountAgeDays > 0) {
        const ageMs = Date.now() - member.user.createdTimestamp;
        const ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));
        if (ageDays < minAccountAgeDays) return;
      }
      if (minLevel > 0 || minXp > 0) {
        const data = leveling[member.id] || { level: 0, xp: 0 };
        if (minLevel > 0 && Number(data.level) < minLevel) return;
        if (minXp > 0 && Number(data.xp) < minXp) return;
      }

      const hasRole = member.roles.cache.some(r => roleSet.has(r.id));
      if (!hasRole) return;

      members.push({
        id: member.id,
        username: member.user.username,
        displayName: member.displayName || member.user.displayName
      });
    });

    return res.json({ members });
  } catch (err) {
    addLog('error', `Preview members error: ${err.message}`);
    return res.status(500).json({ error: 'Failed to fetch members', details: err.message });
  }
});

// NEW: Poll routes
app.post('/poll/create', requireAuth, async (req, res) => {
  const { question, options, durationMinutes } = req.body;
  if (!question || !Array.isArray(options) || options.length < 2) {
    return res.status(400).json({ error: 'Need question and at least 2 options' });
  }

  const emojis = ['1ï¸âƒ£','2ï¸âƒ£','3ï¸âƒ£','4ï¸âƒ£','5ï¸âƒ£','6ï¸âƒ£','7ï¸âƒ£','8ï¸âƒ£','9ï¸âƒ£','ðŸ”Ÿ'];
  if (options.length > emojis.length) {
    return res.status(400).json({ error: `Max ${emojis.length} options` });
  }

  const channelId = process.env.DISCORD_CHANNEL_ID;
  if (!channelId) {
    return res.status(400).json({ error: 'DISCORD_CHANNEL_ID not set' });
  }

  try {
    const channel = await client.channels.fetch(channelId);
    if (!channel || !channel.send) {
      return res.status(400).json({ error: 'Poll channel not found or not sendable' });
    }

    const pollId = `poll_${Date.now()}`;
    const endsAt = durationMinutes && durationMinutes > 0 ? Date.now() + (durationMinutes * 60 * 1000) : null;
    const optionsText = options.map((opt, i) => `${emojis[i]} ${opt}`).join('\n');
    const embed = new EmbedBuilder()
      .setColor(0x5865F2)
      .setTitle('ðŸ“Š ' + question)
      .setDescription(optionsText)
      .setFooter({ text: `ID: ${pollId}${endsAt ? ' | Ends' : ' | No time limit'}` });

    if (endsAt) embed.setTimestamp(endsAt);

    const msg = await channel.send({ embeds: [embed] });
    for (let i = 0; i < options.length; i++) {
      await msg.react(emojis[i]);
    }

    polls.push({
      id: pollId,
      messageId: msg.id,
      channelId,
      question,
      options,
      endTime: endsAt,
      active: true,
      createdBy: 'dashboard',
      votes: options.map(() => 0)
    });
    saveState();

    addLog('info', `Poll created: "${question}"`);
    return res.json({ success: true });
  } catch (err) {
    console.error('Error creating poll', err);
    return res.status(500).json({ error: 'Failed to post poll to Discord' });
  }
});

app.post('/poll/end', async (req, res) => {
  const { pollId } = req.body;
  if (!pollId) return res.status(400).json({ error: 'Poll ID required' });
  const poll = polls.find(p => p.id === pollId && p.active);
  if (!poll) return res.status(404).json({ error: 'Poll not found or already ended' });
  try {
    await endPoll(poll);
    return res.json({ success: true });
  } catch (err) {
    return res.status(500).json({ error: 'Failed to end poll' });
  }
});

app.post('/poll/delete', async (req, res) => {
  const { pollId, messageId, pollIndex } = req.body;
  if (!pollId && !messageId && (typeof pollIndex !== 'number')) {
    return res.status(400).json({ error: 'Poll ID required' });
  }
  
  let index = -1;
  if (pollId) index = polls.findIndex(p => p.id === pollId);
  if (index === -1 && messageId) index = polls.findIndex(p => p.messageId === messageId);
  if (index === -1 && typeof pollIndex === 'number' && pollIndex >= 0 && pollIndex < polls.length) {
    index = pollIndex;
  }
  
  if (index === -1) {
    return res.status(404).json({ error: 'Poll not found' });
  }
  
  const poll = polls[index];
  
  // Try to delete the Discord message
  try {
    if (poll.messageId && poll.channelId) {
      const channel = await client.channels.fetch(poll.channelId);
      if (channel && channel.messages) {
        const msg = await channel.messages.fetch(poll.messageId);
        if (msg) await msg.delete();
      }
    }
  } catch (err) {
    console.error('Could not delete poll message from Discord:', err);
  }
  
  polls.splice(index, 1);
  saveState();
  addLog('info', `Poll deleted: "${poll.question}"`);
  return res.json({ success: true });
});

// NEW: Reminder routes
app.post('/reminder/add', requireAuth, (req, res) => {
  const { text, time } = req.body;
  if (!text || !time) return res.status(400).json({ error: 'Missing fields' });
  
  const minutes = parseInt(time);
  if (isNaN(minutes) || minutes < 1) {
    return res.status(400).json({ error: 'Invalid time value' });
  }
  
  const reminderId = `reminder_${Date.now()}`;
  const reminderTime = Date.now() + (minutes * 60 * 1000);
  
  const reminder = {
    id: reminderId,
    message: text,
    text: text, // backwards compatibility
    reminderTime,
    time: new Date(reminderTime).toLocaleString(), // backwards compatibility
    active: true,
    triggered: false,
    createdAt: new Date().toISOString(),
    userId: null, // From dashboard, no specific user
    channelId: config.CUSTOM_CHANNEL_ID || process.env.DISCORD_CHANNEL_ID || null,
    createdBy: 'dashboard'
  };
  
  reminders.push(reminder);
  saveState();
  addLog('info', `Reminder added from dashboard: "${text}" in ${minutes} minutes`);
  res.json({ success: true });
});

// NEW: Embeds routes
app.get('/embeds', requireAuth, requireTier('moderator'), (req,res)=>res.send(renderPage('embeds', req)));
app.post('/embed/send', requireAuth, async (req, res) => {
  const {
    title, description, color, footer, thumbnail, image, timestamp, fields, channelId
  } = req.body || {};

  const targetChannelId = channelId || process.env.DISCORD_CHANNEL_ID;
  if (!targetChannelId) return res.status(400).json({ error: 'No channel ID provided and DISCORD_CHANNEL_ID not set' });

  try {
    const channel = await client.channels.fetch(targetChannelId);
    if (!channel || !channel.send) return res.status(400).json({ error: 'Channel not found or not sendable' });

    const embed = new EmbedBuilder();
    if (title) embed.setTitle(title);
    if (description) embed.setDescription(description);
    if (color) {
      const c = String(color).trim().replace(/^#/, '');
      const num = parseInt(c, 16);
      if (Number.isFinite(num)) embed.setColor(num);
    }
    if (footer) embed.setFooter({ text: footer });
    if (thumbnail) embed.setThumbnail(thumbnail);
    if (image) embed.setImage(image);
    if (timestamp) embed.setTimestamp();
    if (Array.isArray(fields)) {
      const safeFields = fields
        .filter(f => f && f.name && f.value)
        .slice(0, 25) // Discord limit
        .map(f => ({ name: String(f.name).slice(0, 256), value: String(f.value).slice(0, 1024), inline: !!f.inline }));
      if (safeFields.length) embed.addFields(safeFields);
    }

    await channel.send({ embeds: [embed] });
    addLog('info', `Embed posted${title ? ': ' + title : ''}`);
    return res.json({ success: true });
  } catch (err) {
    addLog('error', 'Failed to send embed: ' + err.message);
    return res.status(500).json({ error: 'Failed to send embed' });
  }
});

app.post('/reminder/delete', (req, res) => {
  const { id } = req.body;
  if (id >= 0 && id < reminders.length) {
    const rem = reminders[id];
    reminders.splice(id, 1);
    saveState();
    addLog('info', `Reminder deleted: "${rem.text}"`);
    res.json({ success: true });
  } else {
    res.status(400).json({ error: 'Invalid ID' });
  }
});

/* ======================
   DISCORD CLIENT
====================== */

// Helper for testing delayed stream notification
async function forceDelayedNotification() {
  if (!schedule) schedule = {};
  if (!schedule.nextStreamAt) {
    schedule.nextStreamAt = new Date(Date.now() - 5 * 60 * 1000).toISOString();
  }
  schedule.streamDelayed = false;
  saveState();
  await checkStream();
}

client.once('ready', async () => {
  console.log('[Discord] âœ… Ready event fired');
  addLog('info', 'Discord ready');

  // Load RPG worlds from file
  console.log('[Discord] Loading RPG worlds...');
  loadRPGWorlds();
  console.log('[Discord] RPG worlds loaded');

  // Cache all guild members for preview and other features
  try {
    const guildId = process.env.GUILD_ID || process.env.DISCORD_GUILD_ID;
    if (guildId) {
      console.log('[Discord] Fetching guild...', guildId);
      const guild = await client.guilds.fetch(guildId);
      if (guild) {
        addLog('info', `Caching members for guild ${guild.name}...`);
        console.log('[Discord] Caching members...');
        await guild.members.fetch({ force: true });
        addLog('info', `Cached ${guild.members.cache.size} members`);
        console.log('[Discord] Cached', guild.members.cache.size, 'members');
      }
    } else {
      console.log('[Discord] No GUILD_ID set, skipping member cache');
    }
  } catch (err) {
    addLog('error', `Failed to cache members: ${err.message}`);
    console.error('[Discord] Member cache error:', err.message);
  }

  // Non-Twitch background processes should always run
  console.log('[Discord] Starting background processes...');
  setInterval(checkGiveaways, 30000);
  setInterval(checkPolls, 30000);
  setInterval(checkReminders, 15000);
  console.log('[Discord] Background processes started');

  // Refresh member cache every 30 minutes (GuildMembers intent keeps it updated between refreshes)
  setInterval(async () => {
    try {
      const guildId = process.env.GUILD_ID || process.env.DISCORD_GUILD_ID;
      if (guildId) {
        const guild = await client.guilds.fetch(guildId);
        if (guild) {
          await guild.members.fetch();
        }
      }
    } catch (err) {
      addLog('error', `Member cache refresh failed: ${err.message}`);
    }
  }, 30 * 60 * 1000);

  if (!schedule.nextStreamAt && !schedule.noStreamToday) {
    console.log('[Discord] Computing next scheduled stream...');
    computeNextScheduledStream();
    console.log('[Discord] Next stream computed');
  }

  console.log('[Discord] Initializing Twitch...');
  try {
    await ensureTwitchInitialized({ reloadFromEnv: false, forceBroadcasterRefresh: true });
    console.log('[Discord] Twitch initialized');
  } catch (err) {
    addLog('error', 'Startup initialization failed: ' + err.message);
    addLog('error', 'Check your .env file for: STREAMER_LOGIN, TWITCH_CLIENT_ID, TWITCH_ACCESS_TOKEN');
    console.error('[Discord] Twitch init failed:', err.message);
  }

  console.log('[Discord] Registering slash commands...');
  const rest = new REST({ version: '10' }).setToken(process.env.DISCORD_TOKEN);

  // ðŸŒ Global commands
  const globalCommands = [
    rpgBot.getSlashCommand(),
    rpgBot.getLeaderboardSlashCommand(),
    new SlashCommandBuilder()
      .setName('streamstatus')
      .setDescription('Shows current stream status')
      .toJSON(),

    new SlashCommandBuilder()
      .setName('lastlive')
      .setDescription('Shows last stream title and timestamp')
      .toJSON(),

    new SlashCommandBuilder()
      .setName('topgame')
      .setDescription('Shows most played game recently')
      .toJSON()
  ];

  try {
    await rest.put(
      Routes.applicationCommands(client.user.id),
      { body: globalCommands }
    );
    addLog('info', 'Global commands registered');
    console.log('[Discord] Global commands registered');
  } catch (err) {
    addLog('error', 'Global commands registration failed: ' + err.message);
    console.error('[Discord] Global commands error:', err.message);
  }

  console.log('[Discord] Registering guild commands...');
  // ðŸ  Guild-only (admin / test)
  const guildCommands = [
    new SlashCommandBuilder().setName('cancelstream').setDescription("Cancels today's stream"),
    new SlashCommandBuilder().setName('alertsoff').setDescription('Disable alerts for today'),
    new SlashCommandBuilder().setName('alertson').setDescription('Enable alerts for today'),
    new SlashCommandBuilder().setName('testdelay').setDescription('Force delayed notification'),
    new SlashCommandBuilder().setName('streamhealth').setDescription('Internal stream state'),

    new SlashCommandBuilder()
      .setName('setschedule')
      .setDescription('Set weekly stream schedule')
      .addStringOption(o =>
        o.setName('time1').setDescription('HH:MM (24h)').setRequired(true)
      )
      .addStringOption(o =>
        o.setName('days1').setDescription('mon,tue,wed,thu,fri ...').setRequired(true)
      )
      .addChannelOption(o =>
        o.setName('channel').setDescription('Post schedule here').setRequired(true)
      )
      .addStringOption(o =>
        o.setName('time2').setDescription('Secondary time').setRequired(false)
      )
      .addStringOption(o =>
        o.setName('days2').setDescription('Secondary days').setRequired(false)
      ),

    new SlashCommandBuilder().setName('forcelive').setDescription('Force stream LIVE'),
    new SlashCommandBuilder().setName('forceoffline').setDescription('Force stream OFFLINE'),
    
    // NEW COMMANDS
    new SlashCommandBuilder().setName('help').setDescription('Show all available commands'),
    new SlashCommandBuilder().setName('stats').setDescription('View stream statistics'),
    new SlashCommandBuilder().setName('uptime').setDescription('Show bot uptime'),
    new SlashCommandBuilder()
      .setName('suggest')
      .setDescription('Make a community suggestion')
      .addStringOption(o => o.setName('suggestion').setDescription('Your suggestion').setRequired(true)),
    new SlashCommandBuilder()
      .setName('warn')
      .setDescription('Warn a user')
      .addUserOption(o => o.setName('user').setDescription('User to warn').setRequired(true))
      .addStringOption(o => o.setName('reason').setDescription('Reason for warning').setRequired(false)),
    new SlashCommandBuilder()
      .setName('warnings')
      .setDescription('Check warnings for a user')
      .addUserOption(o => o.setName('user').setDescription('User to check').setRequired(true)),
    new SlashCommandBuilder()
      .setName('setlivemessage')
      .setDescription('Set custom live announcement message')
      .addStringOption(o => o
        .setName('message')
        .setDescription('Message template (use {role} and {streamer} placeholders)')
        .setRequired(true)
      ),
    new SlashCommandBuilder()
      .setName('setmilestones')
      .setDescription('Set viewer milestone alerts')
      .addStringOption(o => o
        .setName('milestones')
        .setDescription('Comma-separated viewer counts: 100,250,500,1000')
        .setRequired(true)
      ),
    new SlashCommandBuilder()
      .setName('setofflinethreshold')
      .setDescription('Set how long stream can be offline before marking offline')
      .addIntegerOption(o => o
        .setName('seconds')
        .setDescription('Seconds to wait (default 120)')
        .setMinValue(1)
        .setMaxValue(600)
        .setRequired(true)
      ),
    new SlashCommandBuilder()
      .setName('setalertroles')
      .setDescription('Set which role gets pinged for different alerts')
      .addStringOption(o => o
        .setName('role_type')
        .setDescription('Alert type')
        .addChoices(
          { name: 'Live Alerts', value: 'liveAlert' },
          { name: 'Schedule Alerts', value: 'scheduleAlert' },
          { name: 'Suggestion Alerts', value: 'suggestionAlert' }
        )
        .setRequired(true)
      )
      .addRoleOption(o => o
        .setName('role')
        .setDescription('Role to ping')
        .setRequired(true)
      ),
    new SlashCommandBuilder()
      .setName('setlevelchannel')
      .setDescription('Set the channel for level-up notifications')
      .addChannelOption(o => o
        .setName('channel')
        .setDescription('Channel to post level-up alerts (leave empty to reset)')
        .setRequired(false)
      ),
    // Leveling
    new SlashCommandBuilder()
      .setName('rank')
      .setDescription('Check your or another user\'s rank')
      .addUserOption(o => o.setName('user').setDescription('User to check').setRequired(false)),
    new SlashCommandBuilder()
      .setName('leaderboard')
      .setDescription('View the leveling leaderboard'),
    new SlashCommandBuilder()
      .setName('xp')
      .setDescription('Check your or another user\'s XP')
      .addUserOption(o => o.setName('user').setDescription('User to check').setRequired(false)),
    new SlashCommandBuilder()
      .setName('addxp')
      .setDescription('Add XP to a user (Admin only)')
      .addUserOption(o => o.setName('user').setDescription('User to give XP to').setRequired(true))
      .addIntegerOption(o => o.setName('amount').setDescription('Amount of XP to add').setMinValue(1).setRequired(true)),
    new SlashCommandBuilder()
      .setName('removexp')
      .setDescription('Remove XP from a user (Admin only)')
      .addUserOption(o => o.setName('user').setDescription('User to remove XP from').setRequired(true))
      .addIntegerOption(o => o.setName('amount').setDescription('Amount of XP to remove').setMinValue(1).setRequired(true)),
    new SlashCommandBuilder()
      .setName('setlevel')
      .setDescription('Set a user\'s level directly (Admin only)')
      .addUserOption(o => o.setName('user').setDescription('User to modify').setRequired(true))
      .addIntegerOption(o => o.setName('level').setDescription('New level').setMinValue(0).setRequired(true)),
    new SlashCommandBuilder()
      .setName('levelconfig')
      .setDescription('View current leveling configuration'),
    new SlashCommandBuilder()
      .setName('setxpmultiplier')
      .setDescription('Set XP multiplier (e.g., 2x for double XP event) (Admin only)')
      .addNumberOption(o => o.setName('multiplier').setDescription('Multiplier value (1 = normal, 2 = 2x)').setMinValue(0.5).setMaxValue(10).setRequired(true))
      .addIntegerOption(o => o.setName('hours').setDescription('Duration in hours (0 = disable)').setMinValue(0).setRequired(true)),
    new SlashCommandBuilder()
      .setName('prestige')
      .setDescription('Reset your level to gain prestige rank'),
    new SlashCommandBuilder()
      .setName('weekly')
      .setDescription('View the weekly leaderboard'),
    
    // Giveaways
    new SlashCommandBuilder()
      .setName('giveaway')
      .setDescription('Start a giveaway')
      .addStringOption(o => o.setName('prize').setDescription('Prize to give away').setRequired(true))
      .addIntegerOption(o => o.setName('winners').setDescription('Number of winners').setMinValue(1).setMaxValue(20).setRequired(true))
      .addIntegerOption(o => o.setName('duration').setDescription('Duration in minutes').setMinValue(1).setMaxValue(10080).setRequired(true))
      .addChannelOption(o => o.setName('channel').setDescription('Channel to post in').setRequired(false)),
    new SlashCommandBuilder()
      .setName('giveawayend')
      .setDescription('End a giveaway early')
      .addStringOption(o => o.setName('giveaway_id').setDescription('Giveaway ID').setRequired(true)),
    new SlashCommandBuilder()
      .setName('giveawayreroll')
      .setDescription('Reroll giveaway winners')
      .addStringOption(o => o.setName('giveaway_id').setDescription('Giveaway ID').setRequired(true)),
    new SlashCommandBuilder()
      .setName('giveawaylist')
      .setDescription('List all active giveaways'),
    
    // Polls
    new SlashCommandBuilder()
      .setName('poll')
      .setDescription('Create a poll')
      .addStringOption(o => o.setName('question').setDescription('Poll question').setRequired(true))
      .addStringOption(o => o.setName('options').setDescription('Options separated by | (e.g., Yes|No|Maybe)').setRequired(true))
      .addIntegerOption(o => o.setName('duration').setDescription('Duration in minutes (0 = no end)').setMinValue(0).setMaxValue(10080).setRequired(false))
      .addChannelOption(o => o.setName('channel').setDescription('Channel to post in').setRequired(false)),
    new SlashCommandBuilder()
      .setName('pollend')
      .setDescription('End a poll early')
      .addStringOption(o => o.setName('poll_id').setDescription('Poll ID').setRequired(true)),
    new SlashCommandBuilder()
      .setName('pollresults')
      .setDescription('View poll results')
      .addStringOption(o => o.setName('poll_id').setDescription('Poll ID').setRequired(true)),
    new SlashCommandBuilder()
      .setName('polllist')
      .setDescription('List all active polls'),
    
    // Reminders
    new SlashCommandBuilder()
      .setName('remind')
      .setDescription('Set a reminder')
      .addStringOption(o => o.setName('message').setDescription('What to remind you about').setRequired(true))
      .addIntegerOption(o => o.setName('time').setDescription('Time in minutes').setMinValue(1).setMaxValue(525600).setRequired(true))
      .addUserOption(o => o.setName('user').setDescription('User to remind (default: you)').setRequired(false))
      .addChannelOption(o => o.setName('channel').setDescription('Channel to send reminder in').setRequired(false)),
    new SlashCommandBuilder()
      .setName('reminders')
      .setDescription('List your active reminders'),
    new SlashCommandBuilder()
      .setName('cancelreminder')
      .setDescription('Cancel a reminder')
      .addStringOption(o => o.setName('reminder_id').setDescription('Reminder ID').setRequired(true)),
    
    // Custom Commands
    new SlashCommandBuilder()
      .setName('addcommand')
      .setDescription('Add a custom command')
      .addStringOption(o => o.setName('name').setDescription('Command name (without !)').setRequired(true))
      .addStringOption(o => o.setName('response').setDescription('Command response').setRequired(true)),
    new SlashCommandBuilder()
      .setName('removecommand')
      .setDescription('Remove a custom command')
      .addStringOption(o => o.setName('name').setDescription('Command name').setRequired(true)),
    new SlashCommandBuilder()
      .setName('editcommand')
      .setDescription('Edit a custom command')
      .addStringOption(o => o.setName('name').setDescription('Command name').setRequired(true))
      .addStringOption(o => o.setName('response').setDescription('New response').setRequired(true)),
    new SlashCommandBuilder()
      .setName('cmd')
      .setDescription('Run a custom command (slash)')
      .addStringOption(o => o.setName('name').setDescription('Command name').setRequired(true)),
    new SlashCommandBuilder()
      .setName('commands')
      .setDescription('List all custom commands'),
    
    // Notification Filters
    new SlashCommandBuilder()
      .setName('addfilter')
      .setDescription('Add a notification filter (keywords to suppress)')
      .addStringOption(o => o.setName('keyword').setDescription('Keyword to filter').setRequired(true))
      .addStringOption(o => o.setName('type').setDescription('Filter type')
        .addChoices(
          { name: 'Title', value: 'title' },
          { name: 'Game', value: 'game' },
          { name: 'All', value: 'all' }
        )
        .setRequired(true)),
    new SlashCommandBuilder()
      .setName('removefilter')
      .setDescription('Remove a notification filter')
      .addStringOption(o => o.setName('filter_id').setDescription('Filter ID').setRequired(true)),
    new SlashCommandBuilder()
      .setName('filters')
      .setDescription('List all active notification filters'),
    
    // RPG Test Mode
    new SlashCommandBuilder()
      .setName('rpg-test-mode')
      .setDescription('Toggle RPG-only test mode (disable other bot features)'),
    
    // Dashboard/Admin
    new SlashCommandBuilder()
      .setName('dashboard')
      .setDescription('Open the RPG Dashboard (Admin only)'),

    // Pets
    new SlashCommandBuilder()
      .setName('pet')
      .setDescription('Manage server pets')
      .addSubcommand(sub =>
        sub.setName('add')
          .setDescription('Add a pet to the server collection')
          .addStringOption(o =>
            o.setName('pet')
              .setDescription('Search for a pet to add')
              .setRequired(true)
              .setAutocomplete(true))
          .addIntegerOption(o =>
            o.setName('quantity')
              .setDescription('How many to add (default: 1)')
              .setRequired(false)
              .setMinValue(1)
              .setMaxValue(25))
          )
      .addSubcommand(sub =>
        sub.setName('list')
          .setDescription('View all server pets'))
      .addSubcommand(sub =>
        sub.setName('remove')
          .setDescription('Remove a pet from the collection (Admin only)')
          .addStringOption(o =>
            o.setName('pet')
              .setDescription('Search for a pet to remove')
              .setRequired(true)
              .setAutocomplete(true))
          .addIntegerOption(o =>
            o.setName('quantity')
              .setDescription('How many to remove (default: 1)')
              .setRequired(false)
              .setMinValue(1)
              .setMaxValue(25)))
  ].map(c => c.toJSON());

  const guildId = process.env.GUILD_ID || process.env.DISCORD_GUILD_ID;
  if (!guildId) {
    addLog('error', 'No guild ID configured; slash commands not registered');
    return;
  }

  try {
    await rest.put(
      Routes.applicationGuildCommands(client.user.id, guildId),
      { body: guildCommands }
    );
    addLog('info', `Guild commands registered (${guildCommands.length} commands)`);
    console.log(`[Discord] Guild commands registered (${guildCommands.length} commands)`);
  } catch (err) {
    addLog('error', 'Guild commands registration failed: ' + err.message);
    console.error('[Discord] Guild commands error:', err);
  }

  console.log('[Discord] âœ… Bot fully ready and operational!');
  addLog('info', 'âœ… Bot fully ready and operational');
});

// Handle new members joining
client.on('guildMemberAdd', async (member) => {
  try {
    const hasAutoRoles = (Array.isArray(welcomeSettings.autoRoles) && welcomeSettings.autoRoles.length > 0) ||
                         (Array.isArray(welcomeSettings.autoRoleConditions) && welcomeSettings.autoRoleConditions.length > 0);
    if (!welcomeSettings.enabled && !hasAutoRoles) return;

    // Anti-spam check: skip if user already has certain roles (re-join)
    if (welcomeSettings.antiSpamEnabled && welcomeSettings.antiSpamRoles?.length > 0) {
      const userRoleIds = member.roles.cache.map(r => r.id);
      const hasAntiSpamRole = welcomeSettings.antiSpamRoles.some(rid => userRoleIds.includes(rid));
      if (hasAntiSpamRole) {
        addLog('info', `Skipped welcome for ${member.user.tag} (anti-spam: has existing role)`);
        // Still do auto-roles though
      } else {
        await sendWelcomeMessage(member);
      }
    } else {
      await sendWelcomeMessage(member);
    }

    // Auto-assign roles with conditions
    if (hasAutoRoles) {
      const botMember = await member.guild.members.fetchMe().catch(() => null);
      if (botMember && !botMember.permissions.has('ManageRoles')) {
        addLog('error', 'Auto-role failed: Bot lacks Manage Roles permission');
        return;
      }

      const accountAgeDays = member.user.createdAt 
        ? Math.floor((Date.now() - member.user.createdAt.getTime()) / (1000 * 60 * 60 * 24)) 
        : 999;

      const rolesToAssign = welcomeSettings.autoRoleConditions?.length > 0 
        ? welcomeSettings.autoRoleConditions 
        : (welcomeSettings.autoRoles || []).map(id => ({ roleId: id, condition: 'always' }));

      for (const roleConfig of rolesToAssign) {
        const roleId = roleConfig.roleId || roleConfig;
        const condition = roleConfig.condition || 'always';
        const minAge = roleConfig.minAccountAge || 7;

        // Check condition
        if (condition === 'accountAge' && accountAgeDays < minAge) {
          addLog('info', `Skipped role ${roleId} for ${member.user.tag} (account age ${accountAgeDays}d < ${minAge}d)`);
          continue;
        }

        try {
          const role = await member.guild.roles.fetch(roleId);
          if (role) {
            if (botMember && role.position >= botMember.roles.highest.position) {
              addLog('error', `Auto-role failed: Role ${role.name} is higher than bot role`);
              continue;
            }
            await member.roles.add(role);
            addLog('info', `Assigned role ${role.name} to ${member.user.tag}`);
          }
        } catch (roleErr) {
          addLog('error', `Failed to assign role ${roleId}: ${roleErr.message}`);
        }
      }
    }
  } catch (err) {
    addLog('error', `Failed to process new member ${member.user.tag}: ${err.message}`);
  }
});

// Helper function to send welcome message
async function sendWelcomeMessage(member) {
  if (!welcomeSettings.enabled) return;

  let channel = null;
  if (welcomeSettings.channelId) {
    channel = await member.guild.channels.fetch(welcomeSettings.channelId).catch(() => null);
    if (!channel || !channel.isTextBased()) {
      addLog('error', 'Welcome channel not found or not a text channel');
      channel = null;
    }
  }

  if (!channel) return;

  // Prepare replacement data
  const memberCount = member.guild.memberCount;
  const joinTime = new Date().toLocaleString();
  const avatarUrl = member.user.displayAvatarURL({ dynamic: true, size: 256 });

  const replaceVars = (text) => {
    if (!text) return text;
    return text
      .replace(/{user}/g, `<@${member.id}>`)
      .replace(/{mention}/g, `<@${member.id}>`)
      .replace(/{username}/g, member.user.username)
      .replace(/{server}/g, member.guild.name)
      .replace(/{count}/g, memberCount.toLocaleString())
      .replace(/{position}/g, memberCount.toString())
      .replace(/{time}/g, joinTime)
      .replace(/{avatar}/g, avatarUrl);
  };

  // Determine which message to send (single, random, or cycle)
  let messageToSend;
  if (welcomeSettings.messageMode === 'random' && welcomeSettings.messages?.length > 0) {
    const randomIndex = Math.floor(Math.random() * welcomeSettings.messages.length);
    messageToSend = welcomeSettings.messages[randomIndex]?.text;
  } else if (welcomeSettings.messageMode === 'cycle' && welcomeSettings.messages?.length > 0) {
    const cycleIndex = welcomeSettings.cycleIndex || 0;
    messageToSend = welcomeSettings.messages[cycleIndex % welcomeSettings.messages.length]?.text;
    welcomeSettings.cycleIndex = (cycleIndex + 1) % welcomeSettings.messages.length;
    saveState();
  } else {
    messageToSend = welcomeSettings.message;
  }

  try {
    if (welcomeSettings.useEmbed) {
      // Send embed
      const embed = new EmbedBuilder()
        .setColor(parseInt((welcomeSettings.embedColor || '#9146ff').replace('#', ''), 16));

      if (welcomeSettings.embedTitle) {
        embed.setTitle(replaceVars(welcomeSettings.embedTitle));
      }
      if (welcomeSettings.embedDescription) {
        embed.setDescription(replaceVars(welcomeSettings.embedDescription));
      }
      if (welcomeSettings.embedFooter) {
        embed.setFooter({ text: replaceVars(welcomeSettings.embedFooter) });
      }
      if (welcomeSettings.embedThumbnail === 'avatar') {
        embed.setThumbnail(avatarUrl);
      } else if (welcomeSettings.embedThumbnail === 'custom' && welcomeSettings.embedThumbnailUrl) {
        embed.setThumbnail(welcomeSettings.embedThumbnailUrl);
      }
      if (welcomeSettings.embedImage) {
        embed.setImage(welcomeSettings.embedImage);
      }
      if (welcomeSettings.embedFields?.length > 0) {
        for (const field of welcomeSettings.embedFields) {
          if (field.name && field.value) {
            embed.addFields({ 
              name: replaceVars(field.name), 
              value: replaceVars(field.value), 
              inline: field.inline || false 
            });
          }
        }
      }

      embed.setTimestamp();
      await channel.send({ embeds: [embed] });
    } else {
      // Send plain text
      const message = replaceVars(messageToSend || 'Welcome {user} to {server}!');
      await channel.send(message);
    }
    addLog('info', `Sent welcome message to ${member.user.tag}`);
  } catch (err) {
    addLog('error', `Failed to send welcome message: ${err.message}`);
  }

  // Send DM if enabled
  if (welcomeSettings.dmEnabled) {
    try {
      const dmChannel = await member.user.createDM();
      
      if (welcomeSettings.dmUseEmbed && welcomeSettings.useEmbed) {
        // Send same embed style to DM
        const dmEmbed = new EmbedBuilder()
          .setColor(parseInt((welcomeSettings.embedColor || '#9146ff').replace('#', ''), 16));

        if (welcomeSettings.embedTitle) {
          dmEmbed.setTitle(replaceVars(welcomeSettings.embedTitle));
        }
        if (welcomeSettings.embedDescription) {
          dmEmbed.setDescription(replaceVars(welcomeSettings.embedDescription));
        }
        if (welcomeSettings.embedFooter) {
          dmEmbed.setFooter({ text: replaceVars(welcomeSettings.embedFooter) });
        }
        dmEmbed.setTimestamp();

        await dmChannel.send({ embeds: [dmEmbed] });
      } else {
        // Send plain DM message
        const dmText = replaceVars(welcomeSettings.dmMessage || welcomeSettings.message || 'Welcome to {server}!');
        await dmChannel.send(dmText);
      }
      addLog('info', `Sent welcome DM to ${member.user.tag}`);
    } catch (dmErr) {
      addLog('warn', `Could not DM ${member.user.tag}: ${dmErr.message}`);
    }
  }
}

client.on('guildMemberAdd', async (member) => {
  try {
    if (!auditLogSettings?.enabled || !auditLogSettings?.logMemberJoins) return;
    const roleIds = getMemberRoleIds(member);
    if (isExcludedBySettings({ userId: member.id, roleIds })) return;
    const createdAt = member.user?.createdAt ? new Date(member.user.createdAt) : null;
    const ageDays = createdAt ? Math.floor((Date.now() - createdAt.getTime()) / (1000 * 60 * 60 * 24)) : null;
    const warnNew = auditLogSettings.warnNewAccounts && ageDays !== null && ageDays < (auditLogSettings.newAccountThresholdDays || 7);
    const joinPosition = auditLogSettings.logJoinPosition ? member.guild.memberCount : null;

    const joinColor = warnNew 
      ? parseInt((auditLogSettings.eventColors?.timeout || '#E67E22').replace('#', ''), 16)
      : parseInt((auditLogSettings.eventColors?.join || '#2ECC71').replace('#', ''), 16);

    const embed = new EmbedBuilder()
      .setColor(joinColor)
      .setTitle(warnNew ? 'âš ï¸ New Member (New Account)' : 'âœ… Member Joined')
      .setDescription(`<@${member.id}> joined the server`)
      .addFields(
        { name: 'User', value: `${member.user.tag} (${member.id})` }
      )
      .setTimestamp();

    if (createdAt) {
      embed.addFields({ name: 'Account Created', value: createdAt.toISOString() + (ageDays !== null ? ` (${ageDays}d ago)` : '') });
    }

    if (joinPosition !== null) {
      embed.addFields({ name: 'Join Position', value: `#${joinPosition}`, inline: true });
    }

    await sendAuditLog({ embeds: [embed], eventType: 'logMemberJoins' });

    addAuditLogEntry({
      type: warnNew ? 'warn' : 'info',
      action: 'member_join',
      userId: member.id,
      userTag: member.user.tag,
      details: { summary: joinPosition !== null ? `Join #${joinPosition}` : '', accountAgeDays: ageDays }
    });

    // Send critical event DM for new accounts
    if (warnNew) {
      await sendCriticalEventDM('newAccounts', {
        summary: `New account joined: ${member.user.tag} (${ageDays} days old)`,
        userId: member.id,
        userTag: member.user.tag
      });
    }

    if (member.user?.bot && auditLogSettings.logIntegrations) {
      const botEmbed = new EmbedBuilder()
        .setColor(0x7289DA)
        .setTitle('ðŸ¤– Bot Added')
        .setDescription(`<@${member.id}> was added to the server`)
        .setTimestamp();
      await sendAuditLog({ embeds: [botEmbed], eventType: 'logIntegrations' });
      addAuditLogEntry({
        type: 'info',
        action: 'integration_update',
        userId: member.id,
        userTag: member.user.tag,
        details: { summary: 'Bot added' }
      });

      // Send critical event DM for bot changes
      await sendCriticalEventDM('botChanges', {
        summary: `Bot added: ${member.user.tag}`,
        userId: member.id,
        userTag: member.user.tag
      });
    }
  } catch (err) {
    addLog('error', `Member join log failed: ${err.message}`);
  }
});

// Goodbye message handler
client.on('guildMemberRemove', async (member) => {
  try {
    if (!welcomeSettings.goodbyeEnabled) return;

    let channel = null;
    const channelId = welcomeSettings.goodbyeChannelId || welcomeSettings.channelId;
    if (channelId) {
      channel = await member.guild.channels.fetch(channelId).catch(() => null);
      if (!channel || !channel.isTextBased()) {
        addLog('error', 'Goodbye channel not found or not a text channel');
        return;
      }
    }

    if (!channel) return;

    // Prepare replacement data
    const memberCount = member.guild.memberCount;
    const leaveTime = new Date().toLocaleString();
    const avatarUrl = member.user?.displayAvatarURL({ dynamic: true, size: 256 }) || '';

    const replaceVars = (text) => {
      if (!text) return text;
      return text
        .replace(/{user}/g, member.user?.tag || 'Unknown')
        .replace(/{mention}/g, member.user?.tag || 'Unknown')
        .replace(/{username}/g, member.user?.username || 'Unknown')
        .replace(/{server}/g, member.guild.name)
        .replace(/{count}/g, memberCount.toLocaleString())
        .replace(/{position}/g, memberCount.toString())
        .replace(/{time}/g, leaveTime)
        .replace(/{avatar}/g, avatarUrl);
    };

    // Determine which message to send
    let messageToSend;
    if (welcomeSettings.goodbyeMessageMode === 'random' && welcomeSettings.goodbyeMessages?.length > 0) {
      const randomIndex = Math.floor(Math.random() * welcomeSettings.goodbyeMessages.length);
      messageToSend = welcomeSettings.goodbyeMessages[randomIndex]?.text;
    } else {
      messageToSend = welcomeSettings.goodbyeMessage;
    }

    if (welcomeSettings.goodbyeUseEmbed) {
      // Send embed
      const embed = new EmbedBuilder()
        .setColor(parseInt((welcomeSettings.goodbyeEmbedColor || '#E74C3C').replace('#', ''), 16));

      if (welcomeSettings.goodbyeEmbedTitle) {
        embed.setTitle(replaceVars(welcomeSettings.goodbyeEmbedTitle));
      }
      if (welcomeSettings.goodbyeEmbedDescription) {
        embed.setDescription(replaceVars(welcomeSettings.goodbyeEmbedDescription));
      }
      if (welcomeSettings.goodbyeEmbedFooter) {
        embed.setFooter({ text: replaceVars(welcomeSettings.goodbyeEmbedFooter) });
      }
      if (welcomeSettings.goodbyeEmbedThumbnail === 'avatar' && avatarUrl) {
        embed.setThumbnail(avatarUrl);
      } else if (welcomeSettings.goodbyeEmbedThumbnail === 'custom' && welcomeSettings.goodbyeEmbedThumbnailUrl) {
        embed.setThumbnail(welcomeSettings.goodbyeEmbedThumbnailUrl);
      }
      if (welcomeSettings.goodbyeEmbedImage) {
        embed.setImage(welcomeSettings.goodbyeEmbedImage);
      }

      embed.setTimestamp();
      await channel.send({ embeds: [embed] });
    } else {
      // Send plain text
      const message = replaceVars(messageToSend || 'Goodbye {username}! ðŸ‘‹');
      await channel.send(message);
    }

    addLog('info', `Sent goodbye message for ${member.user?.tag || 'Unknown'}`);
  } catch (err) {
    addLog('error', `Failed to send goodbye message: ${err.message}`);
  }
});

client.on('guildMemberRemove', async (member) => {
  try {
    if (!auditLogSettings?.enabled || !auditLogSettings?.logMemberLeaves) return;
    const roleIds = getMemberRoleIds(member);
    if (isExcludedBySettings({ userId: member.id, roleIds })) return;
    const embed = new EmbedBuilder()
      .setColor(0xE74C3C)
      .setTitle('ðŸ‘‹ Member Left')
      .setDescription(`${member.user?.tag || 'Unknown user'} left the server`)
      .addFields({ name: 'User ID', value: member.id })
      .setTimestamp();

    await sendAuditLog({ embeds: [embed] });

    addAuditLogEntry({
      type: 'info',
      action: 'member_leave',
      userId: member.id,
      userTag: member.user?.tag || null,
      details: { summary: 'Member left' }
    });

    if (member.user?.bot && auditLogSettings.logIntegrations) {
      const botEmbed = new EmbedBuilder()
        .setColor(0x99AAB5)
        .setTitle('ðŸ¤– Bot Removed')
        .setDescription(`${member.user?.tag || 'Unknown bot'} removed from the server`)
        .setTimestamp();
      await sendAuditLog({ embeds: [botEmbed] });
      addAuditLogEntry({
        type: 'info',
        action: 'integration_update',
        userId: member.id,
        userTag: member.user?.tag || null,
        details: { summary: 'Bot removed' }
      });
    }
  } catch (err) {
    addLog('error', `Member leave log failed: ${err.message}`);
  }
});

// Member log events
client.on('messageUpdate', async (oldMessage, newMessage) => {
  try {
    if (!auditLogSettings?.enabled) return;
    if (newMessage?.partial) newMessage = await newMessage.fetch();
    if (oldMessage?.partial) oldMessage = await oldMessage.fetch();
    if (!newMessage?.guild) return;
    if (newMessage.author?.bot) return;

    const roleIds = getMemberRoleIds(newMessage.member);
    if (isExcludedBySettings({ userId: newMessage.author?.id, channelId: newMessage.channel?.id, roleIds })) return;

    if (auditLogSettings.logMessagePins && oldMessage?.pinned !== newMessage?.pinned) {
      const pinned = newMessage.pinned;
      const embed = new EmbedBuilder()
        .setColor(pinned ? 0xF1C40F : 0x95A5A6)
        .setTitle(pinned ? 'ðŸ“Œ Message Pinned' : 'ðŸ“Œ Message Unpinned')
        .setDescription(`<@${newMessage.author.id}> ${pinned ? 'pinned' : 'unpinned'} a message in <#${newMessage.channel.id}>`)
        .setTimestamp();

      if (newMessage.url) {
        embed.addFields({ name: 'Message Link', value: newMessage.url });
      }

      await sendAuditLog({ embeds: [embed] });

      addAuditLogEntry({
        type: 'info',
        action: pinned ? 'message_pin' : 'message_unpin',
        userId: newMessage.author.id,
        userTag: newMessage.author.tag,
        channelId: newMessage.channel.id,
        details: { summary: pinned ? 'Pinned message' : 'Unpinned message' }
      });
    }

    if (!auditLogSettings.logMessageEdits) return;

    const before = oldMessage?.content ?? '';
    const after = newMessage?.content ?? '';
    if (before === after) return;

    const embed = new EmbedBuilder()
      .setColor(0xF1C40F)
      .setTitle('âœï¸ Message Edited')
      .setDescription(`<@${newMessage.author.id}> edited a message in <#${newMessage.channel.id}>`)
      .addFields(
        { name: 'Before', value: truncateLogText(before || '*empty*', 900) },
        { name: 'After', value: truncateLogText(after || '*empty*', 900) }
      )
      .setTimestamp();

    if (newMessage.url) {
      embed.addFields({ name: 'Message Link', value: newMessage.url });
    }

    await sendAuditLog({ embeds: [embed] });

    addAuditLogEntry({
      type: 'info',
      action: 'message_edit',
      userId: newMessage.author.id,
      userTag: newMessage.author.tag,
      channelId: newMessage.channel.id,
      details: { summary: 'Message edited' }
    });
  } catch (err) {
    addLog('error', `Message edit log failed: ${err.message}`);
  }
});

client.on('messageDelete', async (message) => {
  try {
    if (!auditLogSettings?.enabled || !auditLogSettings.logMessageDeletes) return;
    if (message?.partial) message = await message.fetch().catch(() => message);
    if (!message?.guild) return;
    if (message.author?.bot) return;

    const roleIds = getMemberRoleIds(message.member);
    if (isExcludedBySettings({ userId: message.author?.id, channelId: message.channel?.id, roleIds })) return;

    const executor = await getAuditExecutor(message.guild, AuditLogEvent.MessageDelete, message.author?.id);

    const embed = new EmbedBuilder()
      .setColor(0xE74C3C)
      .setTitle('ðŸ—‘ï¸ Message Deleted')
      .setDescription(`A message by <@${message.author?.id || 'unknown'}> was deleted in <#${message.channel?.id}>`)
      .setTimestamp();

    if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });
    if (executor?.reason) embed.addFields({ name: 'Reason', value: executor.reason });

    const content = message.content ? truncateLogText(message.content, 900) : '*empty or embed*';
    embed.addFields({ name: 'Content', value: content });

    await sendAuditLog({ embeds: [embed] });

    addAuditLogEntry({
      type: 'info',
      action: 'message_delete',
      userId: message.author?.id || null,
      userTag: message.author?.tag || null,
      channelId: message.channel?.id || null,
      executorId: executor?.id || null,
      executorTag: executor?.tag || null,
      details: { summary: 'Message deleted' }
    });
  } catch (err) {
    addLog('error', `Message delete log failed: ${err.message}`);
  }
});

client.on('messageDeleteBulk', async (messages) => {
  try {
    if (!auditLogSettings?.enabled || !auditLogSettings.logMessageBulkDeletes) return;
    const first = messages?.first?.();
    if (!first?.guild) return;

    const channelId = first.channel?.id;
    if (isExcludedBySettings({ channelId })) return;

    const executor = await getAuditExecutor(first.guild, AuditLogEvent.MessageBulkDelete, channelId);
    const count = messages?.size || 0;

    const embed = new EmbedBuilder()
      .setColor(0xC0392B)
      .setTitle('ðŸ§¹ Bulk Messages Deleted')
      .setDescription(`${count} messages deleted in <#${channelId}>`)
      .setTimestamp();

    if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });
    if (executor?.reason) embed.addFields({ name: 'Reason', value: executor.reason });

    await sendAuditLog({ embeds: [embed] });

    addAuditLogEntry({
      type: 'info',
      action: 'message_bulk_delete',
      channelId: channelId || null,
      executorId: executor?.id || null,
      executorTag: executor?.tag || null,
      details: { summary: `${count} messages deleted` }
    });
  } catch (err) {
    addLog('error', `Bulk message delete log failed: ${err.message}`);
  }
});

client.on('userUpdate', async (oldUser, newUser) => {
  try {
    if (!auditLogSettings?.enabled) return;
    if (isExcludedBySettings({ userId: newUser.id })) return;

    if (auditLogSettings.logUsernameChanges && oldUser.username !== newUser.username) {
      const embed = new EmbedBuilder()
        .setColor(0x3498DB)
        .setTitle('ðŸ“ Username Changed')
        .setDescription(`<@${newUser.id}> changed their username`)
        .addFields(
          { name: 'Before', value: oldUser.username || '*unknown*' },
          { name: 'After', value: newUser.username || '*unknown*' }
        )
        .setTimestamp();
      await sendAuditLog({ embeds: [embed] });

      addAuditLogEntry({
        type: 'info',
        action: 'username_change',
        userId: newUser.id,
        userTag: newUser.tag || newUser.username,
        details: { summary: `${oldUser.username || 'unknown'} â†’ ${newUser.username || 'unknown'}` }
      });
    }

    if (auditLogSettings.logAvatarChanges && oldUser.avatar !== newUser.avatar) {
      const embed = new EmbedBuilder()
        .setColor(0x9B59B6)
        .setTitle('ðŸ–¼ï¸ Avatar Changed')
        .setDescription(`<@${newUser.id}> changed their avatar`)
        .setThumbnail(newUser.displayAvatarURL({ size: 256 }))
        .setTimestamp();
      await sendAuditLog({ embeds: [embed] });

      addAuditLogEntry({
        type: 'info',
        action: 'avatar_change',
        userId: newUser.id,
        userTag: newUser.tag || newUser.username,
        details: { summary: 'Avatar updated' }
      });
    }
  } catch (err) {
    addLog('error', `User update log failed: ${err.message}`);
  }
});

client.on('guildMemberUpdate', async (oldMember, newMember) => {
  try {
    if (!auditLogSettings?.enabled) return;
    if (newMember.user?.bot) return;
    const roleIds = getMemberRoleIds(newMember);
    if (isExcludedBySettings({ userId: newMember.id, roleIds })) return;

    if (auditLogSettings.logMemberTimeouts) {
      const oldTimeout = oldMember.communicationDisabledUntilTimestamp || null;
      const newTimeout = newMember.communicationDisabledUntilTimestamp || null;

      if (oldTimeout !== newTimeout) {
        const executor = await getAuditExecutor(newMember.guild, AuditLogEvent.MemberUpdate, newMember.id);
        if (newTimeout && (!oldTimeout || newTimeout > Date.now())) {
          const mins = Math.max(1, Math.round((newTimeout - Date.now()) / 60000));
          const embed = new EmbedBuilder()
            .setColor(0xE67E22)
            .setTitle('â±ï¸ Member Timed Out')
            .setDescription(`<@${newMember.id}> was timed out`)
            .addFields({ name: 'Duration', value: `${mins} min` })
            .setTimestamp();
          if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });
          if (executor?.reason) embed.addFields({ name: 'Reason', value: executor.reason });
          await sendAuditLog({ embeds: [embed] });

          addAuditLogEntry({
            type: 'warn',
            action: 'member_timeout',
            userId: newMember.id,
            userTag: newMember.user.tag,
            executorId: executor?.id || null,
            executorTag: executor?.tag || null,
            details: { summary: `Timeout ${mins} min` }
          });
        } else if (oldTimeout && (!newTimeout || newTimeout < Date.now())) {
          const embed = new EmbedBuilder()
            .setColor(0x2ECC71)
            .setTitle('âœ… Timeout Ended')
            .setDescription(`<@${newMember.id}>'s timeout expired or was removed`)
            .setTimestamp();
          if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });
          if (executor?.reason) embed.addFields({ name: 'Reason', value: executor.reason });
          await sendAuditLog({ embeds: [embed] });

          addAuditLogEntry({
            type: 'info',
            action: 'member_timeout_expired',
            userId: newMember.id,
            userTag: newMember.user.tag,
            executorId: executor?.id || null,
            executorTag: executor?.tag || null,
            details: { summary: 'Timeout ended' }
          });
        }
      }
    }

    if (auditLogSettings.logMemberMutes && Array.isArray(auditLogSettings.muteRoleIds) && auditLogSettings.muteRoleIds.length) {
      const oldRoles = new Set(oldMember.roles.cache.map(r => r.id));
      const newRoles = new Set(newMember.roles.cache.map(r => r.id));
      const muteIds = new Set(auditLogSettings.muteRoleIds);

      const addedMute = [...newRoles].some(id => muteIds.has(id) && !oldRoles.has(id));
      const removedMute = [...oldRoles].some(id => muteIds.has(id) && !newRoles.has(id));

      if (addedMute || removedMute) {
        const executor = await getAuditExecutor(newMember.guild, AuditLogEvent.MemberRoleUpdate, newMember.id);
        const embed = new EmbedBuilder()
          .setColor(addedMute ? 0xE74C3C : 0x2ECC71)
          .setTitle(addedMute ? 'ðŸ”‡ Member Muted' : 'ðŸ”Š Member Unmuted')
          .setDescription(`<@${newMember.id}> ${addedMute ? 'was muted' : 'was unmuted'}`)
          .setTimestamp();
        if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });
        if (executor?.reason) embed.addFields({ name: 'Reason', value: executor.reason });
        await sendAuditLog({ embeds: [embed] });

        addAuditLogEntry({
          type: addedMute ? 'warn' : 'info',
          action: addedMute ? 'member_mute' : 'member_unmute',
          userId: newMember.id,
          userTag: newMember.user.tag,
          executorId: executor?.id || null,
          executorTag: executor?.tag || null,
          details: { summary: addedMute ? 'Mute role added' : 'Mute role removed' }
        });
      }
    }

    if (auditLogSettings.logMemberBoosts) {
      const oldBoost = oldMember.premiumSinceTimestamp || null;
      const newBoost = newMember.premiumSinceTimestamp || null;
      if (!oldBoost && newBoost) {
        const embed = new EmbedBuilder()
          .setColor(0x9B59B6)
          .setTitle('ðŸ’œ Server Boosted')
          .setDescription(`<@${newMember.id}> started boosting the server`)
          .setTimestamp();
        await sendAuditLog({ embeds: [embed] });

        addAuditLogEntry({
          type: 'info',
          action: 'member_boost',
          userId: newMember.id,
          userTag: newMember.user.tag,
          details: { summary: 'Boost started' }
        });
      } else if (oldBoost && !newBoost) {
        const embed = new EmbedBuilder()
          .setColor(0x95A5A6)
          .setTitle('ðŸ’” Boost Ended')
          .setDescription(`<@${newMember.id}> stopped boosting the server`)
          .setTimestamp();
        await sendAuditLog({ embeds: [embed] });

        addAuditLogEntry({
          type: 'info',
          action: 'member_boost',
          userId: newMember.id,
          userTag: newMember.user.tag,
          details: { summary: 'Boost ended' }
        });
      }
    }

    if (auditLogSettings.logNicknameChanges) {
      const oldNick = oldMember.nickname || '';
      const newNick = newMember.nickname || '';
      if (oldNick !== newNick) {
        const executor = await getAuditExecutor(newMember.guild, AuditLogEvent.MemberUpdate, newMember.id);
        const embed = new EmbedBuilder()
          .setColor(0x2ECC71)
          .setTitle('ðŸ”¤ Nickname Changed')
          .setDescription(`<@${newMember.id}> changed their nickname`)
          .addFields(
            { name: 'Before', value: oldNick || '*none*' },
            { name: 'After', value: newNick || '*none*' }
          )
          .setTimestamp();

        if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });
        await sendAuditLog({ embeds: [embed] });

        addAuditLogEntry({
          type: 'info',
          action: 'nickname_change',
          userId: newMember.id,
          userTag: newMember.user.tag,
          executorId: executor?.id || null,
          executorTag: executor?.tag || null,
          details: { summary: `${oldNick || 'none'} â†’ ${newNick || 'none'}` }
        });
      }
    }

    if (auditLogSettings.logRoleChanges) {
      const oldRoles = new Set(oldMember.roles.cache.map(r => r.id));
      const newRoles = new Set(newMember.roles.cache.map(r => r.id));

      const added = [...newRoles].filter(id => !oldRoles.has(id));
      const removed = [...oldRoles].filter(id => !newRoles.has(id));

      if (added.length || removed.length) {
        const executor = await getAuditExecutor(newMember.guild, AuditLogEvent.MemberRoleUpdate, newMember.id);
        const embed = new EmbedBuilder()
          .setColor(0x9B59B6)
          .setTitle('ðŸ§© Roles Updated')
          .setDescription(`<@${newMember.id}> roles changed`)
          .addFields(
            { name: 'Added', value: added.length ? added.map(id => `<@&${id}>`).join(' ') : 'None' },
            { name: 'Removed', value: removed.length ? removed.map(id => `<@&${id}>`).join(' ') : 'None' }
          )
          .setTimestamp();

        if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });

        await sendAuditLog({ embeds: [embed] });

        addAuditLogEntry({
          type: 'info',
          action: 'role_update',
          userId: newMember.id,
          userTag: newMember.user.tag,
          executorId: executor?.id || null,
          executorTag: executor?.tag || null,
          details: { summary: `Added ${added.length}, Removed ${removed.length}` }
        });
      }
    }
  } catch (err) {
    addLog('error', `Nickname log failed: ${err.message}`);
  }
});

client.on('guildBanAdd', async (ban) => {
  try {
    if (!auditLogSettings?.enabled || !auditLogSettings?.logMemberBans) return;
    if (isExcludedBySettings({ userId: ban.user?.id })) return;

    const executor = await getAuditExecutor(ban.guild, AuditLogEvent.MemberBanAdd, ban.user?.id);
    const embed = new EmbedBuilder()
      .setColor(parseInt((auditLogSettings.eventColors?.ban || '#E74C3C').replace('#', ''), 16))
      .setTitle('â›” Member Banned')
      .setDescription(`<@${ban.user?.id}> was banned`)
      .setTimestamp();
    if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });
    if (executor?.reason) embed.addFields({ name: 'Reason', value: executor.reason });

    await sendAuditLog({ embeds: [embed], eventType: 'logMemberBans' });

    addAuditLogEntry({
      type: 'warn',
      action: 'member_ban',
      userId: ban.user?.id || null,
      userTag: ban.user?.tag || null,
      executorId: executor?.id || null,
      executorTag: executor?.tag || null,
      details: { summary: executor?.reason || 'Banned', reason: executor?.reason }
    });

    // Send critical event DM
    await sendCriticalEventDM('bans', {
      summary: `${ban.user?.tag || 'Unknown user'} was banned`,
      userId: ban.user?.id,
      userTag: ban.user?.tag,
      reason: executor?.reason
    });
  } catch (err) {
    addLog('error', `Member ban log failed: ${err.message}`);
  }
});

client.on('guildBanRemove', async (ban) => {
  try {
    if (!auditLogSettings?.enabled || !auditLogSettings?.logMemberUnbans) return;
    if (isExcludedBySettings({ userId: ban.user?.id })) return;

    const executor = await getAuditExecutor(ban.guild, AuditLogEvent.MemberBanRemove, ban.user?.id);
    const embed = new EmbedBuilder()
      .setColor(0x2ECC71)
      .setTitle('âœ… Member Unbanned')
      .setDescription(`<@${ban.user?.id}> was unbanned`)
      .setTimestamp();
    if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });
    if (executor?.reason) embed.addFields({ name: 'Reason', value: executor.reason });

    await sendAuditLog({ embeds: [embed] });

    addAuditLogEntry({
      type: 'info',
      action: 'member_unban',
      userId: ban.user?.id || null,
      userTag: ban.user?.tag || null,
      executorId: executor?.id || null,
      executorTag: executor?.tag || null,
      details: { summary: 'Unbanned' }
    });
  } catch (err) {
    addLog('error', `Member unban log failed: ${err.message}`);
  }
});

client.on('guildUpdate', async (oldGuild, newGuild) => {
  try {
    if (!auditLogSettings?.enabled || !auditLogSettings?.logServerUpdates) return;

    const changes = [];
    if (oldGuild.name !== newGuild.name) changes.push(`Name: ${oldGuild.name} â†’ ${newGuild.name}`);
    if (oldGuild.icon !== newGuild.icon) changes.push('Icon updated');
    if (oldGuild.banner !== newGuild.banner) changes.push('Banner updated');
    if (oldGuild.description !== newGuild.description) changes.push('Description updated');
    if (oldGuild.verificationLevel !== newGuild.verificationLevel) changes.push(`Verification: ${oldGuild.verificationLevel} â†’ ${newGuild.verificationLevel}`);
    if (oldGuild.afkChannelId !== newGuild.afkChannelId) changes.push('AFK channel updated');
    if (oldGuild.afkTimeout !== newGuild.afkTimeout) changes.push('AFK timeout updated');

    if (!changes.length) return;

    const executor = await getAuditExecutor(newGuild, AuditLogEvent.GuildUpdate, newGuild.id);
    const embed = new EmbedBuilder()
      .setColor(0x3498DB)
      .setTitle('âš™ï¸ Server Settings Updated')
      .setDescription(changes.join('\n'))
      .setTimestamp();
    if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });

    await sendAuditLog({ embeds: [embed] });

    addAuditLogEntry({
      type: 'info',
      action: 'server_update',
      userId: null,
      userTag: null,
      executorId: executor?.id || null,
      executorTag: executor?.tag || null,
      details: { summary: changes.join('; ') }
    });

    // Send critical event DM for server changes
    await sendCriticalEventDM('serverChanges', {
      summary: `Server settings updated: ${changes.join(', ')}`
    });
  } catch (err) {
    addLog('error', `Server update log failed: ${err.message}`);
  }
});

client.on('guildIntegrationsUpdate', async (guild) => {
  try {
    if (!auditLogSettings?.enabled || !auditLogSettings?.logIntegrations) return;

    const executor = await getAuditExecutor(guild, AuditLogEvent.IntegrationUpdate, guild.id) ||
      await getAuditExecutor(guild, AuditLogEvent.IntegrationCreate, guild.id) ||
      await getAuditExecutor(guild, AuditLogEvent.IntegrationDelete, guild.id);

    const embed = new EmbedBuilder()
      .setColor(0x8E44AD)
      .setTitle('ðŸ”Œ Integrations Updated')
      .setDescription('An integration or app setting changed')
      .setTimestamp();
    if (executor?.tag) embed.addFields({ name: 'By', value: executor.tag });

    await sendAuditLog({ embeds: [embed] });

    addAuditLogEntry({
      type: 'info',
      action: 'integration_update',
      executorId: executor?.id || null,
      executorTag: executor?.tag || null,
      details: { summary: 'Integration update' }
    });
  } catch (err) {
    addLog('error', `Integration update log failed: ${err.message}`);
  }
});

client.on('interactionCreate', async (interaction) => {
  try {
    // Handle RPG interactions (buttons, selects, commands)
    if (interaction.isChatInputCommand() && interaction.commandName === 'rpg') {
      if (!isRpgChannelAllowed(interaction.channelId, interaction.channel)) {
        await interaction.reply({ content: getRpgRestrictionMessage(), ephemeral: true });
        return;
      }
      await rpgBot.handleInteraction(interaction);
      return;
    }

    if (interaction.isButton() && interaction.customId.startsWith('rpg-')) {
      if (!isRpgChannelAllowed(interaction.channelId, interaction.channel)) {
        await interaction.reply({ content: getRpgRestrictionMessage(), ephemeral: true });
        return;
      }
      await rpgBot.handleInteraction(interaction);
      return;
    }

    if (interaction.isStringSelectMenu && interaction.isStringSelectMenu() && interaction.customId.startsWith('rpg-')) {
      if (!isRpgChannelAllowed(interaction.channelId, interaction.channel)) {
        await interaction.reply({ content: getRpgRestrictionMessage(), ephemeral: true });
        return;
      }
      await rpgBot.handleInteraction(interaction);
      return;
    }

    if (interaction.isModalSubmit && interaction.isModalSubmit() && interaction.customId.startsWith('rpg-')) {
      if (!isRpgChannelAllowed(interaction.channelId, interaction.channel)) {
        await interaction.reply({ content: getRpgRestrictionMessage(), ephemeral: true });
        return;
      }
      await rpgBot.handleInteraction(interaction);
      return;
    }

    if (interaction.isButton() && interaction.customId.startsWith('dashboard-')) {
      const DashboardCommand = (await import('./Discord bot - test branch/rpg/dashboard/DashboardCommand.js')).default;
      const dashboardCmd = new DashboardCommand();
      return dashboardCmd.handleButtonInteraction(interaction);
    }

    if (interaction.isModalSubmit && interaction.isModalSubmit() && interaction.customId.startsWith('dashboard-')) {
      const DashboardCommand = (await import('./Discord bot - test branch/rpg/dashboard/DashboardCommand.js')).default;
      const dashboardCmd = new DashboardCommand();
      return dashboardCmd.handleModalSubmit(interaction);
    }

    // Pet autocomplete handler
    if (interaction.isAutocomplete && interaction.isAutocomplete() && interaction.commandName === 'pet') {
      const focused = interaction.options.getFocused().toLowerCase();
      const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });
      const catalog = petsData.catalog || [];
      const filtered = catalog
        .filter(p => p.name.toLowerCase().includes(focused) || p.category.toLowerCase().includes(focused) || p.id.includes(focused))
        .slice(0, 25)
        .map(p => ({ name: p.emoji + ' ' + p.name + ' (' + p.category + ')', value: p.id }));
      return interaction.respond(filtered);
    }

    if (!interaction.isChatInputCommand()) return;

    // Check bot permissions
    if (interaction.guild) {
      const botMember = await interaction.guild.members.fetchMe();
      if (!botMember.permissions.has('SendMessages')) {
        return interaction.reply({ content: 'âŒ Bot does not have permission to send messages in this channel', ephemeral: true });
      }
    }

    // If RPG test mode is enabled, only allow RPG and test mode commands
    if (rpgTestMode) {
      const rpgOnlyCommands = ['rpg', 'leaderboard', 'dashboard', 'rpg-test-mode'];
      if (!rpgOnlyCommands.includes(interaction.commandName)) {
        return interaction.reply({ 
          content: 'ðŸ§ª **RPG TEST MODE ACTIVE** - Only RPG commands are available right now. Toggle off with `/rpg-test-mode` to enable other features.', 
          ephemeral: true 
        });
      }
    }

    // Admin-only commands
    const adminOnly = [
      'cancelstream',
      'alertsoff',
      'alertson',
      'setschedule',
      'forcelive',
      'forceoffline',
      'testdelay',
      'warn',
      'setlivemessage',
      'setmilestones',
      'setofflinethreshold',
      'setalertroles',
      'setlevelchannel',
      'addxp',
      'removexp',
      'setlevel',
      'setxpmultiplier',
      'giveaway',
      'giveawayend',
      'giveawayreroll',
      'pollend',
      'addcommand',
      'removecommand',
      'editcommand',
      'addfilter',
      'removefilter',
      'rpg-test-mode'
    ];

    // âœ… Check admin permissions
    if (adminOnly.includes(interaction.commandName)) {
      if (!interaction.guild || !interaction.memberPermissions?.has(PermissionsBitField.Flags.Administrator)) {
        return interaction.reply({ content: 'â›” Admin only command.', ephemeral: true });
      }
    }

    const cmdKey = interaction.commandName;
    if (config.commandDisabled?.[cmdKey]) {
      return interaction.reply({ content: 'â›” This command is disabled in the dashboard.', ephemeral: true });
    }
    const cooldownSeconds = Number(config.commandCooldowns?.[cmdKey] || 0);
    if (cooldownSeconds > 0) {
      const key = cmdKey + ':' + interaction.user.id;
      const last = slashCommandCooldowns.get(key) || 0;
      const remainingMs = cooldownSeconds * 1000 - (Date.now() - last);
      if (remainingMs > 0) {
        const remainingSec = Math.ceil(remainingMs / 1000);
        return interaction.reply({ content: `â³ This command is on cooldown. Try again in ${remainingSec}s.`, ephemeral: true });
      }
      slashCommandCooldowns.set(key, Date.now());
    }

    // Defer reply for long-running commands
    if (['setschedule', 'stats', 'streamhealth'].includes(interaction.commandName)) {
      await interaction.deferReply({ ephemeral: true });
    }

    logCommandUsage(cmdKey, interaction.user);

    switch (interaction.commandName) {
      case 'dashboard': {
        const DashboardCommand = (await import('./Discord bot - test branch/rpg/dashboard/DashboardCommand.js')).default;
        const dashboardCmd = new DashboardCommand();
        return dashboardCmd.handleCommand(interaction);
      }

      case 'streamstatus':
        return interaction.reply(
          streamInfo.startedAt
            ? `ðŸ”´ LIVE | ${streamInfo.viewers} viewers`
            : 'âš« OFFLINE'
        );

      case 'lastlive':
        if (!lastStreamId) {
          return interaction.reply('No previous stream recorded');
        }
        return interaction.reply(
          `Last stream: "${streamInfo.title}" at ${new Date(streamInfo.startedAt).toLocaleString()}`
        );

      case 'topgame': {
        const counts = history.reduce((acc, i) => {
          acc[i.game] = (acc[i.game] || 0) + 1;
        }, {});
        const top = Object.entries(counts).sort((a, b) => b[1] - a[1])[0];
        return interaction.reply(
          top ? `Top Game: ${top[0]} (${top[1]} streams)` : 'No game data'
        );
      }

      // Force stream LIVE
      case 'forcelive': {
        streamInfo.startedAt = new Date().toISOString();
        streamInfo.viewers = 1;
        streamInfo.isForced = true;
        saveState();
        // Recompute the next scheduled stream immediately after updating weekly schedule
        try { computeNextScheduledStream(true); } catch (e) { addLog('error', 'Failed to compute next scheduled stream: ' + (e?.message || e)); }
        await checkStream();
        return interaction.reply('ðŸ§ª Stream forced LIVE');
      }

      // Force stream OFFLINE
      case 'forceoffline':
        streamInfo.startedAt = null;
        streamInfo.viewers = 0;
        streamInfo.isForced = false;
        saveState();
        await checkStream();
        return interaction.reply('ðŸ§ª Stream forced OFFLINE');

      // Cancel stream
      case 'cancelstream':
        schedule.noStreamToday = true;
        schedule.alertsSent = { oneHour: false, tenMin: false };
        saveState();
        addLog('info', 'Stream cancelled for today');
        
        // Send cancellation announcement
        try {
          const channelId = getChannelOrDefault('liveAlert');
          const channel = await client.channels.fetch(channelId);
          
          if (channel) {
            // CLEAN CHANNEL: Delete previous bot messages and unpin old announcement
            try {
              const messages = await channel.messages.fetch({ limit: 50 });
              const botMessages = messages.filter(m => m.author.id === client.user.id);
              
              // Unpin the old announcement if it exists
              if (announcementMessageId) {
                const oldMsg = botMessages.get(announcementMessageId);
                if (oldMsg && oldMsg.pinned) {
                  await oldMsg.unpin();
                  addLog('info', 'Unpinned old announcement');
                }
              }
              
              // Delete all bot messages in the channel
              for (const [, msg] of botMessages) {
                try {
                  await msg.delete();
                } catch (err) {
                  addLog('warn', `Could not delete message: ${err.message}`);
                }
              }
              addLog('info', 'Cleaned announcement channel');
            } catch (err) {
              addLog('warn', 'Could not clean channel: ' + err.message);
            }
            
            const roleId = getRoleOrDefault('liveAlert');
            const cancelEmbed = new EmbedBuilder()
              .setColor(0xFF0000)
              .setTitle('âŒ Stream Cancelled')
              .setDescription(`${roleId ? `<@&${roleId}> ` : ''}Today's stream has been cancelled. Sorry for the inconvenience!`)
              .setTimestamp();
            
            const cancelMsg = await channel.send({ embeds: [cancelEmbed] });
            
            // PIN the cancellation message
            try {
              await cancelMsg.pin();
              addLog('info', 'Pinned cancellation announcement');
              announcementMessageId = cancelMsg.id;
              saveState();
            } catch (err) {
              addLog('warn', 'Could not pin cancellation message: ' + err.message);
            }
          }
        } catch (err) {
          addLog('error', 'Failed to send cancellation announcement: ' + err.message);
        }
        
        return interaction.reply('âŒ Stream cancelled for today');


      // Alerts off
      case 'alertsoff':
        schedule.alertsEnabledToday = false;
        saveState();
        addLog('info', 'Alerts disabled for today');
        return interaction.reply('ðŸ”‡ Alerts disabled for today');

      // Alerts on
      case 'alertson':
        schedule.alertsEnabledToday = true;
        saveState();
        addLog('info', 'Alerts enabled for today');
        return interaction.reply('ðŸ”” Alerts enabled for today');

      // Force delayed notification
      case 'testdelay':
        await forceDelayedNotification();
        return interaction.reply('â±ï¸ Delayed notification forced');

      // Stream health embed
      case 'streamhealth': {
        const next = getNextScheduledStream();
        const alertInfo = getNextAlertInfo();

        const status = streamInfo.startedAt ? 'ðŸ”´ LIVE' : 'âš« OFFLINE';

        // Stream duration if live
        let streamDuration = 'N/A';
        if (streamInfo.startedAt) {
          const uptime = Date.now() - new Date(streamInfo.startedAt).getTime();
          const hours = Math.floor(uptime / (1000 * 60 * 60));
          const mins = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
          streamDuration = `${hours}h ${mins}m`;
        }

        // Bot uptime
        const botUptime = Date.now() - startTime;
        const botDays = Math.floor(botUptime / (1000 * 60 * 60 * 24));
        const botHours = Math.floor((botUptime % (1000 * 60 * 60 * 24)) / (1000 * 60));

        let nextStreamText = 'Not scheduled';
        let daysUntilNext = 'N/A';
        if (next) {
          const ts = Math.floor(next.ts / 1000);
          const dayName = next.day.charAt(0).toUpperCase() + next.day.slice(1);
          nextStreamText = `${dayName} â€¢ <t:${ts}:t>`;
          const daysLeft = Math.ceil((next.ts - Date.now()) / (1000 * 60 * 60 * 24));
          daysUntilNext = `${daysLeft} day${daysLeft !== 1 ? 's' : ''}`;
        }

        const flags = [];
        if (schedule.noStreamToday) flags.push('âŒ Cancelled today');
        if (schedule.streamDelayed) flags.push('âš ï¸ Delayed');
        if (!client.isReady()) flags.push('âš ï¸ Bot not ready');

        const embed = new EmbedBuilder()
          .setTitle('ðŸ§  Stream Health Dashboard')
          .setColor(streamInfo.startedAt ? 0x00FF00 : 0x9146FF)
          .setDescription(`Last updated: <t:${Math.floor(Date.now() / 1000)}:R>`)
          .addFields(
            // Status section
            { name: 'â”â”â”â”â”â”â”â”â”â”â” STATUS â”â”â”â”â”â”â”â”â”â”â”', value: ' ', inline: false },
            { name: 'Stream Status', value: status, inline: true },
            { name: 'Stream Duration', value: streamDuration, inline: true },
            { name: 'Viewers', value: String(streamInfo.viewers), inline: true },
            { name: 'Last Check', value: lastStreamCheckAt ? new Date(lastStreamCheckAt).toLocaleString() : 'N/A', inline: true },
            
            // Stream info section
            { name: 'â”â”â”â”â”â”â” CURRENT INFO â”â”â”â”â”â”â”', value: ' ', inline: false },
            { name: 'Title', value: streamInfo.title || 'No title', inline: false },
            { name: 'Game', value: streamInfo.game || 'No game', inline: true },
            { name: 'Timezone', value: botTimezone, inline: true },
            
            // Schedule section
            { name: 'â”â”â”â”â”â”â” NEXT STREAM â”â”â”â”â”â”â”', value: ' ', inline: false },
            { name: 'When', value: nextStreamText, inline: true },
            { name: 'Days Until', value: daysUntilNext, inline: true },
            
            // Alerts section
            { name: 'â”â”â”â”â”â”â”â” ALERTS â”â”â”â”â”â”â”â”', value: ' ', inline: false },
            {
              name: '1h Alert',
              value: schedule.alertsSent.oneHour ? 'âœ… Sent' : 'â³ Pending',
              inline: true
            },
            {
              name: '10m Alert',
              value: schedule.alertsSent.tenMin ? 'âœ… Sent' : 'â³ Pending',
              inline: true
            },
            {
              name: 'Next Alert',
              value: alertInfo.nextAlert ? `${alertInfo.nextAlert} (${alertInfo.timeRemaining})` : alertInfo.status,
              inline: true
            },
            
            // Stats section
            { name: 'â”â”â”â”â”â”â”â” STATS â”â”â”â”â”â”â”â”', value: ' ', inline: false },
            { name: 'Total Streams', value: String(stats.totalStreams), inline: true },
            { name: 'Peak Viewers', value: String(stats.peakViewers), inline: true },
            { name: 'Avg Viewers', value: stats.totalStreams > 0 ? String(Math.round(stats.totalViewers / stats.totalStreams)) : '0', inline: true },
            
            // Bot info section
            { name: 'â”â”â”â”â”â”â” BOT INFO â”â”â”â”â”â”â”', value: ' ', inline: false },
            { name: 'Bot Uptime', value: `${botDays}d ${botHours}h`, inline: true },
            { name: 'Notification Role', value: config.ROLE_ID ? `<@&${config.ROLE_ID}>` : 'Not set', inline: true },
            
            // Flags section
            { name: 'â”â”â”â”â”â”â” FLAGS â”â”â”â”â”â”â”', value: flags.length ? flags.join('\n') : 'âœ… All good', inline: false }
          )
          .setFooter({ text: `Timezone: ${botTimezone}` });

        return interaction.editReply({ embeds: [embed] });
      }

      // Set weekly schedule
      case 'setschedule': {
        const channel = interaction.options.getChannel('channel');
        if (!channel) {
          return interaction.reply({ content: 'âŒ Invalid channel.', ephemeral: true });
        }
        if (!schedule.weekly) schedule.weekly = {};

        const groups = [
          { time: interaction.options.getString('time1'), days: interaction.options.getString('days1') },
          { time: interaction.options.getString('time2'), days: interaction.options.getString('days2') }
        ].filter(g => g.time && g.days);

        // Validate time format
        const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
        
        const updated = [];
        const now = getNowInBotTimezone(); // Use bot's timezone safely

        for (const g of groups) {
          if (!timeRegex.test(g.time)) {
            return interaction.editReply({ content: `âŒ Invalid time format: ${g.time}. Use HH:MM (24-hour)` });
          }

          const [h, m] = g.time.split(':').map(Number);
          for (const d of g.days.toLowerCase().split(',')) {
            const day = DAY_MAP[d.trim()];
            if (!day) {
              return interaction.editReply({ content: `âŒ Invalid day: ${d.trim()}` });
            }

            const targetDayIndex = DAY_INDEX[day];
            const currentDayIndex = now.getUTCDay();
            
            // Calculate days to add
            let daysToAdd = targetDayIndex - currentDayIndex;
            if (daysToAdd < 0) daysToAdd += 7; // If day already passed this week, schedule for next week
            if (daysToAdd === 0) {
              // If it's today, check if time has passed
              const currentHour = now.getUTCHours();
              const currentMinute = now.getUTCMinutes();
              if (currentHour > h || (currentHour === h && currentMinute >= m)) {
                daysToAdd = 7; // Schedule for next week
              }
            }

            const target = new Date(now.getTime());
            target.setUTCDate(now.getUTCDate() + daysToAdd);
            target.setUTCHours(h, m, 0, 0);

            // Calculate timezone offset between system timezone and bot timezone
            const utcNow = new Date();
            const botTime = new Date(utcNow.toLocaleString('en-US', { timeZone: botTimezone }));
            const systemTime = new Date(utcNow.toLocaleString('en-US'));
            const offsetMs = botTime.getTime() - systemTime.getTime();
            
            // Store schedule as hour/minute for the weekday (safer than storing an absolute timestamp)
            schedule.weekly[day] = { hour: h, minute: m };
            updated.push(`${day.charAt(0).toUpperCase() + day.slice(1)} @ ${g.time}`);
          }
        }

        if (updated.length === 0) {
          return interaction.editReply({ content: 'âŒ No valid schedule entries created' });
        }

        saveState();

        await channel.send({
          embeds: [{
            title: 'ðŸ“… Weekly Stream Schedule',
            color: 0x9146FF,
            description: 'Updated schedule:',
            fields: updated.map(u => {
              const dayName = u.split(' @ ')[0].toLowerCase();
              const entry = schedule.weekly[dayName];
              if (!entry) {
                return { name: u.split(' @ ')[0], value: 'Error: Schedule not found', inline: false };
              }

              // Compute a next occurrence for display
              const computeTsForDisplay = (() => {
                const map = { sunday:0, monday:1, tuesday:2, wednesday:3, thursday:4, friday:5, saturday:6 };
                const idx = map[dayName];
                if (idx === undefined) return null;
                const hour = entry.hour ?? (new Date(Number(entry) || Date.now()).getHours());
                const minute = entry.minute ?? (new Date(Number(entry) || Date.now()).getMinutes());

                const utcMs = getNextOccurrenceUtcMs(botTimezone, idx, hour, minute, Date.now());
                return Math.floor(utcMs / 1000);
              })();

              return { name: u.split(' @ ')[0], value: computeTsForDisplay ? `<t:${computeTsForDisplay}:t>` : 'N/A', inline: false };
            })
          }]
        });

        return interaction.editReply({
          content: `âœ… Schedule updated:\nâ€¢ ${updated.join('\nâ€¢ ')}`
        });
      }

      // NEW: Help command
      case 'help': {
        const helpEmbed = new EmbedBuilder()
          .setTitle('ðŸ“‹ Bot Commands')
          .setColor(0x9146FF)
          .addFields(
            { name: 'ðŸ“¡ Stream Info', value: '`/streamstatus` - Current stream status\n`/lastlive` - Last stream info\n`/topgame` - Most played game\n`/stats` - Stream statistics\n`/uptime` - Bot uptime' },
            { name: 'ðŸ”” Alerts', value: '`/alertson` - Enable alerts\n`/alertsoff` - Disable alerts' },
            { name: 'â° Schedule', value: '`/setschedule` - Set weekly schedule\n`/cancelstream` - Cancel today\'s stream\n`/testdelay` - Test delayed notification' },
            { name: 'ðŸ’¬ Community', value: '`/suggest` - Make a suggestion\n`/warnings` - Check user warnings\n`/commands` - List custom commands' },
            { name: 'ðŸŽ‰ Giveaways', value: '`/giveaway` - Start a giveaway\n`/giveawaylist` - List active giveaways\n`/giveawayend` - End giveaway early\n`/giveawayreroll` - Reroll winners' },
            { name: 'ðŸ“Š Polls', value: '`/poll` - Create a poll\n`/polllist` - List active polls\n`/pollend` - End poll early\n`/pollresults` - View poll results' },
            { name: 'â° Reminders', value: '`/remind` - Set a reminder\n`/reminders` - List your reminders\n`/cancelreminder` - Cancel a reminder' },
            { name: 'ðŸ“ Custom Commands', value: '`/addcommand` - Add custom command\n`/editcommand` - Edit custom command\n`/removecommand` - Remove custom command' },
            { name: 'ðŸ”• Filters', value: '`/addfilter` - Add notification filter\n`/filters` - List active filters\n`/removefilter` - Remove filter' },
            { name: 'âš™ï¸ Admin', value: '`/streamhealth` - Stream health status\n`/forcelive` - Force LIVE\n`/forceoffline` - Force OFFLINE\n`/warn` - Warn a user' }
          )
          .setFooter({ text: 'Use /help for command details' })
          .setTimestamp();
        return interaction.reply({ embeds: [helpEmbed], ephemeral: true });
      }

      // NEW: Stats command
      case 'stats': {
        recomputeStreamStatsFromHistory();
        const statsEmbed = new EmbedBuilder()
          .setTitle('ðŸ“Š Stream Statistics')
          .setColor(0x9146FF)
          .addFields(
            { name: 'Total Streams', value: String(stats.totalStreams), inline: true },
            { name: 'Peak Viewers', value: String(stats.peakViewers), inline: true },
            { name: 'Total Viewers', value: String(stats.totalViewers), inline: true },
            { name: 'Most Played Game', value: getMostPlayedGame() || 'N/A', inline: true },
            { name: 'Average Viewers', value: String(stats.avgViewers ?? (history.length ? Math.round(history.reduce((sum, h) => sum + ((h.avgViewers ?? h.viewers) || 0), 0) / history.length) : 0)), inline: true },
            { name: 'Streams This Week', value: String(history.filter(h => {
              if (!h.startedAt) return false;
              const d = new Date(h.startedAt);
              const now = new Date();
              return (now - d) / (1000 * 60 * 60 * 24) <= 7;
            }).length), inline: true }
          )
          .setTimestamp();
        return interaction.editReply({ embeds: [statsEmbed] });
      }

      // NEW: Uptime command
      case 'uptime': {
        const uptime = Date.now() - startTime;
        const days = Math.floor(uptime / (1000 * 60 * 60 * 24));
        const hours = Math.floor((uptime % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = Math.floor((uptime % (1000 * 60 * 60)) / (1000 * 60));
        return interaction.reply(`â±ï¸ Bot uptime: **${days}d ${hours}h ${minutes}m**`);
      }

      // NEW: Suggest command
      case 'suggest': {
        const suggestion = interaction.options.getString('suggestion');
        const userId = interaction.user.id;
        
        // Check cooldown
        const cooldownMinutes = dashboardSettings.suggestionCooldownMinutes || 60;
        const cooldownMs = cooldownMinutes * 60 * 1000;
        const lastSuggestion = suggestionCooldowns[userId];
        
        if (lastSuggestion && cooldownMinutes > 0) {
          const timeSince = Date.now() - lastSuggestion;
          if (timeSince < cooldownMs) {
            const remaining = Math.ceil((cooldownMs - timeSince) / 60000);
            return interaction.reply({ 
              content: `â±ï¸ Please wait ${remaining} more minute${remaining !== 1 ? 's' : ''} before submitting another suggestion.`, 
              ephemeral: true 
            });
          }
        }
        
        suggestions.push({
          id: suggestions.length,
          user: interaction.user.username,
          userId,
          suggestion,
          timestamp: new Date().toISOString(),
          upvotes: 0
        });
        
        // Set cooldown
        suggestionCooldowns[userId] = Date.now();
        
        saveState();
        addLog('info', `Suggestion from ${interaction.user.username}: ${suggestion}`);
        return interaction.reply({ content: 'âœ… Suggestion recorded! Thank you!', ephemeral: true });
      }

      // NEW: Warn command
      case 'warn': {
        const user = interaction.options.getUser('user');
        const reason = interaction.options.getString('reason') || 'No reason specified';
        const userId = user.id;
        
        if (!warnings[userId]) warnings[userId] = [];
        warnings[userId].push({
          reason,
          warnedBy: interaction.user.username,
          timestamp: new Date().toISOString()
        });
        saveState();
        addLog('info', `User ${user.username} warned: ${reason}`);
        return interaction.reply({ content: `âš ï¸ **${user.username}** has been warned for: *${reason}*`, ephemeral: false });
      }

      // NEW: Warnings command
      case 'warnings': {
        const user = interaction.options.getUser('user');
        const userId = user.id;
        const userWarnings = warnings[userId] || [];
        
        if (userWarnings.length === 0) {
          return interaction.reply({ content: `âœ… **${user.username}** has no warnings` });
        }
        
        const warningsList = userWarnings.map((w, i) => `${i + 1}. **${w.reason}** - by ${w.warnedBy}`).join('\n');
        return interaction.reply({ content: `âš ï¸ **${user.username}** has ${userWarnings.length} warning(s):\n${warningsList}` });
      }

      // NEW: Set live message command
      case 'setlivemessage': {
        const message = interaction.options.getString('message');
        dashboardSettings.customLiveMessage = message;
        saveState();
        addLog('info', `Live message set to: ${message}`);
        return interaction.reply({
          content: `âœ… Live message updated!\n\nPreview:\n${message.replace('{role}', '<@&ROLE>').replace('{streamer}', 'YourName')}`,
          ephemeral: true
        });
      }

      // NEW: Set milestone alerts command
      case 'setmilestones': {
        const milestones = interaction.options.getString('milestones');
        try {
          const nums = milestones.split(',').map(m => parseInt(m.trim())).filter(m => m > 0);
          engagementSettings.viewerMilestones = nums.sort((a, b) => a - b);
          saveState();
          return interaction.reply({
            content: `âœ… Viewer milestones set to: ${nums.join(', ')}`,
            ephemeral: true
          });
        } catch (err) {
          return interaction.reply({
            content: `âŒ Invalid format. Use comma-separated numbers: 100,250,500,1000`,
            ephemeral: true
          });
        }
      }

      // NEW: Set offline threshold command
      case 'setofflinethreshold': {
        const seconds = interaction.options.getInteger('seconds');
        dashboardSettings.offlineThreshold = seconds * 1000;
        saveState();
        return interaction.reply({
          content: `âœ… Offline threshold set to ${seconds} seconds (${Math.round(seconds / 60)} minutes)`,
          ephemeral: true
        });
      }

      // NEW: Set alert roles command
      case 'setalertroles': {
        const roleType = interaction.options.getString('role_type');
        const role = interaction.options.getRole('role');
        
        if (!dashboardSettings.alertRoles) dashboardSettings.alertRoles = {};
        dashboardSettings.alertRoles[roleType] = role.id;
        saveState();
        
        return interaction.reply({
          content: `âœ… ${roleType} alerts will now ping <@&${role.id}>`,
          ephemeral: true
        });
      }

      case 'setlevelchannel': {
        const channel = interaction.options.getChannel('channel');
        if (channel) {
          dashboardSettings.levelUpChannelId = channel.id;
          saveState();
          return interaction.reply({ content: `âœ… Level-up alerts will now post in ${channel}.`, ephemeral: true });
        } else {
          dashboardSettings.levelUpChannelId = null;
          saveState();
          return interaction.reply({ content: 'âœ… Level-up alerts will now post in the channel where the user levels up.', ephemeral: true });
        }
      }

      // Leveling commands
      case 'leaderboard': {
        const top = Object.entries(leveling || {})
          .map(([id, data]) => ({
            id,
            level: Number(data?.level || 0),
            xp: Number(data?.xp || 0)
          }))
          .sort((a, b) => (b.level - a.level) || (b.xp - a.xp))
          .slice(0, 10);

        const lines = top.map((entry, idx) => {
          const medal = idx === 0 ? 'ðŸ¥‡' : idx === 1 ? 'ðŸ¥ˆ' : idx === 2 ? 'ðŸ¥‰' : `#${idx + 1}`;
          return `${medal} <@${entry.id}> â€” Level ${entry.level} (${entry.xp.toLocaleString()} XP)`;
        });

        const embed = new EmbedBuilder()
          .setColor(0x9146ff)
          .setTitle('ðŸ† Leveling Leaderboard')
          .setDescription(lines.join('\n') || 'No leveling data yet.')
          .setFooter({ text: 'Top 10 by level, then XP' });

        return interaction.reply({ embeds: [embed], ephemeral: true });
      }

      case 'rank': {
        const userId = interaction.options.getUser('user')?.id || interaction.user.id;
        const member = await interaction.guild.members.fetch(userId);
        const data = leveling[userId] || { xp: 0, level: 0 };

        const currentLevel = data.level || 0;
        const prevNeeded = currentLevel <= 0 ? 0 : getXpForLevel(currentLevel);
        const nextLevel = currentLevel + 1;
        const nextNeeded = getXpForLevel(nextLevel);
        const progress = Math.max(0, data.xp - prevNeeded);
        const span = Math.max(1, nextNeeded - prevNeeded);
        const percent = Math.min(100, Math.floor((progress / span) * 100));

        // Create prettier progress bar
        const barLength = 25;
        const filledLength = Math.round((percent / 100) * barLength);
        const progressBar = 'â–ˆ'.repeat(filledLength) + 'â–‘'.repeat(barLength - filledLength);
        const progressDisplay = `${progressBar} ${percent}%\n${data.xp}/${nextNeeded} XP`;

        // Compute next role reward (no pings)
        let nextRewardText = 'No upcoming rewards';
        if (levelingConfig?.roleRewards) {
          const nextReward = Object.entries(levelingConfig.roleRewards)
            .map(([lvl, rid]) => ({ lvl: Number(lvl), rid }))
            .filter(r => r.rid && !Number.isNaN(r.lvl) && r.lvl > currentLevel)
            .sort((a, b) => a.lvl - b.lvl)[0];

          if (nextReward) {
            let roleName = `Role ${nextReward.rid}`;
            try {
              const roleObj = await interaction.guild.roles.fetch(nextReward.rid);
              if (roleObj) roleName = roleObj.name;
            } catch (e) {
              // ignore fetch errors; fallback stays
            }
            nextRewardText = `${roleName} at level ${nextReward.lvl}`;
          }
        }

        const embed = new EmbedBuilder()
          .setColor(0x9146ff)
          .setTitle(`${member.displayName}`)
          .setThumbnail(member.displayAvatarURL())
          .addFields(
            { name: 'Level', value: String(currentLevel), inline: true },
            { name: 'XP', value: `${data.xp} / ${nextNeeded} (next)`, inline: true },
            { name: 'Next LV Progress', value: progressDisplay, inline: false },
            { name: 'Next Reward', value: nextRewardText, inline: false }
          )
        return interaction.reply({ embeds: [embed] });
      }
      case 'xp': {
        const userId = interaction.options.getUser('user')?.id || interaction.user.id;
        const user = await interaction.client.users.fetch(userId);
        const data = leveling[userId] || { xp: 0, level: 0 };

        const currentLevel = data.level || 0;
        const prevNeeded = currentLevel <= 0 ? 0 : getXpForLevel(currentLevel);
        const nextLevel = currentLevel + 1;
        const nextNeeded = getXpForLevel(nextLevel);
        const progress = Math.max(0, data.xp - prevNeeded);
        const span = Math.max(1, nextNeeded - prevNeeded);
        const percent = Math.min(100, Math.floor((progress / span) * 100));

        const embed = new EmbedBuilder()
          .setColor(0x9146ff)
          .setTitle(`XP for ${user.username}`)
          .setThumbnail(user.displayAvatarURL())
          .addFields(
            { name: 'Current XP', value: String(data.xp), inline: true },
            { name: 'Next Level XP', value: String(nextNeeded), inline: true },
            { name: 'Progress', value: `${percent}%`, inline: true }
          )
          .setFooter({ text: `Level ${currentLevel}` });

        return interaction.reply({ embeds: [embed] });
      }

      case 'addxp': {
        const targetUser = interaction.options.getUser('user');
        const amount = interaction.options.getInteger('amount');
        const userId = targetUser.id;

        if (!leveling[userId]) leveling[userId] = { xp: 0, level: 0, lastMsg: 0 };
        const prevXp = leveling[userId].xp;
        leveling[userId].xp += amount;
        saveState();

        const embed = new EmbedBuilder()
          .setColor(0x4caf50)
          .setTitle('XP Added')
          .setDescription(`Added **${amount}** XP to **${targetUser.username}**`)
          .addFields(
            { name: 'Previous XP', value: String(prevXp), inline: true },
            { name: 'New XP', value: String(leveling[userId].xp), inline: true },
            { name: 'Level', value: String(leveling[userId].level), inline: true }
          )
          .setThumbnail(targetUser.displayAvatarURL());

        addLog('info', `${interaction.user.username} added ${amount} XP to ${targetUser.username}`);
        return interaction.reply({ embeds: [embed], ephemeral: true });
      }
      case 'removexp': {
        const targetUser = interaction.options.getUser('user');
        const amount = interaction.options.getInteger('amount');
        const userId = targetUser.id;

        if (!leveling[userId]) leveling[userId] = { xp: 0, level: 0, lastMsg: 0 };
        const prevXp = leveling[userId].xp;
        leveling[userId].xp = Math.max(0, leveling[userId].xp - amount);
        saveState();

        const embed = new EmbedBuilder()
          .setColor(0xff6b6b)
          .setTitle('XP Removed')
          .setDescription(`Removed **${amount}** XP from **${targetUser.username}**`)
          .addFields(
            { name: 'Previous XP', value: String(prevXp), inline: true },
            { name: 'New XP', value: String(leveling[userId].xp), inline: true },
            { name: 'Level', value: String(leveling[userId].level), inline: true }
          )
          .setThumbnail(targetUser.displayAvatarURL());

        addLog('info', `${interaction.user.username} removed ${amount} XP from ${targetUser.username}`);
        return interaction.reply({ embeds: [embed], ephemeral: true });
      }
      case 'setlevel': {
        const targetUser = interaction.options.getUser('user');
        const newLevel = interaction.options.getInteger('level');
        const userId = targetUser.id;

        if (!leveling[userId]) leveling[userId] = { xp: 0, level: 0, lastMsg: 0 };
        const prevLevel = leveling[userId].level;
        leveling[userId].level = newLevel;
        saveState();

        const embed = new EmbedBuilder()
          .setColor(0x9146ff)
          .setTitle('Level Set')
          .setDescription(`Set **${targetUser.username}**'s level to **${newLevel}**`)
          .addFields(
            { name: 'Previous Level', value: String(prevLevel), inline: true },
            { name: 'New Level', value: String(newLevel), inline: true },
            { name: 'XP', value: String(leveling[userId].xp), inline: true }
          )
          .setThumbnail(targetUser.displayAvatarURL());

        addLog('info', `${interaction.user.username} set ${targetUser.username} level to ${newLevel}`);
        return interaction.reply({ embeds: [embed], ephemeral: true });
      }
      case 'levelconfig': {
        const cfg = levelingConfig;
        const multiplierStatus = cfg.xpMultiplier > 1 
          ? `${cfg.xpMultiplier}x (${cfg.multiplierEndTime ? 'ends ' + new Date(cfg.multiplierEndTime).toLocaleString() : 'indefinite'})` 
          : 'None (1x)';

        const embed = new EmbedBuilder()
          .setColor(0x9146ff)
          .setTitle('Leveling Configuration')
          .addFields(
            { name: 'Message XP', value: `${cfg.xpPerMessageMin}-${cfg.xpPerMessageMax} XP`, inline: true },
            { name: 'Message Cooldown', value: `${Math.round(cfg.messageCooldownMs / 1000)}s`, inline: true },
            { name: 'Voice XP', value: `${cfg.xpPerVoiceMinute} XP/min`, inline: true },
            { name: 'Reaction XP', value: `${cfg.xpPerReaction} XP`, inline: true },
            { name: 'XP Multiplier', value: multiplierStatus, inline: true },
            { name: 'Level Milestones', value: cfg.levelMilestones.join(', ') || 'None', inline: true }
          );

        return interaction.reply({ embeds: [embed], ephemeral: true });
      }
      case 'setxpmultiplier': {
        const multiplier = interaction.options.getNumber('multiplier');
        const hours = interaction.options.getInteger('hours');

        if (hours === 0) {
          levelingConfig.xpMultiplier = 1;
          levelingConfig.multiplierEndTime = null;
          saveState();
          return interaction.reply({ content: 'âœ… XP multiplier disabled (back to 1x)', ephemeral: true });
        }

        levelingConfig.xpMultiplier = multiplier;
        levelingConfig.multiplierEndTime = Date.now() + (hours * 60 * 60 * 1000);
        saveState();

        const endTime = new Date(levelingConfig.multiplierEndTime);
        return interaction.reply({ 
          content: `âœ… XP multiplier set to **${multiplier}x** for **${hours} hour(s)**\nEnds: <t:${Math.floor(endTime.getTime() / 1000)}:R>`, 
          ephemeral: true 
        });
      }
      case 'prestige': {
        const userId = interaction.user.id;
        const currentLevel = leveling[userId]?.level || 0;

        if (currentLevel < 10) {
          return interaction.reply({ content: 'âŒ You must reach level 10 to prestige', ephemeral: true });
        }

        if (!prestige[userId]) prestige[userId] = 0;
        prestige[userId]++;
        
        if (!leveling[userId]) leveling[userId] = { xp: 0, level: 0, lastMsg: 0 };
        leveling[userId].level = 0;
        leveling[userId].xp = 0;
        saveState();

        const embed = new EmbedBuilder()
          .setColor(0xffd700)
          .setTitle('ðŸŽ–ï¸ Prestige!')
          .setDescription(`${interaction.user.username} has reached prestige **${prestige[userId]}**!`)
          .addFields(
            { name: 'Previous Level', value: String(currentLevel), inline: true },
            { name: 'Prestige Rank', value: String(prestige[userId]), inline: true }
          );

        interaction.guild.channels.cache.forEach(channel => {
          if (channel.isTextBased() && channel.permissionsFor(interaction.guild.members.me).has('SendMessages')) {
            channel.send({ embeds: [embed] }).catch(() => {});
          }
        });

        addLog('info', `${interaction.user.username} reached prestige ${prestige[userId]}`);
        return interaction.reply({ embeds: [embed], ephemeral: true });
      }
      case 'weekly': {
        const now = Date.now();
        const weekAgo = now - (7 * 24 * 60 * 60 * 1000);

        const top = Object.entries(weeklyLeveling)
          .filter(([, d]) => d.lastGain >= weekAgo)
          .sort((a, b) => (b[1].xp - a[1].xp))
          .slice(0, 10);

        const lines = top.map(([id, d], i) => {
          const medal = i === 0 ? 'ðŸ¥‡' : i === 1 ? 'ðŸ¥ˆ' : i === 2 ? 'ðŸ¥‰' : `#${i+1}`;
          return `${medal} <@${id}> â€” ${d.xp} XP`;
        });

        const embed = new EmbedBuilder()
          .setColor(0x4caf50)
          .setTitle('ðŸ“Š Weekly Leaderboard (Last 7 days)')
          .setDescription(lines.join('\n') || 'No data yet.')
          .setFooter({ text: 'Top 10 by XP gained this week' });

        return interaction.reply({ embeds: [embed], ephemeral: true });
      }

      // ==================== GIVEAWAYS ====================
      case 'giveaway': {
        const prize = interaction.options.getString('prize');
        const winners = interaction.options.getInteger('winners');
        const duration = interaction.options.getInteger('duration');
        const channel = interaction.options.getChannel('channel') || interaction.channel;

        const giveawayId = `giveaway_${Date.now()}`;
        const endsAt = Date.now() + (duration * 60 * 1000);

        const embed = new EmbedBuilder()
          .setColor(0xFF6B9D)
          .setTitle('ðŸŽ‰ GIVEAWAY ðŸŽ‰')
          .setDescription(`**Prize:** ${prize}\n**Winners:** ${winners}\n**Ends:** <t:${Math.floor(endsAt / 1000)}:R>`)
          .setFooter({ text: `React with ðŸŽ‰ to enter | ID: ${giveawayId}` })
          .setTimestamp(endsAt);

        const msg = await channel.send({ embeds: [embed] });
        await msg.react('ðŸŽ‰');

        giveaways.push({
          id: giveawayId,
          messageId: msg.id,
          channelId: channel.id,
          prize,
          winners,
          endTime: endsAt,
          active: true,
          createdBy: interaction.user.id,
          entries: [],
          participants: []
        });
        saveState();

        addLog('info', `Giveaway started: ${prize} (${winners} winners, ${duration}min)`);
        return interaction.reply({ content: `âœ… Giveaway started in ${channel}!`, ephemeral: true });
      }
      case 'giveawayend': {
        const giveawayId = interaction.options.getString('giveaway_id');
        const giveaway = giveaways.find(g => g.id === giveawayId && g.active);

        if (!giveaway) {
          return interaction.reply({ content: 'âŒ Giveaway not found or already ended', ephemeral: true });
        }

        await endGiveaway(giveaway);
        return interaction.reply({ content: 'âœ… Giveaway ended!', ephemeral: true });
      }
      case 'giveawayreroll': {
        const giveawayId = interaction.options.getString('giveaway_id');
        const giveaway = giveaways.find(g => g.id === giveawayId);

        if (!giveaway) {
          return interaction.reply({ content: 'âŒ Giveaway not found', ephemeral: true });
        }

        try {
          const channel = await client.channels.fetch(giveaway.channelId);
          const msg = await channel.messages.fetch(giveaway.messageId);
          const reaction = msg.reactions.cache.get('ðŸŽ‰');
          
          if (!reaction) {
            return interaction.reply({ content: 'âŒ No participants found', ephemeral: true });
          }

          const users = await reaction.users.fetch();
          const participants = users.filter(u => !u.bot).map(u => u.id);

          if (participants.length === 0) {
            return interaction.reply({ content: 'âŒ No valid participants', ephemeral: true });
          }

          const rerollWinners = [];
          const winnerCount = Math.min(giveaway.winners, participants.length);
          const shuffled = participants.sort(() => Math.random() - 0.5);
          
          for (let i = 0; i < winnerCount; i++) {
            rerollWinners.push(shuffled[i]);
          }

          const winnerMentions = rerollWinners.map(id => `<@${id}>`).join(', ');
          const embed = new EmbedBuilder()
            .setColor(0xFFD700)
            .setTitle('ðŸŽ‰ Giveaway Rerolled!')
            .setDescription(`**Prize:** ${giveaway.prize}\n**New Winner(s):** ${winnerMentions}`)
            .setTimestamp();

          await channel.send({ embeds: [embed] });
          addLog('info', `Giveaway rerolled: ${giveaway.id}`);
          return interaction.reply({ content: 'âœ… Giveaway rerolled!', ephemeral: true });
        } catch (err) {
          addLog('error', `Giveaway reroll error: ${err.message}`);
          return interaction.reply({ content: 'âŒ Failed to reroll giveaway', ephemeral: true });
        }
      }
      case 'giveawaylist': {
        const active = giveaways.filter(g => g.active);
        
        if (active.length === 0) {
          return interaction.reply({ content: 'ðŸ“­ No active giveaways', ephemeral: true });
        }

        const lines = active.map(g => {
          const endsIn = Math.floor((g.endsAt - Date.now()) / 60000);
          return `**${g.id}** - ${g.prize} (${g.winners} winners, ends in ${endsIn}min)`;
        });

        const embed = new EmbedBuilder()
          .setColor(0xFF6B9D)
          .setTitle('ðŸŽ‰ Active Giveaways')
          .setDescription(lines.join('\n'));

        return interaction.reply({ embeds: [embed], ephemeral: true });
      }

      // ==================== POLLS ====================
      case 'poll': {
        const question = interaction.options.getString('question');
        const optionsStr = interaction.options.getString('options');
        const duration = interaction.options.getInteger('duration') || 0;
        const channel = interaction.options.getChannel('channel') || interaction.channel;

        const options = optionsStr.split('|').map(o => o.trim()).filter(o => o.length > 0);
        
        if (options.length < 2) {
          return interaction.reply({ content: 'âŒ Need at least 2 options (separate with |)', ephemeral: true });
        }
        if (options.length > 10) {
          return interaction.reply({ content: 'âŒ Maximum 10 options allowed', ephemeral: true });
        }

        const pollId = `poll_${Date.now()}`;
        const endsAt = duration > 0 ? Date.now() + (duration * 60 * 1000) : null;
        const emojis = ['1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ðŸ”Ÿ'];

        const optionsText = options.map((opt, i) => `${emojis[i]} ${opt}`).join('\n');
        const embed = new EmbedBuilder()
          .setColor(0x5865F2)
          .setTitle('ðŸ“Š ' + question)
          .setDescription(optionsText)
          .setFooter({ text: `ID: ${pollId}${endsAt ? ' | Ends' : ' | No time limit'}` });

        if (endsAt) {
          embed.setTimestamp(endsAt);
        }

        const msg = await channel.send({ embeds: [embed] });
        
        for (let i = 0; i < options.length; i++) {
          await msg.react(emojis[i]);
        }

        polls.push({
          id: pollId,
          messageId: msg.id,
          channelId: channel.id,
          question,
          options,
          endTime: endsAt,
          active: true,
          createdBy: interaction.user.id,
          votes: options.map(() => 0)
        });
        saveState();

        addLog('info', `Poll created: ${question} (${options.length} options)`);
        return interaction.reply({ content: `âœ… Poll created in ${channel}!`, ephemeral: true });
      }
      case 'pollend': {
        const pollId = interaction.options.getString('poll_id');
        const poll = polls.find(p => p.id === pollId && p.active);

        if (!poll) {
          return interaction.reply({ content: 'âŒ Poll not found or already ended', ephemeral: true });
        }

        await endPoll(poll);
        return interaction.reply({ content: 'âœ… Poll ended!', ephemeral: true });
      }
      case 'pollresults': {
        const pollId = interaction.options.getString('poll_id');
        const poll = polls.find(p => p.id === pollId);

        if (!poll) {
          return interaction.reply({ content: 'âŒ Poll not found', ephemeral: true });
        }

        try {
          const channel = await client.channels.fetch(poll.channelId);
          const msg = await channel.messages.fetch(poll.messageId);
          const emojis = ['1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ðŸ”Ÿ'];
          
          const results = [];
          let totalVotes = 0;

          for (let i = 0; i < poll.options.length; i++) {
            const reaction = msg.reactions.cache.get(emojis[i]);
            const count = reaction ? reaction.count - 1 : 0; // -1 for bot's reaction
            results.push({ option: poll.options[i], votes: count });
            totalVotes += count;
          }

          const resultsText = results
            .map(r => {
              const percentage = totalVotes > 0 ? Math.round((r.votes / totalVotes) * 100) : 0;
              const bar = 'â–ˆ'.repeat(Math.floor(percentage / 5));
              return `**${r.option}**\n${bar} ${r.votes} votes (${percentage}%)`;
            })
            .join('\n\n');

          const embed = new EmbedBuilder()
            .setColor(0x5865F2)
            .setTitle('ðŸ“Š Poll Results')
            .setDescription(`**${poll.question}**\n\n${resultsText}`)
            .setFooter({ text: `Total votes: ${totalVotes} | ID: ${poll.id}` });

          return interaction.reply({ embeds: [embed], ephemeral: true });
        } catch (err) {
          addLog('error', `Poll results error: ${err.message}`);
          return interaction.reply({ content: 'âŒ Failed to fetch poll results', ephemeral: true });
        }
      }
      case 'polllist': {
        const active = polls.filter(p => p.active);
        
        if (active.length === 0) {
          return interaction.reply({ content: 'ðŸ“­ No active polls', ephemeral: true });
        }

        const lines = active.map(p => {
          const timeInfo = p.endsAt ? `ends in ${Math.floor((p.endsAt - Date.now()) / 60000)}min` : 'no time limit';
          return `**${p.id}** - ${p.question} (${timeInfo})`;
        });

        const embed = new EmbedBuilder()
          .setColor(0x5865F2)
          .setTitle('ðŸ“Š Active Polls')
          .setDescription(lines.join('\n'));

        return interaction.reply({ embeds: [embed], ephemeral: true });
      }

      // ==================== REMINDERS ====================
      case 'remind': {
        const message = interaction.options.getString('message');
        const time = interaction.options.getInteger('time');
        const targetUser = interaction.options.getUser('user') || interaction.user;
        const channel = interaction.options.getChannel('channel') || interaction.channel;

        const reminderId = `reminder_${Date.now()}`;
        const reminderTime = Date.now() + (time * 60 * 1000);

        reminders.push({
          id: reminderId,
          message,
          userId: targetUser.id,
          channelId: channel.id,
          reminderTime,
          createdBy: interaction.user.id,
          active: true
        });
        saveState();

        addLog('info', `Reminder set: ${message} (${time}min for ${targetUser.username})`);
        return interaction.reply({ 
          content: `âœ… Reminder set for ${targetUser} in ${time} minutes!\n**Message:** ${message}\n**When:** <t:${Math.floor(reminderTime / 1000)}:R>`, 
          ephemeral: true 
        });
      }
      case 'reminders': {
        const userId = interaction.user.id;
        const userReminders = reminders.filter(r => r.userId === userId && r.active);

        if (userReminders.length === 0) {
          return interaction.reply({ content: 'ðŸ“­ You have no active reminders', ephemeral: true });
        }

        const lines = userReminders.map(r => {
          const timeLeft = Math.floor((r.reminderTime - Date.now()) / 60000);
          return `**${r.id}** - "${r.message}" (in ${timeLeft}min)`;
        });

        const embed = new EmbedBuilder()
          .setColor(0xFFA500)
          .setTitle('â° Your Reminders')
          .setDescription(lines.join('\n'));

        return interaction.reply({ embeds: [embed], ephemeral: true });
      }
      case 'cancelreminder': {
        const reminderId = interaction.options.getString('reminder_id');
        const reminder = reminders.find(r => r.id === reminderId && r.userId === interaction.user.id && r.active);

        if (!reminder) {
          return interaction.reply({ content: 'âŒ Reminder not found or already completed', ephemeral: true });
        }

        reminder.active = false;
        saveState();

        addLog('info', `Reminder cancelled: ${reminderId}`);
        return interaction.reply({ content: 'âœ… Reminder cancelled!', ephemeral: true });
      }

      // ==================== CUSTOM COMMANDS ====================
      case 'addcommand': {
        const name = interaction.options.getString('name').toLowerCase().replace(/^!/, '');
        const response = interaction.options.getString('response');

        if (customCommands.find(c => c.name === name)) {
          return interaction.reply({ content: `âŒ Command !${name} already exists`, ephemeral: true });
        }

        customCommands.push({ name, response, createdBy: interaction.user.id, uses: 0 });
        saveState();

        addLog('info', `Custom command added: !${name}`);
        return interaction.reply({ content: `âœ… Custom command !${name} created!`, ephemeral: true });
      }
      case 'removecommand': {
        const name = interaction.options.getString('name').toLowerCase().replace(/^!/, '');
        const index = customCommands.findIndex(c => c.name === name);

        if (index === -1) {
          return interaction.reply({ content: `âŒ Command !${name} not found`, ephemeral: true });
        }

        customCommands.splice(index, 1);
        saveState();

        addLog('info', `Custom command removed: !${name}`);
        return interaction.reply({ content: `âœ… Custom command !${name} removed!`, ephemeral: true });
      }
      case 'editcommand': {
        const name = interaction.options.getString('name').toLowerCase().replace(/^!/, '');
        const response = interaction.options.getString('response');
        const cmd = customCommands.find(c => c.name === name);

        if (!cmd) {
          return interaction.reply({ content: `âŒ Command !${name} not found`, ephemeral: true });
        }

        cmd.response = response;
        saveState();

        addLog('info', `Custom command edited: !${name}`);
        return interaction.reply({ content: `âœ… Custom command !${name} updated!`, ephemeral: true });
      }
      case 'cmd': {
        const name = interaction.options.getString('name').toLowerCase().replace(/^!/, '');
        const cmd = customCommands.find(c => c.name === name);
        if (!cmd) {
          return interaction.reply({ content: `âŒ Command !${name} not found`, ephemeral: true });
        }
        if (cmd.paused) {
          return interaction.reply({ content: `â¸ï¸ Command !${name} is paused`, ephemeral: true });
        }

        if (Array.isArray(cmd.allowedChannelIds) && cmd.allowedChannelIds.length > 0) {
          if (!cmd.allowedChannelIds.includes(interaction.channelId)) {
            return interaction.reply({ content: 'âŒ This command cannot be used in this channel.', ephemeral: true });
          }
        }
        if (Array.isArray(cmd.allowedRoleIds) && cmd.allowedRoleIds.length > 0) {
          const roles = interaction.member?.roles?.cache;
          const hasRole = roles && cmd.allowedRoleIds.some(r => roles.has(r));
          if (!hasRole) {
            return interaction.reply({ content: 'âŒ You do not have permission to use this command.', ephemeral: true });
          }
        }

        if (cmd.cooldownMs && cmd.cooldownMs > 0) {
          const key = cmd.name + ':' + interaction.user.id;
          const last = commandCooldowns.get(key) || 0;
          if (Date.now() - last < cmd.cooldownMs) {
            return interaction.reply({ content: 'â³ This command is on cooldown.', ephemeral: true });
          }
          commandCooldowns.set(key, Date.now());
        }

        const formattedResponse = formatCommandResponses(cmd);
        const payload = typeof formattedResponse === 'object' && formattedResponse !== null
          ? formattedResponse
          : { title: '', description: String(formattedResponse || ''), plain: String(formattedResponse || ''), imageUrl: cmd.imageUrl || '' };

        if (cmd.sendAsEmbed !== false) {
          const embed = new EmbedBuilder()
            .setColor(0x9146FF)
            .setTitle(payload.title || `ðŸ’¬ ${cmd.name} Command Response`)
            .setDescription(payload.description || '');

          const imageUrl = payload.imageUrl || cmd.imageUrl;
          let files = [];

          if (imageUrl) {
            const uploadsIndex = imageUrl.indexOf('/uploads/');
            if (uploadsIndex !== -1) {
              const filename = imageUrl.substring(uploadsIndex + '/uploads/'.length).split(/[?#]/)[0];
              const localPath = path.join(uploadsDir, filename);
              if (fs.existsSync(localPath)) {
                const attachment = new AttachmentBuilder(localPath, { name: filename });
                embed.setImage(`attachment://${filename}`);
                files = [attachment];
              } else {
                embed.setImage(imageUrl);
              }
            } else {
              embed.setImage(imageUrl);
            }
          }

          return interaction.reply({ embeds: [embed], files });
        }

        return interaction.reply({ content: payload.plain || '' });
      }
      case 'commands': {
        if (customCommands.length === 0) {
          return interaction.reply({ content: 'ðŸ“­ No custom commands created yet', ephemeral: true });
        }

        const lines = customCommands.map(c => `**!${c.name}** - Used ${c.uses} times`);
        const embed = new EmbedBuilder()
          .setColor(0x9146FF)
          .setTitle('ðŸ“ Custom Commands')
          .setDescription(lines.join('\n'))
          .setFooter({ text: `Total: ${customCommands.length} commands` });

        return interaction.reply({ embeds: [embed], ephemeral: true });
      }

      // ==================== NOTIFICATION FILTERS ====================
      case 'addfilter': {
        const keyword = interaction.options.getString('keyword').toLowerCase();
        const type = interaction.options.getString('type');
        const filterId = `filter_${Date.now()}`;

        notificationFilters.push({
          id: filterId,
          keyword,
          type,
          createdBy: interaction.user.id
        });
        saveState();

        addLog('info', `Notification filter added: ${keyword} (${type})`);
        return interaction.reply({ content: `âœ… Filter added! Notifications with "${keyword}" in ${type} will be suppressed.\n**ID:** ${filterId}`, ephemeral: true });
      }
      case 'removefilter': {
        const filterId = interaction.options.getString('filter_id');
        const index = notificationFilters.findIndex(f => f.id === filterId);

        if (index === -1) {
          return interaction.reply({ content: 'âŒ Filter not found', ephemeral: true });
        }

        notificationFilters.splice(index, 1);
        saveState();

        addLog('info', `Notification filter removed: ${filterId}`);
        return interaction.reply({ content: 'âœ… Filter removed!', ephemeral: true });
      }
      case 'filters': {
        if (notificationFilters.length === 0) {
          return interaction.reply({ content: 'ðŸ“­ No notification filters active', ephemeral: true });
        }

        const lines = notificationFilters.map(f => `**${f.id}** - "${f.keyword}" (${f.type})`);
        const embed = new EmbedBuilder()
          .setColor(0x95A5A6)
          .setTitle('ðŸ”• Notification Filters')
          .setDescription(lines.join('\n'))
          .setFooter({ text: `Total: ${notificationFilters.length} filters` });

        return interaction.reply({ embeds: [embed], ephemeral: true });
      }

      case 'rpg-test-mode': {
        rpgTestMode = !rpgTestMode;
        state.rpgTestMode = rpgTestMode;
        saveState();
        
        const embed = new EmbedBuilder()
          .setColor(rpgTestMode ? 0x00FF00 : 0xFF0000)
          .setTitle(rpgTestMode ? 'ðŸŸ¢ RPG TEST MODE ENABLED' : 'ðŸ”´ RPG TEST MODE DISABLED')
          .setDescription(rpgTestMode 
            ? 'âœ… Only RPG and dashboard commands are active.\n\nOther bot features are disabled to avoid duplicate actions while testing.\n\nPlayer data and progress are isolated to this test environment.'
            : 'âœ… All bot features are now active.\n\nYou can run stream alerts, custom commands, and other features alongside RPG commands.')
          .addFields(
            { name: 'Current Status', value: rpgTestMode ? 'ðŸŸ¢ RPG Only' : 'ðŸ”µ Full Bot', inline: true },
            { name: 'Available Commands', value: rpgTestMode ? '`/rpg`, `/leaderboard rpg`, `/dashboard`, `/rpg-test-mode`' : 'All commands', inline: true }
          )
          .setFooter({ text: 'Run this command again to toggle back' });

        addLog('info', `RPG Test Mode ${rpgTestMode ? 'ENABLED' : 'DISABLED'}`);
        return interaction.reply({ embeds: [embed], ephemeral: false });
      }

      case 'pet': {
        const sub = interaction.options.getSubcommand();
        const petsData = loadJSON(PETS_PATH, { pets: [], catalog: [] });

        if (sub === 'add') {
          const petId = interaction.options.getString('pet');
          const quantity = interaction.options.getInteger('quantity') || 1;
          const givenBy = interaction.user.displayName || interaction.user.username;
          const catalogEntry = (petsData.catalog || []).find(c => c.id === petId);
          if (!catalogEntry) {
            return interaction.reply({ content: 'âŒ Pet not found in catalog.', ephemeral: true });
          }
          petsData.pets = petsData.pets || [];
          for (let i = 0; i < quantity; i++) {
            petsData.pets.push({
              id: `pet-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
              petId,
              addedBy: interaction.user.id,
              addedByName: interaction.user.displayName || interaction.user.username,
              givenBy: givenBy,
              addedAt: new Date().toISOString()
            });
          }
          saveJSON(PETS_PATH, petsData);
          const ownedCount = petsData.pets.filter(p => p.petId === petId).length;
          addLog('info', `Pet "${catalogEntry.name}" x${quantity} added by ${interaction.user.username} (now x${ownedCount})`);

          const petEmbed = new EmbedBuilder()
            .setColor(catalogEntry.rarity === 'legendary' ? 0xf39c12 : catalogEntry.rarity === 'rare' ? 0x3498db : catalogEntry.rarity === 'uncommon' ? 0x2ecc71 : 0x8b8fa3)
            .setTitle(`${catalogEntry.emoji} ${quantity > 1 ? `${quantity}x ` : ''}New Pet Added!`)
            .setDescription(`**${catalogEntry.name}**${ownedCount > 1 ? ` (now x${ownedCount} total)` : ''}`)
            .addFields(
              { name: 'Rarity', value: catalogEntry.rarity.charAt(0).toUpperCase() + catalogEntry.rarity.slice(1), inline: true },
              { name: 'Added by', value: interaction.user.displayName || interaction.user.username, inline: true },
              { name: 'Owned', value: `x${ownedCount}`, inline: true },
              { name: 'ðŸŽ Given by', value: givenBy, inline: true },
              ...(catalogEntry.bonus ? [{ name: 'âš¡ Bonus', value: catalogEntry.bonus, inline: true }] : [])
            )
            .setFooter({ text: 'Use /pet list to see all server pets' });

          if (catalogEntry.animatedUrl || catalogEntry.imageUrl) {
            const imgUrl = catalogEntry.animatedUrl || catalogEntry.imageUrl;
            // Only set thumbnail if it's an absolute URL (Discord requires full URLs)
            if (imgUrl.startsWith('http')) {
              petEmbed.setThumbnail(imgUrl);
            }
          }

          const reply = await interaction.reply({ embeds: [petEmbed], fetchReply: true });
          setTimeout(() => reply.delete().catch(() => {}), 15000);
          return;
        }

        if (sub === 'list') {
          const pets = petsData.pets || [];
          if (pets.length === 0) {
            return interaction.reply({ content: 'ðŸ¾ No pets in the collection yet! Use `/pet add` to add the first one.', ephemeral: false });
          }

          const catalog = petsData.catalog || [];
          const categories = petsData.categories || [...new Set(catalog.map(p => p.category).filter(Boolean))];
          const catIcons = { 'Legacy Companions': 'ðŸ›ï¸', 'Fallen Spirits': 'ðŸ‘»', 'Shallow Waters': 'ðŸŒŠ', 'Exclusive Companions': 'â­' };

          // Group owned pets by category
          const grouped = {};
          for (const p of pets) {
            const cat = catalog.find(c => c.id === p.petId);
            const category = cat?.category || 'Other';
            if (!grouped[category]) grouped[category] = [];
            grouped[category].push(p);
          }

          const lines = [];
          for (const cat of categories) {
            if (!grouped[cat] || grouped[cat].length === 0) continue;
            lines.push(`\n**${catIcons[cat] || 'ðŸ“‚'} ${cat}**`);
            for (const p of grouped[cat]) {
              const entry = catalog.find(c => c.id === p.petId);
              const emoji = entry?.emoji || 'ðŸ¾';
              const name = entry?.name || p.petId;
              const rarity = entry?.rarity || 'common';
              const rarityIcon = rarity === 'legendary' ? 'â­' : rarity === 'rare' ? 'ðŸ’Ž' : rarity === 'uncommon' ? 'ðŸŸ¢' : 'âšª';
              // Group duplicates: count how many of same petId
              const alreadyListed = lines.find(l => l.includes(`**${emoji} ${name}**`));
              if (alreadyListed) continue;
              const pCount = pets.filter(pp => pp.petId === p.petId).length;
              lines.push(`${rarityIcon} **${emoji} ${name}**${pCount > 1 ? ` x${pCount}` : ''}${entry?.bonus ? ` â€” âš¡ ${entry.bonus}` : ''}`);
            }
          }

          const listEmbed = new EmbedBuilder()
            .setColor(0x9146ff)
            .setTitle('ðŸ¾ Server Pet Collection')
            .setDescription(lines.join('\n').trim())
            .setFooter({ text: `${pets.length} pet${pets.length !== 1 ? 's' : ''} total â€¢ Use /pet add to add more` });

          const listReply = await interaction.reply({ embeds: [listEmbed], fetchReply: true });
          setTimeout(() => listReply.delete().catch(() => {}), 30000);
          return;
        }

        if (sub === 'remove') {
          // Admin only
          if (!interaction.memberPermissions?.has(PermissionsBitField.Flags.Administrator)) {
            return interaction.reply({ content: 'âŒ Only administrators can remove pets.', ephemeral: true });
          }
          const petId = interaction.options.getString('pet');
          const quantity = interaction.options.getInteger('quantity') || 1;
          const catalogEntry = (petsData.catalog || []).find(c => c.id === petId);
          if (!catalogEntry) {
            return interaction.reply({ content: 'âŒ Pet not found in catalog.', ephemeral: true });
          }
          petsData.pets = petsData.pets || [];
          let removedCount = 0;
          for (let i = 0; i < quantity; i++) {
            const idx = petsData.pets.findIndex(p => p.petId === petId);
            if (idx === -1) break;
            petsData.pets.splice(idx, 1);
            removedCount++;
          }
          if (removedCount === 0) {
            return interaction.reply({ content: `âŒ No **${catalogEntry.emoji} ${catalogEntry.name}** in the collection to remove.`, ephemeral: true });
          }
          saveJSON(PETS_PATH, petsData);
          const remainCount = petsData.pets.filter(p => p.petId === petId).length;
          addLog('info', `Pet "${catalogEntry.name}" x${removedCount} removed by ${interaction.user.username} (${remainCount} remaining)`);
          const reply = await interaction.reply({ content: `âœ… Removed **${removedCount}x ${catalogEntry.emoji} ${catalogEntry.name}**${remainCount > 0 ? ` (${remainCount} remaining)` : ' (none left)'}`, fetchReply: true });
          setTimeout(() => reply.delete().catch(() => {}), 10000);
          return;
        }

        return interaction.reply({ content: 'âŒ Unknown subcommand.', ephemeral: true });
      }

      default:
        return interaction.reply({ content: 'Unknown command', ephemeral: true });
    }
  } catch (err) {
    addLog('error', `Command error (${interaction.commandName}): ${err.message}`);
    console.error(err);
    
    // Try to reply - but handle case where already replied
    try {
      if (interaction.deferred) {
        return await interaction.editReply({ content: `âŒ Error: ${err.message}` });
      } else {
        return await interaction.reply({ content: `âŒ Error: ${err.message}`, ephemeral: true });
      }
    } catch (replyErr) {
      addLog('error', `Failed to send error reply: ${replyErr.message}`);
    }
  }
});
 // end interactionCreate

const commandCooldowns = new Map();
const slashCommandCooldowns = new Map();

function logCommandUsage(commandKey, user) {
  const key = String(commandKey || '').toLowerCase();
  if (!key) return;
  if (!commandUsage[key]) {
    commandUsage[key] = { total: 0, lastUsed: null, history: [], userCounts: {} };
  }
  const entry = commandUsage[key];
  entry.total = (entry.total || 0) + 1;
  entry.lastUsed = new Date().toISOString();
  if (!Array.isArray(entry.history)) entry.history = [];
  entry.history.unshift({
    userId: user?.id || 'unknown',
    username: user?.username || 'Unknown',
    timestamp: entry.lastUsed
  });
  if (entry.history.length > 200) entry.history = entry.history.slice(0, 200);

  if (!entry.userCounts) entry.userCounts = {};
  const uKey = user?.id || 'unknown';
  if (!entry.userCounts[uKey]) entry.userCounts[uKey] = { count: 0, username: user?.username || 'Unknown' };
  entry.userCounts[uKey].count += 1;
  entry.userCounts[uKey].username = user?.username || entry.userCounts[uKey].username;

  saveState();
}

function isCommandAllowed(cmd, msg) {
  if (Array.isArray(cmd.allowedChannelIds) && cmd.allowedChannelIds.length > 0) {
    if (!cmd.allowedChannelIds.includes(msg.channel.id)) return false;
  }
  if (Array.isArray(cmd.allowedRoleIds) && cmd.allowedRoleIds.length > 0) {
    const memberRoles = msg.member?.roles?.cache;
    if (!memberRoles) return false;
    const hasRole = cmd.allowedRoleIds.some(r => memberRoles.has(r));
    if (!hasRole) return false;
  }
  return true;
}

function formatCommandResponses(cmd) {
  const rawLines = [];
  if (Array.isArray(cmd.response)) {
    cmd.response.forEach(r => {
      const line = String(r || '').trim();
      if (line) rawLines.push(line);
    });
  } else if (typeof cmd.response === 'string') {
    cmd.response.split('\n').forEach(r => {
      const line = String(r || '').trim();
      if (line) rawLines.push(line);
    });
  }

  const isImageUrl = (url) => /\.(png|jpe?g|gif|webp)(\?|#|$)/i.test(url);
  const urlRegex = /https?:\/\/\S+/gi;
  const textLines = [];
  const linkLines = [];
  let imageUrl = '';

  rawLines.forEach(line => {
    const urls = (line.match(urlRegex) || []).map(u => u.trim());
    if (!urls.length) {
      textLines.push(line);
      return;
    }

    urls.forEach(url => {
      if (!imageUrl && isImageUrl(url)) {
        imageUrl = url;
      } else if (!isImageUrl(url)) {
        linkLines.push(url);
      }
    });
  });

  const title = textLines.shift() || '';
  const description = (linkLines.length ? linkLines : textLines).join('\n');

  return {
    title,
    description,
    plain: rawLines.join('\n'),
    imageUrl: cmd.imageUrl || imageUrl
  };
}

async function sendCommandResponse(cmd, msg, contentText) {
  const messages = [];
  if (cmd.sendAsEmbed !== false) {
    const payload = typeof contentText === 'object' && contentText !== null
      ? contentText
      : { title: '', description: String(contentText || ''), plain: String(contentText || '') };
    const embed = new EmbedBuilder()
      .setColor(0x9146FF)
      .setTitle(payload.title || `ðŸ’¬ ${cmd.name} Command Response`)
      .setDescription(payload.description || '');
    const imageUrl = payload.imageUrl || cmd.imageUrl;
    let files = [];
    if (imageUrl) {
      const uploadsIndex = imageUrl.indexOf('/uploads/');
      if (uploadsIndex !== -1) {
        const filename = imageUrl.substring(uploadsIndex + '/uploads/'.length).split(/[?#]/)[0];
        const localPath = path.join(uploadsDir, filename);
        if (fs.existsSync(localPath)) {
          const attachment = new AttachmentBuilder(localPath, { name: filename });
          embed.setImage(`attachment://${filename}`);
          files = [attachment];
        } else {
          embed.setImage(imageUrl);
        }
      } else {
        embed.setImage(imageUrl);
      }
    }
    const replyMessage = await msg.reply({ embeds: [embed], files });
    messages.push(replyMessage);
  } else {
    const plain = (typeof contentText === 'object' && contentText !== null) ? contentText.plain : contentText;
    const replyMessage = await msg.reply({ content: plain || '' });
    messages.push(replyMessage);
    if (cmd.imageUrl) {
      const imageMsg = await msg.channel.send({ files: [{ attachment: cmd.imageUrl }] });
      messages.push(imageMsg);
    }
  }

  if (cmd.autoDeleteDelayMs && cmd.autoDeleteDelayMs > 0) {
    setTimeout(() => {
      messages.forEach(m => m.delete().catch(() => {}));
      if (msg.deletable) msg.delete().catch(() => {});
    }, cmd.autoDeleteDelayMs);
  }
}

client.on('messageCreate', async (msg) => {
  if (msg.author.bot || !msg.guild) return;
  
  // ==================== CUSTOM COMMANDS ====================
  if (msg.content.startsWith('!')) {
    const contentAfterPrefix = msg.content.slice(1).trim();
    
    // Try to find custom command - check longest names first to handle spaces
    let cmd = null;
    let cmdName = null;
    
    // Sort custom commands by name length (longest first) to match phrases before single words
    const sortedCmds = [...customCommands].sort((a, b) => (b.name?.length || 0) - (a.name?.length || 0));
    
    for (const customCmd of sortedCmds) {
      if (contentAfterPrefix.toLowerCase().startsWith(customCmd.name.toLowerCase())) {
        // Check if it's a complete command (followed by space or end of string)
        const afterCmd = contentAfterPrefix.slice(customCmd.name.length);
        if (afterCmd === '' || afterCmd[0] === ' ') {
          cmd = customCmd;
          cmdName = customCmd.name;
          break;
        }
      }
    }
    
    addLog('info', `Custom command check: cmdName=${cmdName}, found=${!!cmd}, total=${customCommands.length}`);
    
    if (cmd) {
      if (cmd.paused) return;
      if (!isCommandAllowed(cmd, msg)) return;

      const now = Date.now();
      if (cmd.cooldownMs && cmd.cooldownMs > 0) {
        const key = cmd.name + ':' + msg.author.id;
        const last = commandCooldowns.get(key) || 0;
        if (now - last < cmd.cooldownMs) return;
        commandCooldowns.set(key, now);
      }

      cmd.uses = (cmd.uses || 0) + 1;
      
      // Track usage history
      if (!cmd.usageHistory) cmd.usageHistory = [];
      cmd.usageHistory.unshift({
        userId: msg.author.id,
        username: msg.author.username,
        displayName: msg.member?.displayName || msg.author.username,
        timestamp: new Date().toISOString()
      });
      // Keep only last 10
      if (cmd.usageHistory.length > 10) cmd.usageHistory = cmd.usageHistory.slice(0, 10);
      
      saveState();
      
      const formattedResponse = formatCommandResponses(cmd);
      await sendCommandResponse(cmd, msg, formattedResponse);

      const cmdIndex = customCommands.findIndex(c => c.name === cmd.name);
      if (cmdIndex >= 0 && cmd.autoDeleteAfterUses && cmd.uses >= cmd.autoDeleteAfterUses) {
        const removed = customCommands.splice(cmdIndex, 1)[0];
        saveState();
        addLog('info', `Custom command auto-deleted after ${removed.autoDeleteAfterUses} uses: !${removed.name}`);
        if (msg.deletable) {
          msg.delete().catch(() => {});
        }
      }

      return;
    }
  }
  
  // ==================== LEVELING SYSTEM ====================
  const userId = msg.author.id;
  if (!leveling[userId]) leveling[userId] = { xp: 0, level: 0, lastMsg: 0 };
  const now = Date.now();

  const cooldown = levelingConfig?.messageCooldownMs ?? 45000;
  if (now - (leveling[userId].lastMsg || 0) < cooldown) return;
  leveling[userId].lastMsg = now;

  const min = levelingConfig?.xpPerMessageMin ?? 15;
  const max = levelingConfig?.xpPerMessageMax ?? 25;
  const spread = Math.max(0, max - min);
  let xpGain = min + Math.floor(Math.random() * (spread + 1));
  
  // Apply global XP multiplier if active
  const now2 = Date.now();
  if (levelingConfig?.xpMultiplier && levelingConfig.xpMultiplier > 1) {
    if (!levelingConfig.multiplierEndTime || now2 < levelingConfig.multiplierEndTime) {
      xpGain = Math.floor(xpGain * levelingConfig.xpMultiplier);
    } else {
      levelingConfig.xpMultiplier = 1;
      levelingConfig.multiplierEndTime = null;
    }
  }
  
  // Apply per-user XP multiplier
  if (leveling[userId].xpMultiplier && leveling[userId].xpMultiplier > 1) {
    xpGain = Math.floor(xpGain * leveling[userId].xpMultiplier);
  }
  
  leveling[userId].xp += xpGain;
  
  // Track weekly XP
  if (!weeklyLeveling[userId]) weeklyLeveling[userId] = { xp: 0, lastGain: now };
  weeklyLeveling[userId].xp += xpGain;
  weeklyLeveling[userId].lastGain = now;

  const checkMilestones = (level) => {
    const milestones = levelingConfig?.levelMilestones || [10, 25, 50, 100];
    return milestones.includes(level);
  };

  const playerLabel = dashboardSettings.levelUpPingPlayer !== false ? `<@${userId}>` : `**${msg.author.username}**`;

  let leveledUp = false;
  let lastLevel = leveling[userId].level;

  // Resolve target channel for level-up notifications
  let levelChannel = msg.channel;
  if (dashboardSettings.levelUpChannelId) {
    try {
      const ch = await msg.client.channels.fetch(dashboardSettings.levelUpChannelId);
      if (ch && ch.isTextBased()) levelChannel = ch;
    } catch (e) {
      addLog('warn', `Level-up channel fetch failed: ${e.message}`);
    }
  }
  const safeSend = async (content) => { try { await levelChannel.send(content); } catch (_) {} };

  while (true) {
    const nextLevel = leveling[userId].level + 1;
    const needed = getXpForLevel(nextLevel);
    if (leveling[userId].xp < needed) break;

    leveling[userId].level++;
    lastLevel = leveling[userId].level;
    leveledUp = true;

    // Auto-prestige thresholds
    const nextRank = (prestige[userId] || 0) + 1;
    const threshold = levelingConfig?.prestigeThresholds?.[nextRank];
    if (threshold && leveling[userId].level >= threshold.levelRequired) {
      prestige[userId] = nextRank;
      leveling[userId].level = 1;
      leveling[userId].xp = 0;

      if (threshold.roleId && msg.guild) {
        try {
          const member = msg.member || await msg.guild.members.fetch(userId);
          const role = await msg.guild.roles.fetch(threshold.roleId);
          if (member && role && !member.roles.cache.has(role.id)) {
            await member.roles.add(role.id);
            await safeSend(`ðŸŽ–ï¸ ${playerLabel} reached Prestige ${nextRank}! Granted role **${role.name}** and reset to Level 1.`);
          } else {
            await safeSend(`ðŸŽ–ï¸ ${playerLabel} reached Prestige ${nextRank}! Level reset to 1.`);
          }
        } catch (err) {
          addLog('error', `Prestige role assignment failed: ${err.message}`);
          await safeSend(`ðŸŽ–ï¸ ${playerLabel} reached Prestige ${nextRank}! Level reset to 1.`);
        }
      } else {
        await safeSend(`ðŸŽ–ï¸ ${playerLabel} reached Prestige ${nextRank}! Level reset to 1.`);
      }
      saveState();
      break;
    }
  }

  if (leveledUp) {
    const newLevel = lastLevel;
    await safeSend(`ðŸŽ‰ ${playerLabel} leveled up to **${newLevel}**!`);

    if (checkMilestones(newLevel)) {
      const prestigeRank = prestige[userId] || 0;
      await safeSend(`ðŸ† **MILESTONE!** ${playerLabel} reached **Level ${newLevel}** (Prestige: ${prestigeRank})!`);
    }

    const rewardRoleId = levelingConfig?.roleRewards?.[String(newLevel)] || levelingConfig?.roleRewards?.[newLevel];
    addLog('info', `Level up check: userId=${userId}, level=${newLevel}, roleRewards=${JSON.stringify(levelingConfig?.roleRewards || {})}, rewardRoleId=${rewardRoleId}`);

    if (rewardRoleId && msg.guild) {
      try {
        const member = msg.member || await msg.guild.members.fetch(userId);
        const role = msg.guild.roles.cache.get(rewardRoleId) || await msg.guild.roles.fetch(rewardRoleId);
        if (member && role && !member.roles.cache.has(role.id)) {
          await member.roles.add(role.id);
          await safeSend(`ðŸ… Awarded role **${role.name}** for reaching level ${newLevel}!`);
          addLog('info', `Assigned role ${role.name} (${role.id}) to ${msg.author.username} for level ${newLevel}`);
        }
      } catch (err) {
        addLog('error', `Failed to assign level role: ${err.message}`);
      }
    }
  }

  saveState();
});

// Voice activity tracking for XP
const voiceXpTracker = {};
client.on('voiceStateUpdate', async (oldState, newState) => {
  try {
    const userId = newState.id;
    
    // User joined voice
    if (!oldState.channel && newState.channel) {
      voiceXpTracker[userId] = Date.now();
    }
    // User left voice
    else if (oldState.channel && !newState.channel) {
      const joinedAt = voiceXpTracker[userId];
      if (!joinedAt) return;
      
      const timeInVoice = Math.floor((Date.now() - joinedAt) / 60000); // minutes
      if (timeInVoice < 1) return; // minimum 1 minute
      
      if (!leveling[userId]) leveling[userId] = { xp: 0, level: 0, lastMsg: 0 };
      
      let xpGain = timeInVoice * (levelingConfig?.xpPerVoiceMinute ?? 5);
      
      // Apply multiplier
      if (levelingConfig?.xpMultiplier && levelingConfig.xpMultiplier > 1) {
        if (!levelingConfig.multiplierEndTime || Date.now() < levelingConfig.multiplierEndTime) {
          xpGain = Math.floor(xpGain * levelingConfig.xpMultiplier);
        }
      }
      
      leveling[userId].xp += xpGain;
      
      // Track weekly
      if (!weeklyLeveling[userId]) weeklyLeveling[userId] = { xp: 0, lastGain: Date.now() };
      weeklyLeveling[userId].xp += xpGain;
      weeklyLeveling[userId].lastGain = Date.now();
      
      saveState();
      delete voiceXpTracker[userId];
      
      addLog('info', `Voice XP: ${userId} gained ${xpGain} XP for ${timeInVoice}m in voice`);
    }
  } catch (err) {
    addLog('error', `Voice XP tracking error: ${err.message}`);
  }
});

// Reaction tracking for XP
client.on('messageReactionAdd', async (reaction, user) => {
  try {
    if (user.bot) return;
    
    const userId = user.id;
    if (!leveling[userId]) leveling[userId] = { xp: 0, level: 0, lastMsg: 0 };
    
    let xpGain = levelingConfig?.xpPerReaction ?? 2;
    
    // Apply multiplier
    if (levelingConfig?.xpMultiplier && levelingConfig.xpMultiplier > 1) {
      if (!levelingConfig.multiplierEndTime || Date.now() < levelingConfig.multiplierEndTime) {
        xpGain = Math.floor(xpGain * levelingConfig.xpMultiplier);
      }
    }
    
    leveling[userId].xp += xpGain;
    
    // Track weekly
    if (!weeklyLeveling[userId]) weeklyLeveling[userId] = { xp: 0, lastGain: Date.now() };
    weeklyLeveling[userId].xp += xpGain;
    weeklyLeveling[userId].lastGain = Date.now();
    
    saveState();
  } catch (err) {
    addLog('error', `Reaction XP tracking error: ${err.message}`);
  }
});

/* ======================
   TWITCH AUTH & HELPERS
====================== */

function computeNextScheduledStream(force = false) {
  try {
    // ensure schedule exists
    if (!schedule) schedule = {};
    if (!schedule.alertsSent) schedule.alertsSent = { oneHour: false, tenMin: false };

    // skip if no stream today unless forced
    if (schedule.noStreamToday && !force) return;

    schedule.noStreamToday = false;
    schedule.alertsEnabledToday = true;
    schedule.alertsSent = { oneHour: false, tenMin: false };

    const now = Date.now();
    const nowParts = getTimeZoneParts(new Date(now), botTimezone);
    const localNow = new Date(Date.UTC(
      nowParts.year,
      nowParts.month - 1,
      nowParts.day,
      nowParts.hour,
      nowParts.minute,
      nowParts.second
    ));

    let nextUtcMs = null;
    for (let offset = 0; offset < 7; offset += 1) {
      const dayIndex = (localNow.getUTCDay() + offset) % 7;
      const isWeekend = dayIndex === 0 || dayIndex === 6;
      const hour = isWeekend ? 14 : 17;

      const candidateLocal = new Date(localNow.getTime());
      candidateLocal.setUTCDate(candidateLocal.getUTCDate() + offset);

      const candidateUtcMs = zonedTimeToUtcMillis({
        year: candidateLocal.getUTCFullYear(),
        month: candidateLocal.getUTCMonth() + 1,
        day: candidateLocal.getUTCDate(),
        hour,
        minute: 0,
        second: 0
      }, botTimezone);

      if (candidateUtcMs > now) {
        nextUtcMs = candidateUtcMs;
        break;
      }
    }

    if (!nextUtcMs) {
      nextUtcMs = zonedTimeToUtcMillis({
        year: localNow.getUTCFullYear(),
        month: localNow.getUTCMonth() + 1,
        day: localNow.getUTCDate() + 7,
        hour: 17,
        minute: 0,
        second: 0
      }, botTimezone);
    }

    const next = new Date(nextUtcMs);
    schedule.nextStreamAt = next.toISOString();
    saveState();

    addLog(
      'info',
      `Next stream scheduled for ${next.toLocaleString('en-US', { timeZone: botTimezone })}`
    );
  } catch (err) {
    addLog('error', 'computeNextScheduledStream failed: ' + err.message);
  }
}

// Shows the next alert
function getNextAlertInfo() {
  if (!schedule || schedule.noStreamToday) {
    return {
      status: 'CANCELLED',
      nextAlert: null,
      timeRemaining: null
    };
  }

  if (schedule.streamDelayed) {
    return {
      status: 'DELAYED',
      nextAlert: null,
      timeRemaining: null
    };
  }

  if (!schedule.nextStreamAt) {
    return {
      status: 'NOT SCHEDULED',
      nextAlert: null,
      timeRemaining: null
    };
  }

  const now = Date.now();
  const streamTime = new Date(schedule.nextStreamAt).getTime();

  const alerts = [];

  if (!schedule.alertsSent?.oneHour) {
    alerts.push({
      type: '1 hour',
      time: streamTime - 60 * 60 * 1000
    });
  }

  if (!schedule.alertsSent?.tenMin) {
    alerts.push({
      type: '10 minutes',
      time: streamTime - 10 * 60 * 1000
    });
  }

  const upcoming = alerts
    .filter(a => a.time > now)
    .sort((a, b) => a.time - b.time)[0];

  if (!upcoming) {
    return {
      status: 'NO UPCOMING ALERTS',
      nextAlert: null,
      timeRemaining: null
    };
  }

  const diffMs = upcoming.time - now;
  const minutes = Math.floor(diffMs / 60000);
  const seconds = Math.floor((diffMs % 60000) / 1000);

  return {
    status: 'SCHEDULED',
    nextAlert: upcoming.type,
    timeRemaining: `${minutes}m ${seconds}s`
  };
}

function getNextScheduledStream() {
  if (!schedule.weekly) return null;
  // Helper: compute next occurrence UTC ms for a weekly entry (supports {hour,minute} or legacy numeric ts)
  const computeNextForEntry = (dayName, entry) => {
    const nowMs = Date.now();

    // Determine hour/minute
    let hour = 0, minute = 0;
    if (entry && typeof entry === 'object' && Number.isFinite(entry.hour)) {
      hour = Number(entry.hour);
      minute = Number(entry.minute) || 0;
    } else if (Number.isFinite(Number(entry))) {
      const sample = new Date(Number(entry));
      hour = sample.getHours();
      minute = sample.getMinutes();
    } else {
      return null;
    }

    const map = { sunday:0, monday:1, tuesday:2, wednesday:3, thursday:4, friday:5, saturday:6 };
    const dayIndex = map[dayName.toLowerCase()];
    if (dayIndex === undefined) return null;

    return getNextOccurrenceUtcMs(botTimezone, dayIndex, hour, minute, nowMs);
  };

  const upcoming = Object.entries(schedule.weekly || {})
    .map(([day, entry]) => ({ day, ts: computeNextForEntry(day, entry) }))
    .filter(e => e && Number.isFinite(e.ts))
    .sort((a, b) => a.ts - b.ts);

  return upcoming[0] || null;
}

function maybeDailyReset() {
  const today = getNowInBotTimezone().toISOString().slice(0, 10);

  if (today !== lastResetDate) {
    schedule.alertsSent = { oneHour: false, tenMin: false };
    schedule.noStreamToday = false;
    schedule.streamDelayed = false;
    schedule.alertsEnabledToday = true;

    lastResetDate = today;
    state.lastResetDate = today;
    saveState();
    addLog('info', 'Daily reset completed');
  }
}

/* ======================
   ANNOUNCEMENTS
====================== */

// Helper function to get role for notification type
const getRoleOrDefault = (notifType) => {
  return config.notificationRoles[notifType] || config.ROLE_ID;
};

// Helper function to get channel for notification type
const getChannelOrDefault = (notifType) => {
  return config.notificationChannels[notifType] || config.CUSTOM_CHANNEL_ID || process.env.DISCORD_CHANNEL_ID;
};

// NEW: Send embed notification
async function sendEmbedNotification(title, description, color, notificationType = 'liveAlert') {
  try {
    // Check if notification is enabled
    if (config.notificationEnabled[notificationType] === false) {
      addLog('info', `${notificationType} notification disabled, skipping`);
      return;
    }

    const channelId = getChannelOrDefault(notificationType);
    const channel = await client.channels.fetch(channelId);
    if (!channel) return;

    const embed = new EmbedBuilder()
      .setTitle(title)
      .setDescription(description)
      .setColor(color)
      .setTimestamp();

    const roleId = getRoleOrDefault(notificationType);
    const shouldPing = config.notificationPing[notificationType] !== false;
    const content = (roleId && shouldPing) ? `<@&${roleId}> ` : '';
    const msg = await channel.send({ content, embeds: [embed] });
    
    // Auto-delete if enabled for this notification type
    const autoDeleteKey = 'autoDelete' + notificationType.charAt(0).toUpperCase() + notificationType.slice(1);
    const shouldAutoDelete = engagementSettings[autoDeleteKey];
    const deleteDelay = engagementSettings.autoDeleteDelay || 60000;
    
    if (shouldAutoDelete) {
      setTimeout(() => {
        msg.delete().catch(err => addLog('warn', `Could not auto-delete ${notificationType} message: ${err.message}`));
      }, deleteDelay);
      addLog('info', `${notificationType} message scheduled for auto-delete in ${deleteDelay/1000}s`);
    }
  } catch (err) {
    addLog('error', `Failed to send embed notification: ${err.message}`);
  }
}
function buildLiveEmbed(){ return new EmbedBuilder().setColor(0x9146FF).setTitle(`${process.env.STREAMER_LOGIN} is LIVE ðŸ”´`).setURL(`https://twitch.tv/${process.env.STREAMER_LOGIN}`).setDescription(streamInfo.title||'Live now!').addFields({name:'ðŸŽ® Game',value:streamInfo.game||'Unknown',inline:true},{name:'ðŸ‘€ Viewers',value:String(streamInfo.viewers),inline:true}).setImage(streamInfo.thumbnail).setFooter({text:'Twitch Live Notification'}).setTimestamp(); }
function buildOfflineEmbed(){ return new EmbedBuilder().setColor(0x2f3136).setTitle(`${process.env.STREAMER_LOGIN} is OFFLINE âš«`).setDescription('Stream has ended').setTimestamp(); }

async function announceLive(isTest=false,autoDelete=false){
  // Check if notification is enabled
  if (!isTest && config.notificationEnabled.liveAlert === false) {
    addLog('info', 'Live notification disabled, skipping');
    return;
  }

  // NEW: Check cooldown to prevent spam
  if (!isTest && isOnCooldown('livAnnounce', 300000)) {
    addLog('info', 'Live announcement on cooldown, skipping');
    return;
  }

  const channelId = getChannelOrDefault('liveAlert');
  const channel = await client.channels.fetch(channelId);
  if(!channel) return;
  
  // CLEAN CHANNEL: Delete previous bot messages and unpin old announcement
  try {
    const messages = await channel.messages.fetch({ limit: 50 });
    const botMessages = messages.filter(m => m.author.id === client.user.id);
    
    // Unpin the old announcement if it exists
    if (announcementMessageId) {
      const oldMsg = botMessages.get(announcementMessageId);
      if (oldMsg && oldMsg.pinned) {
        await oldMsg.unpin();
        addLog('info', 'Unpinned old announcement');
      }
    }
    
    // Delete all bot messages in the channel
    for (const [, msg] of botMessages) {
      try {
        await msg.delete();
      } catch (err) {
        addLog('warn', `Could not delete message: ${err.message}`);
      }
    }
    addLog('info', 'Cleaned announcement channel');
  } catch (err) {
    addLog('warn', 'Could not clean channel: ' + err.message);
  }
  
  const roleId = getRoleOrDefault('liveAlert');
  const shouldPing = config.notificationPing.liveAlert !== false; // default true
  const rolePing = (roleId && shouldPing) ? `<@&${roleId}> ` : '';
  
  let content;
  if (dashboardSettings.customLiveMessage) {
    // Replace placeholders in custom message
    content = dashboardSettings.customLiveMessage
      .replace('{streamer}', process.env.STREAMER_LOGIN)
      .replace('{role}', rolePing);
  } else {
    content = rolePing + `ðŸ”´ **${process.env.STREAMER_LOGIN} is LIVE!**`;
  }
  
  if (isTest) content += ' *(test)*';
  
  const embed = buildLiveEmbed();
  const msg = await channel.send({content,embeds:[embed]});
  
  // PIN the live announcement
  try {
    await msg.pin();
    addLog('info', 'Pinned live announcement');
  } catch (err) {
    addLog('warn', 'Could not pin message: ' + err.message);
  }
  
  announcementMessageId = msg.id; saveState(); addLog('announce','Announcement sent');
  logNotification('live', `${process.env.STREAMER_LOGIN} went live`, { game: streamInfo.game, viewers: streamInfo.viewer });
  setCooldown('liveAnnounce');
  io.emit('streamUpdate', streamInfo);
  if(autoDelete){ setTimeout(()=>msg.delete().catch(()=>{}),60000); }
}

/* ======================
   SCHEDULE ALERTS
====================== */
async function sendScheduleAlert(type, isTest = false) {
  
  // Check if notification is enabled
  if (!isTest && config.notificationEnabled.scheduleAlert === false) {
    addLog('info', 'Schedule alert notification disabled, skipping');
    return;
  }

  // â›” Don't send schedule alerts if stream is already live
  // (unless it's a manual test)
  if (!isTest && streamInfo.startedAt) {
    addLog('info', `Skipped ${type} alert â€” stream already live`);
    return;
  }

  if (!client.isReady()) {
    throw new Error('Discord client not ready yet');
  }

  try {
    const channelId = getChannelOrDefault('scheduleAlert');
    const channel = await client.channels.fetch(channelId);
    if (!channel) throw new Error('Channel not found');

    const label = type === 'oneHour' ? '1 hour' : '10 minutes';

    const roleId = getRoleOrDefault('scheduleAlert');
    const shouldPing = config.notificationPing.scheduleAlert !== false;
    const content =
      (!isTest && roleId && shouldPing ? `<@&${roleId}> ` : '') +
      `â° **Stream starts in ${label}!**` +
      (isTest ? ' *(test)*' : '');

    await channel.send({ content });

    if (!isTest) {
      schedule.alertsSent[type] = true;
      saveState();
    }

    addLog('info', `Schedule alert sent: ${label}${isTest ? ' (test)' : ''}`);
  } catch (err) {
    addLog('error', `Schedule alert failed: ${err.message}`);
    throw err;
  }
}
/* ======================
   STREAM CHECK
====================== */
// Track game changes during a live stream
function trackStreamGameChange(newGame) {
  try {
    if (!Array.isArray(currentStreamGameTimeline)) currentStreamGameTimeline = [];
    const now = Date.now();

    // Close the previous segment (if any)
    if (currentStreamGameTimeline.length > 0) {
      const last = currentStreamGameTimeline[currentStreamGameTimeline.length - 1];
      if (last && !last.endMs) last.endMs = now;
    }

    // Start a new segment for the new game
    currentStreamGameTimeline.push({
      streamId: lastStreamId || null,
      game: (newGame || 'Unknown').toString(),
      startMs: now,
      endMs: null
    });

    streamMetadata.lastGame = newGame;
    streamMetadata.gameChangeDetected = true;
    addLog('info', `Game changed -> ${newGame}`);
    saveState();
  } catch (err) {
    addLog('error', `trackStreamGameChange failed: ${err?.message || err}`);
  }
}

// NEW: Update stream info and detect changes
function updateStreamInfo(data) {
  if (!data.data || !data.data[0]) return;

  const stream = data.data[0];
  const newTitle = stream.title;
  const newGame = stream.game_name;
  const newViewers = stream.viewer_count;

  // If we're live, start tracking game segments (and record changes)
  if (isLive) {
    ensureCurrentStreamGameTimelineInitialized(newGame);
    if (streamMetadata.lastGame !== null && streamMetadata.lastGame !== newGame) {
      trackStreamGameChange(newGame);
    }
  }

  // Update current stream info
  streamInfo.title = newTitle;
  streamInfo.game = newGame;
  streamInfo.viewers = newViewers;
  streamInfo.thumbnail = stream.thumbnail_url?.replace('{width}', '320').replace('{height}', '180');
  streamInfo.startedAt = stream.started_at;

  // NEW: Track activity (viewers by hour)
  trackActivity(newViewers);

  // NEW: Track viewers over time during stream
  trackStreamViewers(newViewers);

  // Track follower count over time (non-blocking)
  fetchChannelInfo().then(channelData => {
    if (channelData && channelData.followers !== undefined) {
      const now = new Date().toISOString();
      if (!followerHistory.length || Date.now() - new Date(followerHistory[followerHistory.length-1].timestamp).getTime() > 300000) {
        followerHistory.push({ timestamp: now, count: channelData.followers });
        if (followerHistory.length > 500) followerHistory = followerHistory.slice(-500);
        debouncedSaveState();
      }
    }
  }).catch(() => {});

  // Track stats
  if (newViewers > stats.peakViewers) {
    stats.peakViewers = newViewers;
  }

  // Keep the most recent history entry in sync while live
  if (history.length > 0) {
    const last = history[history.length - 1];
    if (last && last.duration === null && last.startedAt === streamInfo.startedAt) {
      last.viewers = newViewers;
      last.game = newGame;
      last.title = newTitle;
      last.peakViewers = Math.max(last.peakViewers ?? 0, newViewers);
      if (currentStreamViewerData.length > 0) {
        const avg = Math.round(currentStreamViewerData.reduce((sum, p) => sum + (p.viewers || 0), 0) / currentStreamViewerData.length);
        last.avgViewers = isFinite(avg) ? avg : (last.avgViewers ?? last.viewers ?? 0);
      }
      saveState();
    }
  }

  // Check viewer milestones
  const milestones = engagementSettings.viewerMilestones || [100, 250, 500, 1000];
  if (!dashboardSettings.hitMilestonesThisStream) dashboardSettings.hitMilestonesThisStream = {};
  
  for (const milestone of milestones) {
    if (newViewers >= milestone && !dashboardSettings.hitMilestonesThisStream[milestone]) {
      dashboardSettings.hitMilestonesThisStream[milestone] = true;
      addLog('milestone', `ðŸŽ‰ Hit ${milestone} viewers!`);
      
      // Send milestone notification if channel is set and notification is enabled
      if (config.notificationEnabled.viewerMilestone !== false && process.env.DISCORD_CHANNEL_ID) {
        const channelId = getChannelOrDefault('viewerMilestone');
        client.channels.fetch(channelId).then(channel => {
          const roleId = getRoleOrDefault('viewerMilestone');
          const shouldPing = config.notificationPing.viewerMilestone !== false;
          const content = (roleId && shouldPing) 
            ? `<@&${roleId}> ðŸŽ‰ We just hit **${milestone}** viewers!`
            : `ðŸŽ‰ We just hit **${milestone}** viewers!`;
          
          channel.send({
            content,
            embeds: [{
              color: 0xFFD700,
              title: 'ðŸŽ‰ Viewer Milestone!',
              fields: [
                { name: 'Milestone', value: String(milestone), inline: true },
                { name: 'Current Viewers', value: String(newViewers), inline: true }
              ]
            }]
          }).then(msg => {
            // Auto-delete if enabled
            if (engagementSettings.autoDeleteViewerMilestone) {
              const deleteDelay = engagementSettings.autoDeleteDelay || 60000;
              setTimeout(() => {
                msg.delete().catch(err => addLog('warn', `Could not auto-delete viewer milestone message: ${err.message}`));
              }, deleteDelay);
              addLog('info', `Viewer milestone message scheduled for auto-delete in ${deleteDelay/1000}s`);
            }
          });
        }).catch(err => addLog('error', 'Failed to send milestone notification: ' + err.message));
      }
    }
  }

  // Detect title change
  if (streamMetadata.lastTitle !== null && streamMetadata.lastTitle !== newTitle) {
    streamMetadata.titleChangeDetected = true;
    addLog('info', `Stream title changed: "${streamMetadata.lastTitle}" â†’ "${newTitle}"`);
  }
  streamMetadata.lastTitle = newTitle;

  // Detect game change
  if (streamMetadata.lastGame !== null && streamMetadata.lastGame !== newGame) {
    streamMetadata.gameChangeDetected = true;
    addLog('info', `Game changed: "${streamMetadata.lastGame}" â†’ "${newGame}"`);
  }
  streamMetadata.lastGame = newGame;
}

// NEW: Fetch Twitch channel info for followers and subs
async function fetchChannelInfo() {
  try {
    const res = await fetch(
      `https://api.twitch.tv/helix/channels?broadcaster_id=${BROADCASTER_ID}`,
      {
        headers: {
          'Client-ID': process.env.TWITCH_CLIENT_ID,
          'Authorization': `Bearer ${TWITCH_ACCESS_TOKEN}`
        }
      }
    );
    const data = await res.json();
    if (data.data?.[0]) {
      const channel = data.data[0];
      return {
        followers: channel.follower_count || 0,
        language: channel.language,
        category: channel.game_name
      };
    }
  } catch (err) {
    addLog('error', 'Failed to fetch channel info: ' + err.message);
  }
  return null;
}

// ==================== GIVEAWAY HELPER ====================
async function getGiveawayParticipants(giveaway) {
  const channel = await client.channels.fetch(giveaway.channelId);
  let participants = [];
  const allowedRoles = Array.isArray(giveaway.allowedRoleIds) ? giveaway.allowedRoleIds : [];

  if (allowedRoles.length > 0) {
    participants = await getRoleBasedGiveawayParticipants(giveaway);
  } else {
    const msg = await channel.messages.fetch(giveaway.messageId);
    const reaction = msg.reactions.cache.get('ðŸŽ‰');
    if (!reaction) return [];
    const users = await reaction.users.fetch();
    participants = users.filter(u => !u.bot).map(u => u.id);
  }

  return participants;
}

async function endGiveaway(giveaway) {
  try {
    const channel = await client.channels.fetch(giveaway.channelId);
    let participants = [];
    const allowedRoles = Array.isArray(giveaway.allowedRoleIds) ? giveaway.allowedRoleIds : [];

    if (allowedRoles.length > 0) {
      participants = await getRoleBasedGiveawayParticipants(giveaway);
    } else {
      const msg = await channel.messages.fetch(giveaway.messageId);
      const reaction = msg.reactions.cache.get('ðŸŽ‰');
      if (!reaction) {
        await channel.send(`âŒ Giveaway ended but no participants found for: **${giveaway.prize}**`);
        giveaway.active = false;
        saveState();
        return;
      }
      const users = await reaction.users.fetch();
      participants = users.filter(u => !u.bot).map(u => u.id);
    }

    const eligible = await getEligibleGiveawayParticipants(giveaway, participants);

    if (eligible.length === 0) {
      await channel.send(`âŒ Giveaway ended but no valid participants for: **${giveaway.prize}**`);
      giveaway.active = false;
      saveState();
      return;
    }

    const winners = [];
    const winnerCount = Math.min(giveaway.winners, eligible.length);
    const shuffled = eligible.sort(() => Math.random() - 0.5);
    
    for (let i = 0; i < winnerCount; i++) {
      winners.push(shuffled[i]);
    }

    const winnerMentions = winners.map(id => `<@${id}>`).join(', ');
    const claimContact = (config.giveawayClaimContact || '').trim() || 'Contact <@284616307482165249> or <@150381666257469441> to claim your prize.';
    const resolvedColor = (giveaway.embedColor || config.giveawayDefaultColor || '').replace('#', '').trim();
    const parsedColor = resolvedColor ? parseInt(resolvedColor, 16) : NaN;
    const embedColorInt = Number.isFinite(parsedColor) ? parsedColor : 0xFFD700;
    const embed = new EmbedBuilder()
      .setColor(embedColorInt)
      .setTitle('ðŸŽ‰ Giveaway Ended!')
      .setDescription(`**Prize:** ${giveaway.prize}\n**Winner(s):** ${winnerMentions}\n\nCongratulations!\n\n*${claimContact}*`)
      .setTimestamp();

    if (giveaway.imageUrl) {
      embed.setImage(giveaway.imageUrl);
    }

    await channel.send({ content: winnerMentions, embeds: [embed] });
    
    giveaway.active = false;
    giveaway.winners = winners;
    saveState();
    
    addLog('info', `Giveaway ended: ${giveaway.id} - ${winners.length} winner(s)`);

    if (config.giveawayLogChannelId) {
      try {
        const logChannel = await client.channels.fetch(config.giveawayLogChannelId);
        if (logChannel && logChannel.send) {
          await logChannel.send({ embeds: [new EmbedBuilder()
            .setColor(embedColorInt)
            .setTitle('ðŸŽ‰ Giveaway Ended')
            .setDescription(`**Prize:** ${giveaway.prize}\n**Winners:** ${winnerMentions}\n**ID:** ${giveaway.id}`)
            .setTimestamp()
          ] });
        }
      } catch {}
    }
  } catch (err) {
    addLog('error', `Failed to end giveaway ${giveaway.id}: ${err.message}`);
  }
}

async function getRoleBasedGiveawayParticipants(giveaway) {
  const allowedRoles = Array.isArray(giveaway.allowedRoleIds) ? giveaway.allowedRoleIds : [];
  if (allowedRoles.length === 0) return [];

  const guildId = process.env.GUILD_ID || process.env.DISCORD_GUILD_ID;
  if (!guildId) return [];

  try {
    const guild = await client.guilds.fetch(guildId);
    const ids = new Set();
    for (const roleId of allowedRoles) {
      try {
        const role = await guild.roles.fetch(roleId);
        if (role) {
          role.members.forEach(m => { if (!m.user.bot) ids.add(m.id); });
        }
      } catch {}
    }
    return Array.from(ids);
  } catch {
    return [];
  }
}

async function getEligibleGiveawayParticipants(giveaway, participants) {
  let eligible = participants.slice();
  const excluded = new Set(giveaway.excludedUserIds || []);
  eligible = eligible.filter(id => !excluded.has(id));

  if (giveaway.excludePreviousWinners) {
    const previousWinners = new Set(getAllGiveawayWinnerIds());
    eligible = eligible.filter(id => !previousWinners.has(id));
  }

  const staffRoleIds = Array.isArray(giveaway.excludeStaffRoleIds) ? giveaway.excludeStaffRoleIds : [];
  const minAccountAgeDays = Number(giveaway.minAccountAgeDays) || 0;
  const minLevel = Number(giveaway.minLevel) || 0;
  const minXp = Number(giveaway.minXp) || 0;
  const shouldCheckMembers = (staffRoleIds.length > 0)
    || (giveaway.excludeBots !== false)
    || (minAccountAgeDays > 0)
    || (minLevel > 0)
    || (minXp > 0);
  if (shouldCheckMembers) {
    const guildId = process.env.GUILD_ID || process.env.DISCORD_GUILD_ID;
    const guild = guildId ? await client.guilds.fetch(guildId) : client.guilds.cache.first();
    const filtered = [];

    for (const id of eligible) {
      try {
        const member = guild.members.cache.get(id) || await guild.members.fetch(id);
        if (!member) continue;
        if (giveaway.excludeBots !== false && member.user.bot) continue;
        if (staffRoleIds.length > 0 && member.roles.cache.some(r => staffRoleIds.includes(r.id))) continue;
        if (minAccountAgeDays > 0) {
          const ageMs = Date.now() - member.user.createdTimestamp;
          const ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));
          if (ageDays < minAccountAgeDays) continue;
        }
        if (minLevel > 0 || minXp > 0) {
          const data = leveling[id] || { level: 0, xp: 0 };
          if (minLevel > 0 && Number(data.level) < minLevel) continue;
          if (minXp > 0 && Number(data.xp) < minXp) continue;
        }
        filtered.push(id);
      } catch {
        // Skip members we can't resolve
      }
    }
    eligible = filtered;
  }

  return eligible;
}

function getAllGiveawayWinnerIds() {
  const ids = new Set();
  for (const g of giveaways) {
    if (Array.isArray(g.winners)) {
      g.winners.forEach(id => ids.add(id));
    } else if (g.winner) {
      ids.add(g.winner);
    }
  }
  return Array.from(ids);
}

// ==================== POLL HELPER ====================
async function endPoll(poll) {
  try {
    const channel = await client.channels.fetch(poll.channelId);
    const msg = await channel.messages.fetch(poll.messageId);
    const emojis = ['1ï¸âƒ£', '2ï¸âƒ£', '3ï¸âƒ£', '4ï¸âƒ£', '5ï¸âƒ£', '6ï¸âƒ£', '7ï¸âƒ£', '8ï¸âƒ£', '9ï¸âƒ£', 'ðŸ”Ÿ'];
    
    const results = [];
    let totalVotes = 0;

    for (let i = 0; i < poll.options.length; i++) {
      const reaction = msg.reactions.cache.get(emojis[i]);
      const count = reaction ? reaction.count - 1 : 0; // -1 for bot's reaction
      results.push({ option: poll.options[i], votes: count });
      totalVotes += count;
    }

    const resultsText = results
      .map(r => {
        const percentage = totalVotes > 0 ? Math.round((r.votes / totalVotes) * 100) : 0;
        const bar = 'â–ˆ'.repeat(Math.floor(percentage / 5));
        return `**${r.option}**\n${bar} ${r.votes} votes (${percentage}%)`;
      })
      .join('\n\n');

    const winner = results.length ? results.slice().sort((a, b) => b.votes - a.votes)[0] : null;

    const embed = new EmbedBuilder()
      .setColor(0x5865F2)
      .setTitle('ðŸ“Š Poll Ended!')
      .setDescription(`**${poll.question}**\n\n${resultsText}`)
      .addFields({ name: 'ðŸ† Winner', value: winner ? winner.option : 'N/A', inline: true })
      .setFooter({ text: `Total votes: ${totalVotes}` })
      .setTimestamp();

    await channel.send({ embeds: [embed] });
    
    poll.active = false;
    poll.results = results;
    saveState();
    
    addLog('info', `Poll ended: ${poll.id} - ${totalVotes} total votes`);
  } catch (err) {
    addLog('error', `Failed to end poll ${poll.id}: ${err.message}`);
  }
}

// ==================== BACKGROUND PROCESSES ====================
async function checkGiveaways() {
  const now = Date.now();
  for (const giveaway of giveaways) {
    if (giveaway.paused) continue;
    if (giveaway.active && giveaway.endTime <= now) {
      await endGiveaway(giveaway);
    }
  }
}

async function checkPolls() {
  const now = Date.now();
  for (const poll of polls) {
    if (poll.active && poll.endTime && poll.endTime <= now) {
      await endPoll(poll);
    }
  }
}

async function checkReminders() {
  const now = Date.now();
  for (const reminder of reminders) {
    if (reminder.active && reminder.reminderTime <= now) {
      try {
        if (!reminder.channelId) {
          throw new Error('No channel ID set for reminder');
        }
        
        const channel = await client.channels.fetch(reminder.channelId);
        
        let messageContent = '';
        let embed = new EmbedBuilder()
          .setColor(0xFFA500)
          .setTitle('â° Reminder!')
          .setDescription(`You asked to be reminded:\n\n**${reminder.message}**`)
          .setFooter({ text: `Set by ${reminder.createdBy}` })
          .setTimestamp();

        // Only mention user if userId exists (not from dashboard)
        if (reminder.userId) {
          try {
            const user = await client.users.fetch(reminder.userId);
            messageContent = `<@${reminder.userId}>`;
            embed.setDescription(`${user}, you asked to be reminded:\n\n**${reminder.message}**`);
          } catch (err) {
            messageContent = '';
          }
        }

        await channel.send({ content: messageContent, embeds: [embed] });
        
        reminder.active = false;
        saveState();
        
        addLog('info', `Reminder sent: ${reminder.id}`);
      } catch (err) {
        addLog('error', `Failed to send reminder ${reminder.id}: ${err.message}`);
        reminder.active = false;
        saveState();
      }
    }
  }
}

function finalizeStreamViewerData() {
  if (!currentStreamViewerData || currentStreamViewerData.length === 0) {
    return { peakViewers: 0, avgViewers: 0 };
  }
  
  const viewers = currentStreamViewerData.map(p => p.viewers || 0);
  const peakViewers = Math.max(...viewers);
  const avgViewers = Math.round(viewers.reduce((a, b) => a + b, 0) / viewers.length);
  
  return { peakViewers, avgViewers };
}

function finalizeStreamGameTimeline(endTime) {
  if (!currentStreamGameTimeline || currentStreamGameTimeline.length === 0) {
    return { totals: {} };
  }
  
  const totals = {};
  currentStreamGameTimeline.forEach(entry => {
    const game = entry.game || 'Unknown';
    const startTime = new Date(entry.startedAt).getTime();
    const endTimeMs = entry.endedAt ? new Date(entry.endedAt).getTime() : endTime;
    const durationSec = Math.max(0, Math.floor((endTimeMs - startTime) / 1000));
    
    totals[game] = (totals[game] || 0) + durationSec;
  });
  
  return { totals };
}

// Check and send schedule alerts automatically
async function checkScheduleAlerts() {
  try {
    // Don't send alerts if canceled, delayed, or no stream scheduled
    if (schedule.noStreamToday || schedule.streamDelayed) {
      return;
    }

    const now = Date.now();
    const nextComputed = getNextScheduledStream();
    const streamTime = (nextComputed && Number.isFinite(nextComputed.ts))
      ? Number(nextComputed.ts)
      : (schedule.nextStreamAt ? new Date(schedule.nextStreamAt).getTime() : null);
    if (!streamTime) return;

    const computedIso = (nextComputed && Number.isFinite(nextComputed.ts))
      ? new Date(streamTime).toISOString()
      : null;
    if (computedIso && schedule.nextStreamAt !== computedIso) {
      schedule.nextStreamAt = computedIso;
      saveState();
    }

    // Check for 1 hour alert
    if (!schedule.alertsSent?.oneHour) {
      const oneHourBefore = streamTime - 60 * 60 * 1000;
      if (now >= oneHourBefore && now < oneHourBefore + 120000) { // Within 2 minute window
        await sendScheduleAlert('oneHour');
      }
    }

    // Check for 10 minute alert
    if (!schedule.alertsSent?.tenMin) {
      const tenMinBefore = streamTime - 10 * 60 * 1000;
      if (now >= tenMinBefore && now < tenMinBefore + 120000) { // Within 2 minute window
        await sendScheduleAlert('tenMin');
      }
    }
  } catch (err) {
    addLog('error', 'checkScheduleAlerts failed: ' + err.message);
  }
}

async function checkStream() {
  maybeDailyReset();
  if (isCheckingStream) {
    addLog('info', 'checkStream skipped (already running)');
    return;
  }

  isCheckingStream = true;

  // ðŸ§  FIX: Always normalize first
  normalizeSchedule();

  // âœ… Ensure today's schedule exists
  if (!schedule.nextStreamAt && !schedule.noStreamToday) {
    computeNextScheduledStream();
  }

  try {
    let res, data;
    try {
      res = await fetch(
        `https://api.twitch.tv/helix/streams?user_id=${BROADCASTER_ID}`,
        {
          headers: {
            'Client-ID': process.env.TWITCH_CLIENT_ID,
            'Authorization': `Bearer ${TWITCH_ACCESS_TOKEN}`
          }
        }
      );
    } catch (err) {
      addLog('error', `Fetch error from Twitch API: ${err.message}`);
      return;
    }

    try {
      data = await res.json();
    } catch (err) {
      addLog('error', `Failed to parse Twitch API response: ${err.message}`);
      return;
    }

    // Extra logging for debugging
    addLog('info', `Twitch API response: ${JSON.stringify(data).substring(0, 500)}`);

    // Safety check for API response
    if (!data || !Array.isArray(data.data)) {
      addLog('error', `Invalid API response from Twitch: ${JSON.stringify(data).substring(0, 500)}`);
      return;
    }

    updateStreamInfo(data);

    const liveNow = data.data.length > 0;

    // ======================
    // STREAM IS LIVE
    // ======================
    if (liveNow) {

      // âœ… Reset delayed state if stream starts late
      if (schedule.streamDelayed) {
        addLog('info', 'Stream went live after delay â€” resetting delayed state');
        schedule.streamDelayed = false;
        saveState();
      }

      schedule.alertsSent.oneHour = true;
      schedule.alertsSent.tenMin = true;
      saveState();

      const streamId = data.data[0].id;

      if (!isLive || lastStreamId !== streamId) {
        if (suppressNextAnnounce) {
          addLog('info', 'LIVE detected but announcement suppressed');
          suppressNextAnnounce = false;
          isLive = true;
          lastStreamId = streamId;
          saveState();
          return;
        }

        isLive = true;
        lastStreamId = streamId;
        addLog('live', 'OFFLINE â†’ LIVE detected');
        streamMetadata.streamStartTime = new Date().toISOString();

        // Delete the old stream end message if it exists
        if (announcementMessageId && process.env.DISCORD_CHANNEL_ID) {
          try {
            const channel = await client.channels.fetch(process.env.DISCORD_CHANNEL_ID);
            const oldMsg = await channel.messages.fetch(announcementMessageId).catch(() => null);
            if (oldMsg) {
              await oldMsg.delete();
              addLog('info', 'Deleted old stream end message');
            }
          } catch (err) {
            addLog('warn', 'Could not delete old message: ' + err.message);
          }
        }
        announcementMessageId = null;

        // Reset per-stream game timeline
        currentStreamGameTimeline = [];
        ensureCurrentStreamGameTimelineInitialized(streamInfo.game);

        // Reset RPG events per-stream tracking
        rpgEvents.triggeredThisStream = {};
        rpgEvents.activeEvents = [];
        
        // Add to history
        history.push({
          streamId,
          startedAt: streamInfo.startedAt,
          viewers: streamInfo.viewers,
          peakViewers: streamInfo.viewers,
          avgViewers: streamInfo.viewers,
          game: streamInfo.game,
          title: streamInfo.title,
          gameSegments: [],
          endedAt: null,
          duration: null // Will be calculated when stream ends
        });
        
        await announceLive();
        recomputeStreamStatsFromHistory();
        saveState();
      } else if (streamMetadata.titleChangeDetected || streamMetadata.gameChangeDetected) {
        // Update the live announcement message with new title/game
        if (announcementMessageId) {
          try {
            const channel = await client.channels.fetch(process.env.DISCORD_CHANNEL_ID);
            const msg = await channel.messages.fetch(announcementMessageId);
            const updatedEmbed = buildLiveEmbed();
            await msg.edit({ embeds: [updatedEmbed] });
            addLog('info', 'Live announcement updated with title/game changes');
          } catch (err) {
            addLog('error', 'Failed to update announcement: ' + err.message);
          }
        }
        
        // Send notifications
        if (streamMetadata.titleChangeDetected && engagementSettings.titleChangeNotif) {
          await sendEmbedNotification(
            `ðŸ“ **Stream Title Updated**`,
            `New title: *${streamInfo.title}*`,
            0x9146FF,
            'titleChange'
          );
          streamMetadata.titleChangeDetected = false;
        }
        if (streamMetadata.gameChangeDetected && engagementSettings.gameChangeNotif) {
          await sendEmbedNotification(
            `ðŸŽ® **Game Changed**`,
            `Now playing: *${streamInfo.game}*`,
            0x9146FF,
            'gameChange'
          );
          streamMetadata.gameChangeDetected = false;
        }
        saveState();
      }

      // Check for viewer milestones
      const viewerMilestones = engagementSettings.viewerMilestones || [100, 250, 500, 1000];
      const nextMilestone = viewerMilestones.find(m => m > (engagementSettings.lastViewerMilestone || 0) && m <= streamInfo.viewers);
      if (nextMilestone) {
        engagementSettings.lastViewerMilestone = nextMilestone;
        await sendEmbedNotification(
          `ðŸŽ‰ **Milestone Reached!**`,
          `We hit **${nextMilestone}** viewers!`,
          0xFFD700
        );
        saveState();
      }

      // Check RPG milestone events
      checkRPGMilestoneEvents(streamInfo.viewers);

      // Expire finished RPG events
      expireRPGEvents();

      return; // â›” IMPORTANT: stop here if live
    }

    // ======================
    // STREAM IS OFFLINE
    // ======================
    addLog('info', `Offline check | isLive=${isLive}`);

    // If we're currently live but stream appears offline, start the offline timer
    if (isLive && !liveNow) {
      if (!offlineDetectedAt) {
        offlineDetectedAt = Date.now();
        addLog('info', `Stream went offline, waiting ${dashboardSettings.offlineThreshold / 1000}s before marking offline`);
        return; // Don't mark offline yet
      }

      // Check if we've waited long enough before marking offline
      const offlineFor = Date.now() - offlineDetectedAt;
      if (offlineFor < dashboardSettings.offlineThreshold) {
        addLog('info', `Still within offline threshold (${Math.floor(offlineFor / 1000)}s / ${Math.floor(dashboardSettings.offlineThreshold / 1000)}s)`);
        return;
      }

      // Now mark as offline
      addLog('offline', 'Offline threshold exceeded, marking stream as offline');
    } else if (isLive && liveNow) {
      // Stream came back online, reset timer
      if (offlineDetectedAt) {
        offlineDetectedAt = null;
        addLog('info', 'Stream came back online, offline timer reset');
      }
    } else if (!isLive) {
      // Stream is already offline, reset timer
      offlineDetectedAt = null;
    }

    if (isLive) {
      if (announcementMessageId) {
        try {
          const channel = await client.channels.fetch(process.env.DISCORD_CHANNEL_ID);
          const msg = await channel.messages.fetch(announcementMessageId);
          
          // Unpin the live message before editing it to stream end
          if (msg.pinned) {
            try {
              await msg.unpin();
              addLog('info', 'Unpinned live message before editing to stream end');
            } catch (err) {
              addLog('warn', 'Could not unpin live message: ' + err.message);
            }
          }
          
          // Finalize viewer graph history BEFORE resetting IDs
          const finalizedGraph = finalizeStreamViewerData();

          // Finalize game timeline
          const finalizedGames = finalizeStreamGameTimeline(Date.now());
          
          // Get user info for VOD link
          const broadcasterLogin = process.env.TWITCH_BROADCASTER_LOGIN || 'unknown';
          const vodUrl = `https://twitch.tv/${broadcasterLogin}/videos`;
          
          // Calculate stream duration
          const streamStartMs = streamInfo.startedAt 
            ? new Date(streamInfo.startedAt).getTime() 
            : (streamMetadata.streamStartTime ? new Date(streamMetadata.streamStartTime).getTime() : null);
          const streamEndMs = Date.now();
          const streamDurationSec = streamStartMs ? Math.floor((streamEndMs - streamStartMs) / 1000) : 0;
          const durationHours = Math.floor(streamDurationSec / 3600);
          const durationMins = Math.floor((streamDurationSec % 3600) / 60);
          const durationStr = durationHours > 0 ? `${durationHours}h ${durationMins}m` : `${durationMins}m`;
          
          // Calculate comparisons to historical averages
          const peakViewers = finalizedGraph?.peakViewers || 0;
          const avgViewers = finalizedGraph?.avgViewers || 0;
          const historicalAvgPeak = stats.peakViewers || 0;
          const historicalAvgViewers = stats.avgViewers || 0;
          const totalStreams = stats.totalStreams || 1;
          
          // Calculate average stream duration from history
          const historyWithDuration = history.filter(h => h.duration && h.duration > 0);
          const avgDurationSec = historyWithDuration.length > 0 
            ? historyWithDuration.reduce((sum, h) => sum + h.duration, 0) / historyWithDuration.length 
            : 0;
          
          // Comparison indicators
          const peakCompare = peakViewers >= historicalAvgPeak ? 'ðŸ”º' : 'ðŸ”»';
          const avgCompare = avgViewers >= historicalAvgViewers ? 'ðŸ”º' : 'ðŸ”»';
          const durationCompare = streamDurationSec >= avgDurationSec ? 'ðŸ”º' : 'ðŸ”»';
          
          // Calculate percentage differences
          const peakDiff = historicalAvgPeak > 0 ? Math.round(((peakViewers - historicalAvgPeak) / historicalAvgPeak) * 100) : 0;
          const avgDiff = historicalAvgViewers > 0 ? Math.round(((avgViewers - historicalAvgViewers) / historicalAvgViewers) * 100) : 0;
          
          // Create a nice embed for stream end
          const endEmbed = new EmbedBuilder()
            .setColor(peakViewers >= historicalAvgPeak ? 0x00b894 : 0x6441A4) // Green if above average
            .setTitle('ðŸŽ¬ Stream Ended')
            .setDescription(`Thank you for watching! Here's how this stream performed:`)
            .addFields(
              { name: 'ðŸ‘¥ Peak Viewers', value: `**${peakViewers}** ${peakCompare}\n${peakDiff >= 0 ? '+' : ''}${peakDiff}% vs avg`, inline: true },
              { name: 'ðŸ“Š Avg Viewers', value: `**${avgViewers}** ${avgCompare}\n${avgDiff >= 0 ? '+' : ''}${avgDiff}% vs avg`, inline: true },
              { name: 'â±ï¸ Duration', value: `**${durationStr}** ${durationCompare}`, inline: true }
            )
            .setFooter({ text: `Stream #${totalStreams} â€¢ ðŸ’œ See you next stream!` })
            .setTimestamp();
          
          // Add game segments if available
          if (finalizedGames?.totals && Object.keys(finalizedGames.totals).length > 0) {
            const gamesList = Object.entries(finalizedGames.totals)
              .sort((a, b) => b[1] - a[1])
              .slice(0, 5)
              .map(([game, seconds]) => {
                const hours = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                return `**${game}** - ${hours > 0 ? hours + 'h ' : ''}${mins}m`;
              })
              .join('\n');
            
            endEmbed.addFields({ name: 'ðŸŽ® Games Played', value: gamesList || 'Unknown', inline: false });
          }
          
          // Add milestone celebration if this was a record-breaking stream
          const milestones = [];
          if (peakViewers > 0 && peakViewers >= historicalAvgPeak && history.length > 1) {
            const allTimePeak = Math.max(...history.map(h => h.peakViewers || 0), 0);
            if (peakViewers >= allTimePeak) {
              milestones.push('ðŸ† **NEW ALL-TIME PEAK VIEWERS!**');
            }
          }
          if (streamDurationSec > 0 && historyWithDuration.length > 0) {
            const longestStream = Math.max(...historyWithDuration.map(h => h.duration), 0);
            if (streamDurationSec >= longestStream) {
              milestones.push('â° **LONGEST STREAM EVER!**');
            }
          }
          if (milestones.length > 0) {
            endEmbed.addFields({ name: 'ðŸŽ‰ Milestones', value: milestones.join('\n'), inline: false });
          }
          
          // Try to find the actual VOD
          let actualVodUrl = null;
          try {
            const vodRes = await fetch(`https://api.twitch.tv/helix/videos?user_id=${process.env.TWITCH_BROADCASTER_ID}&first=1&sort=time`, {
              headers: {
                'Client-ID': process.env.TWITCH_CLIENT_ID,
                'Authorization': 'Bearer ' + TWITCH_ACCESS_TOKEN
              }
            });
            const vodData = await vodRes.json();
            if (vodData.data && vodData.data.length > 0) {
              actualVodUrl = vodData.data[0].url;
              addLog('info', 'VOD found immediately: ' + actualVodUrl);
            }
          } catch (err) {
            addLog('warn', 'Could not fetch VOD immediately: ' + err.message);
          }

          // Add VOD link button
          const row = new ActionRowBuilder();
          
          if (actualVodUrl) {
            row.addComponents(
              new ButtonBuilder()
                .setLabel('Watch VOD')
                .setStyle(ButtonStyle.Link)
                .setURL(actualVodUrl)
            );
          } else {
            row.addComponents(
              new ButtonBuilder()
                .setLabel('VOD not out yet')
                .setStyle(ButtonStyle.Secondary)
                .setDisabled(true)
            );
          }
          
          await msg.edit({ content: '', embeds: [endEmbed], components: [row] });
          addLog('offline', 'LIVE â†’ OFFLINE (message edited with stream summary)');
          
          // If VOD wasn't available yet, check for it periodically and update the message
          if (!actualVodUrl && announcementMessageId && process.env.DISCORD_CHANNEL_ID) {
            let vodCheckCount = 0;
            const maxChecks = 120; // 120 attempts = ~1 hour with 30s interval
            const vodCheckInterval = setInterval(async () => {
              vodCheckCount++;
              
              try {
                const vodRes = await fetch(`https://api.twitch.tv/helix/videos?user_id=${process.env.TWITCH_BROADCASTER_ID}&first=1&sort=time`, {
                  headers: {
                    'Client-ID': process.env.TWITCH_CLIENT_ID,
                    'Authorization': 'Bearer ' + TWITCH_ACCESS_TOKEN
                  }
                });
                const vodData = await vodRes.json();
                if (vodData.data && vodData.data.length > 0) {
                  const foundVodUrl = vodData.data[0].url;
                  addLog('info', 'VOD found on check ' + vodCheckCount + ': ' + foundVodUrl);
                  
                  // Update the message with the new VOD button
                  try {
                    const channel = await client.channels.fetch(process.env.DISCORD_CHANNEL_ID);
                    const msgToUpdate = await channel.messages.fetch(announcementMessageId);
                    const newRow = new ActionRowBuilder()
                      .addComponents(
                        new ButtonBuilder()
                          .setLabel('Watch VOD')
                          .setStyle(ButtonStyle.Link)
                          .setURL(foundVodUrl)
                      );
                    await msgToUpdate.edit({ components: [newRow] });
                    addLog('info', 'Updated stream end message with VOD link');
                    clearInterval(vodCheckInterval);
                  } catch (err) {
                    addLog('error', 'Failed to update message with VOD link: ' + err.message);
                  }
                }
              } catch (err) {
                addLog('warn', 'VOD check failed: ' + err.message);
              }
              
              // After 1 hour of checking, give up and link to latest available VOD
              if (vodCheckCount > maxChecks) {
                clearInterval(vodCheckInterval);
                addLog('warn', 'VOD check timeout after 1 hour - linking to previous VOD');
                
                try {
                  const vodRes = await fetch(`https://api.twitch.tv/helix/videos?user_id=${process.env.TWITCH_BROADCASTER_ID}&first=1&sort=time`, {
                    headers: {
                      'Client-ID': process.env.TWITCH_CLIENT_ID,
                      'Authorization': 'Bearer ' + TWITCH_ACCESS_TOKEN
                    }
                  });
                  const vodData = await vodRes.json();
                  if (vodData.data && vodData.data.length > 0) {
                    const fallbackVodUrl = vodData.data[0].url;
                    const channel = await client.channels.fetch(process.env.DISCORD_CHANNEL_ID);
                    const msgToUpdate = await channel.messages.fetch(announcementMessageId);
                    const newRow = new ActionRowBuilder()
                      .addComponents(
                        new ButtonBuilder()
                          .setLabel('Watch VOD (Previous - Timeout)')
                          .setStyle(ButtonStyle.Link)
                          .setURL(fallbackVodUrl)
                      );
                    await msgToUpdate.edit({ components: [newRow] });
                    addLog('info', 'Updated message with fallback VOD after timeout');
                  }
                } catch (err) {
                  addLog('error', 'Failed to apply fallback VOD: ' + err.message);
                }
              }
            }, 30000); // Check every 30 seconds
          }
        } catch (err) {
          addLog('error', 'Failed to edit live message on offline: ' + err.message);
        }
      }

      // Finalize viewer graph history BEFORE resetting IDs
      const finalizedGraph = finalizeStreamViewerData();

      // Finalize game timeline
      const finalizedGames = finalizeStreamGameTimeline(Date.now());

      // Update the last history entry with end time and duration
      if (history.length > 0 && history[history.length - 1].duration === null) {
        const lastStream = history[history.length - 1];
        const startMs = lastStream.startedAt
          ? new Date(lastStream.startedAt).getTime()
          : (streamMetadata.streamStartTime ? new Date(streamMetadata.streamStartTime).getTime() : NaN);
        const endMs = Date.now();
        if (!isNaN(startMs)) {
          lastStream.duration = Math.max(0, Math.floor((endMs - startMs) / 1000));
        } else {
          lastStream.duration = 0;
        }
        lastStream.endedAt = new Date(endMs).toISOString();

        if (finalizedGraph) {
          lastStream.peakViewers = finalizedGraph.peakViewers;
          lastStream.avgViewers = finalizedGraph.avgViewers;
        }

        if (finalizedGames && finalizedGames.totals) {
          lastStream.gameSegments = Object.entries(finalizedGames.totals)
            .map(([game, seconds]) => ({
              game: (game || '').toString().trim() || 'Unknown',
              seconds: Number(seconds) || 0
            }))
            .sort((a, b) => b.seconds - a.seconds);
        }
        
        // Check if it's Sunday (end of week) and send summary
        const now = getNowInBotTimezone();
        if (now.getDay() === 0) {
          // Calculate week stats
          const weekStart = new Date(now);
          weekStart.setDate(now.getDate() - 7);
          weekStart.setHours(0, 0, 0, 0);
          
          const weekStreams = history.filter(s => s.startedAt && new Date(s.startedAt) >= weekStart);
          const totalDuration = weekStreams.reduce((sum, s) => sum + (s.duration || 0), 0);
          const avgViewers = weekStreams.length > 0 
            ? Math.round(weekStreams.reduce((sum, s) => sum + (s.viewers || 0), 0) / weekStreams.length)
            : 0;
          const peakViewersWeek = weekStreams.length > 0 ? Math.max(...weekStreams.map(s => s.viewers || 0)) : 0;
          const topGame = weekStreams.length > 0
            ? weekStreams.reduce((a, b) => 
                (weekStreams.filter(s => s.game === a.game).length > 
                 weekStreams.filter(s => s.game === b.game).length) ? a : b
              ).game
            : 'N/A';
          
          const hours = Math.floor(totalDuration / 3600);
          const mins = Math.floor((totalDuration % 3600) / 60);
          
          try {
            const channel = await client.channels.fetch(process.env.DISCORD_CHANNEL_ID);
            await channel.send({
              embeds: [{
                title: 'ðŸ“Š Weekly Stream Summary',
                color: 0x9146FF,
                description: `Week of ${weekStart.toLocaleDateString()} - ${now.toLocaleDateString()}`,
                fields: [
                  { name: 'ðŸ“º Total Streams', value: String(weekStreams.length), inline: true },
                  { name: 'â±ï¸ Total Hours', value: `${hours}h ${mins}m`, inline: true },
                  { name: 'ðŸ‘¥ Average Viewers', value: String(avgViewers), inline: true },
                  { name: 'ðŸ“ˆ Peak Viewers', value: String(peakViewersWeek), inline: true },
                  { name: 'ðŸŽ® Top Game', value: topGame, inline: true },
                  { name: '\u200b', value: '\u200b', inline: true }
                ]
              }]
            });
            addLog('info', 'Weekly summary sent');
          } catch (err) {
            addLog('error', 'Failed to send weekly summary: ' + err.message);
          }
        }
      }

      isLive = false;
      lastStreamId = null;
      announcementMessageId = null;
      currentStreamGameTimeline = [];
      
      // Save viewer data to history before clearing
      if (currentStreamViewerData.length > 0 && history.length > 0) {
        const lastStream = history[history.length - 1];
        viewerGraphHistory.push({
          streamId: lastStream.id || (lastStream.startedAt + lastStream.game),
          startedAt: lastStream.startedAt,
          peakViewers: lastStream.peakViewers || 0,
          data: currentStreamViewerData.map(v => ({ time: new Date(v.timestamp).toLocaleTimeString(), viewers: v.viewers }))
        });
        // Cap viewerGraphHistory to 30 streams
        if (viewerGraphHistory.length > 30) {
          viewerGraphHistory.splice(0, viewerGraphHistory.length - 30);
        }
      }
      
      // Reset stream snapshot so the dashboard reflects the offline state
      streamInfo.startedAt = null;
      streamInfo.viewers = 0;
      streamInfo.title = '\u2014';
      streamInfo.game = '\u2014';
      streamInfo.thumbnail = null;
      streamMetadata.titleChangeDetected = false;
      streamMetadata.gameChangeDetected = false;
      streamMetadata.streamStartTime = null;
      offlineDetectedAt = null;
      dashboardSettings.hitMilestonesThisStream = {};
      currentStreamViewerData = [];
      io.emit('streamUpdate', streamInfo);
      recomputeStreamStatsFromHistory();
      saveState();
    }

    // ======================
    // DELAYED STREAM LOGIC
    // ======================

    // â›” Never mark delayed if canceled
    if (schedule.noStreamToday) return;

    // âœ… Only delay if NOT live
    if (
      !schedule.streamDelayed &&
      !isLive
    ) {
      const now = getNowInBotTimezone();
      const nextComputed = getNextScheduledStream();
      const nextTimeMs = (nextComputed && Number.isFinite(nextComputed.ts))
        ? Number(nextComputed.ts)
        : (schedule.nextStreamAt ? new Date(schedule.nextStreamAt).getTime() : null);
      if (!nextTimeMs) return;
      const nextTime = new Date(nextTimeMs);
      const gracePeriod = 2 * 60 * 1000; // 2 minutes

      if (now >= nextTime.getTime() + gracePeriod) {
        const delayedKey = (nextComputed && Number.isFinite(nextComputed.ts))
          ? new Date(nextTimeMs).toISOString()
          : schedule.nextStreamAt;

        // Avoid re-sending delayed alert for the same scheduled stream
        if (schedule.lastDelayedAlertFor === delayedKey) {
          addLog('info', 'Delayed alert already sent for this schedule â€” skipping');
          return;
        }
        // Backup check: verify if stream was scheduled (started before or at scheduled time)
        let isScheduledStream = false;
        try {
          const resp = await fetch('https://api.twitch.tv/helix/streams?user_login=' + process.env.STREAMER_LOGIN, {
            headers: {
              'Client-ID': process.env.TWITCH_CLIENT_ID,
              'Authorization': 'Bearer ' + TWITCH_ACCESS_TOKEN
            }
          });
          const data = await resp.json();
          const stream = data.data?.[0];
          
          if (stream) {
            const streamStartTime = new Date(stream.started_at).getTime();
            // If stream started BEFORE scheduled time, it's the same scheduled stream (not a late start)
            if (streamStartTime <= nextTime.getTime()) {
              isScheduledStream = true;
              addLog('info', 'Stream verified as scheduled stream - skipping delayed notification');
            } else {
              const minutesLate = Math.floor((streamStartTime - nextTime.getTime()) / 60000);
              addLog('info', `Stream started ${minutesLate} minutes after scheduled time - treating as delayed`);
            }
          }
        } catch (err) {
          addLog('error', 'Backup check failed: ' + err.message);
        }

        // Only send delayed if it's NOT a scheduled stream that started on time
        if (!isScheduledStream) {
          schedule.streamDelayed = true;
          schedule.lastDelayedAlertFor = delayedKey;
          if (delayedKey && schedule.nextStreamAt !== delayedKey) {
            schedule.nextStreamAt = delayedKey;
          }
          saveState();

          addLog('info', 'Stream marked as delayed');

          if (process.env.DISCORD_CHANNEL_ID) {
            const channel = await client.channels.fetch(
              process.env.DISCORD_CHANNEL_ID
            );

            // CLEAN CHANNEL: Delete previous bot messages and unpin old announcement
            try {
              const messages = await channel.messages.fetch({ limit: 50 });
              const botMessages = messages.filter(m => m.author.id === client.user.id);
              
              // Unpin the old announcement if it exists
              if (announcementMessageId) {
                const oldMsg = botMessages.get(announcementMessageId);
                if (oldMsg && oldMsg.pinned) {
                  await oldMsg.unpin();
                  addLog('info', 'Unpinned old announcement');
                }
              }
              
              // Delete all bot messages in the channel
              for (const [, msg] of botMessages) {
                try {
                  await msg.delete();
                } catch (err) {
                  addLog('warn', `Could not delete message: ${err.message}`);
                }
              }
              addLog('info', 'Cleaned announcement channel');
            } catch (err) {
              addLog('warn', 'Could not clean channel: ' + err.message);
            }

            const embed = new EmbedBuilder()
              .setColor(0xFFA500)
              .setDescription(
                `âš ï¸ **Stream delayed â€” not cancelled**\nI'll be live shortly!`
              )
              .setImage(
                'https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExODA1Y3djcGFtemVlbHkzcDRlMnhyOXEwbGY4NW12cGM2dTg0N3hvZCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/hJF9fl8DfG0AJ1xN4d/giphy.gif'
              )
              .setTimestamp();

            const delayMsg = await channel.send({ embeds: [embed] });
            
            // PIN the delay message
            try {
              await delayMsg.pin();
              addLog('info', 'Pinned delay announcement');
              announcementMessageId = delayMsg.id;
              saveState();
            } catch (err) {
              addLog('warn', 'Could not pin delay message: ' + err.message);
            }
          }
        }
      }
    }

  } catch (err) {
    addLog('error', 'checkStream crashed: ' + err.message);
  } finally {
    lastStreamCheckAt = new Date().toISOString();
    isCheckingStream = false; // ðŸ”“ ALWAYS unlock
  }
} // âœ… <-- This closes the checkStream() function

let twitchCheckInterval = null;
let scheduleAlertInterval = null;
let tokenRefreshInterval = null;

async function validateTwitchToken(token) {
  const res = await fetch('https://api.twitch.tv/helix/users', {
    headers: {
      'Client-ID': process.env.TWITCH_CLIENT_ID,
      'Authorization': `Bearer ${token}`
    }
  });
  if (!res.ok) {
    let error = {};
    try { error = await res.json(); } catch {}
    throw new Error(`Token validation failed: ${res.status} ${error.message || error.error || 'Unauthorized'}`);
  }
}

// Refresh Twitch OAuth token automatically before expiration
async function refreshTwitchToken() {
  if (!twitchTokens.refresh_token) {
    addLog('warn', 'No refresh token available. Skipping token refresh.');
    return false;
  }

  try {
    addLog('info', 'Attempting to refresh Twitch token...');
    const tokenRes = await fetch('https://id.twitch.tv/oauth2/token', {
      method: 'POST',
      body: new URLSearchParams({
        client_id: process.env.TWITCH_CLIENT_ID,
        client_secret: process.env.TWITCH_CLIENT_SECRET,
        grant_type: 'refresh_token',
        refresh_token: twitchTokens.refresh_token
      })
    });

    const tokenData = await tokenRes.json();

    if (!tokenData.access_token) {
      throw new Error(tokenData.message || 'Failed to refresh token');
    }

    // Update tokens in memory
    const newExpiresAt = Date.now() + (tokenData.expires_in * 1000);
    twitchTokens.access_token = tokenData.access_token;
    twitchTokens.refresh_token = tokenData.refresh_token || twitchTokens.refresh_token; // Keep old refresh token if new one not provided
    twitchTokens.expires_at = newExpiresAt;

    // Update global variable
    TWITCH_ACCESS_TOKEN = tokenData.access_token;

    // Update .env file if it exists (not on Render)
    try {
      if (fs.existsSync('.env')) {
        let envContent = fs.readFileSync('.env', 'utf-8');
        envContent = envContent.replace(/TWITCH_ACCESS_TOKEN=.*/, `TWITCH_ACCESS_TOKEN=${tokenData.access_token}`);
        fs.writeFileSync('.env', envContent);
      }
    } catch { /* .env not available (e.g. Render) â€” tokens persisted in state.json instead */ }

    // Save to state.json (primary persistence on Render)
    saveState();

    addLog('info', `âœ… Twitch token refreshed successfully. New expiry: ${new Date(newExpiresAt).toLocaleString()}`);
    return true;
  } catch (err) {
    addLog('error', `Failed to refresh Twitch token: ${err.message}`);
    return false;
  }
}

async function ensureTwitchInitialized({ reloadFromEnv = false, forceBroadcasterRefresh = false } = {}) {
  if (reloadFromEnv) {
    if (!process.env.TWITCH_ACCESS_TOKEN) {
      throw new Error('No TWITCH_ACCESS_TOKEN in .env file');
    }
    TWITCH_ACCESS_TOKEN = process.env.TWITCH_ACCESS_TOKEN;
    // Update in-memory tokens from .env (in case it was manually edited)
    twitchTokens.access_token = TWITCH_ACCESS_TOKEN;
    addLog('info', 'Twitch token loaded from .env');
  }

  if (!process.env.TWITCH_CLIENT_ID) {
    throw new Error('TWITCH_CLIENT_ID not set in environment');
  }
  if (!process.env.STREAMER_LOGIN) {
    throw new Error('STREAMER_LOGIN not set in environment');
  }
  if (!TWITCH_ACCESS_TOKEN) {
    throw new Error('TWITCH_ACCESS_TOKEN not set');
  }

  try {
    await validateTwitchToken(TWITCH_ACCESS_TOKEN);
    addLog('info', 'Twitch token validated successfully');
  } catch (err) {
    addLog('warn', `Token validation error: ${err.message}`);
    const refreshed = await refreshTwitchToken();
    if (refreshed && TWITCH_ACCESS_TOKEN) {
      await validateTwitchToken(TWITCH_ACCESS_TOKEN);
      addLog('info', 'Twitch token validated successfully after refresh');
    } else {
      addLog('error', 'Your TWITCH_ACCESS_TOKEN is invalid or expired. Re-authorize via the dashboard or update .env, then reload.');
      throw err;
    }
  }

  if (!BROADCASTER_ID || forceBroadcasterRefresh) {
    BROADCASTER_ID = await getBroadcasterId();
    addLog('info', `Broadcaster ID loaded: ${BROADCASTER_ID}`);
  }

  // Start periodic stream checks once.
  if (!twitchCheckInterval) {
    twitchCheckInterval = setInterval(checkStream, 60000);
  }

  // Start schedule alert checks (every 30 seconds)
  if (!scheduleAlertInterval) {
    scheduleAlertInterval = setInterval(checkScheduleAlerts, 30000);
  }

  // Start automatic token refresh checks (every 20 minutes)
  // Tokens expire in 1 hour, so refresh halfway to be safe
  if (!tokenRefreshInterval) {
    tokenRefreshInterval = setInterval(async () => {
      const now = Date.now();
      if (twitchTokens.expires_at && now > (twitchTokens.expires_at - 10 * 60 * 1000)) {
        // Token expires in less than 10 minutes, refresh immediately
        await refreshTwitchToken();
      }
    }, 20 * 60 * 1000); // Check every 20 minutes
    addLog('info', 'Token refresh interval started (every 20 minutes)');
  }

  await checkStream();
  saveState();
}

async function getBroadcasterId() {
  if (!process.env.STREAMER_LOGIN) {
    throw new Error('STREAMER_LOGIN not set in environment');
  }
  if (!process.env.TWITCH_CLIENT_ID) {
    throw new Error('TWITCH_CLIENT_ID not set in environment');
  }
  if (!TWITCH_ACCESS_TOKEN) {
    throw new Error('TWITCH_ACCESS_TOKEN not set');
  }

  try {
    const url = `https://api.twitch.tv/helix/users?login=${process.env.STREAMER_LOGIN}`;
    const res = await fetch(url, {
      headers: {
        'Client-ID': process.env.TWITCH_CLIENT_ID,
        'Authorization': `Bearer ${TWITCH_ACCESS_TOKEN}`
      }
    });
    const data = await res.json();
    
    if (!res.ok) {
      throw new Error(`API error: ${res.status} - ${data.error || data.message || 'Unknown'}`);
    }
    
    if (!data.data?.[0]?.id) {
      addLog('error', `API returned no user for login: ${process.env.STREAMER_LOGIN}`);
      addLog('error', `API response: ${JSON.stringify(data)}`);
      throw new Error(`Broadcaster not found for login: ${process.env.STREAMER_LOGIN}`);
    }
    
    return data.data[0].id;
  } catch (err) {
    addLog('error', `getBroadcasterId error: ${err.message}`);
    throw err;
  }
}

async function getChannelVIPs() {
  if (!BROADCASTER_ID) {
    throw new Error('Broadcaster ID not set');
  }
  if (!process.env.TWITCH_CLIENT_ID || !TWITCH_ACCESS_TOKEN) {
    throw new Error('Twitch credentials not configured');
  }

  try {
    const url = `https://api.twitch.tv/helix/channels/vips?broadcaster_id=${BROADCASTER_ID}`;
    const res = await fetch(url, {
      headers: {
        'Client-ID': process.env.TWITCH_CLIENT_ID,
        'Authorization': `Bearer ${TWITCH_ACCESS_TOKEN}`
      }
    });
    
    const data = await res.json();
    
    if (!res.ok) {
      throw new Error(`API error: ${res.status} - ${data.error || data.message || 'Unknown'}`);
    }
    
    return data.data || [];
  } catch (err) {
    addLog('error', `getChannelVIPs error: ${err.message}`);
    throw err;
  }
}

/* ======================
   STARTUP
====================== */
// Removed - now runs in client.once('ready') event

/* ======================
   RPG API ROUTES
====================== */
// Get all worlds
app.get('/api/rpg/worlds', requireAuth, (req, res) => {
  try {
    if (!global.rpgWorlds) global.rpgWorlds = {};
    const worlds = Object.values(global.rpgWorlds);
    res.json({ success: true, worlds });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Create world
app.post('/api/rpg/worlds', requireAuth, (req, res) => {
  try {
    const world = req.body;
    if (!world.name) {
      return res.json({ success: false, error: 'World name required' });
    }
    if (!global.rpgWorlds) global.rpgWorlds = {};
    const worldId = world.id || Date.now().toString();
    global.rpgWorlds[worldId] = {
      ...world,
      id: worldId,
      createdAt: world.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    saveRPGWorlds();
    res.json({ success: true, message: 'World created', worldId });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Delete world
app.delete('/api/rpg/worlds/:id', requireAuth, (req, res) => {
  try {
    if (!global.rpgWorlds) global.rpgWorlds = {};
    delete global.rpgWorlds[req.params.id];
    saveRPGWorlds();
    res.json({ success: true, message: 'World deleted' });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Update world
app.put('/api/rpg/worlds/:id', requireAuth, (req, res) => {
  try {
    if (!global.rpgWorlds) global.rpgWorlds = {};
    const world = global.rpgWorlds[req.params.id];
    if (!world) {
      return res.json({ success: false, error: 'World not found' });
    }
    Object.assign(world, req.body);
    world.updatedAt = new Date().toISOString();
    saveRPGWorlds();
    res.json({ success: true, message: 'World updated' });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Get all quests
app.get('/api/rpg/quests', requireAuth, (req, res) => {
  try {
    loadRPGWorlds();
    const worlds = global.rpgWorlds || {};
    let quests = [];
    
    // Collect all quests from all worlds
    Object.values(worlds).forEach(world => {
      if (world.entities?.quests && typeof world.entities.quests === 'object') {
        Object.values(world.entities.quests).forEach(q => {
          if (q && q.id) {
            quests.push({
              id: q.id,
              name: q.name || q.title || 'Unnamed Quest',
              title: q.title || q.name,
              description: q.description || '',
              minLevel: q.minLevel || 1,
              type: q.type || q.category || 'main',
              xpReward: q.xpReward || 0,
              goldReward: q.goldReward || 0,
              itemRewards: q.itemRewards || [],
              enemyMultiplier: q.enemyMultiplier
            });
          }
        });
      }
    });
    
    res.json({ success: true, quests });
  } catch (err) {
    console.error('Error loading quests:', err);
    res.json({ success: false, error: err.message, quests: [] });
  }
});

// Create quest
app.post('/api/rpg/quests', requireAuth, (req, res) => {
  try {
    const { title, description, rewards } = req.body;
    if (!title || !description) {
      return res.json({ success: false, error: 'Missing required fields' });
    }
    rpgBot?.contentStore?.createQuest?.({ title, description, rewards });
    res.json({ success: true, message: 'Quest created' });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Delete quest
app.delete('/api/rpg/quests/:id', requireAuth, (req, res) => {
  try {
    rpgBot?.contentStore?.deleteQuest?.(req.params.id);
    res.json({ success: true, message: 'Quest deleted' });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Validate all content
app.get('/api/rpg/validate', requireAuth, (req, res) => {
  try {
    const results = rpgBot?.validator?.validateAll?.() || { 
      isValid: true, 
      issues: [] 
    };
    const issues = (results.issues || []).map(issue => ({
      severity: issue.severity || 'warning',
      message: issue.message,
      details: issue.details || ''
    }));
    res.json({ success: true, issues });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Combat simulator
app.get('/api/rpg/simulators/combat', requireAuth, (req, res) => {
  try {
    const result = rpgBot?.combatSimulator?.simulate?.() || { 
      message: 'Combat simulation feature not available' 
    };
    res.json({ success: true, result });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Quest simulator
app.get('/api/rpg/simulators/quest', requireAuth, (req, res) => {
  try {
    const result = rpgBot?.questSimulator?.simulate?.() || { 
      message: 'Quest simulation feature not available' 
    };
    res.json({ success: true, result });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// World state simulator
app.get('/api/rpg/simulators/world', requireAuth, (req, res) => {
  try {
    const result = rpgBot?.worldStateSimulator?.generateDailyState?.() || { 
      message: 'World state simulation feature not available' 
    };
    res.json({ success: true, result });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Flag tester
app.get('/api/rpg/simulators/flags', requireAuth, (req, res) => {
  try {
    const result = rpgBot?.flagTester?.testFlags?.() || { 
      message: 'Flag testing feature not available' 
    };
    res.json({ success: true, result });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Get all flags
app.get('/api/rpg/flags', requireAuth, (req, res) => {
  try {
    const flags = rpgBot?.flagRegistry?.getAllFlags?.() || [];
    res.json({ success: true, flags: flags.map(f => ({ 
      id: f.id, 
      name: f.name, 
      description: f.description 
    })) });
  } catch (err) {
    res.json({ success: false, error: err.message });
  }
});

// Level Analysis Tool
app.post('/api/rpg/analyze-level', requireAuth, async (req, res) => {
  try {
    const { level, quest, weaponId } = req.body;
    
    if (!level || !quest) {
      return res.json({ success: false, error: 'Missing level or quest' });
    }
    
    // Load all quests to find stat rewards from lower level quests
    loadRPGWorlds();
    const worlds = global.rpgWorlds || {};
    let allQuests = [];
    
    Object.values(worlds).forEach(world => {
      if (world.entities?.quests && typeof world.entities.quests === 'object') {
        Object.values(world.entities.quests).forEach(q => {
          if (q && q.id && q.minLevel && q.minLevel < level) {
            allQuests.push(q);
          }
        });
      }
    });
    
    // Calculate base player stats at this level
    const baseHp = 100;
    const baseAttackPower = 10;
    const attackPowerPerLevel = 0.8;
    const baseDefense = 10;
    const defensePerLevel = 0.5;
    
    const levelScaling = Math.max(1, level / 50);
    
    let playerStats = {
      health: Math.round(baseHp * levelScaling),
      attackPower: Math.round((baseAttackPower + (level - 1) * attackPowerPerLevel) * levelScaling),
      defense: Math.round((baseDefense + (level - 1) * defensePerLevel) * levelScaling),
      critChance: Math.min(0.5, 0.1 + (level * 0.005))
    };
    
    let questStatRewards = {};
    
    // Add stat rewards from completed quests
    allQuests.forEach(q => {
      if (q.statRewards && typeof q.statRewards === 'object') {
        Object.entries(q.statRewards).forEach(([stat, value]) => {
          questStatRewards[stat] = (questStatRewards[stat] || 0) + value;
        });
      }
    });
    
    // Apply quest stat bonuses
    if (questStatRewards.health) playerStats.health += questStatRewards.health;
    if (questStatRewards.attackPower) playerStats.attackPower += questStatRewards.attackPower;
    if (questStatRewards.defense) playerStats.defense += questStatRewards.defense;
    if (questStatRewards.strength) playerStats.attackPower += (questStatRewards.strength * 0.5);
    if (questStatRewards.vitality) playerStats.health += (questStatRewards.vitality * 2);
    
    // Add weapon bonuses if provided
    if (weaponId) {
      try {
        const { getEquipment } = await import('./Discord bot - test branch/rpg/data/equipment.js');
        const weapon = getEquipment(weaponId);
        if (weapon && weapon.bonuses) {
          if (weapon.bonuses.attackPower) playerStats.attackPower += weapon.bonuses.attackPower;
          if (weapon.bonuses.strength) playerStats.attackPower += (weapon.bonuses.strength * 0.5);
          if (weapon.bonuses.hp) playerStats.health += weapon.bonuses.hp;
          if (weapon.bonuses.defense) playerStats.defense += weapon.bonuses.defense;
        }
      } catch (e) {
        // Weapon loading optional
      }
    }
    
    // Calculate enemy stats based on quest
    let enemyStats = null;
    if (quest.type === 'combat' || quest.minLevel) {
      const questLevel = quest.minLevel || 1;
      const questLevelScaling = Math.max(1, questLevel / 50);
      
      enemyStats = {
        health: Math.round(baseHp * questLevelScaling * (quest.enemyMultiplier?.health || 1.2)),
        attackPower: Math.round((baseAttackPower + (questLevel - 1) * attackPowerPerLevel) * questLevelScaling * (quest.enemyMultiplier?.attackPower || 1.1)),
        defense: Math.round((baseDefense + (questLevel - 1) * defensePerLevel) * questLevelScaling * (quest.enemyMultiplier?.defense || 1.0))
      };
    }
    
    // Determine difficulty
    let difficulty = 'Too Easy';
    let outcome = 'âœ… Highly likely to win';
    let turnsToWin = 1;
    
    if (enemyStats) {
      const playerDPS = Math.max(0.1, playerStats.attackPower * (0.5 + playerStats.critChance));
      const defenseReduction = Math.max(0, Math.min(0.9, playerStats.defense / (playerStats.defense + 100)));
      const enemyDPS = Math.max(0.1, enemyStats.attackPower * (1 - defenseReduction));
      
      turnsToWin = Math.ceil(enemyStats.health / playerDPS);
      const turnsToLose = Math.ceil(playerStats.health / enemyDPS);
      const survivalRatio = turnsToLose / turnsToWin;
      
      if (survivalRatio >= 2.5) {
        difficulty = 'Too Easy';
        outcome = 'âœ… Should win easily';
      } else if (survivalRatio >= 1.0) {
        difficulty = 'Moderate';
        outcome = 'âš”ï¸ Good challenge, should win';
      } else {
        difficulty = 'Too Hard';
        outcome = 'âŒ Likely to lose, consider leveling';
      }
    }
    
    const damageComparison = {
      playerDPS: Math.max(0.1, playerStats.attackPower * (0.5 + playerStats.critChance)),
      enemyDPS: enemyStats ? Math.max(0.1, enemyStats.attackPower * (1 - Math.max(0, Math.min(0.9, playerStats.defense / (playerStats.defense + 100))))) : 0,
      turnsToWin
    };
    
    // Extract quest rewards
    const questRewards = {
      xp: quest.xpReward || Math.round(100 * (quest.minLevel || 1)),
      gold: quest.goldReward || Math.round(50 * (quest.minLevel || 1)),
      items: quest.itemRewards || []
    };
    
    const difficultyMultiplier = difficulty === 'Too Easy' ? 0.5 : (difficulty === 'Moderate' ? 1.0 : 2.5);
    const rewardEfficiency = Math.round((questRewards.xp + questRewards.gold) / Math.max(1, difficultyMultiplier));
    let valueAssessment = 'Poor value';
    if (rewardEfficiency > 200) valueAssessment = 'â­ Excellent value';
    else if (rewardEfficiency > 150) valueAssessment = 'â­â­ Great value';
    else if (rewardEfficiency > 100) valueAssessment = 'â­â­â­ Good value';
    else if (rewardEfficiency > 50) valueAssessment = 'Fair value';
    
    res.json({
      success: true,
      analysis: {
        playerLevel: level,
        playerStats,
        questStatRewards,
        completedQuestsBelow: allQuests.length,
        enemyStats,
        quest,
        difficulty,
        outcome,
        damageComparison,
        questRewards,
        rewardEfficiency,
        valueAssessment
      }
    });
  } catch (err) {
    console.error('Error in analyze-level:', err);
    res.json({ success: false, error: err.message });
  }
});

// Reset character
app.post('/api/rpg/reset-character', requireAuth, (req, res) => {
  try {
    res.json({ success: false, message: 'Use /dashboard Discord command to reset your character.' });
  } catch (err) {
    res.json({ success: false, message: 'âŒ Error: ' + err.message });
  }
});

/* ======================
   GUILD API ROUTES
====================== */

// Get all guild quests
app.get('/api/rpg/guild/quests', requireAuth, (req, res) => {
  try {
    const questsPath = path.join(process.cwd(), 'rpg', 'data', 'guild-quests.json');
    let quests = { daily: [], weekly: [], limited: [] };
    
    if (fs.existsSync(questsPath)) {
      const data = cachedReadJSON(questsPath);
      quests = data;
    }
    
    res.json(quests);
  } catch (err) {
    console.error('Error loading guild quests:', err);
    res.status(500).json({ error: err.message });
  }
});

// Create quest
app.post('/api/rpg/guild/quests/:type', requireAuth, (req, res) => {
  try {
    const { type } = req.params;
    if (!['daily', 'weekly', 'limited'].includes(type)) {
      return res.status(400).json({ error: 'Invalid quest type' });
    }
    
    const questsPath = path.join(process.cwd(), 'rpg', 'data', 'guild-quests.json');
    let quests = { daily: [], weekly: [], limited: [] };
    
    if (fs.existsSync(questsPath)) {
      quests = cachedReadJSON(questsPath);
    }
    
    const newQuest = req.body;
    if (!newQuest.id || !newQuest.title) {
      return res.status(400).json({ error: 'Quest ID and title required' });
    }
    
    // Check for duplicate ID
    if (quests[type].some(q => q.id === newQuest.id)) {
      return res.status(400).json({ error: 'Quest ID already exists' });
    }
    
    quests[type].push(newQuest);
    
    fs.writeFileSync(questsPath, JSON.stringify(quests, null, 2), 'utf8');
    invalidateRPGCache(questsPath);
    
    res.json({ success: true, message: 'Quest created', quest: newQuest });
  } catch (err) {
    console.error('Error creating quest:', err);
    res.status(500).json({ error: err.message });
  }
});

// Update quest
app.put('/api/rpg/guild/quests/:type/:questId', requireAuth, (req, res) => {
  try {
    const { type, questId } = req.params;
    if (!['daily', 'weekly', 'limited'].includes(type)) {
      return res.status(400).json({ error: 'Invalid quest type' });
    }
    
    const questsPath = path.join(process.cwd(), 'rpg', 'data', 'guild-quests.json');
    let quests = { daily: [], weekly: [], limited: [] };
    
    if (fs.existsSync(questsPath)) {
      quests = cachedReadJSON(questsPath);
    }
    
    const questIndex = quests[type].findIndex(q => q.id === questId);
    if (questIndex === -1) {
      return res.status(404).json({ error: 'Quest not found' });
    }
    
    const updatedQuest = req.body;
    quests[type][questIndex] = updatedQuest;
    
    fs.writeFileSync(questsPath, JSON.stringify(quests, null, 2), 'utf8');
    invalidateRPGCache(questsPath);
    
    res.json({ success: true, message: 'Quest updated', quest: updatedQuest });
  } catch (err) {
    console.error('Error updating quest:', err);
    res.status(500).json({ error: err.message });
  }
});

// Delete quest
app.delete('/api/rpg/guild/quests/:type/:questId', requireAuth, (req, res) => {
  try {
    const { type, questId } = req.params;
    if (!['daily', 'weekly', 'limited'].includes(type)) {
      return res.status(400).json({ error: 'Invalid quest type' });
    }
    
    const questsPath = path.join(process.cwd(), 'rpg', 'data', 'guild-quests.json');
    let quests = { daily: [], weekly: [], limited: [] };
    
    if (fs.existsSync(questsPath)) {
      quests = cachedReadJSON(questsPath);
    }
    
    quests[type] = quests[type].filter(q => q.id !== questId);
    
    fs.writeFileSync(questsPath, JSON.stringify(quests, null, 2), 'utf8');
    invalidateRPGCache(questsPath);
    
    res.json({ success: true, message: 'Quest deleted' });
  } catch (err) {
    console.error('Error deleting quest:', err);
    res.status(500).json({ error: err.message });
  }
});

// Get all bounties
app.get('/api/rpg/guild/bounties', requireAuth, (req, res) => {
  try {
    const bountiesPath = path.join(process.cwd(), 'rpg', 'data', 'bounties.json');
    let bounties = [];
    
    if (fs.existsSync(bountiesPath)) {
      const data = cachedReadJSON(bountiesPath);
      bounties = data;
    }
    
    res.json(bounties);
  } catch (err) {
    console.error('Error loading bounties:', err);
    res.status(500).json({ error: err.message });
  }
});

// Create bounty
app.post('/api/rpg/guild/bounties', requireAuth, (req, res) => {
  try {
    const bountiesPath = path.join(process.cwd(), 'rpg', 'data', 'bounties.json');
    let bounties = [];
    
    if (fs.existsSync(bountiesPath)) {
      bounties = cachedReadJSON(bountiesPath);
    }
    
    const newBounty = {
      id: 'bounty_' + Date.now(),
      ...req.body,
      createdAt: new Date().toISOString()
    };
    
    bounties.push(newBounty);
    
    fs.writeFileSync(bountiesPath, JSON.stringify(bounties, null, 2), 'utf8');
    invalidateRPGCache(bountiesPath);
    
    res.json({ success: true, message: 'Bounty created', bounty: newBounty });
  } catch (err) {
    console.error('Error creating bounty:', err);
    res.status(500).json({ error: err.message });
  }
});

// Update bounty
app.put('/api/rpg/guild/bounties/:bountyId', requireAuth, (req, res) => {
  try {
    const { bountyId } = req.params;
    
    const bountiesPath = path.join(process.cwd(), 'rpg', 'data', 'bounties.json');
    let bounties = [];
    
    if (fs.existsSync(bountiesPath)) {
      bounties = cachedReadJSON(bountiesPath);
    }
    
    const bountyIndex = bounties.findIndex(b => b.id === bountyId);
    if (bountyIndex === -1) {
      return res.status(404).json({ error: 'Bounty not found' });
    }
    
    bounties[bountyIndex] = { ...bounties[bountyIndex], ...req.body };
    
    fs.writeFileSync(bountiesPath, JSON.stringify(bounties, null, 2), 'utf8');
    invalidateRPGCache(bountiesPath);
    
    res.json({ success: true, message: 'Bounty updated', bounty: bounties[bountyIndex] });
  } catch (err) {
    console.error('Error updating bounty:', err);
    res.status(500).json({ error: err.message });
  }
});

// Delete bounty
app.delete('/api/rpg/guild/bounties/:bountyId', requireAuth, (req, res) => {
  try {
    const { bountyId } = req.params;
    
    const bountiesPath = path.join(process.cwd(), 'rpg', 'data', 'bounties.json');
    let bounties = [];
    
    if (fs.existsSync(bountiesPath)) {
      bounties = cachedReadJSON(bountiesPath);
    }
    
    bounties = bounties.filter(b => b.id !== bountyId);
    
    fs.writeFileSync(bountiesPath, JSON.stringify(bounties, null, 2), 'utf8');
    invalidateRPGCache(bountiesPath);
    
    res.json({ success: true, message: 'Bounty deleted' });
  } catch (err) {
    console.error('Error deleting bounty:', err);
    res.status(500).json({ error: err.message });
  }
});

// Guild Statistics - Leaderboard
app.get('/api/rpg/guild/statistics/leaderboard', requireAuth, (req, res) => {
  try {
    const playersPath = path.join(process.cwd(), 'data', 'players.json');
    let players = [];
    
    if (fs.existsSync(playersPath)) {
      const data = cachedReadJSON(playersPath);
      players = Array.isArray(data) ? data : Object.values(data);
    }

    const leaderboard = players
      .map(p => ({
        userId: p.userId,
        username: p.username || 'Unknown',
        rank: p.guildRank || 'F',
        guildXP: p.guildXP || 0,
        level: p.level || 1,
        totalQuestsCompleted: (p.dailyQuestsCompleted || []).length + (p.weeklyQuestsCompleted || []).length + (p.limitedQuestsCompleted || []).length,
      }))
      .sort((a, b) => b.guildXP - a.guildXP)
      .slice(0, 100);

    res.json({ success: true, leaderboard });
  } catch (err) {
    console.error('Error loading leaderboard:', err);
    res.status(500).json({ error: err.message });
  }
});

// Guild Statistics - Overview
app.get('/api/rpg/guild/statistics/overview', requireAuth, (req, res) => {
  try {
    const playersPath = path.join(process.cwd(), 'data', 'players.json');
    const questsPath = path.join(process.cwd(), 'data', 'guild-quests.json');
    
    let players = [];
    if (fs.existsSync(playersPath)) {
      const data = cachedReadJSON(playersPath);
      players = Array.isArray(data) ? data : Object.values(data);
    }

    let quests = { daily: [], weekly: [], limited: [] };
    if (fs.existsSync(questsPath)) {
      quests = cachedReadJSON(questsPath);
    }

    const statistics = {
      timestamp: new Date().toISOString(),
      totalPlayers: players.length,
      averageRankXP: players.length > 0 ? (players.reduce((sum, p) => sum + (p.guildXP || 0), 0) / players.length).toFixed(0) : 0,
      
      questStats: {
        totalDaily: quests.daily.length,
        totalWeekly: quests.weekly.length,
        totalLimited: quests.limited.length,
      },

      completionRates: {
        dailyCompletionRate: players.length > 0 
          ? (players.filter(p => p.dailyQuestsCompleted && p.dailyQuestsCompleted.length > 0).length / players.length * 100).toFixed(1) + '%'
          : '0%',
        weeklyCompletionRate: players.length > 0
          ? (players.filter(p => p.weeklyQuestsCompleted && p.weeklyQuestsCompleted.length > 0).length / players.length * 100).toFixed(1) + '%'
          : '0%',
      },

      rankDistribution: ['F', 'E', 'D', 'C', 'B', 'A', 'S'].map(rank => {
        const count = players.filter(p => p.guildRank === rank).length;
        return {
          rank,
          count,
          percentage: players.length > 0 ? (count / players.length * 100).toFixed(1) : 0,
        };
      }),

      completionByRank: ['F', 'E', 'D', 'C', 'B', 'A', 'S'].map(rank => {
        const rankPlayers = players.filter(p => p.guildRank === rank);
        if (rankPlayers.length === 0) return { rank, average: 0 };
        
        const avgCompleted = (rankPlayers.reduce((sum, p) => {
          return sum + ((p.dailyQuestsCompleted || []).length + (p.weeklyQuestsCompleted || []).length + (p.limitedQuestsCompleted || []).length);
        }, 0) / rankPlayers.length).toFixed(1);
        
        return { rank, average: avgCompleted };
      }),
    };

    res.json({ success: true, statistics });
  } catch (err) {
    console.error('Error calculating statistics:', err);
    res.status(500).json({ error: err.message });
  }
});

// Guild Shop - Get all items
app.get('/api/rpg/guild/shop', requireAuth, (req, res) => {
  try {
    const shopPath = path.join(process.cwd(), 'data', 'guild-shop.json');
    let shopItems = {};
    
    if (fs.existsSync(shopPath)) {
      shopItems = cachedReadJSON(shopPath);
    }

    res.json({ success: true, items: shopItems });
  } catch (err) {
    console.error('Error loading shop:', err);
    res.status(500).json({ error: err.message });
  }
});

// Guild Shop - Purchase item
app.post('/api/rpg/guild/shop/purchase/:itemId', requireAuth, (req, res) => {
  try {
    const { itemId } = req.params;
    const userId = req.body.userId;

    const playersPath = path.join(process.cwd(), 'data', 'players.json');
    let players = [];
    
    if (fs.existsSync(playersPath)) {
      const data = cachedReadJSON(playersPath);
      players = Array.isArray(data) ? data : Object.values(data);
    }

    const player = players.find(p => p.userId === userId);
    if (!player) {
      return res.status(404).json({ error: 'Player not found' });
    }

    const shopPath = path.join(process.cwd(), 'data', 'guild-shop.json');
    let shopItems = {};
    
    if (fs.existsSync(shopPath)) {
      shopItems = cachedReadJSON(shopPath);
    }

    // Find item
    let item = null;
    for (const category of Object.values(shopItems)) {
      item = category.find(i => i.id === itemId);
      if (item) break;
    }

    if (!item) {
      return res.status(404).json({ error: 'Item not found' });
    }

    if (player.guildXP < item.price) {
      return res.status(400).json({ error: 'Not enough Guild XP' });
    }

    // Purchase
    player.guildXP -= item.price;
    player.shopInventory = player.shopInventory || [];
    player.shopInventory.push({
      id: itemId,
      purchasedAt: new Date().toISOString(),
      active: false,
    });

    // Save player
    if (Array.isArray(players)) {
      fs.writeFileSync(playersPath, JSON.stringify(players, null, 2));
      invalidateRPGCache(playersPath);
    }

    res.json({ success: true, message: 'Item purchased', item });
  } catch (err) {
    console.error('Error purchasing item:', err);
    res.status(500).json({ error: err.message });
  }
});

// Quest Chains - Get available chains
app.get('/api/rpg/guild/chains', requireAuth, (req, res) => {
  try {
    const chainsPath = path.join(process.cwd(), 'data', 'quest-chains.json');
    let chains = [];
    
    if (fs.existsSync(chainsPath)) {
      chains = cachedReadJSON(chainsPath);
    }

    res.json({ success: true, chains });
  } catch (err) {
    console.error('Error loading chains:', err);
    res.status(500).json({ error: err.message });
  }
});

// Quest Chains - Create new chain
app.post('/api/rpg/guild/chains', requireAuth, (req, res) => {
  try {
    const { name, description, questIds } = req.body;

    if (!questIds || !Array.isArray(questIds) || questIds.length < 2) {
      return res.status(400).json({ error: 'Chain must have at least 2 quests' });
    }

    const chainsPath = path.join(process.cwd(), 'data', 'quest-chains.json');
    let chains = [];
    
    if (fs.existsSync(chainsPath)) {
      chains = cachedReadJSON(chainsPath);
    }

    const newChain = {
      id: `chain_${Date.now()}`,
      name,
      description,
      questIds,
      bonusMultiplier: 1.25,
      chainCompletionBonus: 500,
      createdAt: new Date().toISOString(),
    };

    chains.push(newChain);
    fs.writeFileSync(chainsPath, JSON.stringify(chains, null, 2));
    invalidateRPGCache(chainsPath);

    res.json({ success: true, message: 'Chain created', chain: newChain });
  } catch (err) {
    console.error('Error creating chain:', err);
    res.status(500).json({ error: err.message });
  }
});

/* ======================
   PLAYER MANAGEMENT API ROUTES
====================== */

// List all players with statistics
app.get('/api/rpg/players/list', requireAuth, (req, res) => {
  try {
    const playersPath = path.join(process.cwd(), 'data', 'players.json');
    let players = {};
    
    if (fs.existsSync(playersPath)) {
      const data = cachedReadJSON(playersPath);
      players = data;
    }

    // Calculate statistics
    const playerArray = Object.values(players);
    const stats = {
      totalPlayers: playerArray.length,
      avgLevel: playerArray.length > 0 ? Math.round(playerArray.reduce((sum, p) => sum + (p.level || 1), 0) / playerArray.length) : 0,
      maxLevel: playerArray.length > 0 ? Math.max(...playerArray.map(p => p.level || 1)) : 0,
      totalGold: playerArray.reduce((sum, p) => sum + (p.gold || 0), 0),
    };

    res.json({ success: true, players, stats });
  } catch (err) {
    console.error('Error listing players:', err);
    res.status(500).json({ success: false, message: err.message });
  }
});

// Get individual player data
app.get('/api/rpg/players/:userId', requireAuth, (req, res) => {
  try {
    const { userId } = req.params;
    const playersPath = path.join(process.cwd(), 'data', 'players.json');
    
    if (!fs.existsSync(playersPath)) {
      return res.status(404).json({ success: false, message: 'No player data found' });
    }

    const players = cachedReadJSON(playersPath);
    const player = players[userId];

    if (!player) {
      return res.status(404).json({ success: false, message: 'Player not found' });
    }

    res.json({ success: true, player });
  } catch (err) {
    console.error('Error getting player:', err);
    res.status(500).json({ success: false, message: err.message });
  }
});

// Reset individual player
app.post('/api/rpg/players/:userId/reset', requireAuth, (req, res) => {
  try {
    const { userId } = req.params;
    const playersPath = path.join(process.cwd(), 'data', 'players.json');
    
    if (!fs.existsSync(playersPath)) {
      return res.status(404).json({ success: false, message: 'No player data found' });
    }

    const players = cachedReadJSON(playersPath);
    
    if (!players[userId]) {
      return res.status(404).json({ success: false, message: 'Player not found' });
    }

    // Keep username, reset everything else
    const username = players[userId].username || 'Unknown';
    players[userId] = {
      userId: userId,
      username: username,
      level: 1,
      xp: 0,
      gold: 0,
      hp: 100,
      maxHp: 100,
      class: 'Warrior',
      internalClass: 'Warrior',
      skillPoints: 0,
      talentPoints: 0,
      inventory: [],
      quests: [],
      completedQuests: [],
      stats: {
        strength: 5,
        dexterity: 5,
        intelligence: 5,
        vitality: 5,
        wisdom: 5,
        charisma: 5,
      },
      professions: {
        blacksmith: { level: 0, xp: 0 },
        mining: { level: 0, xp: 0 },
        chopping: { level: 0, xp: 0 },
        herbing: { level: 0, xp: 0 },
      },
      equippedItems: {},
      availableSkillPoints: 0,
      availableTalentPoints: 0,
      skills: {},
      talents: {},
      badges: [],
      achievements: [],
      guildId: null,
      lastDaily: new Date(0).toISOString(),
      combatLog: [],
      autoGatherMaterials: [],
      pendingGatherAllMaterials: null,
      collectibles: [],
    };

    fs.writeFileSync(playersPath, JSON.stringify(players, null, 2), 'utf8');
    invalidateRPGCache(playersPath);
    res.json({ success: true, message: 'Player reset successfully' });
  } catch (err) {
    console.error('Error resetting player:', err);
    res.status(500).json({ success: false, message: err.message });
  }
});

// Delete individual player
app.delete('/api/rpg/players/:userId', requireAuth, (req, res) => {
  try {
    const { userId } = req.params;
    const playersPath = path.join(process.cwd(), 'data', 'players.json');
    
    if (!fs.existsSync(playersPath)) {
      return res.status(404).json({ success: false, message: 'No player data found' });
    }

    const players = cachedReadJSON(playersPath);
    
    if (!players[userId]) {
      return res.status(404).json({ success: false, message: 'Player not found' });
    }

    delete players[userId];
    
    fs.writeFileSync(playersPath, JSON.stringify(players, null, 2), 'utf8');
    invalidateRPGCache(playersPath);
    res.json({ success: true, message: 'Player deleted successfully' });
  } catch (err) {
    console.error('Error deleting player:', err);
    res.status(500).json({ success: false, message: err.message });
  }
});

// Backup players data
app.post('/api/rpg/players/backup', requireAuth, (req, res) => {
  try {
    const playersPath = path.join(process.cwd(), 'data', 'players.json');
    
    if (!fs.existsSync(playersPath)) {
      return res.status(404).json({ success: false, message: 'No player data found' });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(process.cwd(), 'data', `players-backup-${timestamp}.json`);
    
    const playersData = fs.readFileSync(playersPath, 'utf8');
    fs.writeFileSync(backupPath, playersData, 'utf8');
    invalidateRPGCache(backupPath);
    
    res.json({ 
      success: true, 
      message: 'Players backup created successfully',
      backupPath: `data/players-backup-${timestamp}.json`
    });
  } catch (err) {
    console.error('Error backing up players:', err);
    res.status(500).json({ success: false, message: err.message });
  }
});

// Reset all players
app.post('/api/rpg/players/reset-all', requireAuth, (req, res) => {
  try {
    const playersPath = path.join(process.cwd(), 'data', 'players.json');
    
    if (!fs.existsSync(playersPath)) {
      return res.status(404).json({ success: false, message: 'No player data found' });
    }

    // Create backup first
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(process.cwd(), 'data', `players-pre-reset-${timestamp}.json`);
    const playersData = fs.readFileSync(playersPath, 'utf8');
    fs.writeFileSync(backupPath, playersData, 'utf8');
    invalidateRPGCache(backupPath);

    const players = JSON.parse(playersData);
    const playerCount = Object.keys(players).length;

    // Reset all players
    for (const userId in players) {
      const username = players[userId].username || 'Unknown';
      players[userId] = {
        userId: userId,
        username: username,
        level: 1,
        xp: 0,
        gold: 0,
        hp: 100,
        maxHp: 100,
        inventory: [],
        quests: [],
        stats: {
          strength: 5,
          dexterity: 5,
          intelligence: 5,
          vitality: 5,
        }
      };
    }

    fs.writeFileSync(playersPath, JSON.stringify(players, null, 2), 'utf8');
    invalidateRPGCache(playersPath);
    
    res.json({ 
      success: true, 
      message: `All ${playerCount} players reset successfully`,
      count: playerCount,
      backupPath: `data/players-pre-reset-${timestamp}.json`
    });
  } catch (err) {
    console.error('Error resetting all players:', err);
    res.status(500).json({ success: false, message: err.message });
  }
});

// Delete all players
app.post('/api/rpg/players/delete-all', requireAuth, (req, res) => {
  try {
    const playersPath = path.join(process.cwd(), 'data', 'players.json');
    
    if (!fs.existsSync(playersPath)) {
      return res.status(404).json({ success: false, message: 'No player data found' });
    }

    // Create backup first
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(process.cwd(), 'data', `players-pre-delete-${timestamp}.json`);
    const playersData = fs.readFileSync(playersPath, 'utf8');
    fs.writeFileSync(backupPath, playersData, 'utf8');
    invalidateRPGCache(backupPath);

    const players = JSON.parse(playersData);
    const playerCount = Object.keys(players).length;

    // Write empty object
    fs.writeFileSync(playersPath, '{}', 'utf8');
    invalidateRPGCache(playersPath);
    
    res.json({ 
      success: true, 
      message: `All ${playerCount} players deleted successfully`,
      count: playerCount,
      backupPath: `data/players-pre-delete-${timestamp}.json`
    });
  } catch (err) {
    console.error('Error deleting all players:', err);
    res.status(500).json({ success: false, message: err.message });
  }
});

/* ======================
   DASHBOARD API ROUTES (World-based content management)
====================== */

// Items API (read-only from data definitions)
function flattenItems() {
  const list = [];
  for (const [category, items] of Object.entries(ITEMS)) {
    if (!Array.isArray(items)) continue;
    items.forEach(item => {
      if (!item?.id) return;
      list.push({
        ...item,
        category,
        itemType: item.itemType || category,
      });
    });
  }
  return list;
}

app.get('/api/items', requireAuth, (_req, res) => {
  try {
    res.json(flattenItems());
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.get('/api/items/:id', requireAuth, (req, res) => {
  try {
    const itemId = req.params.id;
    const item = flattenItems().find(i => i.id === itemId);
    if (!item) return res.status(404).json({ error: 'Item not found' });
    res.json(item);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Recipes API (read-only from data definitions)
app.get('/api/recipes', requireAuth, (_req, res) => {
  try {
    res.json(Object.values(RECIPES));
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.get('/api/recipes/:id', requireAuth, (req, res) => {
  try {
    const recipe = RECIPES[req.params.id];
    if (!recipe) return res.status(404).json({ error: 'Recipe not found' });
    res.json(recipe);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

app.get('/api/recipes/by-item/:id', requireAuth, (req, res) => {
  try {
    const itemId = req.params.id;
    const recipe = Object.values(RECIPES).find(r => r?.output?.item === itemId);
    if (!recipe) return res.json({});
    res.json(recipe);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get all worlds
app.get('/api/editor/worlds', requireAuth, (req, res) => {
  try {
    loadRPGWorlds();
    res.json(Object.values(global.rpgWorlds || {}));
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get single world by ID
app.get('/api/editor/worlds/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds();
    const worlds = global.rpgWorlds || {};
    const worldId = req.params.id;
    if (!worlds[worldId]) {
      return res.status(404).json({ error: 'World not found' });
    }
    res.json(worlds[worldId]);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Create/Update world
app.post('/api/editor/worlds', requireAuth, (req, res) => {
  try {
    const world = req.body;
    if (!world.name) {
      return res.status(400).json({ error: 'World name required' });
    }
    loadRPGWorlds();
    const worlds = global.rpgWorlds || {};
    const worldId = world.id || 'world_' + Date.now();
    worlds[worldId] = {
      ...world,
      id: worldId,
      quests: world.quests || { main: [], side: [], daily: [] },
      bosses: world.bosses || [],
      dungeons: world.dungeons || [],
      raids: world.raids || [],
      createdAt: world.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    global.rpgWorlds = worlds;
    saveRPGWorlds();
    res.json({ success: true, worldId });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Update world
app.put('/api/editor/worlds/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds();
    const worlds = global.rpgWorlds || {};
    const worldId = req.params.id;
    if (!worlds[worldId]) {
      return res.status(404).json({ error: 'World not found' });
    }
    worlds[worldId] = {
      ...worlds[worldId],
      ...req.body,
      id: worldId,
      updatedAt: new Date().toISOString()
    };
    global.rpgWorlds = worlds;
    saveRPGWorlds();
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Delete world
app.delete('/api/editor/worlds/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds();
    const worlds = global.rpgWorlds || {};
    delete worlds[req.params.id];
    global.rpgWorlds = worlds;
    saveRPGWorlds();
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get quests for a world
function mapQuestTypeToCategory(type) {
  const t = String(type || 'side').toLowerCase();
  if (t === 'main') return 'main';
  if (t === 'daily') return 'daily';
  if (t === 'weekly') return 'daily';
  if (t === 'side' || t === 'choice' || t === 'repeatable') return 'side';
  return 'side';
}

function mergeQuestsById(listA = [], listB = []) {
  const map = new Map();
  listA.forEach(q => q?.id && map.set(q.id, q));
  listB.forEach(q => q?.id && map.set(q.id, q));
  return Array.from(map.values());
}

app.get('/api/editor/quests', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const worldId = req.query.worldId;
    if (!worldId) {
      return res.status(400).json({ error: 'worldId required' });
    }
    const world = worlds[worldId];
    if (!world) {
      return res.json({ main: [], side: [], daily: [] });
    }
    const legacy = world.quests || { main: [], side: [], daily: [] };
    const entities = world.entities?.quests || {};
    const categorized = { main: [], side: [], daily: [] };
    Object.values(entities).forEach(q => {
      const category = mapQuestTypeToCategory(q?.type || q?.category);
      categorized[category].push(q);
    });
    res.json({
      main: mergeQuestsById(legacy.main, categorized.main),
      side: mergeQuestsById(legacy.side, categorized.side),
      daily: mergeQuestsById(legacy.daily, categorized.daily)
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Create quest
app.post('/api/editor/quests', requireAuth, (req, res) => {
  try {
    const quest = req.body;
    if (!quest.title || !quest.worldId) {
      return res.status(400).json({ error: 'Quest title and worldId required' });
    }
    loadRPGWorlds();
    const worlds = global.rpgWorlds || {};
    const world = worlds[quest.worldId];
    if (!world) {
      return res.status(404).json({ error: 'World not found' });
    }
    if (!world.quests) world.quests = { main: [], side: [], daily: [] };
    
    const storageCategory = mapQuestTypeToCategory(quest.type);
    
    if (!world.quests[storageCategory]) world.quests[storageCategory] = [];
    
    const questId = quest.id || 'quest_' + Date.now();
    const newQuest = {
      ...quest,
      id: questId,
      name: quest.name || quest.title,
      createdAt: quest.createdAt || new Date().toISOString()
    };
    
    world.quests[storageCategory].push(newQuest);
    if (!world.entities) {
      world.entities = { monsters: {}, items: {}, npcs: {}, locations: {}, dungeons: {}, raids: {}, worldBosses: {}, quests: {} };
    }
    if (!world.entities.quests) world.entities.quests = {};
    world.entities.quests[questId] = {
      ...newQuest,
      category: storageCategory
    };
    world.updatedAt = new Date().toISOString();
    global.rpgWorlds = worlds;
    saveRPGWorlds();
    
    res.json({ success: true, questId });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get single quest
app.get('/api/editor/quests/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const questId = req.params.id;
    
    for (const world of Object.values(worlds)) {
      const entityQuest = world.entities?.quests?.[questId];
      if (entityQuest) {
        return res.json(entityQuest);
      }
      if (world.quests) {
        for (const type of ['main', 'side', 'daily']) {
          const quest = world.quests[type]?.find(q => q.id === questId);
          if (quest) {
            return res.json(quest);
          }
        }
      }
    }
    res.status(404).json({ error: 'Quest not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Update quest
app.put('/api/editor/quests/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const questId = req.params.id;
    const updates = req.body;
    
    for (const world of Object.values(worlds)) {
      if (world.entities?.quests?.[questId]) {
        world.entities.quests[questId] = {
          ...world.entities.quests[questId],
          ...updates,
          id: questId,
          updatedAt: new Date().toISOString()
        };
      }
      if (world.quests) {
        for (const type of ['main', 'side', 'daily']) {
          const questIndex = world.quests[type]?.findIndex(q => q.id === questId);
          if (questIndex !== -1) {
            world.quests[type][questIndex] = {
              ...world.quests[type][questIndex],
              ...updates,
              id: questId,
              updatedAt: new Date().toISOString()
            };
            world.updatedAt = new Date().toISOString();
            global.rpgWorlds = worlds;
            saveRPGWorlds();
            return res.json({ success: true });
          }
        }
      }
      if (world.entities?.quests?.[questId]) {
        world.updatedAt = new Date().toISOString();
        global.rpgWorlds = worlds;
        saveRPGWorlds();
        return res.json({ success: true });
      }
    }
    res.status(404).json({ error: 'Quest not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Delete quest
app.delete('/api/editor/quests/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const questId = req.params.id;
    
    for (const world of Object.values(worlds)) {
      let deletedEntity = false;
      if (world.entities?.quests?.[questId]) {
        delete world.entities.quests[questId];
        deletedEntity = true;
      }
      if (world.quests) {
        for (const type of ['main', 'side', 'daily']) {
          const questIndex = world.quests[type]?.findIndex(q => q.id === questId);
          if (questIndex !== -1) {
            world.quests[type].splice(questIndex, 1);
            world.updatedAt = new Date().toISOString();
            global.rpgWorlds = worlds;
            saveRPGWorlds();
            return res.json({ success: true });
          }
        }
      }
      if (deletedEntity) {
        world.updatedAt = new Date().toISOString();
        global.rpgWorlds = worlds;
        saveRPGWorlds();
        return res.json({ success: true });
      }
    }
    res.status(404).json({ error: 'Quest not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// === TOWN DEFENCE QUEST ROUTES ===
app.get('/api/defense-quests', requireAuth, async (req, res) => {
  try {
    const defenseQuestsPath = path.join(DATA_DIR, 'defense-quests.json');
    let defenseQuests = [];
    
    // Try to load from JSON file first
    if (fs.existsSync(defenseQuestsPath)) {
      const data = fs.readFileSync(defenseQuestsPath, 'utf8');
      defenseQuests = JSON.parse(data);
    } else {
      // Fall back to code-based quests
      const { DEFENSE_QUESTS } = await import('./Discord bot - test branch/rpg/data/defense-quests.js');
      defenseQuests = DEFENSE_QUESTS;
      // Save them to JSON for future edits
      fs.writeFileSync(defenseQuestsPath, JSON.stringify(defenseQuests, null, 2));
      invalidateRPGCache(defenseQuestsPath);
    }
    
    res.json(defenseQuests);
  } catch (err) {
    console.error('Error loading defense quests:', err);
    res.status(500).json({ error: err.message });
  }
});

app.get('/api/defense-quests/:id', requireAuth, async (req, res) => {
  try {
    const defenseQuestsPath = path.join(DATA_DIR, 'defense-quests.json');
    let defenseQuests = [];
    
    if (fs.existsSync(defenseQuestsPath)) {
      const data = fs.readFileSync(defenseQuestsPath, 'utf8');
      defenseQuests = JSON.parse(data);
    } else {
      const { DEFENSE_QUESTS } = await import('./Discord bot - test branch/rpg/data/defense-quests.js');
      defenseQuests = DEFENSE_QUESTS;
    }
    
    const quest = defenseQuests.find(q => q.id === req.params.id);
    if (!quest) {
      return res.status(404).json({ error: 'Defense quest not found' });
    }
    res.json(quest);
  } catch (err) {
    console.error('Error loading defense quest:', err);
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/defense-quests', requireAuth, (req, res) => {
  try {
    const defenseQuestsPath = path.join(DATA_DIR, 'defense-quests.json');
    let defenseQuests = [];
    
    if (fs.existsSync(defenseQuestsPath)) {
      const data = fs.readFileSync(defenseQuestsPath, 'utf8');
      defenseQuests = JSON.parse(data);
    }
    
    const newQuest = req.body;
    if (!newQuest.id) {
      newQuest.id = 'defense_' + Date.now();
    }
    
    defenseQuests.push(newQuest);
    fs.writeFileSync(defenseQuestsPath, JSON.stringify(defenseQuests, null, 2));
    invalidateRPGCache(defenseQuestsPath);
    
    res.json({ success: true, questId: newQuest.id });
  } catch (err) {
    console.error('Error creating defense quest:', err);
    res.status(500).json({ error: err.message });
  }
});

app.put('/api/defense-quests/:id', requireAuth, (req, res) => {
  try {
    const defenseQuestsPath = path.join(DATA_DIR, 'defense-quests.json');
    let defenseQuests = [];
    
    if (fs.existsSync(defenseQuestsPath)) {
      const data = fs.readFileSync(defenseQuestsPath, 'utf8');
      defenseQuests = JSON.parse(data);
    }
    
    const index = defenseQuests.findIndex(q => q.id === req.params.id);
    if (index === -1) {
      return res.status(404).json({ error: 'Defense quest not found' });
    }
    
    defenseQuests[index] = { ...defenseQuests[index], ...req.body, id: req.params.id };
    fs.writeFileSync(defenseQuestsPath, JSON.stringify(defenseQuests, null, 2));
    invalidateRPGCache(defenseQuestsPath);
    
    res.json({ success: true });
  } catch (err) {
    console.error('Error updating defense quest:', err);
    res.status(500).json({ error: err.message });
  }
});

app.delete('/api/defense-quests/:id', requireAuth, (req, res) => {
  try {
    const defenseQuestsPath = path.join(DATA_DIR, 'defense-quests.json');
    let defenseQuests = [];
    
    if (fs.existsSync(defenseQuestsPath)) {
      const data = fs.readFileSync(defenseQuestsPath, 'utf8');
      defenseQuests = JSON.parse(data);
    }
    
    const index = defenseQuests.findIndex(q => q.id === req.params.id);
    if (index === -1) {
      return res.status(404).json({ error: 'Defense quest not found' });
    }
    
    defenseQuests.splice(index, 1);
    fs.writeFileSync(defenseQuestsPath, JSON.stringify(defenseQuests, null, 2));
    invalidateRPGCache(defenseQuestsPath);
    
    res.json({ success: true });
  } catch (err) {
    console.error('Error deleting defense quest:', err);
    res.status(500).json({ error: err.message });
  }
});

// Get bosses for a world
app.get('/api/editor/bosses', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const worldId = req.query.worldId;
    if (!worldId) {
      // Return all bosses if no worldId
      const allBosses = [];
      for (const world of Object.values(worlds)) {
        if (world.entities?.worldBosses) {
          allBosses.push(...Object.values(world.entities.worldBosses));
        }
      }
      return res.json(allBosses);
    }
    const world = worlds[worldId];
    if (!world) {
      return res.json([]);
    }
    const bosses = world.entities?.worldBosses ? Object.values(world.entities.worldBosses) : [];
    res.json(bosses);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Create boss
app.post('/api/editor/bosses', requireAuth, (req, res) => {
  try {
    const boss = req.body;
    if (!boss.name || !boss.worldId) {
      return res.status(400).json({ error: 'Boss name and worldId required' });
    }
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const world = worlds[boss.worldId];
    if (!world) {
      return res.status(404).json({ error: 'World not found' });
    }
    if (!world.entities) world.entities = { monsters: {}, items: {}, npcs: {}, locations: {}, dungeons: {}, raids: {}, worldBosses: {}, quests: {} };
    if (!world.entities.worldBosses) world.entities.worldBosses = {};
    
    const bossId = boss.id || 'e_' + Date.now();
    const newBoss = {
      ...boss,
      id: bossId,
      createdAt: boss.createdAt || new Date().toISOString()
    };
    
    world.entities.worldBosses[bossId] = newBoss;
    world.updatedAt = new Date().toISOString();
    global.rpgWorlds = worlds;
    saveRPGWorlds();
    
    res.json({ success: true, bossId });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get single boss
app.get('/api/editor/bosses/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const bossId = req.params.id;
    
    for (const world of Object.values(worlds)) {
      const boss = world.entities?.worldBosses?.[bossId];
      if (boss) {
        return res.json(boss);
      }
    }
    res.status(404).json({ error: 'Boss not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Update boss
app.put('/api/editor/bosses/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const bossId = req.params.id;
    const updates = req.body;
    
    for (const world of Object.values(worlds)) {
      const boss = world.entities?.worldBosses?.[bossId];
      if (boss) {
        world.entities.worldBosses[bossId] = {
          ...boss,
          ...updates,
          id: bossId,
          updatedAt: new Date().toISOString()
        };
        world.updatedAt = new Date().toISOString();
        global.rpgWorlds = worlds;
        saveRPGWorlds();
        return res.json({ success: true });
      }
    }
    res.status(404).json({ error: 'Boss not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Delete boss
app.delete('/api/editor/bosses/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const bossId = req.params.id;
    
    for (const world of Object.values(worlds)) {
      if (world.entities?.worldBosses?.[bossId]) {
        delete world.entities.worldBosses[bossId];
        world.updatedAt = new Date().toISOString();
        global.rpgWorlds = worlds;
        saveRPGWorlds();
        return res.json({ success: true });
      }
    }
    res.status(404).json({ error: 'Boss not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get dungeons for a world
app.get('/api/editor/dungeons', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const worldId = req.query.worldId;
    if (!worldId) {
      return res.status(400).json({ error: 'worldId required' });
    }
    const world = worlds[worldId];
    if (!world) {
      return res.json([]);
    }
    const combined = [];
    if (Array.isArray(world.dungeons)) {
      combined.push(...world.dungeons);
    }
    const entityDungeons = Object.values(world.entities?.dungeons || {});
    if (entityDungeons.length > 0) {
      combined.push(...entityDungeons.map(d => ({
        ...d,
        worldId: d.worldId || world.id || worldId,
      })));
    }

    const byId = new Map();
    for (const dungeon of combined) {
      const id = dungeon?.id || dungeon?.name;
      if (!id) continue;
      if (!byId.has(id)) {
        byId.set(id, { ...dungeon, id });
      }
    }

    res.json(Array.from(byId.values()));
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Create dungeon
app.post('/api/editor/dungeons', requireAuth, (req, res) => {
  try {
    const dungeon = req.body;
    if (!dungeon.name || !dungeon.worldId) {
      return res.status(400).json({ error: 'Dungeon name and worldId required' });
    }
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const world = worlds[dungeon.worldId];
    if (!world) {
      return res.status(404).json({ error: 'World not found' });
    }
    if (!world.dungeons) world.dungeons = [];
    
    const dungeonId = dungeon.id || 'dungeon_' + Date.now();
    const newDungeon = {
      ...dungeon,
      id: dungeonId,
      createdAt: dungeon.createdAt || new Date().toISOString()
    };
    
    world.dungeons.push(newDungeon);
    world.updatedAt = new Date().toISOString();
    global.rpgWorlds = worlds;
    saveRPGWorlds();
    
    res.json({ success: true, dungeonId });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get single dungeon
app.get('/api/editor/dungeons/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const dungeonId = req.params.id;
    
    for (const world of Object.values(worlds)) {
      const dungeon = world.dungeons?.find(d => d.id === dungeonId);
      if (dungeon) {
        return res.json(dungeon);
      }
      const entityDungeon = world.entities?.dungeons?.[dungeonId];
      if (entityDungeon) {
        return res.json({
          ...entityDungeon,
          worldId: entityDungeon.worldId || world.id,
        });
      }
    }
    res.status(404).json({ error: 'Dungeon not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Update dungeon
app.put('/api/editor/dungeons/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const dungeonId = req.params.id;
    const updates = req.body;
    
    for (const world of Object.values(worlds)) {
      const dungeonIndex = world.dungeons?.findIndex(d => d.id === dungeonId);
      if (dungeonIndex !== -1) {
        world.dungeons[dungeonIndex] = {
          ...world.dungeons[dungeonIndex],
          ...updates,
          id: dungeonId,
          updatedAt: new Date().toISOString()
        };
        world.updatedAt = new Date().toISOString();
        global.rpgWorlds = worlds;
        saveRPGWorlds();
        return res.json({ success: true });
      }

      if (world.entities?.dungeons?.[dungeonId]) {
        world.entities.dungeons[dungeonId] = {
          ...world.entities.dungeons[dungeonId],
          ...updates,
          id: dungeonId,
          updatedAt: new Date().toISOString()
        };
        world.updatedAt = new Date().toISOString();
        global.rpgWorlds = worlds;
        saveRPGWorlds();
        return res.json({ success: true });
      }
    }
    res.status(404).json({ error: 'Dungeon not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Delete dungeon
app.delete('/api/editor/dungeons/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const dungeonId = req.params.id;
    
    for (const world of Object.values(worlds)) {
      const dungeonIndex = world.dungeons?.findIndex(d => d.id === dungeonId);
      if (dungeonIndex !== -1) {
        world.dungeons.splice(dungeonIndex, 1);
        world.updatedAt = new Date().toISOString();
        global.rpgWorlds = worlds;
        saveRPGWorlds();
        return res.json({ success: true });
      }

      if (world.entities?.dungeons?.[dungeonId]) {
        delete world.entities.dungeons[dungeonId];
        world.updatedAt = new Date().toISOString();
        global.rpgWorlds = worlds;
        saveRPGWorlds();
        return res.json({ success: true });
      }
    }
    res.status(404).json({ error: 'Dungeon not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/* ======================
   RAIDS API ROUTES
====================== */

// Get all raids for a world
app.get('/api/editor/raids', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const worldId = req.query.worldId;
    if (!worldId) {
      return res.status(400).json({ error: 'worldId required' });
    }
    const world = worlds[worldId];
    if (!world) {
      return res.json([]);
    }
    res.json(world.raids || []);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Create raid
app.post('/api/editor/raids', requireAuth, (req, res) => {
  try {
    const raid = req.body;
    if (!raid.name || !raid.worldId) {
      return res.status(400).json({ error: 'Raid name and worldId required' });
    }
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const world = worlds[raid.worldId];
    if (!world) {
      return res.status(404).json({ error: 'World not found' });
    }
    if (!world.raids) world.raids = [];

    const raidId = raid.id || 'raid_' + Date.now();
    const newRaid = {
      ...raid,
      id: raidId,
      createdAt: raid.createdAt || new Date().toISOString()
    };

    world.raids.push(newRaid);
    world.updatedAt = new Date().toISOString();
    global.rpgWorlds = worlds;
    saveRPGWorlds();

    res.json({ success: true, raidId });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Get single raid
app.get('/api/editor/raids/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const raidId = req.params.id;

    for (const world of Object.values(worlds)) {
      const raid = world.raids?.find(r => r.id === raidId);
      if (raid) {
        return res.json(raid);
      }
    }
    res.status(404).json({ error: 'Raid not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Update raid
app.put('/api/editor/raids/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const raidId = req.params.id;
    const updates = req.body;

    for (const world of Object.values(worlds)) {
      const raidIndex = world.raids?.findIndex(r => r.id === raidId);
      if (raidIndex !== -1) {
        world.raids[raidIndex] = {
          ...world.raids[raidIndex],
          ...updates,
          id: raidId,
          updatedAt: new Date().toISOString()
        };
        world.updatedAt = new Date().toISOString();
        global.rpgWorlds = worlds;
        saveRPGWorlds();
        return res.json({ success: true });
      }
    }
    res.status(404).json({ error: 'Raid not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Delete raid
app.delete('/api/editor/raids/:id', requireAuth, (req, res) => {
  try {
    loadRPGWorlds(); const worlds = global.rpgWorlds || {};
    const raidId = req.params.id;

    for (const world of Object.values(worlds)) {
      const raidIndex = world.raids?.findIndex(r => r.id === raidId);
      if (raidIndex !== -1) {
        world.raids.splice(raidIndex, 1);
        world.updatedAt = new Date().toISOString();
        global.rpgWorlds = worlds;
        saveRPGWorlds();
        return res.json({ success: true });
      }
    }
    res.status(404).json({ error: 'Raid not found' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

/* ======================
   RUN
====================== */
// Error handler for Discord client
client.on('error', (err) => {
  console.error('[Discord] Client error:', err.message);
  try { addLog('error', `Discord client error: ${err.message}`); } catch {}
});

client.on('warn', (msg) => {
  console.warn('[Discord] Warning:', msg);
  try { addLog('warn', `Discord warning: ${msg}`); } catch {}
});

// Login to Discord with error handling
const token = process.env.DISCORD_TOKEN;
if (!token) {
  console.error('[FATAL] DISCORD_TOKEN environment variable is not set!');
} else {
  console.log('[Discord] Logging in...');
  client.login(token).then(() => {
    console.log('[Discord] Login successful, waiting for ready event...');
  }).catch(err => {
    console.error('[FATAL] Discord login failed:', err.message);
    try { addLog('error', `Discord login failed: ${err.message}`); } catch {}
  });
}

// Auto-refresh Twitch token on startup if expired
if (twitchTokens.refresh_token && twitchTokens.expires_at) {
  const now = Date.now();
  const bufferMs = 5 * 60 * 1000; // 5 min buffer
  if (now >= twitchTokens.expires_at - bufferMs) {
    console.log('[Twitch] Persisted token expired or expiring soon, attempting auto-refresh...');
    refreshTwitchToken().then(ok => {
      if (ok) console.log('[Twitch] Token refreshed successfully on startup');
      else console.warn('[Twitch] Token refresh failed on startup â€” re-authorize via dashboard');
    }).catch(() => {});
  } else {
    console.log(`[Twitch] Persisted token valid until ${new Date(twitchTokens.expires_at).toLocaleString()}`);
  }
}

const PORT = Number.parseInt(process.env.PORT || '3000', 10);
httpServer.on('error', (err) => {
  const code = err?.code || 'UNKNOWN';
  const msg = err?.message || String(err);
  try { addLog('error', `HTTP server error (${code}): ${msg}`); } catch {}

  if (code === 'EADDRINUSE') {
    console.error(`Port ${PORT} already in use. Stop the other process or set PORT in .env.`);
  }
});

// Guild Statistics Tab
function renderRPGGuildStatsTab() {
  return `
<div class="card">
  <h2>ðŸ“Š Guild Statistics & Leaderboard</h2>
  <p style="color:#b0b0b0">View player rankings, quest completion rates, and guild analytics</p>
  <div style="display:grid;grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));gap:15px;margin-top:15px">
    <button class="primary" onclick="showGuildLeaderboard()" style="padding:12px;background:#2196f3;border:none;border-radius:6px;color:#fff;cursor:pointer;font-weight:bold">ðŸ‘‘ Leaderboard</button>
    <button class="primary" onclick="showGuildOverviewStats()" style="padding:12px;background:#4caf50;border:none;border-radius:6px;color:#fff;cursor:pointer;font-weight:bold">ðŸ“ˆ Overview</button>
    <button class="primary" onclick="showGuildRankDistribution()" style="padding:12px;background:#ff9800;border:none;border-radius:6px;color:#fff;cursor:pointer;font-weight:bold">ðŸ“Š Rank Distribution</button>
  </div>
</div>
  `;
}

// Show Guild Leaderboard
function showGuildLeaderboard() {
  fetch('/api/rpg/guild/statistics/leaderboard')
    .then(r => r.json())
    .then(data => {
      if (!data.success) {
        alert('Error loading leaderboard');
        return;
      }

      const leaderboard = data.leaderboard || [];
      const rows = leaderboard.slice(0, 20).map((player, idx) => `
        <tr>
          <td style="color:#ffaa00;font-weight:bold">#${idx + 1}</td>
          <td>${player.username}</td>
          <td>${player.rank}</td>
          <td style="color:#4caf50">${player.guildXP.toLocaleString()}</td>
          <td>${player.level}</td>
          <td>${player.totalQuestsCompleted}</td>
        </tr>
      `).join('');

      const modal = `
        <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:2000;display:flex;align-items:center;justify-content:center;padding:20px">
          <div style="background:#1e1e1e;padding:30px;border-radius:8px;max-width:900px;width:100%;max-height:80vh;overflow-y:auto">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
              <h2 style="margin:0">ðŸ‘‘ Guild Leaderboard</h2>
              <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">âœ•</button>
            </div>
            
            <table style="width:100%;border-collapse:collapse">
              <thead>
                <tr style="border-bottom:2px solid #404040">
                  <th style="padding:10px;text-align:left;color:#ffaa00">#</th>
                  <th style="padding:10px;text-align:left">Player</th>
                  <th style="padding:10px;text-align:left">Rank</th>
                  <th style="padding:10px;text-align:left;color:#4caf50">Guild XP</th>
                  <th style="padding:10px;text-align:left">Level</th>
                  <th style="padding:10px;text-align:left">Quests</th>
                </tr>
              </thead>
              <tbody>
                ${rows}
              </tbody>
            </table>

            <button onclick="this.parentElement.parentElement.remove()" style="width:100%;padding:12px;background:#2196f3;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold;margin-top:20px">Close</button>
          </div>
        </div>
      `;
      
      document.body.insertAdjacentHTML('beforeend', modal);
    })
    .catch(err => console.error('Leaderboard error:', err));
}

// Show Guild Overview Stats
function showGuildOverviewStats() {
  fetch('/api/rpg/guild/statistics/overview')
    .then(r => r.json())
    .then(data => {
      if (!data.success) {
        alert('Error loading statistics');
        return;
      }

      const stats = data.statistics || {};
      const rankDist = stats.rankDistribution || [];
      const rankCards = rankDist.map(r => `
        <div style="background:linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0));padding:15px;border-radius:6px;text-align:center">
          <div style="font-size:24px;font-weight:bold;color:#ffaa00">Rank ${r.rank}</div>
          <div style="color:#aaa;font-size:14px">Players: ${r.count}</div>
          <div style="color:#4caf50;font-size:13px">${r.percentage}%</div>
        </div>
      `).join('');

      const modal = `
        <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:2000;display:flex;align-items:center;justify-content:center;padding:20px">
          <div style="background:#1e1e1e;padding:30px;border-radius:8px;max-width:800px;width:100%;max-height:80vh;overflow-y:auto">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
              <h2 style="margin:0">ðŸ“ˆ Guild Overview</h2>
              <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">âœ•</button>
            </div>
            
            <div style="display:grid;grid-template-columns:repeat(2, 1fr);gap:15px;margin-bottom:20px">
              <div style="background:#2a2f3a;padding:15px;border-radius:6px">
                <div style="font-size:12px;color:#aaa">Total Players</div>
                <div style="font-size:28px;font-weight:bold;color:#2196f3">${stats.totalPlayers || 0}</div>
              </div>
              <div style="background:#2a2f3a;padding:15px;border-radius:6px">
                <div style="font-size:12px;color:#aaa">Avg Guild XP</div>
                <div style="font-size:28px;font-weight:bold;color:#4caf50">${stats.averageRankXP || 0}</div>
              </div>
              <div style="background:#2a2f3a;padding:15px;border-radius:6px">
                <div style="font-size:12px;color:#aaa">Daily Completion</div>
                <div style="font-size:28px;font-weight:bold;color:#ff9800">${stats.completionRates?.dailyCompletionRate || '0%'}</div>
              </div>
              <div style="background:#2a2f3a;padding:15px;border-radius:6px">
                <div style="font-size:12px;color:#aaa">Weekly Completion</div>
                <div style="font-size:28px;font-weight:bold;color:#ff9800">${stats.completionRates?.weeklyCompletionRate || '0%'}</div>
              </div>
            </div>

            <h3 style="color:#aaa;margin:20px 0 15px 0">Rank Distribution</h3>
            <div style="display:grid;grid-template-columns:repeat(4, 1fr);gap:10px">
              ${rankCards}
            </div>

            <button onclick="this.parentElement.parentElement.remove()" style="width:100%;padding:12px;background:#2196f3;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold;margin-top:20px">Close</button>
          </div>
        </div>
      `;
      
      document.body.insertAdjacentHTML('beforeend', modal);
    })
    .catch(err => console.error('Stats error:', err));
}

// Show Rank Distribution Chart
function showGuildRankDistribution() {
  fetch('/api/rpg/guild/statistics/overview')
    .then(r => r.json())
    .then(data => {
      if (!data.success) {
        alert('Error loading statistics');
        return;
      }

      const stats = data.statistics || {};
      const rankData = stats.rankDistribution || [];
      const completionByRank = stats.completionByRank || [];

      const rankBars = rankData.map(r => {
        const barWidth = r.percentage * 2;
        return `
          <div style="margin-bottom:15px">
            <div style="display:flex;justify-content:space-between;margin-bottom:5px">
              <strong style="color:#ffaa00">Rank ${r.rank}</strong>
              <span style="color:#aaa">${r.count} players (${r.percentage}%)</span>
            </div>
            <div style="background:#404040;border-radius:4px;height:20px;overflow:hidden">
              <div style="background:linear-gradient(90deg, #2196f3, #4caf50);width:${barWidth}%;height:100%;transition:all 0.3s"></div>
            </div>
          </div>
        `;
      }).join('');

      const completionBars = completionByRank.map(c => {
        return `
          <div style="margin-bottom:15px">
            <div style="display:flex;justify-content:space-between;margin-bottom:5px">
              <strong style="color:#ffaa00">Rank ${c.rank}</strong>
              <span style="color:#aaa">Avg: ${c.average} quests</span>
            </div>
          </div>
        `;
      }).join('');

      const modal = `
        <div style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:2000;display:flex;align-items:center;justify-content:center;padding:20px">
          <div style="background:#1e1e1e;padding:30px;border-radius:8px;max-width:700px;width:100%;max-height:80vh;overflow-y:auto">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px">
              <h2 style="margin:0">ðŸ“Š Rank Distribution</h2>
              <button onclick="this.parentElement.parentElement.parentElement.remove()" style="background:none;border:none;color:#ccc;font-size:24px;cursor:pointer">âœ•</button>
            </div>
            
            <h3 style="color:#aaa;margin:0 0 15px 0">Player Distribution by Rank</h3>
            ${rankBars}

            <h3 style="color:#aaa;margin:30px 0 15px 0">Average Quest Completion by Rank</h3>
            ${completionBars}

            <button onclick="this.parentElement.parentElement.remove()" style="width:100%;padding:12px;background:#2196f3;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:bold;margin-top:20px">Close</button>
          </div>
        </div>
      `;
      
      document.body.insertAdjacentHTML('beforeend', modal);
    })
    .catch(err => console.error('Distribution error:', err));
}

httpServer.listen(PORT, '0.0.0.0', () => {
  console.log(`Dashboard on http://localhost:${PORT}`);
});


