/**
 * RPG Command Handler - Main slash command and interaction handling
 */

import {
  SlashCommandBuilder,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  StringSelectMenuBuilder,
  EmbedBuilder,
  ModalBuilder,
  TextInputBuilder,
  TextInputStyle,
} from 'discord.js';
import fs from 'fs';
import path from 'path';
import Player from '../models/Player.js';
import PlayerManager from '../systems/PlayerManager.js';
import CombatSystem from '../systems/CombatSystem.js';
import QOLSystem from '../systems/QOLSystem.js';
import EquipmentBuilds from '../systems/EquipmentBuilds.js';
import CombatRecommendations from '../systems/CombatRecommendations.js';
import BreadcrumbNavigation from '../systems/BreadcrumbNavigation.js';
import ComboVisualizer from '../systems/ComboVisualizer.js';
import GuildAnalytics from '../systems/GuildAnalytics.js';
import ProfessionEfficiency from '../systems/ProfessionEfficiency.js';
import EnvironmentPredictions from '../systems/EnvironmentPredictions.js';
import DailyQuestTracker from '../systems/DailyQuestTracker.js';
import DamageTracker from '../systems/DamageTracker.js';
import BossWeaknessAnalyzer from '../systems/BossWeaknessAnalyzer.js';
import LootAnalytics from '../systems/LootAnalytics.js';
import SkillMastery from '../systems/SkillMastery.js';
import FavoriteItemLoadout from '../systems/FavoriteItemLoadout.js';
import NotificationSystem from '../systems/NotificationSystem.js';
import EnemyEncyclopedia from '../systems/EnemyEncyclopedia.js';
import ShorthandCommandTips from '../systems/ShorthandCommandTips.js';
import CraftingQueue from '../systems/CraftingQueue.js';
import AutoSellJunk from '../systems/AutoSellJunk.js';
import StatComparison from '../systems/StatComparison.js';
import TimeZoneSupport from '../systems/TimeZoneSupport.js';
import UIThemeManager from '../systems/UIThemeManager.js';
import SessionStatistics from '../systems/SessionStatistics.js';
import RoguelikeManager from '../systems/RoguelikeManager.js';
import TowerManager from '../systems/TowerManager.js';
import UIBuilder from '../ui/UIBuilder.js';
import { getNarrativeChoice } from '../data/narrative-classes.js';
import { getClass, getSkill } from '../data/classes.js';
import { getNextWorldId, getWorld, getWorldBoss } from '../data/worlds.js';
import { 
  getAllWorlds, 
  getWorld as getWorldFromContent,
  getAllBosses,
  getBossesByWorld,
  getAllDungeons,
  getDungeonsByWorld,
  getAllRaids,
  getRaidsByWorld,
  getWorldByBoss,
  getItemsForBot,
  getItemByIdForBot
} from '../data/content-system.js';
import { RECIPES, RECIPES_SORTED, MATERIALS, getRecipe, getMaterial } from '../data/professions.js';
import { getGem } from '../data/gems.js';
import { getEquipment } from '../data/equipment.js';
import { getAvailableDungeons, getDungeonById, DUNGEONS } from '../data/dungeons.js';
import { getAvailableRaids, getRaidById } from '../data/raids.js';
import { getTalent, getTalents, getTalentsByClass } from '../data/talents.js';
import { getItemById } from '../data/items.js';
import { getQuestCategoriesByWorld, getQuestById } from '../data/quests.js';
import { getWeeklyQuests } from '../data/quest-system.js';
import { getCollectible, checkCollectibleMilestone, getNextMilestone, COLLECTIBLE_MILESTONES } from '../data/collectibles.js';
import { getEarnedTitles, getEarnedBadges, getTitle, getBadge, TITLES, BADGES } from '../data/titles.js';
import { getEarnedGuildAchievements, getUnclaimedGuildAchievements, getGuildAchievement, GUILD_ACHIEVEMENTS } from '../data/guild-achievements.js';
import {
  getGatheringSkill,
  getGatheringXpToNextLevel,
  generateGatheringMaterials,
  generateAreaGatheringMaterials,
  getGatheringProfessionLevel,
  getGatheringProfessionBonuses,
  applyGatheringYieldBonus,
  addGatheringProfessionXp,
  getGatheringToolTier,
  GATHERING_SKILLS,
  GATHERING_TOOL_TIERS,
} from '../data/gathering.js';
import { GATHERING_AREAS, getGatheringArea, getAvailableAreas, getUnlockedAreas } from '../data/gathering-areas.js';
import { getMaterials } from '../data/materials-api.js';
import { getProfessionRewards, getUnlockedRewards } from '../data/profession-rewards.js';
import { getGatheringReward } from '../data/gathering-rewards.js';
import AutoGatherManager from '../systems/AutoGatherManager.js';
import { loadBalanceData } from '../data/balance.js';
import { DEFENSE_QUESTS, getAvailableDefenseQuests, getDefenseQuestById, loadDefenseQuests } from '../data/defense-quests.js';
import { getRankByXP, getNextRank, getXPToNextRank, getRankKey, GUILD_RANKS } from '../data/guild-ranks.js';
import { getAvailableDailyQuests, getAvailableWeeklyQuests, getAvailableLimitedQuests, claimLimitedQuest, getGuildQuestById, getAllGuildQuests, normalizeGuildQuestObjective } from '../data/guild-quests.js';
import { getAvailableBounties, claimBounty, getBountyById, createPlayerBounty } from '../data/bounties.js';
import { getUnlockedShopTiers } from '../data/shops.js';
import { guildManager } from '../systems/GuildManager.js';
import { getGuildLevel, getXPToNextLevel, getGuildBuffs, GUILD_BUFF_COSTS } from '../data/guild-levels.js';
import { getAvailableGuildBosses, getAvailableWorldBosses, getGuildBoss, getWorldBoss as getGuildWorldBoss } from '../data/guild-bosses.js';
import { WORLD_BOSSES } from '../data/bosses.js';
import { getCombatStyle, getStylesForClass, COMBAT_STYLES } from '../data/combat-styles.js';
import { ENVIRONMENTS, getEnvironment, getRandomEnvironment, getEnvironmentDescription } from '../data/environmental-effects.js';
import { BOSS_ABILITIES, getBossTemplate, getBossPhaseInfo } from '../data/boss-abilities.js';
import { getCombosForClass } from '../data/skill-combos.js';
import { getEnemyGroup, getRandomEnemyGroupForLevel, getGroupSummary } from '../data/multi-enemy-encounters.js';

// Helper function to get items from content system (with fallback to legacy items)
function getItemByIdDynamic(itemId) {
  // Try gems first (Master Blacksmith items)
  const gem = getGem(itemId);
  if (gem) return gem;
  
  // Try content-based items first (dashboard items have priority)
  const contentItem = getItemByIdForBot(itemId);
  if (contentItem) return contentItem;
  
  // Fall back to hardcoded items from items.js for existing recipes
  // This ensures recipes that output legacy items still work
  return getItemById(itemId);
}

export default class RPGCommand {
  constructor() {
    this.playerManager = new PlayerManager();
    this.combatSystem = new CombatSystem();
    this.qolSystem = new QOLSystem();
    this.equipmentBuilds = new EquipmentBuilds();
    this.combatRecommendations = new CombatRecommendations();
    this.breadcrumbNav = new BreadcrumbNavigation();
    this.comboVisualizer = new ComboVisualizer();
    this.guildAnalytics = new GuildAnalytics();
    this.professionEfficiency = new ProfessionEfficiency();
    this.environmentPredictions = new EnvironmentPredictions();
    // Tier 1 Systems - Lazy loaded (saves 200-300ms startup)
    this._dailyQuestTracker = null;
    this._damageTracker = null;
    this._bossWeaknessAnalyzer = null;
    this._lootAnalytics = null;
    this._skillMastery = null;
    // Tier 2 Systems - Lazy loaded
    this._favoriteItemLoadout = null;
    this._notificationSystem = null;
    this._enemyEncyclopedia = null;
    this._shorthandCommandTips = null;
    this._craftingQueue = null;
    // Tier 4 Systems - Lazy loaded
    this._autoSellJunk = null;
    this._statComparison = null;
    this._timeZoneSupport = null;
    this._uiThemeManager = null;
    this._sessionStatistics = null;
    this.autoGatherManager = new AutoGatherManager(this);
    this.guildManager = guildManager;
    this.activeMenus = new Map();
    this.client = null;
    
    // Performance optimizations
    this.dataCache = new Map();
    this.playerCache = new Map();
    this.cacheExpiry = 5 * 60 * 1000;
    this.performanceMetrics = { totalRequests: 0, slowRequests: 0, avgResponseTime: 0 };
    this.enableDetailedTracking = false;
    
    // Component pooling
    this.componentPool = {
      backButton: null,
      backToHubButton: null,
      commonRows: new Map()
    };
    
    // Debounced save queue
    this.saveQueue = new Map();
    this.saveTimer = null;
    this.saveBatchDelay = 2000;
    
    // Fast paths
    this.fastPaths = {
      skipValidation: false,
      useShallowCopy: true
    };
    
    // Object pool for frequently created objects (5-10% faster)
    this.objectPool = {
      players: [], // Reuse player objects
      maxPoolSize: 50
    };
    
    this.initializeCache();
    this.initializeComponentPool();
  }
  
  // Lazy-loaded system getters (load only when first accessed)
  get dailyQuestTracker() {
    if (!this._dailyQuestTracker) this._dailyQuestTracker = new DailyQuestTracker();
    return this._dailyQuestTracker;
  }
  get damageTracker() {
    if (!this._damageTracker) this._damageTracker = new DamageTracker();
    return this._damageTracker;
  }
  get bossWeaknessAnalyzer() {
    if (!this._bossWeaknessAnalyzer) this._bossWeaknessAnalyzer = new BossWeaknessAnalyzer();
    return this._bossWeaknessAnalyzer;
  }
  get lootAnalytics() {
    if (!this._lootAnalytics) this._lootAnalytics = new LootAnalytics();
    return this._lootAnalytics;
  }
  get skillMastery() {
    if (!this._skillMastery) this._skillMastery = new SkillMastery();
    return this._skillMastery;
  }
  get favoriteItemLoadout() {
    if (!this._favoriteItemLoadout) this._favoriteItemLoadout = new FavoriteItemLoadout();
    return this._favoriteItemLoadout;
  }
  get notificationSystem() {
    if (!this._notificationSystem) this._notificationSystem = new NotificationSystem();
    return this._notificationSystem;
  }
  get enemyEncyclopedia() {
    if (!this._enemyEncyclopedia) this._enemyEncyclopedia = new EnemyEncyclopedia();
    return this._enemyEncyclopedia;
  }
  get shorthandCommandTips() {
    if (!this._shorthandCommandTips) this._shorthandCommandTips = new ShorthandCommandTips();
    return this._shorthandCommandTips;
  }
  get craftingQueue() {
    if (!this._craftingQueue) this._craftingQueue = new CraftingQueue();
    return this._craftingQueue;
  }
  get autoSellJunk() {
    if (!this._autoSellJunk) this._autoSellJunk = new AutoSellJunk();
    return this._autoSellJunk;
  }
  get statComparison() {
    if (!this._statComparison) this._statComparison = new StatComparison();
    return this._statComparison;
  }
  get timeZoneSupport() {
    if (!this._timeZoneSupport) this._timeZoneSupport = new TimeZoneSupport();
    return this._timeZoneSupport;
  }
  get uiThemeManager() {
    if (!this._uiThemeManager) this._uiThemeManager = new UIThemeManager();
    return this._uiThemeManager;
  }
  get sessionStatistics() {
    if (!this._sessionStatistics) this._sessionStatistics = new SessionStatistics();
    return this._sessionStatistics;
  }
  
  /**
   * Pre-load frequently accessed static data into cache
   */
  initializeCache() {
    try {
      // Cache static game data that doesn't change
      this.dataCache.set('talents', { data: getTalents(), timestamp: Date.now() });
      this.dataCache.set('dungeons', { data: DUNGEONS, timestamp: Date.now() });
      this.dataCache.set('materials', { data: MATERIALS, timestamp: Date.now() });
      this.dataCache.set('recipes', { data: RECIPES_SORTED, timestamp: Date.now() });
      console.log('[Performance] Static data cache initialized');
    } catch (err) {
      console.error('[Performance] Cache initialization failed:', err);
    }
  }
  
  /**
   * Pre-create commonly used components for instant reuse
   */
  initializeComponentPool() {
    try {
      // Cache back button (used in 80%+ of menus)
      this.componentPool.backButton = new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary);
      
      this.componentPool.backToHubButton = new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('üè† Back to Hub')
        .setStyle(ButtonStyle.Secondary);
      
      console.log('[Performance] Component pool initialized');
    } catch (err) {
      console.error('[Performance] Component pool failed:', err);
    }
  }
  
  /**
   * Get reusable back button (cloned to avoid mutation)
   */
  getBackButton(customId = 'rpg-back', label = '‚Üê Back') {
    if (customId === 'rpg-back' && label === '‚Üê Back') {
      // Return cloned cached button for default case (70% of calls)
      return ButtonBuilder.from(this.componentPool.backButton.toJSON());
    }
    // Create new for custom cases
    return new ButtonBuilder()
      .setCustomId(customId)
      .setLabel(label)
      .setStyle(ButtonStyle.Secondary);
  }
  
  /**
   * Get cached data or fetch and cache it
   */
  getCachedData(key, fetchFn) {
    const cached = this.dataCache.get(key);
    const now = Date.now();
    
    // Return cached data if valid
    if (cached && (now - cached.timestamp) < this.cacheExpiry) {
      return cached.data;
    }
    
    // Fetch and cache new data
    try {
      const data = fetchFn();
      this.dataCache.set(key, { data, timestamp: now });
      return data;
    } catch (err) {
      console.error(`[Performance] Cache fetch failed for ${key}:`, err);
      return cached ? cached.data : null; // Return stale data if fetch fails
    }
  }
  
  /**
   * Clear player cache for a specific user (call after important updates)
   */
  clearPlayerCache(userId) {
    this.playerCache.delete(userId);
  }
  
  /**
   * Clear expired cache entries (run periodically)
   */
  cleanupCache() {
    const now = Date.now();
    for (const [key, value] of this.dataCache.entries()) {
      if (now - value.timestamp > this.cacheExpiry) {
        this.dataCache.delete(key);
      }
    }
  }

  setClient(client) {
    this.client = client;
    
    // Start cache cleanup interval (every 10 minutes)
    setInterval(() => {
      this.cleanupCache();
    }, 10 * 60 * 1000);
    
    // Flush save queue periodically (every 5 seconds for safety)
    setInterval(() => {
      if (this.saveQueue.size > 0) {
        this.flushSaveQueue();
      }
    }, 5000);
    
    console.log('[Performance] Cache cleanup and save flushing scheduled');
  }

  /**
   * Send a DM notification to a player
   */
  async notifyPlayer(userId, title, message, color = '#2196f3') {
    if (!this.client) return;
    try {
      const user = await this.client.users.fetch(userId);
      if (!user) return;

      const embed = {
        title: title,
        description: message,
        color: parseInt(color.replace('#', ''), 16),
        timestamp: new Date().toISOString(),
        footer: { text: 'Guild Notification' }
      };

      await user.send({ embeds: [embed] });
    } catch (err) {
      console.error(`Error sending notification to ${userId}:`, err);
    }
  }

  /**
   * Check and clear stale combat flags (when player.isInCombat is true but no active combat)
   */
  clearStaleCombatFlag(player) {
    if (player.isInCombat && !this.combatSystem.isInCombat(player.userId)) {
      console.log(`[Combat Safety] Clearing stale combat flag for ${player.username}`);
      player.isInCombat = false;
      player.currentEnemy = null;
      this.persistPlayer(player);
      return true;
    }
    return false;
  }

  /**
   * Cap existing potion buffs to new maximum values (retroactive fix)
   */
  capPotionBuffs(player) {
    if (!player.potionBuffs) return false;
    
    let capped = false;
    const pb = player.potionBuffs;
    
    // XP cap: 500%
    if (pb.xpBonus && pb.xpBonus > 500) {
      console.log(`[Potion Cap] Reducing ${player.username}'s XP bonus from ${pb.xpBonus}% to 500%`);
      pb.xpBonus = 500;
      capped = true;
    }
    
    // Gold cap: 500%
    if (pb.goldBonus && pb.goldBonus > 500) {
      console.log(`[Potion Cap] Reducing ${player.username}'s Gold bonus from ${pb.goldBonus}% to 500%`);
      pb.goldBonus = 500;
      capped = true;
    }
    
    // Loot cap: 200%
    if (pb.lootBonus && pb.lootBonus > 200) {
      console.log(`[Potion Cap] Reducing ${player.username}'s Loot bonus from ${pb.lootBonus}% to 200%`);
      pb.lootBonus = 200;
      capped = true;
    }
    
    // Health cap: 5000 HP
    if (pb.nextCombatHeal && pb.nextCombatHeal > 5000) {
      console.log(`[Potion Cap] Reducing ${player.username}'s pre-heal from ${pb.nextCombatHeal} HP to 5000 HP`);
      pb.nextCombatHeal = 5000;
      capped = true;
    }
    
    // Gathering duration cap: 24 hours
    if (pb.gatheringExpires && pb.gatheringExpires > Date.now() + (24 * 60 * 60 * 1000)) {
      console.log(`[Potion Cap] Reducing ${player.username}'s gathering duration to 24 hours`);
      pb.gatheringExpires = Date.now() + (24 * 60 * 60 * 1000);
      capped = true;
    }
    
    if (capped) {
      this.persistPlayer(player);
    }
    
    return capped;
  }

  persistPlayer(player) {
    // Queue player for batched save (40-60% faster)
    this.saveQueue.set(player.userId, player);
    
    // Debounce: only save after delay (reduces I/O)
    if (this.saveTimer) {
      clearTimeout(this.saveTimer);
    }
    
    this.saveTimer = setTimeout(() => {
      this.flushSaveQueue();
    }, this.saveBatchDelay);
  }
  
  /**
   * Flush queued saves to disk
   */
  flushSaveQueue() {
    if (this.saveQueue.size === 0) return;
    
    const startTime = Date.now();
    
    // Batch save all queued players
    for (const [userId, player] of this.saveQueue.entries()) {
      this.playerManager.savePlayer(player);
    }
    
    const duration = Date.now() - startTime;
    console.log(`[Performance] Flushed ${this.saveQueue.size} saves in ${duration}ms`);
    
    this.saveQueue.clear();
    this.saveTimer = null;
  }
  
  /**
   * Force immediate save (for critical operations)
   */
  persistPlayerImmediate(player) {
    this.playerManager.savePlayer(player);
  }

  /**
   * Define the slash command
   */
  getSlashCommand() {
    return new SlashCommandBuilder()
      .setName('rpg')
      .setDescription('Open the RPG hub menu')
      .toJSON();
  }

  /**
   * Define the leaderboard slash command
   */
  getLeaderboardSlashCommand() {
    return new SlashCommandBuilder()
      .setName('leaderboard')
      .setDescription('View leaderboards')
      .addSubcommand((subcommand) =>
        subcommand
          .setName('rpg')
          .setDescription('View RPG player leaderboards')
      )
      .toJSON();
  }

  /**
   * Define the daily rewards slash command
   */
  getDailySlashCommand() {
    return new SlashCommandBuilder()
      .setName('daily')
      .setDescription('Claim daily rewards')
      .toJSON();
  }



  /**
   * Handle the main command interaction
   */
  async handleCommand(interaction) {
    try {
      await interaction.deferReply({ ephemeral: false });
      
      const player = this.playerManager.getOrCreatePlayer(
          interaction.user.id,
          interaction.user.username
      );

      // Track last active timestamp
      player.lastActive = Date.now();

      if (!player.characterCreated) {
        const embed = UIBuilder.createClassSelectionEmbed();
        const buttons = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-narrative-defender')
            .setLabel('1. Stand Your Ground')
            .setStyle(ButtonStyle.Primary),
          new ButtonBuilder()
            .setCustomId('rpg-narrative-striker')
            .setLabel('2. Strike First')
            .setStyle(ButtonStyle.Danger),
          new ButtonBuilder()
            .setCustomId('rpg-narrative-tactician')
            .setLabel('3. Study Patterns')
            .setStyle(ButtonStyle.Success)
        );

        await interaction.editReply({
          content: 'Create your character by choosing a starter path:',
          embeds: [embed],
          components: [buttons],
        });
        
        // Track ownership for the initial message
        const reply = await interaction.fetchReply();
        this.activeMenus.set(reply.id, {
          ownerId: interaction.user.id,
          timestamp: Date.now(),
        });
        return;
      }

      const embed = UIBuilder.createMainMenuEmbed(player, interaction.user);
      const buttons = this.createMainMenuButtons();

      const reply = await interaction.editReply({
        embeds: [embed],
        components: buttons,
      });
      
      // Track ownership for the initial message
      this.activeMenus.set(reply.id, {
        ownerId: interaction.user.id,
        timestamp: Date.now(),
      });
    } catch (error) {
      console.error('[RPG] Command error:', error);
      if (!interaction.replied && !interaction.deferred) {
        await interaction.reply({
          content: 'An error occurred.',
          ephemeral: true,
        });
      } else {
        // Interaction already acknowledged, log only
        console.error('[RPG] Error reply skipped: interaction already acknowledged.');
      }
    }
  }

  /**
   * Handle the leaderboard command interaction
   */
  async handleLeaderboardCommand(interaction) {
    try {
      // Force reload player data from disk to ensure fresh data
      this.playerManager.loadAllPlayers();
      
      const subcommand = interaction.options?.getSubcommand();
      if (subcommand === 'rpg') {
        await this.handleLeaderboards(interaction);
      }
    } catch (error) {
      console.error('[Leaderboard] Error:', error);
      if (!interaction.replied && !interaction.deferred) {
        await interaction.reply({
          content: '‚ùå An error occurred while loading the leaderboards.',
          ephemeral: true,
        });
      }
    }
  }

  /**
   * Handle the daily rewards command interaction
   */
  async handleDailyCommand(interaction) {
    try {
      await interaction.deferReply({ ephemeral: false });
      const player = this.playerManager.getOrCreatePlayer(
        interaction.user.id,
        interaction.user.username
      );

      if (!player.characterCreated) {
        await interaction.editReply({
          content: 'You need to create a character first using /rpg.',
          embeds: [],
          components: [],
        });
        return;
      }

      await this.handleDailyRewards(interaction, player);
    } catch (error) {
      console.error('[Daily] Error:', error);
      if (!interaction.replied && !interaction.deferred) {
        await interaction.reply({
          content: '‚ùå An error occurred while loading daily rewards.',
          ephemeral: true,
        });
      }
    }
  }
  async handlePlayerMenu(interaction, player) {
    this.trackMenuNavigation(player, 'player');
    const embed = UIBuilder.createPlayerMenuEmbed(player, interaction.user);
    
    // Add leaderboard position if in top 10
    const overallRank = await this.getPlayerOverallRank(player);
    if (overallRank && overallRank.inTopTen) {
      const medal = ['ü•á', 'ü•à', 'ü•â'][overallRank.rank - 1] || `#${overallRank.rank}`;
      embed.addFields({
        name: 'üèÜ Overall Leaderboard',
        value: `${medal} **Rank #${overallRank.rank}** out of ${overallRank.totalPlayers} players`,
        inline: false
      });
    }
    
    const buttons = this.createPlayerMenuButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Create level-up notification message from milestone data
   */
  createLevelUpMessage(levelUpResult) {
    if (!levelUpResult || !levelUpResult.levelsGained || levelUpResult.levelsGained === 0) {
      return '';
    }

    let message = `\n\nüéâ **Level Up!** `;
    if (levelUpResult.levelsGained > 1) {
      message += `Gained ${levelUpResult.levelsGained} levels!`;
    }

    if (levelUpResult.milestones && levelUpResult.milestones.length > 0) {
      message += '\n\n**Milestone Rewards:**';
      levelUpResult.milestones.forEach(milestone => {
        message += `\n‚ú® ${milestone.message}`;
        if (milestone.gold) message += `\n   üí∞ +${milestone.gold} gold`;
        if (milestone.talentPoints) message += `\n   ‚≠ê +${milestone.talentPoints} talent points`;
      });
    }

    return message;
  }

  /**
   * Create main menu buttons
   */
  createMainMenuButtons() {
    // Row 1: Guild - Quests - Combat - Player - Gather
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('üèõÔ∏è Guild')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-quests')
        .setLabel('üìú Quests')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-combat-menu')
        .setLabel('‚öîÔ∏è Combat')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-character')
        .setLabel('üë§ Player')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-gather')
        .setLabel('‚õèÔ∏è Gather')
        .setStyle(ButtonStyle.Secondary)
    );

    // Row 2: Travel - Progress - Economy - QOL - Help
    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-worlds')
        .setLabel('üåç Travel')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-progress-menu')
        .setLabel('üìà Progress')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-economy-menu')
        .setLabel('üí∞ Economy')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-qol-menu')
        .setLabel('üí° Tools')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-help')
        .setLabel('‚ùì Help')
        .setStyle(ButtonStyle.Secondary)
    );

    const row3 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-daily-rewards')
        .setLabel('üéÅ Daily Rewards')
        .setStyle(ButtonStyle.Success)
    );

    return [row1, row2, row3];
  }

  /**
   * Create player menu buttons
   */
  createPlayerMenuButtons() {
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-skills')
        .setLabel('‚ú® Skills')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-equipment')
        .setLabel('‚öôÔ∏è Equipment')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-crafting')
        .setLabel('üî® Crafting')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-inventory')
        .setLabel('üéí Inventory')
        .setStyle(ButtonStyle.Primary)
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-professions')
        .setLabel('üíº Professions')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-stats-talents')
        .setLabel('üìä Stats & Talents')
        .setStyle(ButtonStyle.Primary)
    );

    const row3 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('üè† Back to Hub')
        .setStyle(ButtonStyle.Secondary)
    );

    return [row1, row2, row3];
  }

  /**
   * Create combat menu buttons
   */
  createCombatMenuButtons(player) {
    const level = player ? player.level : 1;
    const isTier2Plus = player && player.worldsUnlocked && player.worldsUnlocked.length >= 2;
    
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-training')
        .setLabel('‚öîÔ∏è Training')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-dungeons')
        .setLabel(level >= 10 ? 'üè∞ Dungeons' : 'üîí Dungeons (Lv 10)')
        .setStyle(ButtonStyle.Primary)
        .setDisabled(level < 10),
      new ButtonBuilder()
        .setCustomId('rpg-world-boss')
        .setLabel('üëπ World Boss')
        .setStyle(ButtonStyle.Danger)
    );

    const row1b = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-arena')
        .setLabel(level >= 5 ? 'üèüÔ∏è Arena (Quick Battle)' : 'üîí Arena (Lv 5)')
        .setStyle(ButtonStyle.Primary)
        .setDisabled(level < 5)
    );

    const components = [row1, row1b];

    // Add roguelike button for Tier 2+ players
    if (isTier2Plus) {
      const row1c = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike')
          .setLabel('üé≤ Roguelike Dungeon')
          .setStyle(ButtonStyle.Success)
      );
      components.push(row1c);
    }

    // Add Niflheim Tower button (level 150+ required)
    const row1d = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-tower')
        .setLabel(level >= 150 ? '‚ùÑÔ∏è Niflheim Tower (100 Floors)' : 'üîí Niflheim Tower (Lv 150)')
        .setStyle(ButtonStyle.Danger)
        .setDisabled(level < 150)
    );
    components.push(row1d);

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('üè† Back to Hub')
        .setStyle(ButtonStyle.Secondary)
    );

    components.push(row2);
    return components;
  }

  /**
   * Create quests menu buttons
   */
  createQuestsMenuButtons() {
    const row = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-quests')
        .setLabel('üìú Quests')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-goals')
        .setLabel('üéØ Goals')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-story-log')
        .setLabel('üìñ Story Log')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('üè† Back to Hub')
        .setStyle(ButtonStyle.Secondary)
    );

    return [row];
  }

  /**
   * Create economy hub buttons
   */
  createEconomyMenuButtons() {
    const row1 = new ActionRowBuilder().addComponents(
      // new ButtonBuilder()
      //   .setCustomId('rpg-shop')
      //   .setLabel('üõçÔ∏è Shop')
      //   .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-inventory')
        .setLabel('üéí Inventory')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-crafting')
        .setLabel('üî® Crafting')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-professions')
        .setLabel('üíº Professions')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-market')
        .setLabel('üè™ Player Market')
        .setStyle(ButtonStyle.Success)
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-gambling')
        .setLabel('üé∞ Gambling')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('üè† Back to Hub')
        .setStyle(ButtonStyle.Secondary)
    );

    return [row1, row2];
  }

  /**
   * Handle button interactions
   */
  async handleButtonInteraction(interaction) {
    // Check if interaction is expired (Discord expires after 3 seconds for button clicks)
    const interactionAge = Date.now() - interaction.createdTimestamp;
    if (interactionAge > 2900) {
      console.warn(`[Interaction] Expired interaction ignored: ${interaction.customId || 'unknown'} (age: ${interactionAge}ms)`);
      return; // Silently ignore - interaction too old
    }

    // Prevent other players from interacting with your embeds
    const player = this.playerManager.getPlayer(interaction.user.id);

    if (!player) {
      await interaction.reply({
        content: 'You need to run /rpg first!',
        ephemeral: true,
      });
      return;
    }

    // Safety check: Clear stale combat flags on every interaction
    this.clearStaleCombatFlag(player);
    
    // Cap existing potion buffs to new limits (retroactive fix)
    this.capPotionBuffs(player);

    // Ensure auto-gathering is running if it should be
    this.autoGatherManager.ensureGatheringActive(player);

    const customId = interaction.customId;
    const isQuestAction =
      customId === 'rpg-quests' ||
      customId === 'rpg-quests-menu' ||
      customId === 'rpg-quest-back' ||
      customId.startsWith('rpg-quest-tab-') ||
      customId.startsWith('rpg-quest-start-') ||
      customId.startsWith('rpg-quest-view-detail-') ||
      customId.startsWith('rpg-quest-choice-') ||
      customId.startsWith('rpg-quest-');

    // Check ownership - prevent users from clicking other people's menus
    const messageOwnerId = this.activeMenus.get(interaction.message.id)?.ownerId;
    if (!isQuestAction && messageOwnerId && messageOwnerId !== interaction.user.id) {
      await interaction.reply({
        content: '‚ùå This is not your menu! Use `/rpg` to create your own.',
        ephemeral: true,
      });
      return;
    }

    // Auto-delete previous menu when opening a new one (prevent duplicate instances)
    // Do this in background - don't await, don't block button response
    const lastMenuData = this.activeMenus.get(interaction.user.id);
    if (lastMenuData?.messageId && lastMenuData?.channelId && lastMenuData.messageId !== interaction.message?.id) {
      // Fire and forget - delete in background
      setImmediate(() => {
        try {
          const channel = interaction.client.channels.cache.get(lastMenuData.channelId);
          if (channel) {
            channel.messages.fetch(lastMenuData.messageId)
              .then(message => {
                if (message && message.id !== interaction.message?.id) {
                  message.delete().catch(() => null);
                }
              })
              .catch(() => null);
          }
        } catch (error) {
          // Silently fail
        }
      });
    }

    // Check if this player owns the interaction (player created the menu)
    if (!player.characterCreated) {
      const isNarrativeChoice = customId.startsWith('rpg-narrative-');
      const isClassSelect = customId.startsWith('rpg-select-') && !customId.startsWith('rpg-select-profession');
      const isProfessionSelect = customId === 'rpg-profession-initial-select' || customId === 'rpg-select-profession';
      if (!isNarrativeChoice && !isClassSelect && !isProfessionSelect) {
        const embed = UIBuilder.createClassSelectionEmbed();
        const buttons = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-narrative-defender')
            .setLabel('1. Stand Your Ground')
            .setStyle(ButtonStyle.Primary),
          new ButtonBuilder()
            .setCustomId('rpg-narrative-striker')
            .setLabel('2. Strike First')
            .setStyle(ButtonStyle.Danger),
          new ButtonBuilder()
            .setCustomId('rpg-narrative-tactician')
            .setLabel('3. Study Patterns')
            .setStyle(ButtonStyle.Success)
        );

        await this.updateInteractionWithTracking(interaction, {
          content: 'Create your character by choosing a starter path:',
          embeds: [embed],
          components: [buttons],
        });
        return;
      }
    }

    if (customId.startsWith('rpg-craft-')) {
      const recipeId = customId.replace('rpg-craft-', '');
      await this.handleCraftRecipe(interaction, player, recipeId);
      return;
    }

    if (customId.startsWith('rpg-use-potion-qty-')) {
      // Format: rpg-use-potion-qty-{potionId}-{quantity}
      const parts = customId.replace('rpg-use-potion-qty-', '').split('-');
      const quantity = parseInt(parts.pop()); // Last part is the quantity
      const potionId = parts.join('-'); // Rest is the potion ID
      
      if (!potionId || !quantity) {
        await interaction.reply({ content: 'Invalid potion or quantity.', ephemeral: true });
        return;
      }
      
      await this.handleUsePotionMultiple(interaction, player, potionId, quantity);
      return;
    }

    if (customId === 'rpg-back-to-gather') {
      await this.handleGatherMenu(interaction, player);
      return;
    }

    if (customId === 'rpg-gather-status') {
      await this.handleGatherStatus(interaction, player);
      return;
    }

    if (customId.startsWith('rpg-autogather-')) {
      const param = customId.replace('rpg-autogather-', '');
      
      // Check if it's an area-based gather (format: rpg-autogather-area-{areaId})
      if (param.startsWith('area-')) {
        const areaId = param.replace('area-', '');
        await this.handleAutoGatherFromArea(interaction, player, areaId);
      } else {
        // Skill-based gather (legacy)
        const skillId = param;
        await this.handleStartAutoGather(interaction, player, skillId);
      }
      return;
    }

    if (customId === 'rpg-stop-autogather') {
      await this.handleStopAutoGather(interaction, player);
      return;
    }

    if (customId === 'rpg-gather-status-overview') {
      await this.handleGatherDetailedOverview(interaction, player);
      return;
    }

    if (customId === 'rpg-gather-status') {
      await this.handleGatherStatus(interaction, player);
      return;
    }

    if (customId === 'rpg-gather-choose-area') {
      await this.handleGatheringAreaSelect(interaction, player);
      return;
    }

    if (customId === 'rpg-gather-rewards') {
      await this.handleGatheringRewards(interaction, player);
      return;
    }

    if (customId === 'rpg-gather-area-details-back') {
      await this.handleGatheringAreaSelect(interaction, player);
      return;
    }

    if (customId === 'rpg-gathering-tools' || customId === 'rpg-manage-tools') {
      await this.handleGatheringTools(interaction, player);
      return;
    }

    if (customId.startsWith('rpg-buy-gathering-tool-')) {
      const tier = parseInt(customId.replace('rpg-buy-gathering-tool-', ''));
      await this.handleBuyGatheringTool(interaction, player, tier);
      return;
    }

    if (customId === 'rpg-back-to-gather') {
      await this.handleGatherMenu(interaction, player);
      return;
    }

    if (customId.startsWith('rpg-gather-area-drops-')) {
      const areaId = customId.replace('rpg-gather-area-drops-', '').trim();
      await this.handleGatheringAreaDrops(interaction, player, areaId);
      return;
    }

    if (customId.startsWith('rpg-gather-area-details-')) {
      const areaId = customId.replace('rpg-gather-area-details-', '');
      await this.handleGatheringAreaDetails(interaction, player, areaId);
      return;
    }

    if (customId.startsWith('rpg-gather-area-')) {
      const areaId = customId.replace('rpg-gather-area-', '');
      const area = getGatheringArea(areaId);
      
      if (!area) {
        await interaction.reply({ content: '‚ùå Area not found.', ephemeral: true });
        return;
      }
      
      player.currentGatherArea = areaId;
      
      // Remove 'gather' from history if it's there (since we're going back to gather)
      if (player.menuHistory && player.menuHistory.length > 0 && 
          player.menuHistory[player.menuHistory.length - 1] === 'gather') {
        player.menuHistory.pop();
      }
      
      this.persistPlayer(player);
      
      // Update the interaction instead of replying - skip tracking to prevent history loop
      await this.handleGatherMenu(interaction, player, true);
      return;
    }

    if (customId.startsWith('rpg-gather-again-')) {
      const skillId = customId.replace('rpg-gather-again-', '');
      await this.handleGather(interaction, player, skillId);
      return;
    }

    if (customId.startsWith('rpg-crafting-page-')) {
      const page = parseInt(customId.replace('rpg-crafting-page-', ''), 10) || 0;
      await this.handleCraftingPage(interaction, player, page);
      return;
    }

    if (customId.startsWith('rpg-talents-page-')) {
      const page = parseInt(customId.replace('rpg-talents-page-', ''), 10) || 1;
      player.currentTalentPage = page;
      this.persistPlayer(player);
      await this.handleTalents(interaction, player, true);
      return;
    }

    switch (customId) {
      case 'rpg-gather':
        await this.handleGatherMenu(interaction, player);
        break;
      case 'rpg-quests-menu':
        await this.handleQuestsMenu(interaction, player);
        break;
      case 'rpg-shop':
        await this.handleShop(interaction, player);
        break;
      case 'rpg-gather-mining':
        await this.handleStartAutoGather(interaction, player, 'mining');
        break;
      case 'rpg-gather-chopping':
        await this.handleStartAutoGather(interaction, player, 'chopping');
        break;
      case 'rpg-gather-gathering':
        await this.handleStartAutoGather(interaction, player, 'gathering');
        break;
      case 'rpg-adventure':
        await this.handleAdventure(interaction, player);
        break;
      case 'rpg-class-select':
        await this.handleClassSelection(interaction, player);
        break;
      case 'rpg-character':
        await this.handlePlayerMenu(interaction, player);
        break;
      case 'rpg-hub':
        await this.handlePlayerMenu(interaction, player);
        break;
      case 'rpg-character-sheet':
        await this.handleCharacterSheet(interaction, player);
        break;
      case 'rpg-skills':
        await this.handleSkills(interaction, player);
        break;
      case 'rpg-talents':
        await this.handleTalents(interaction, player);
        break;
      case 'rpg-equipment':
        await this.handleEquipment(interaction, player);
        break;
      case 'rpg-manage-equipment':
        await this.handleManageEquipment(interaction, player);
        break;
      case 'rpg-equipment-sets':
        await this.handleEquipmentSets(interaction, player);
        break;
      case 'rpg-dismantle-multiple-start':
        await this.handleDismantleMultipleStart(interaction, player);
        break;
      case 'rpg-dismantle-multiple-confirm':
        await this.handleDismantleMultipleConfirm(interaction, player);
        break;
      case 'rpg-remove-enchant-start':
        await this.handleRemoveEnchantStart(interaction, player);
        break;
      case 'rpg-professions':
        await this.handleProfessions(interaction, player);
        break;
      case 'rpg-alchemy':
        await this.handleAlchemy(interaction, player);
        break;
      case 'rpg-enchant':
        await this.handleEnchant(interaction, player);
        break;
      case 'rpg-auto-enchant-menu':
        await this.handleAutoEnchantMenu(interaction, player);
        break;
      case 'rpg-crafting':
        await this.handleCrafting(interaction, player);
        break;
      case 'rpg-combat-menu':
        await this.handleCombatMenu(interaction, player);
        break;
      case 'rpg-arena':
        await this.handleArena(interaction, player);
        break;
      case 'rpg-arena-bot':
        await this.handleArenaBotFight(interaction, player);
        break;
      case 'rpg-arena-player':
        await this.handleArenaPlayerFight(interaction, player);
        break;
      case 'rpg-arena-shop':
        await this.handleArenaShop(interaction, player);
        break;
      case 'rpg-quick-battle':
        await this.handleArena(interaction, player);
        break;
      case 'rpg-world-boss':
        await this.handleWorldBoss(interaction, player);
        break;
      case 'rpg-combat-training':
        await this.handleCombatTraining(interaction, player);
        break;
      case 'rpg-daily-rewards':
        await this.handleDailyRewards(interaction, player);
        break;
      case 'rpg-daily-claim':
        await this.handleDailyRewardClaim(interaction, player, { restore: false });
        break;
      case 'rpg-daily-restore':
        await this.handleDailyRewardClaim(interaction, player, { restore: true });
        break;
      case 'rpg-quests':
        await this.handleQuests(interaction, player);
        break;
      case 'rpg-goals':
        await this.handleHelpMenu(interaction, player);
        break;
      case 'rpg-inventory':
        await this.handleInventory(interaction, player);
        break;
      case 'rpg-filter-materials':
        await this.handleInventoryFilter(interaction, player, 'material');
        break;
      case 'rpg-filter-consumables':
        await this.handleInventoryFilter(interaction, player, 'consumable');
        break;
      case 'rpg-filter-enchants':
        await this.handleInventoryFilter(interaction, player, 'enchant');
        break;
      case 'rpg-filter-all':
        await this.handleInventory(interaction, player);
        break;
      case 'rpg-use-potion':
        await this.handleUsePotionSelector(interaction, player);
        break;
      case 'rpg-open-lootbox':
        await this.handleOpenLootboxMenu(interaction, player);
        break;
      case 'rpg-inventory-rarity-select':
        const rarity = interaction.values?.[0];
        if (!rarity) {
          await interaction.reply({ content: 'No rarity selected.', ephemeral: true });
          return;
        }
        await this.handleInventoryFilterByRarity(interaction, player, rarity);
        break;
      case 'rpg-inventory-profession-select':
        const profession = interaction.values?.[0];
        if (!profession) {
          await interaction.reply({ content: 'No profession selected.', ephemeral: true });
          return;
        }
        await this.handleInventoryFilterByProfession(interaction, player, profession);
        break;
      case 'rpg-dismantle-select-item':
        const selectedItemId = interaction.values?.[0];
        if (selectedItemId) {
          await this.handleDismantleItemOverview(interaction, player, selectedItemId);
        }
        break;
      case 'rpg-dungeons':
        await this.handleDungeons(interaction, player);
        break;
      case 'rpg-roguelike':
        await this.handleRoguelikeStart(interaction, player);
        break;
      case 'rpg-roguelike-start-new':
        await this.handleRoguelikeStartNew(interaction, player);
        break;
      case 'rpg-roguelike-exit':
        await this.handleRoguelikeExit(interaction, player);
        break;
      case 'rpg-roguelike-boss-fight':
        await this.handleRoguelikeBossFight(interaction, player);
        break;
      case 'rpg-roguelike-skill-accept':
        await this.handleRoguelikeSkillAccept(interaction, player);
        break;
      case 'rpg-roguelike-skill-decline':
        await this.handleRoguelikeSkillDecline(interaction, player);
        break;
      case 'rpg-roguelike-upgrades':
        await this.handleRoguelikeUpgrades(interaction, player);
        break;
      case 'rpg-roguelike-stats':
        await this.handleRoguelikeStats(interaction, player);
        break;
      case 'rpg-roguelike-continue':
        await this.handleRoguelikeFloor(interaction, player);
        break;
      case 'rpg-tower':
        await this.handleTowerStart(interaction, player);
        break;
      case 'rpg-tower-enter':
        await this.handleTowerEnter(interaction, player);
        break;
      case 'rpg-tower-reset':
        await this.handleTowerReset(interaction, player);
        break;
      case 'rpg-tower-fight':
        await this.handleTowerFight(interaction, player);
        break;
      case 'rpg-tower-continue':
        await this.handleTowerContinue(interaction, player);
        break;
      case 'rpg-tower-status':
        await this.handleTowerStatus(interaction, player);
        break;
      case 'rpg-roguelike-shop-catalog':
        await this.handleRoguelikeShopCatalog(interaction, player);
        break;
      default:
        // Handle dynamic button IDs
        if (customId.startsWith('rpg-roguelike-upgrade-view-')) {
          const upgradeId = customId.replace('rpg-roguelike-upgrade-view-', '');
          await this.handleRoguelikeUpgradeView(interaction, player, upgradeId);
        } else if (customId.startsWith('rpg-roguelike-upgrade-buy-')) {
          const upgradeId = customId.replace('rpg-roguelike-upgrade-buy-', '');
          await this.handleRoguelikeUpgradePurchase(interaction, player, upgradeId);
        } else if (customId.startsWith('rpg-roguelike-upgrades-category-')) {
          const category = customId.replace('rpg-roguelike-upgrades-category-', '');
          await this.handleRoguelikeUpgrades(interaction, player, category);
        } else if (customId.startsWith('rpg-roguelike-skill-choose-')) {
          const parts = customId.replace('rpg-roguelike-skill-choose-', '').split('-');
          const skillIndex = parseInt(parts.pop(), 10);
          const roomId = parts.join('-');
          await this.handleRoguelikeSkillChoose(interaction, player, roomId, skillIndex);
        } else if (customId.startsWith('rpg-roguelike-skill-decline-')) {
          const roomId = customId.replace('rpg-roguelike-skill-decline-', '');
          await this.handleRoguelikeSkillDecline(interaction, player, roomId);
        } else if (customId.startsWith('rpg-roguelike-miniboss-fight-')) {
          const roomId = customId.replace('rpg-roguelike-miniboss-fight-', '');
          await this.handleRoguelikeMiniBossFight(interaction, player, roomId);
        } else if (customId.startsWith('rpg-roguelike-room-')) {
          const roomId = customId.replace('rpg-roguelike-room-', '');
          await this.handleRoguelikeRoomSelect(interaction, player, roomId);
        }
        break;
      case 'rpg-roguelike-shop-back':
        // Return to shop room
        const room = player.roguelikeState?.currentFloorRooms?.find(r => r.type === 'shop');
        if (room) {
          await this.handleRoguelikeShopRoom(interaction, player, room);
        }
        break;
      case 'rpg-roguelike-shop-leave':
        // Leave shop and advance floor
        if (player.roguelikeState) {
          const roguelike = new RoguelikeManager();
          const actionResults = {};
          roguelike.completeRoom(player.roguelikeState, { type: 'shop' }, actionResults);
          player.roguelikeState.currentFloor++;
          await this.playerManager.savePlayer(player);
          await this.handleRoguelikeFloor(interaction, player);
        }
        break;
    }

    // Handle shop buy buttons
    if (customId.startsWith('rpg-roguelike-shop-buy_')) {
      const itemIndex = parseInt(customId.replace('rpg-roguelike-shop-buy_', ''));
      await this.handleRoguelikeShopBuy(interaction, player, itemIndex);
      return;
    }

    // Handle dynamic button IDs (dungeon-normal, dungeon-boss, etc)
    if (customId.startsWith('rpg-dungeon-normal-')) {
      const dungeonId = customId.replace('rpg-dungeon-normal-', '');
      await this.handleNormalDungeonStart(interaction, player, dungeonId);
      return;
    }

    if (customId.startsWith('rpg-dungeon-boss-')) {
      const dungeonId = customId.replace('rpg-dungeon-boss-', '');
      await this.handleBossDungeonStart(interaction, player, dungeonId);
      return;
    }

    if (customId.startsWith('rpg-dismantle-qty-')) {
      const parts = customId.replace('rpg-dismantle-qty-', '').split('-');
      const qty = parts[parts.length - 1];
      const itemId = parts.slice(0, -1).join('-');
      await this.handleDismantleAddQuantity(interaction, player, itemId, qty);
      return;
    }

    if (customId === 'rpg-dismantle-multiple-start') {
      await this.handleDismantleMultipleStart(interaction, player);
      return;
    }

    if (customId.startsWith('rpg-roguelike-room-')) {
      const roomId = customId.replace('rpg-roguelike-room-', '');
      await this.handleRoguelikeRoomSelect(interaction, player, roomId);
      return;
    }

    if (customId === 'rpg-dismantle-add-another') {
      const selection = this.dismantleSelections?.[player.id];
      if (!selection) {
        await interaction.reply({ content: '‚ùå Selection expired.', ephemeral: true });
        return;
      }

      const selectOptions = selection.equipment.slice(0, 25).map(eq => {
        const count = player.inventory.filter(i => i && i.id === eq.id && i.type === 'equipment').reduce((sum, i) => sum + (i.quantity || 1), 0);
        return {
          label: `${(eq.equipment?.name || 'Unknown').substring(0, 70)} (x${count})`,
          value: eq.id,
          description: `Rarity: ${eq.equipment?.rarity || 'Common'}`,
        };
      });

      const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('rpg-dismantle-select-item')
        .setPlaceholder('Select another item')
        .addOptions(selectOptions)
        .setMinValues(1)
        .setMaxValues(1);

      const selectRow = new ActionRowBuilder().addComponents(selectMenu);

      const queueSummary = Object.entries(selection.queue)
        .map(([id, qty]) => {
          const item = selection.equipment.find(e => e.id === id);
          const name = item?.equipment?.name || 'Unknown';
          return `üìã ${name} x${qty}`;
        })
        .join('\n');

      const buttonRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-dismantle-finish')
          .setLabel('‚úÖ Dismantle All')
          .setStyle(ButtonStyle.Success)
          .setDisabled(Object.keys(selection.queue).length === 0),
        new ButtonBuilder()
          .setCustomId('rpg-dismantle-cancel')
          .setLabel('‚ùå Cancel')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('rpg-dismantle-multiple-start')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );

      const embed = new EmbedBuilder()
        .setColor(16743680)
        .setTitle('‚ôªÔ∏è Add More Items')
        .setDescription(`**Current Queue:**\n${queueSummary || 'Empty'}\n\nSelect another item:`);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [selectRow, buttonRow],
      });
      return;
    }

    if (customId === 'rpg-dismantle-finish') {
      await this.handleDismantleFinish(interaction, player);
      return;
    }

    if (customId === 'rpg-dismantle-cancel') {
      try {
        // Clear selection
        if (this.dismantleSelections) {
          delete this.dismantleSelections[player.id];
        }
        
        // Defer and update to cancel
        if (!interaction.deferred && !interaction.replied) {
          await interaction.deferUpdate();
        }
        
        await interaction.editReply({ 
          content: '‚ùå Cancelled multi-dismantle.',
          embeds: [],
          components: []
        });
      } catch (err) {
        console.error('Error in rpg-dismantle-cancel:', err);
        try {
          if (!interaction.replied && !interaction.deferred) {
            await interaction.reply({ content: '‚ùå Cancelled.', ephemeral: true });
          }
        } catch (e) {
          console.error('Failed to send cancel response:', e);
        }
      }
      return;
    }

    if (customId.startsWith('rpg-remove-enchant-confirm-')) {
      const slot = customId.replace('rpg-remove-enchant-confirm-', '');
      await this.handleRemoveEnchantConfirm(interaction, player, slot);
      return;
    }

    if (customId.startsWith('rpg-auto-enchant-confirm-')) {
      const payload = customId.replace('rpg-auto-enchant-confirm-', '');
      const parts = payload.split('-');
      const targetLevel = parts.pop();
      const enchantId = parts.join('-');
      player.confirmedAutoEnchant = true;
      this.persistPlayer(player);
      await this.handleEnchantCraft(interaction, player, enchantId, targetLevel);
      return;
    }

    // Continue with remaining cases
    switch (customId) {
      case 'rpg-equip-best-weapon':
        await this.handleEquipBestWeapon(interaction, player);
        break;
      case 'rpg-upgrade-weapon':
        await this.handleUpgradeWeapon(interaction, player);
        break;
      case 'rpg-crafting-upgrade':
        // Professions menu upgrade button - redirects to gear upgrade
        await this.handleUpgradeGear(interaction, player);
        break;
      case 'rpg-master-blacksmith-upgrade':
        await this.handleMasterBlacksmithUpgrade(interaction, player);
        break;
      case 'rpg-gem-socketing':
        await this.handleGemSocketing(interaction, player);
        break;
      case 'rpg-stats':
        await this.handleStats(interaction, player);
        break;
      case 'rpg-stats-talents':
        await this.handleStatsAndTalents(interaction, player);
        break;
      case 'rpg-combat-next-turn':
        await this.handleCombatNextTurn(interaction, player);
        break;
      case 'rpg-combat-skill-menu':
        await this.handleCombatSkillMenu(interaction, player);
        break;
      case 'rpg-combat-gear-set':
        await this.handleCombatGearSet(interaction, player);
        break;
      case 'rpg-combat-stance-menu':
        await this.handleCombatStanceMenu(interaction, player);
        break;
      case 'rpg-combat-refresh':
        await this.handleCombatRefresh(interaction, player);
        break;
      case 'rpg-combat-auto':
        await this.handleCombatAuto(interaction, player);
        break;
      case 'rpg-combat-manual':
        await this.handleCombatManual(interaction, player);
        break;
      case 'rpg-combat-action-attack':
        await this.handleCombatActionAttack(interaction, player);
        break;
      case 'rpg-combat-action-defend':
        await this.handleCombatActionDefend(interaction, player);
        break;
      case 'rpg-combat-forfeit':
        await this.handleCombatForfeit(interaction, player);
        break;
      case 'rpg-enter-world':
        await this.handleEnterWorld(interaction, player);
        break;
      case 'rpg-worlds':
        await this.handleWorldTravel(interaction, player);
        break;
      case 'rpg-guild':
        await this.handleGuild(interaction, player);
        break;
      case 'rpg-guild-create':
        // Show guild creation modal
        const guildModal = new ModalBuilder()
          .setCustomId('rpg-guild-create-modal')
          .setTitle('Create Your Guild');
        const guildNameInput = new TextInputBuilder()
          .setCustomId('guild_name')
          .setLabel('Guild Name (3-32 characters)')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('The Legendary Heroes')
          .setRequired(true)
          .setMinLength(3)
          .setMaxLength(32);
        const guildTagInput = new TextInputBuilder()
          .setCustomId('guild_tag')
          .setLabel('Guild Tag (2-6 characters)')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('HERO')
          .setRequired(true)
          .setMinLength(2)
          .setMaxLength(6);
        const guildDescInput = new TextInputBuilder()
          .setCustomId('guild_description')
          .setLabel('Guild Description')
          .setStyle(TextInputStyle.Paragraph)
          .setPlaceholder('We are a guild of legendary heroes...')
          .setRequired(false);
        const row1 = new ActionRowBuilder().addComponents(guildNameInput);
        const row2 = new ActionRowBuilder().addComponents(guildTagInput);
        const row3 = new ActionRowBuilder().addComponents(guildDescInput);
        guildModal.addComponents(row1, row2, row3);
        await interaction.showModal(guildModal);
        return;
      case 'rpg-guild-search':
        await this.handleGuildSearch(interaction, player);
        break;
      case 'rpg-guild-members':
        await this.handleGuildMembers(interaction, player);
        break;
      case 'rpg-guild-manage':
        await this.handleGuildManagement(interaction, player);
        break;
      case 'rpg-guild-bosses':
        await this.handleGuildBosses(interaction, player);
        break;
      case 'rpg-guild-buffs':
        await this.handleGuildBuffs(interaction, player);
        break;
      case 'rpg-guild-donate':
        // Show donation modal
        const donateModal = new ModalBuilder()
          .setCustomId('rpg-guild-donate-modal')
          .setTitle('Donate to Guild Treasury');
        const donateInput = new TextInputBuilder()
          .setCustomId('amount')
          .setLabel('Amount to donate (gold)')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('1000')
          .setRequired(true);
        const donateRow = new ActionRowBuilder().addComponents(donateInput);
        donateModal.addComponents(donateRow);
        await interaction.showModal(donateModal);
        return;
      case 'rpg-guild-leave':
        await this.handleGuildLeaveConfirm(interaction, player);
        break;
      case 'rpg-guild-settings':
        await this.handleGuildSettings(interaction, player);
        break;
      case 'rpg-guild-achievements':
        await this.handleGuildAchievements(interaction, player);
        break;
      case 'rpg-guild-claim-achievements':
        await this.handleClaimGuildAchievements(interaction, player);
        break;
      case 'rpg-guild-achievement-details':
        await this.handleGuildAchievementDetails(interaction, player);
        break;
      case 'rpg-guild-rankings':
        await this.handleGuildRankings(interaction, player);
        break;
      case 'rpg-guild-roles':
        await this.handleGuildRoles(interaction, player);
        break;
      case 'rpg-economy-menu':
        await this.handleEconomyMenu(interaction, player);
        break;
      case 'rpg-market':
        await this.handleMarket(interaction, player);
        break;
      case 'rpg-market-browse':
        await this.handleMarketBrowse(interaction, player);
        break;
      case 'rpg-market-sell':
        await this.handleMarketSellMenu(interaction, player);
        break;
      case 'rpg-market-my-listings':
        await this.handleMarketMyListings(interaction, player);
        break;
      case 'rpg-gambling':
        await this.handleGambling(interaction, player);
        break;
      case 'rpg-slots':
        await this.handleSlots(interaction, player);
        break;
      case 'rpg-slots-play-again':
        const lastBet = player.lastSlotsBet || 100;
        await this.playSlots(interaction, player, lastBet);
        break;
      case 'rpg-slots-custom':
        // Show modal for custom amount
        const modal = new ModalBuilder()
          .setCustomId('rpg-slots-custom-modal')
          .setTitle('Custom Bet Amount');
        const amountInput = new TextInputBuilder()
          .setCustomId('amount')
          .setLabel('Enter bet amount')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('Enter amount in gold')
          .setRequired(true);
        const row = new ActionRowBuilder().addComponents(amountInput);
        modal.addComponents(row);
        await interaction.showModal(modal);
        return;
      case 'rpg-coinflip':
        await this.handleCoinflip(interaction, player);
        break;
      case 'rpg-party-menu':
        await this.handlePartyMenu(interaction, player);
        break;
      case 'rpg-party-add':
        await this.handlePartyAdd(interaction, player);
        break;
      case 'rpg-party-remove':
        await this.handlePartyRemoveMenu(interaction, player);
        break;
      case 'rpg-party-active':
        await this.handlePartyActiveMenu(interaction, player);
        break;
      case 'rpg-progress-menu':
        await this.handleProgressMenu(interaction, player);
        break;
      case 'rpg-achievements':
        await this.handleAchievements(interaction, player);
        break;
      case 'rpg-collectibles':
        await this.handleCollectibles(interaction, player);
        break;
      case 'rpg-collectibles-view':
        await this.handleCollectiblesViewAll(interaction, player);
        break;
      case 'rpg-progress-leaderboards':
        await this.handleProgressLeaderboards(interaction, player);
        break;
      case 'rpg-titles-badges':
        await this.handleTitlesAndBadges(interaction, player);
        break;
      case 'rpg-titles-earned':
        await this.handleTitlesEarned(interaction, player);
        break;
      case 'rpg-titles-unearned':
        await this.handleTitlesUnearned(interaction, player);
        break;
      case 'rpg-badges-earned':
        await this.handleBadgesEarned(interaction, player);
        break;
      case 'rpg-badges-unearned':
        await this.handleBadgesUnearned(interaction, player);
        break;
      case 'rpg-qol-menu':
        await this.handleQOLMenu(interaction, player);
        break;
      case 'rpg-qol-tab-stats':
        await this.handleQOLStatsMenu(interaction, player);
        break;
      case 'rpg-qol-tab-combat':
        await this.handleQOLCombatMenu(interaction, player);
        break;
      case 'rpg-qol-tab-progress':
        await this.handleQOLProgressMenu(interaction, player);
        break;
      case 'rpg-qol-tab-gear':
        await this.handleQOLGearMenu(interaction, player);
        break;
      case 'rpg-qol-tab-utility':
        await this.handleQOLUtilityMenu(interaction, player);
        break;
      case 'rpg-qol-tab-guild':
        await this.handleQOLGuildMenu(interaction, player);
        break;
      case 'rpg-help':
        await this.handleHelpMenu(interaction, player);
        break;
      case 'rpg-narrative-defender':
      case 'rpg-narrative-striker':
      case 'rpg-narrative-tactician':
        await this.handleNarrativeChoice(interaction, player);
        break;
      case 'rpg-select-warrior':
      case 'rpg-select-mage':
      case 'rpg-select-rogue':
      case 'rpg-select-paladin':
        await this.handleClassSelect(interaction, player);
        break;
      case 'rpg-select-profession':
        await this.handleProfessionSelect(interaction, player);
        break;
      case 'rpg-back':
        await this.handleBackButton(interaction, player);
        break;
      case 'rpg-upgrade-confirm':
        if (player.confirmUpgrade) {
          await this.handleUpgradeGear(interaction, player);
        } else {
          await interaction.reply({ content: 'No upgrade confirmation pending.', ephemeral: true });
        }
        break;
      case 'rpg-upgrade-return':
        // Return to upgrade menu after completing upgrade
        await this.handleUpgradeGear(interaction, player);
        break;
      case 'rpg-back-to-hub':
        await this.handleBackToHub(interaction, player);
        break;
      case 'rpg-save-equipment-set':
        await this.handleSaveEquipmentSet(interaction, player);
        break;
      // QOL Feature Button Handlers
      case 'rpg-qol-combat-log':
        await this.handleCombatLog(interaction, player);
        break;
      case 'rpg-qol-boss-guide':
        await this.handleBossGuide(interaction, player);
        break;
      case 'rpg-qol-enemy-summary':
        await this.handleEnemySummary(interaction, player);
        break;
      case 'rpg-qol-combo-preview':
        await this.handleComboPreview(interaction, player);
        break;
      case 'rpg-qol-equipment-compare':
        await this.handleEquipmentComparison(interaction, player);
        break;
      case 'rpg-qol-damage-calc':
        await this.handleDamageCalculator(interaction, player);
        break;
      case 'rpg-qol-stats-timeline':
        await this.handleStatsTimeline(interaction, player);
        break;
      case 'rpg-qol-boss-tracker':
        await this.handleBossTracker(interaction, player);
        break;
      case 'rpg-qol-achievements':
        await this.handleAchievementProgress(interaction, player);
        break;
      case 'rpg-qol-class-guide':
        await this.handleClassMasteryGuide(interaction, player);
        break;
      case 'rpg-qol-env-tool':
        await this.handleEnvironmentTool(interaction, player);
        break;
      // Phase 2 QOL Features
      case 'rpg-qol-equipment-builds':
        await this.handleEquipmentSets(interaction, player);
        break;
      case 'rpg-qol-style-recommendation':
        await this.handleCombatStylesRecommendation(interaction, player);
        break;
      case 'rpg-qol-crit-display':
        await this.handleCriticalHitDisplay(interaction, player);
        break;
      case 'rpg-qol-damage-breakdown':
        await this.handleDamageBreakdown(interaction, player);
        break;
      case 'rpg-qol-milestones':
        await this.handleMilestoneNotifications(interaction, player);
        break;
      case 'rpg-qol-spell-wheel':
        await this.handleQuickSpellWheel(interaction, player);
        break;
      case 'rpg-qol-combo-viz':
        await this.handleComboVisualizer(interaction, player);
        break;
      case 'rpg-qol-env-predict':
        await this.handleEnvironmentPredictions(interaction, player);
        break;
      case 'rpg-qol-profession':
        await this.handleProfessionTips(interaction, player);
        break;
      case 'rpg-guild-leaderboard':
        await this.handleGuildLeaderboard(interaction, player);
        break;
      case 'rpg-guild-growth':
        await this.handleGuildGrowthChart(interaction, player);
        break;
      // Tier 1-4 Features
      case 'rpg-daily-quests':
        await this.handleDailyQuests(interaction, player);
        break;
      case 'rpg-damage-tracker':
        await this.handleDamageTracker(interaction, player);
        break;
      case 'rpg-boss-analyzer':
        await this.handleBossAnalyzer(interaction, player);
        break;
      case 'rpg-loot-analytics':
        await this.handleLootAnalytics(interaction, player);
        break;
      case 'rpg-skill-mastery':
        await this.handleSkillMastery(interaction, player);
        break;
      case 'rpg-favorite-items':
        await this.handleFavoriteItems(interaction, player);
        break;
      case 'rpg-notifications':
        await this.handleNotifications(interaction, player);
        break;
      case 'rpg-enemy-encyclopedia':
        await this.handleEnemyEncyclopedia(interaction, player);
        break;
      case 'rpg-auto-sell':
        await this.handleAutoSellSettings(interaction, player);
        break;
      case 'rpg-stat-comparison':
        await this.handleStatComparison(interaction, player);
        break;
      case 'rpg-timezone':
        await this.handleTimezoneSettings(interaction, player);
        break;
      case 'rpg-ui-theme':
        await this.handleUIThemeSettings(interaction, player);
        break;
      case 'rpg-session-stats':
        await this.handleSessionStats(interaction, player);
        break;
      case 'rpg-qol-back':
        await this.handleQOLMenu(interaction, player);
        break;
      case 'rpg-builds-save':
        // Show modal to save current equipment as a build
        const saveModal = new ModalBuilder()
          .setCustomId('rpg-builds-save-modal')
          .setTitle('Save Equipment Build');
        const buildNameInput = new TextInputBuilder()
          .setCustomId('build_name')
          .setLabel('Build Name (e.g., "Aggressive", "Defensive")')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('My Awesome Build')
          .setRequired(true)
          .setMaxLength(32);
        const buildRow = new ActionRowBuilder().addComponents(buildNameInput);
        saveModal.addComponents(buildRow);
        await interaction.showModal(saveModal);
        break;
      case 'rpg-builds-load':
        // Show select menu of saved builds
        const builds = this.equipmentBuilds.getBuilds(player.userId);
        if (builds.length === 0) {
          await interaction.reply({
            content: '‚ùå No builds saved yet! Use "Save Current" to create one.',
            ephemeral: true
          });
          return;
        }
        
        const buildSelectMenu = new StringSelectMenuBuilder()
          .setCustomId('rpg-builds-load-select')
          .setPlaceholder('Choose a build to load...')
          .addOptions(
            builds.map(build => ({
              label: build.name,
              value: build.name,
              emoji: '‚öôÔ∏è'
            }))
          );
        
        const buildSelectRow = new ActionRowBuilder().addComponents(buildSelectMenu);
        const buildEmbed = new EmbedBuilder()
          .setColor(0x00ccff)
          .setTitle('üìÇ **Load Equipment Build**')
          .setDescription('Select a build to equip');
        
        await this.updateInteractionWithTracking(interaction, {
          embeds: [buildEmbed],
          components: [buildSelectRow],
          ephemeral: true
        });
        break;
      case 'rpg-builds-delete':
        // Show select menu of builds to delete
        const deletableBuilds = this.equipmentBuilds.getBuilds(player.userId);
        if (deletableBuilds.length === 0) {
          await interaction.reply({
            content: '‚ùå No builds to delete.',
            ephemeral: true
          });
          return;
        }
        
        const deleteSelectMenu = new StringSelectMenuBuilder()
          .setCustomId('rpg-builds-delete-select')
          .setPlaceholder('Choose a build to delete...')
          .addOptions(
            deletableBuilds.map(build => ({
              label: build.name,
              value: build.name,
              emoji: 'üóëÔ∏è'
            }))
          );
        
        const deleteSelectRow = new ActionRowBuilder().addComponents(deleteSelectMenu);
        const deleteEmbed = new EmbedBuilder()
          .setColor(0xff0000)
          .setTitle('üóëÔ∏è **Delete Equipment Build**')
          .setDescription('Select a build to permanently delete');
        
        await this.updateInteractionWithTracking(interaction, {
          embeds: [deleteEmbed],
          components: [deleteSelectRow],
          ephemeral: true
        });
        break;
      case 'rpg-guild-quests':
        await this.handleGuildQuestsMenu(interaction, player);
        break;
      case 'rpg-guild-daily':
      case 'rpg-guild-daily-refresh':
        await this.handleGuildDailyQuests(interaction, player);
        break;
      case 'rpg-guild-weekly':
        await this.handleGuildWeeklyQuests(interaction, player);
        break;
      case 'rpg-guild-limited':
        await this.handleGuildLimitedQuests(interaction, player);
        break;
      case 'rpg-guild-toggle-public':
        await this.handleGuildTogglePublic(interaction, player);
        break;
      case 'rpg-guild-toggle-application':
        await this.handleGuildToggleApplication(interaction, player);
        break;
      case 'rpg-guild-set-minlevel':
        // Show modal for minimum level
        const minLevelModal = new ModalBuilder()
          .setCustomId('rpg-guild-minlevel-modal')
          .setTitle('Set Minimum Level');
        const minLevelInput = new TextInputBuilder()
          .setCustomId('min_level')
          .setLabel('Minimum level required to join (1-100)')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('10')
          .setRequired(true)
          .setMinLength(1)
          .setMaxLength(3);
        const minLevelRow = new ActionRowBuilder().addComponents(minLevelInput);
        minLevelModal.addComponents(minLevelRow);
        await interaction.showModal(minLevelModal);
        return;
      default:
        // Handle auto-enchant target selection
        if (customId.startsWith('rpg-auto-enchant-target-')) {
          const targetLevel = parseInt(customId.replace('rpg-auto-enchant-target-', ''));
          const enchantId = player.pendingAutoEnchantType;
          
          if (!enchantId) {
            await interaction.reply({ 
              content: 'Please select an enchant type first from the dropdown menu.', 
              ephemeral: true 
            });
            return;
          }

          delete player.pendingAutoEnchantType;
          this.persistPlayer(player);
          
          // Now go to enchant craft with target level
          await this.handleEnchantCraft(interaction, player, enchantId, targetLevel);
          return;
        }
        // Handle enchant slot selection
        if (customId.startsWith('rpg-enchant-slot-')) {
          const payload = customId.replace('rpg-enchant-slot-', '');
          const knownSlots = this.getResolvedEquippedSlots(player).sort((a, b) => b.length - a.length);
          const matchedSlot = knownSlots.find(slotName => payload.startsWith(`${slotName}-`));
          const slot = matchedSlot || payload.split('-')[0];
          const remainingPayload = matchedSlot
            ? payload.slice(matchedSlot.length + 1)
            : payload.split('-').slice(1).join('-');
          
          // Check for target level pattern: enchantId-target{number}
          let enchantId = remainingPayload;
          let targetLevel = null;
          const targetMatch = remainingPayload.match(/^(.+)-target(\d+)$/);
          if (targetMatch) {
            enchantId = targetMatch[1];
            targetLevel = parseInt(targetMatch[2]);
          }

          if (!slot || !enchantId) {
            await interaction.reply({ content: 'Invalid enchant target selected.', ephemeral: true });
            return;
          }

          player.selectedEnchantSlot = slot;
          this.persistPlayer(player);
          await this.handleEnchantCraft(interaction, player, enchantId, targetLevel);
          return;
        }
        // Handle spell wheel click - Execute spell in combat
        if (customId.startsWith('rpg-spell-')) {
          const skillId = customId.replace('rpg-spell-', '');
          await this.handleSpellWheelClick(interaction, player, skillId);
          return;
        }
        // Handle upgrade slot selection
        if (customId.startsWith('rpg-upgrade-slot-')) {
          const slot = customId.replace('rpg-upgrade-slot-', '');
          player.selectedUpgradeSlot = slot;
          this.persistPlayer(player);
          await this.handleUpgradeGear(interaction, player);
          return;
        }
        if (customId.startsWith('rpg-achievement-claim-')) {
          const [, , , achievementId, tierId] = customId.split('-');
          await this.handleAchievementClaim(interaction, player, achievementId, tierId);
          return;
        }
        // Handle talent upgrade/downgrade
        if (customId.startsWith('rpg-talent-upgrade-max-')) {
          const talentId = customId.replace('rpg-talent-upgrade-max-', '');
          const talent = getTalent(talentId);
          if (talent) {
            if (!player.talents) player.talents = {};
            const currentRank = player.talents[talentId] || 0;
            const maxRank = talent.maxRank || 1;
            const points = player.talentPoints || 0;
            const ranksRemaining = Math.max(0, maxRank - currentRank);
            const spend = Math.min(points, ranksRemaining);
            if (spend <= 0) {
              await interaction.reply({ content: 'You have no talent points to spend.', ephemeral: true });
              return;
            }
            player.talents[talentId] = currentRank + spend;
            player.talentPoints -= spend;
            player.clearStatsCache();
            this.persistPlayer(player);
            await this.handleTalentUpgrade(interaction, player, talentId);
          }
          return;
        }

        if (customId.startsWith('rpg-talent-upgrade-')) {
          const talentId = customId.replace('rpg-talent-upgrade-', '');
          const talent = getTalent(talentId);
          if (talent) {
            if (!player.talents) player.talents = {};
            const currentRank = player.talents[talentId] || 0;
            const maxRank = talent.maxRank || 1;
            if (currentRank < maxRank) {
              if (!player.talentPoints || player.talentPoints <= 0) {
                await interaction.reply({ content: 'You have no talent points to spend.', ephemeral: true });
                return;
              }
              player.talents[talentId] = currentRank + 1;
              player.talentPoints -= 1;
              player.clearStatsCache();
              this.persistPlayer(player);
              await this.handleTalentUpgrade(interaction, player, talentId);
            }
          }
          return;
        }

        if (customId.startsWith('rpg-talent-downgrade-')) {
          const talentId = customId.replace('rpg-talent-downgrade-', '');
          const talent = getTalent(talentId);
          if (talent) {
            if (!player.talents) player.talents = {};
            const currentRank = player.talents[talentId] || 0;
            if (currentRank > 0) {
              player.talents[talentId] = currentRank - 1;
              if (player.talents[talentId] === 0) {
                delete player.talents[talentId];
              }
              this.persistPlayer(player);
              await this.handleTalentUpgrade(interaction, player, talentId);
            }
          }
          return;
        }

        // Handle quest tab buttons
        if (customId.startsWith('rpg-quest-tab-')) {
          const tabName = customId.replace('rpg-quest-tab-', '');
          player.questTab = tabName;
          await this.handleQuests(interaction, player, true);
          return;
        }

        if (customId.startsWith('rpg-open-lootbox-qty-')) {
          const payload = customId.replace('rpg-open-lootbox-qty-', '');
          const parts = payload.split('-');
          const quantity = parts.pop();
          const lootboxId = parts.join('-');
          await this.handleOpenLootbox(interaction, player, lootboxId, quantity);
          return;
        }

        // Handle confirm craft button
        if (customId.startsWith('rpg-confirm-craft-')) {
          const parts = customId.split('-');
          const recipeId = parts[3];
          let quantity;
          
          if (parts[4] === 'all') {
            // Calculate max craftable quantity
            const recipe = getRecipe(recipeId);
            if (recipe) {
              const baseMaterials = this.getAdjustedMaterials(recipe.materials);
              const adjustedMaterials = this.applyCostMultiplier(baseMaterials, this.getProfessionCostMultiplier(player));
              
              quantity = 1;
              for (let i = 2; i <= 100; i++) {
                const multipliedMats = {};
                for (const [matId, qty] of Object.entries(adjustedMaterials)) {
                  multipliedMats[matId] = qty * i;
                }
                if (!this.hasMaterials(player, multipliedMats)) {
                  quantity = i - 1;
                  break;
                }
                if (i === 100) quantity = 100;
              }
            } else {
              quantity = 1;
            }
          } else {
            quantity = parseInt(parts[4]) || 1;
          }
          
          await this.handleCraftRecipe(interaction, player, recipeId, quantity);
          return;
        }

        // Handle alchemy brew confirmation
        if (customId.startsWith('rpg-confirm-brew-')) {
          const parts = customId.split('-');
          const recipeId = parts[3];
          let quantity;
          
          if (parts[4] === 'max') {
            // Calculate max brewable quantity
            const recipe = getRecipe(recipeId);
            if (recipe) {
              const hasBotanic = player.professions?.includes('botanic');
              const baseMaterials = this.getAdjustedMaterials(recipe.materials);
              const costMultiplier = this.getProfessionCostMultiplier(player) * (hasBotanic ? 1 : 1.5);
              const adjustedMaterials = this.applyCostMultiplier(baseMaterials, costMultiplier);
              
              quantity = 1;
              for (let i = 2; i <= 100; i++) {
                const multipliedMats = {};
                for (const [matId, qty] of Object.entries(adjustedMaterials)) {
                  multipliedMats[matId] = qty * i;
                }
                if (!this.hasMaterials(player, multipliedMats)) {
                  quantity = i - 1;
                  break;
                }
                if (i === 100) quantity = 100;
              }
            } else {
              quantity = 1;
            }
          } else {
            quantity = parseInt(parts[4]) || 1;
          }
          
          await this.handleAlchemyBrewWithQuantity(interaction, player, recipeId, quantity);
          return;
        }

        // Handle slots betting
        if (customId.startsWith('rpg-slots-bet-')) {
          const amount = parseInt(customId.replace('rpg-slots-bet-', ''));
          await this.playSlots(interaction, player, amount, false);
          return;
        }

        if (customId === 'rpg-slots-allin') {
          const allInAmount = player.gold || 0;
          if (allInAmount > 0) {
            await this.playSlots(interaction, player, allInAmount, true);
          }
          return;
        }

        // Handle coinflip betting
        if (customId.startsWith('rpg-coinflip-bet-')) {
          const parts = customId.replace('rpg-coinflip-bet-', '').split('-');
          const amount = parseInt(parts[0]);
          const side = parts[1]; // 'heads' or 'tails'
          await this.playCoinflip(interaction, player, amount, side);
          return;
        }

        // Handle coinflip choice selection
        if (customId.startsWith('rpg-coinflip-choice-')) {
          const amount = parseInt(customId.replace('rpg-coinflip-choice-', ''));
          await this.handleCoinflipChoice(interaction, player, amount);
          return;
        }

        // Handle quest back button
        if (customId === 'rpg-quest-back') {
          await this.handleQuests(interaction, player, true);
          return;
        }

        // Handle quest start buttons
        if (customId.startsWith('rpg-quest-start-')) {
          const questId = customId.replace('rpg-quest-start-', '');
          await this.handleStartQuestFromDetail(interaction, player, questId);
          return;
        }

        // Handle quest view detail buttons (for quest chains)
        if (customId.startsWith('rpg-quest-view-detail-')) {
          const questId = customId.replace('rpg-quest-view-detail-', '');
          await this.handleQuestDetail(interaction, player, questId);
          return;
        }

        // Handle quest chain branch selection (route to next quest)
        if (customId.startsWith('rpg-quest-chain-choice-')) {
          const parts = customId.replace('rpg-quest-chain-choice-', '').split('-');
          const branchIdx = parseInt(parts[parts.length - 1]);
          const questId = parts.slice(0, -1).join('-');
          await this.handleQuestChainBranchSelection(interaction, player, questId, branchIdx);
          return;
        }

        // Handle quest choice buttons
        if (customId.startsWith('rpg-quest-choice-')) {
          const parts = customId.replace('rpg-quest-choice-', '').split('-');
          const questId = parts.slice(0, -1).join('-');
          const branchId = parts[parts.length - 1];
          await this.handleQuestChoiceSelection(interaction, player, questId, branchId);
          return;
        }

        // Handle world travel buttons
        if (customId.startsWith('rpg-travel-')) {
          const worldId = customId.replace('rpg-travel-', '');
          await this.handleTravelToWorld(interaction, player, worldId);
          return;
        }

        // Handle guild buff bulk purchases
        if (customId.startsWith('rpg-guild-buff-buy-qty-')) {
          const parts = customId.replace('rpg-guild-buff-buy-qty-', '').split('-');
          const quantity = parseInt(parts[parts.length - 1]);
          const action = parts.slice(0, -1).join('-');
          
          if (!action || !quantity || quantity <= 0) {
            await interaction.reply({ content: '‚ùå Invalid purchase quantity.', ephemeral: true });
            return;
          }
          
          await this.handleGuildBuffBulkPurchase(interaction, player, action, quantity);
          return;
        }

        // Handle guild buff purchases
        if (customId.startsWith('rpg-guild-buy-buff-')) {
          const buffType = customId.replace('rpg-guild-buy-buff-', '');
          const buffMap = {
            'xp': 'xpBonus',
            'gold': 'goldBonus',
            'shop': 'shopDiscount',
            'gathering': 'gatheringSpeed',
            'crafting': 'craftingSpeed',
            'boss': 'bossRewardBoost',
            'rare': 'rareDropRate',
            'damage': 'damageBonus',
            'defense': 'defenseBonus',
          };
          
          const buffKey = buffMap[buffType];
          if (!buffKey) {
            await interaction.reply({ content: '‚ùå Invalid buff type.', ephemeral: true });
            return;
          }

          const guild = this.guildManager.getPlayerGuild(player.userId);
          if (!guild) {
            await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
            return;
          }

          const member = guild.members[player.userId];
          if (member.role !== 'leader' && member.role !== 'officer') {
            await interaction.reply({ content: '‚ùå Only officers and leaders can purchase buffs!', ephemeral: true });
            return;
          }

          const cost = GUILD_BUFF_COSTS[buffKey];
          if (guild.gold < cost) {
            await interaction.reply({ content: `‚ùå Not enough guild gold! Need ${cost.toLocaleString()}g.`, ephemeral: true });
            return;
          }

          const result = this.guildManager.purchaseBuff(guild.id, player.userId, buffKey, cost);
          if (!result.success) {
            await interaction.reply({ content: `‚ùå ${result.error}`, ephemeral: true });
            return;
          }

          await interaction.reply({
            content: `‚úÖ Purchased +1% ${buffKey} buff for ${cost.toLocaleString()}g!`,
            ephemeral: true,
          });

          setTimeout(() => {
            interaction.deleteReply().catch(() => {});
          }, 5000);

          // Refresh buffs page
          setTimeout(() => {
            this.handleGuildBuffs(interaction, player);
          }, 1000);
          return;
        }

        // Handle guild leave confirmation
        if (customId === 'rpg-guild-leave-confirm') {
          const result = this.guildManager.leaveGuild(player.userId);
          
          if (!result.success) {
            await interaction.reply({ content: `‚ùå ${result.error}`, ephemeral: true });
            return;
          }

          if (result.disbanded) {
            await interaction.reply({
              content: '‚úÖ Guild disbanded successfully.',
              ephemeral: true,
            });
          } else {
            await interaction.reply({
              content: '‚úÖ You have left the guild.',
              ephemeral: true,
            });
          }

          setTimeout(() => {
            interaction.deleteReply().catch(() => {});
          }, 5000);

          // Return to guild browser
          setTimeout(() => {
            this.handleGuild(interaction, player);
          }, 1000);
          return;
        }

        // Handle guild join
        if (customId.startsWith('rpg-guild-join-')) {
          const guildId = customId.replace('rpg-guild-join-', '');
          
          // Get guild info first to check requirements
          const guild = this.guildManager.getGuild(guildId);
          if (!guild) {
            await interaction.reply({ content: '‚ùå Guild not found!', ephemeral: true });
            return;
          }

          // Check minimum level requirement
          if (player.level < guild.settings.minLevel) {
            await interaction.reply({ 
              content: `‚ùå You need to be at least level ${guild.settings.minLevel} to join this guild! You are level ${player.level}.`, 
              ephemeral: true 
            });
            return;
          }

          // Check if application is required
          if (guild.settings.requireApplication) {
            await interaction.reply({ 
              content: '‚ùå This guild requires an application. Please contact the guild leader for an invite.', 
              ephemeral: true 
            });
            return;
          }

          const result = this.guildManager.joinGuild(player.userId, guildId);

          if (!result.success) {
            await interaction.reply({ content: `‚ùå ${result.error}`, ephemeral: true });
            return;
          }

          await interaction.reply({
            content: `‚úÖ You joined **[${result.guild.tag}] ${result.guild.name}**!`,
            ephemeral: true,
          });

          setTimeout(() => {
            interaction.deleteReply().catch(() => {});
          }, 5000);

          setTimeout(() => {
            this.handleGuild(interaction, player);
          }, 1000);
          return;
        }

        // Handle guild boss start
        if (customId.startsWith('rpg-guild-start-boss-')) {
          const bossId = customId.replace('rpg-guild-start-boss-', '');
          const boss = getGuildBoss(bossId);
          
          if (!boss) {
            await interaction.reply({ content: '‚ùå Invalid boss!', ephemeral: true });
            return;
          }

          const guild = this.guildManager.getPlayerGuild(player.userId);
          if (!guild) {
            await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
            return;
          }

          // Check tier restrictions - can only fight best boss or one tier below
          const levelInfo = getGuildLevel(guild.xp);
          const availableBosses = getAvailableGuildBosses(levelInfo.level);
          
          if (!availableBosses.includes(boss)) {
            await interaction.reply({ content: '‚ùå Your guild level is too low for this boss!', ephemeral: true });
            return;
          }

          // Get the highest tier boss available
          const highestBoss = availableBosses[availableBosses.length - 1];
          const secondHighestBoss = availableBosses.length > 1 ? availableBosses[availableBosses.length - 2] : null;
          
          // Player can only fight the highest tier or one below
          const canFight = boss.id === highestBoss.id || (secondHighestBoss && boss.id === secondHighestBoss.id);
          if (!canFight) {
            const tierText = secondHighestBoss ? `**${highestBoss.name}** or **${secondHighestBoss.name}**` : `**${highestBoss.name}**`;
            await interaction.reply({ content: `‚ùå You can only fight ${tierText} at your guild level!`, ephemeral: true });
            return;
          }

          const expiresAt = this.getNextGuildBossResetAt(Date.now());
          const bossData = { ...boss, expiresAt };
          const result = this.guildManager.startBoss(guild.id, player.userId, bossData);
          if (!result.success) {
            await interaction.reply({ content: `‚ùå ${result.error}`, ephemeral: true });
            return;
          }

          await interaction.reply({
            content: `üêâ **${boss.name}** has appeared! All guild members can now attack!`,
            ephemeral: false,
          });

          // Show boss fight UI
          setTimeout(() => {
            this.handleGuildBosses(interaction, player);
          }, 1000);
          return;
        }

        // Handle boss upgrade shops
        if (customId === 'rpg-guild-boss-stats-shop') {
          await this.handleGuildBossStatsShop(interaction, player);
          return;
        }
        if (customId === 'rpg-guild-boss-skills-shop') {
          await this.handleGuildBossSkillsShop(interaction, player);
          return;
        }
        if (customId === 'rpg-guild-boss-talents-shop') {
          await this.handleGuildBossTalentsShop(interaction, player);
          return;
        }
        if (customId === 'rpg-guild-boss-enchants-shop') {
          await this.handleGuildBossEnchantsShop(interaction, player);
          return;
        }

        // Handle buy stats from boss shop
        if (customId.startsWith('rpg-guild-boss-buy-stat-')) {
          const bossEssenceId = 'boss_essence';
          const statType = customId.replace('rpg-guild-boss-buy-stat-', '');
          const statMap = {
            'strength': { stat: 'strength', costGold: 500, costEssence: 1 },
            'defense': { stat: 'defense', costGold: 500, costEssence: 1 },
            'agility': { stat: 'agility', costGold: 500, costEssence: 1 },
            'intelligence': { stat: 'intelligence', costGold: 500, costEssence: 1 },
            'vitality': { stat: 'vitality', costGold: 500, costEssence: 1 },
            'wisdom': { stat: 'wisdom', costGold: 500, costEssence: 1 },
            'maxHp': { stat: 'maxHp', costGold: 1000, costEssence: 2 },
            'maxMana': { stat: 'maxMana', costGold: 1000, costEssence: 2 },
          };

          const stat = statMap[statType];
          if (!stat) {
            await interaction.reply({ content: '‚ùå Invalid stat!', ephemeral: true });
            return;
          }

          const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
          if (player.gold < stat.costGold || bossEssenceCount < stat.costEssence) {
            await interaction.reply({ content: `‚ùå You need ${stat.costGold}g + ${stat.costEssence} Boss Essence.`, ephemeral: true });
            return;
          }

          // Ensure bossStats has correct structure with all required properties
          const defaultBossStats = { strength: 5, defense: 5, agility: 5, intelligence: 5, vitality: 5, wisdom: 5, maxHp: 100, maxMana: 50 };
          if (!player.bossStats || typeof player.bossStats !== 'object' || player.bossStats.encounters !== undefined) {
            // Fix corrupted or old structure
            player.bossStats = { ...defaultBossStats };
          } else {
            // Ensure all properties exist with defaults
            for (const [key, value] of Object.entries(defaultBossStats)) {
              if (typeof player.bossStats[key] !== 'number') {
                player.bossStats[key] = value;
              }
            }
          }

          if (!player.bossShopSpent) {
            player.bossShopSpent = { gold: 0, bossEssence: 0 };
          }

          player.gold -= stat.costGold;
          this.trackGoldSpent(player, stat.costGold, 'shop');
          this.removeMaterialFromInventory(player, bossEssenceId, stat.costEssence);
          player.bossStats[stat.stat] += 1;
          player.bossShopSpent.gold = (player.bossShopSpent?.gold || 0) + stat.costGold;
          player.bossShopSpent.bossEssence = (player.bossShopSpent?.bossEssence || 0) + stat.costEssence;
          this.persistPlayer(player);
          this.clearStatsCache(player);

          await interaction.reply({ content: `‚úÖ Purchased **+1 ${stat.stat}** for ${stat.costGold}g + ${stat.costEssence} Essence.`, ephemeral: true });
          setTimeout(() => {
            this.handleGuildBossStatDetail(interaction, player, statType);
          }, 500);
          return;
        }

        // Handle buy boss skill
        if (customId.startsWith('rpg-guild-boss-buy-skill-')) {
          const bossEssenceId = 'boss_essence';
          const skillId = customId.replace('rpg-guild-boss-buy-skill-', '');
          const skillItem = this.getBossSkillShopItems().find(item => item.id === skillId);
          if (!skillItem) {
            await interaction.reply({ content: '‚ùå Invalid skill!', ephemeral: true });
            return;
          }

          const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
          if (player.gold < skillItem.costGold || bossEssenceCount < skillItem.costEssence) {
            await interaction.reply({ content: `‚ùå You need ${skillItem.costGold}g + ${skillItem.costEssence} Boss Essence.`, ephemeral: true });
            return;
          }

          player.bossSkills = Array.isArray(player.bossSkills) ? player.bossSkills : [];
          if (player.bossSkills.includes(skillId)) {
            await interaction.reply({ content: '‚ùå You already own that skill.', ephemeral: true });
            return;
          }

          if (!player.bossShopSpent) {
            player.bossShopSpent = { gold: 0, bossEssence: 0 };
          }

          player.gold -= skillItem.costGold;
          this.trackGoldSpent(player, skillItem.costGold, 'shop');
          this.removeMaterialFromInventory(player, bossEssenceId, skillItem.costEssence);
          player.bossSkills.push(skillId);
          player.bossShopSpent.gold = (player.bossShopSpent?.gold || 0) + skillItem.costGold;
          player.bossShopSpent.bossEssence = (player.bossShopSpent?.bossEssence || 0) + skillItem.costEssence;
          this.persistPlayer(player);

          await interaction.reply({ content: `‚úÖ Unlocked **${skillItem.name}**.`, ephemeral: true });
          setTimeout(() => {
            this.handleGuildBossSkillDetail(interaction, player, skillId);
          }, 500);
          return;
        }

        // Handle buy boss talent
        if (customId.startsWith('rpg-guild-boss-buy-talent-')) {
          const bossEssenceId = 'boss_essence';
          const talentId = customId.replace('rpg-guild-boss-buy-talent-', '');
          const talentItem = this.getBossTalentShopItems().find(item => item.id === talentId);
          if (!talentItem) {
            await interaction.reply({ content: '‚ùå Invalid talent!', ephemeral: true });
            return;
          }

          const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
          if (player.gold < talentItem.costGold || bossEssenceCount < talentItem.costEssence) {
            await interaction.reply({ content: `‚ùå You need ${talentItem.costGold}g + ${talentItem.costEssence} Boss Essence.`, ephemeral: true });
            return;
          }

          player.bossTalents = player.bossTalents || {};
          if (!player.bossShopSpent) {
            player.bossShopSpent = { gold: 0, bossEssence: 0 };
          }

          player.gold -= talentItem.costGold;
          this.trackGoldSpent(player, talentItem.costGold, 'shop');
          this.removeMaterialFromInventory(player, bossEssenceId, talentItem.costEssence);
          player.bossTalents[talentId] = (player.bossTalents[talentId] || 0) + 1;
          player.bossShopSpent.gold = (player.bossShopSpent?.gold || 0) + talentItem.costGold;
          player.bossShopSpent.bossEssence = (player.bossShopSpent?.bossEssence || 0) + talentItem.costEssence;
          this.persistPlayer(player);

          await interaction.reply({ content: `‚úÖ Upgraded **${talentItem.name}** to Rank ${player.bossTalents[talentId]}.`, ephemeral: true });
          setTimeout(() => {
            this.handleGuildBossTalentDetail(interaction, player, talentId);
          }, 500);
          return;
        }

        // Handle buy boss enchant recipe
        if (customId.startsWith('rpg-guild-boss-buy-enchant-')) {
          const bossEssenceId = 'boss_essence';
          const recipeId = customId.replace('rpg-guild-boss-buy-enchant-', '');
          const recipeItem = this.getBossEnchantShopItems().find(item => item.id === recipeId);
          if (!recipeItem) {
            await interaction.reply({ content: '‚ùå Invalid recipe!', ephemeral: true });
            return;
          }

          const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
          if (player.gold < recipeItem.costGold || bossEssenceCount < recipeItem.costEssence) {
            await interaction.reply({ content: `‚ùå You need ${recipeItem.costGold}g + ${recipeItem.costEssence} Boss Essence.`, ephemeral: true });
            return;
          }

          player.bossEnchantRecipesUnlocked = Array.isArray(player.bossEnchantRecipesUnlocked)
            ? player.bossEnchantRecipesUnlocked
            : [];
          if (player.bossEnchantRecipesUnlocked.includes(recipeId)) {
            await interaction.reply({ content: '‚ùå You already unlocked that recipe.', ephemeral: true });
            return;
          }

          if (!player.bossShopSpent) {
            player.bossShopSpent = { gold: 0, bossEssence: 0 };
          }

          player.gold -= recipeItem.costGold;
          this.trackGoldSpent(player, recipeItem.costGold, 'shop');
          this.removeMaterialFromInventory(player, bossEssenceId, recipeItem.costEssence);
          player.bossEnchantRecipesUnlocked.push(recipeId);
          player.bossShopSpent.gold = (player.bossShopSpent?.gold || 0) + recipeItem.costGold;
          player.bossShopSpent.bossEssence = (player.bossShopSpent?.bossEssence || 0) + recipeItem.costEssence;
          this.persistPlayer(player);

          await interaction.reply({ content: `‚úÖ Unlocked **${recipeItem.name}**.`, ephemeral: true });
          setTimeout(() => {
            this.handleGuildBossEnchantDetail(interaction, player, recipeId);
          }, 500);
          return;
        }

        // Handle reset boss upgrades
        if (customId === 'rpg-guild-boss-reset-stats') {
          const refundGold = player.bossShopSpent?.gold || 0;
          const refundEssence = player.bossShopSpent?.bossEssence || 0;
          const bossEssenceId = 'boss_essence';

          player.gold += refundGold;
          if (refundEssence > 0) {
            this.addMaterialToInventory(player, bossEssenceId, refundEssence);
          }

          player.bossStats = { strength: 5, defense: 5, agility: 5, intelligence: 5, vitality: 5, wisdom: 5, maxHp: 100, maxMana: 50 };
          player.bossSkills = [];
          player.bossSkillLevels = {};
          player.bossTalents = {};
          player.bossEnchantRecipesUnlocked = [];
          player.bossShopSpent = { gold: 0, bossEssence: 0 };
          this.persistPlayer(player);
          this.clearStatsCache(player);

          await interaction.reply({ content: `üîÑ **Boss upgrades reset!** Refunded ${refundGold}g and ${refundEssence} Essence.`, ephemeral: true });
          setTimeout(() => {
            this.handleGuildBossStatsShop(interaction, player);
          }, 500);
          return;
        }

        // Handle guild member promote
        if (customId.startsWith('rpg-guild-promote-')) {
          const targetUserId = customId.replace('rpg-guild-promote-', '');
          const guild = this.guildManager.getPlayerGuild(player.userId);
          
          if (!guild) {
            await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
            return;
          }

          const member = guild.members[player.userId];
          if (member.role !== 'leader') {
            await interaction.reply({ content: '‚ùå Only the guild leader can promote members!', ephemeral: true });
            return;
          }

          const targetMember = guild.members[targetUserId];
          if (!targetMember) {
            await interaction.reply({ content: '‚ùå Member not found!', ephemeral: true });
            return;
          }

          if (targetMember.role !== 'member') {
            await interaction.reply({ content: '‚ùå That member is already promoted!', ephemeral: true });
            return;
          }

          // Get username
          let targetUsername = `User ${targetUserId}`;
          try {
            const targetUser = await this.client.users.fetch(targetUserId);
            targetUsername = targetUser.username;
          } catch (err) {
            // Use fallback
          }

          // Promote to officer
          targetMember.role = 'officer';
          this.guildManager.save();

          // Notify the promoted member
          this.notifyPlayer(targetUserId, '‚≠ê Guild Promotion!', `You have been promoted to Officer in [${guild.tag}] ${guild.name}!`, '#FFD700');
          
          // Show success message and refresh roles view
          await interaction.update({
            content: `‚úÖ **${targetUsername}** has been promoted to Officer!`,
            embeds: [],
            components: [
              new ActionRowBuilder().addComponents(
                new ButtonBuilder()
                  .setCustomId('rpg-guild-roles')
                  .setLabel('‚Üê Back to Roles')
                  .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                  .setCustomId('rpg-hub')
                  .setLabel('üè† Hub')
                  .setStyle(ButtonStyle.Primary)
              )
            ]
          });
          return;
        }

        // Handle guild member demote
        if (customId.startsWith('rpg-guild-demote-')) {
          const targetUserId = customId.replace('rpg-guild-demote-', '');
          const guild = this.guildManager.getPlayerGuild(player.userId);
          
          if (!guild) {
            await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
            return;
          }

          const member = guild.members[player.userId];
          if (member.role !== 'leader') {
            await interaction.reply({ content: '‚ùå Only the guild leader can demote members!', ephemeral: true });
            return;
          }

          const targetMember = guild.members[targetUserId];
          if (!targetMember) {
            await interaction.reply({ content: '‚ùå Member not found!', ephemeral: true });
            return;
          }

          if (targetMember.role !== 'officer') {
            await interaction.reply({ content: '‚ùå That member is not an officer!', ephemeral: true });
            return;
          }

          // Get username
          let targetUsername = `User ${targetUserId}`;
          try {
            const targetUser = await this.client.users.fetch(targetUserId);
            targetUsername = targetUser.username;
          } catch (err) {
            // Use fallback
          }

          // Demote to member
          targetMember.role = 'member';
          this.guildManager.save();

          // Notify the demoted member
          this.notifyPlayer(targetUserId, 'üë§ Guild Demotion', `You have been demoted to Member in [${guild.tag}] ${guild.name}.`, '#FFA500');
          
          // Show success message and refresh roles view
          await interaction.update({
            content: `‚úÖ **${targetUsername}** has been demoted to Member.`,
            embeds: [],
            components: [
              new ActionRowBuilder().addComponents(
                new ButtonBuilder()
                  .setCustomId('rpg-guild-roles')
                  .setLabel('‚Üê Back to Roles')
                  .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                  .setCustomId('rpg-hub')
                  .setLabel('üè† Hub')
                  .setStyle(ButtonStyle.Primary)
              )
            ]
          });
          return;
        }

        // Handle guild member kick
        if (customId.startsWith('rpg-guild-kick-')) {
          const targetUserId = customId.replace('rpg-guild-kick-', '');
          const guild = this.guildManager.getPlayerGuild(player.userId);
          
          if (!guild) {
            await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
            return;
          }

          const member = guild.members[player.userId];
          const targetMember = guild.members[targetUserId];

          if (!targetMember) {
            await interaction.reply({ content: '‚ùå Member not found!', ephemeral: true });
            return;
          }

          const isLeader = member.role === 'leader';
          const isOfficer = member.role === 'officer';

          // Permission check
          if (!isLeader && !isOfficer) {
            await interaction.reply({ content: '‚ùå Only officers and leaders can kick members!', ephemeral: true });
            return;
          }

          // Officers can only kick regular members
          if (isOfficer && !isLeader && targetMember.role !== 'member') {
            await interaction.reply({ content: '‚ùå Officers can only kick regular members!', ephemeral: true });
            return;
          }

          // Can't kick the leader
          if (targetMember.role === 'leader') {
            await interaction.reply({ content: '‚ùå Cannot kick the guild leader!', ephemeral: true });
            return;
          }

          // Get username
          let targetUsername = `User ${targetUserId}`;
          try {
            const targetUser = await this.client.users.fetch(targetUserId);
            targetUsername = targetUser.username;
          } catch (err) {
            // Use fallback
          }

          // Remove from guild
          delete guild.members[targetUserId];
          this.guildManager.save();

          // Notify the kicked member
          this.notifyPlayer(targetUserId, 'üö™ Removed from Guild', `You have been removed from [${guild.tag}] ${guild.name}.`, '#FF0000');
          
          // Show success message and refresh roles view
          await interaction.update({
            content: `‚úÖ **${targetUsername}** has been kicked from the guild.`,
            embeds: [],
            components: [
              new ActionRowBuilder().addComponents(
                new ButtonBuilder()
                  .setCustomId('rpg-guild-roles')
                  .setLabel('‚Üê Back to Roles')
                  .setStyle(ButtonStyle.Secondary),
                new ButtonBuilder()
                  .setCustomId('rpg-hub')
                  .setLabel('üè† Hub')
                  .setStyle(ButtonStyle.Primary)
              )
            ]
          });
          return;
        }

        // Handle guild boss attack
        if (customId === 'rpg-guild-boss-attack') {
          const guild = this.guildManager.getPlayerGuild(player.userId);
          if (!guild) {
            await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
            return;
          }

          if (!guild.activeBoss) {
            await interaction.reply({ content: '‚ùå No active boss fight!', ephemeral: true });
            return;
          }

          const existingCombat = this.combatSystem.getActiveCombat(player.userId);
          if (existingCombat && existingCombat.meta?.type !== 'guild_boss') {
            await interaction.reply({ content: '‚ùå Finish your current combat before attacking the guild boss.', ephemeral: true });
            return;
          }

          if (existingCombat && existingCombat.meta?.type === 'guild_boss') {
            await this.handleCombatRefresh(interaction, player);
            return;
          }

          await this.startGuildBossCombat(interaction, player, guild);
          return;
        }

        // Handle dungeon floor continuation
        if (customId.startsWith('rpg-dungeon-continue-')) {
          await interaction.deferUpdate();
          
          const parts = customId.replace('rpg-dungeon-continue-', '').split('-');
          const dungeonId = parts[0];
          const completedFloor = parseInt(parts[1]) || 1;
          const nextFloor = completedFloor + 1;
          
          const dungeon = getDungeonById(dungeonId);

          if (!dungeon) {
            await interaction.reply({ content: 'Invalid dungeon.', ephemeral: true });
            return;
          }

          if (this.combatSystem.isInCombat(player.userId)) {
            await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
            return;
          }

          const totalFloors = dungeon.floors || 1;
          
          if (nextFloor > totalFloors) {
            await interaction.reply({ content: 'All floors completed!', ephemeral: true });
            return;
          }

          // Get the boss for this floor (cycle through bosses if fewer bosses than floors)
          const bossIndex = Math.min(nextFloor - 1, (dungeon.bosses?.length || 1) - 1);
          
          let enemyName = 'Dungeon Foe';
          let enemyLevel = Math.max(1, player.level + nextFloor); // Scale level with floor
          let bossData = null;

          if (dungeon.bosses && dungeon.bosses.length > 0) {
            const currentBoss = dungeon.bosses[bossIndex];
            let bossId = null;
            
            if (typeof currentBoss === 'string') {
              bossId = currentBoss;
            } else if (currentBoss && typeof currentBoss === 'object') {
              enemyName = currentBoss.name || enemyName;
              enemyLevel = currentBoss.level || enemyLevel;
            }
            
            if (bossId) {
              const allWorlds = getAllWorlds();
              for (const world of allWorlds) {
                if (world.entities?.worldBosses?.[bossId]) {
                  bossData = world.entities.worldBosses[bossId];
                  enemyName = bossData.name || enemyName;
                  enemyLevel = parseInt(bossData.level) || enemyLevel;
                  break;
                }
              }
            }
          }

          let combatState;
          const combatMeta = {
            type: 'dungeon',
            dungeonId: dungeon.id,
            currentFloor: nextFloor,
            totalFloors: totalFloors,
            bossIndex: bossIndex
          };
          
          // Dungeon difficulty multipliers
          const DUNGEON_HP_MULT = 2.5;
          const DUNGEON_STAT_MULT = 1.8;
          
          if (bossData && bossData.hp) {
            const baseHp = parseInt(bossData.hp) || 100;
            const baseStr = parseInt(bossData.strength) || 10;
            const baseDef = parseInt(bossData.constitution) || 5;
            const baseInt = parseInt(bossData.intelligence) || 5;
            const baseAgi = parseInt(bossData.dexterity) || 5;
            
            combatState = this.combatSystem.startCombatWithCustomEnemy(
              player,
              enemyName,
              enemyLevel,
              Math.floor(baseHp * DUNGEON_HP_MULT),
              {
                strength: Math.floor(baseStr * DUNGEON_STAT_MULT),
                defense: Math.floor(baseDef * DUNGEON_STAT_MULT),
                intelligence: Math.floor(baseInt * DUNGEON_STAT_MULT),
                agility: Math.floor(baseAgi * DUNGEON_STAT_MULT),
              },
              bossData.abilities || [],
              combatMeta
            );
          } else {
            combatState = this.combatSystem.startCombat(
              player,
              enemyName,
              enemyLevel,
              { meta: combatMeta }
            );
          }

          this.persistPlayer(player);

          const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
          embed.setFooter({ text: `Floor ${nextFloor}/${totalFloors}` });
          
          const buttons = this.createCombatButtons();

          await interaction.editReply({
            embeds: [embed],
            components: buttons,
          });
          return;
        }

        if (customId.startsWith('rpg-raid-continue-')) {
          await interaction.deferUpdate();
          
          const parts = customId.replace('rpg-raid-continue-', '').split('-');
          const raidId = parts[0];
          const completedBossIndex = parseInt(parts[1]) || 0;
          const nextBossIndex = completedBossIndex + 1;
          
          const raid = getRaidById(raidId);

          if (!raid) {
            await interaction.reply({ content: 'Invalid raid.', ephemeral: true });
            return;
          }

          if (this.combatSystem.isInCombat(player.userId)) {
            await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
            return;
          }

          const totalBosses = raid.bosses?.length || 0;
          
          if (nextBossIndex >= totalBosses) {
            await interaction.reply({ content: 'All raid bosses defeated!', ephemeral: true });
            return;
          }

          // Get the next boss
          const boss = raid.bosses[nextBossIndex];
          const enemyName = boss.name || 'Raid Boss';
          const enemyLevel = boss.level || raid.minLevel;
          const enemyHp = boss.hp || (enemyLevel * 100);

          console.log('[Raid] Continuing raid:', raid.name);
          console.log('[Raid] Fighting boss:', nextBossIndex + 1, '/', totalBosses);

          // Calculate current floor based on bosses per floor (approximate)
          const totalFloors = raid.floors || 1;
          const bossesPerFloor = Math.ceil(totalBosses / totalFloors);
          const currentFloor = Math.min(Math.floor(nextBossIndex / bossesPerFloor) + 1, totalFloors);

          // Start combat with next raid boss
          const combatState = this.combatSystem.startCombatWithCustomEnemy(
            player,
            enemyName,
            enemyLevel,
            enemyHp,
            {
              strength: enemyLevel * 2,
              defense: enemyLevel,
              intelligence: enemyLevel,
              agility: enemyLevel,
            },
            boss.abilities || [],
            { 
              type: 'raid', 
              raidId: raid.id,
              currentFloor: currentFloor,
              totalFloors: totalFloors,
              bossIndex: nextBossIndex,
              totalBosses: totalBosses
            }
          );

          this.persistPlayer(player);

          const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
          embed.setFooter({ text: `Boss ${nextBossIndex + 1}/${totalBosses} ‚Ä¢ Floor ${currentFloor}/${totalFloors}` });
          
          const buttons = this.createCombatButtons();

          await interaction.editReply({
            embeds: [embed],
            components: buttons,
          });
          return;
        }

        // Handle dungeon claim reward button
        if (customId.startsWith('rpg-dungeon-claim-')) {
          await interaction.deferUpdate();
          const parts = customId.replace('rpg-dungeon-claim-', '').split('-');
          const dungeonId = parts[0];
          const currentFloor = parseInt(parts[1]) || 1;
          const dungeon = getDungeonById(dungeonId);

          if (!dungeon) {
            await interaction.reply({ content: 'Invalid dungeon.', ephemeral: true });
            return;
          }

          // Get floor-specific rewards
          const floorReward = dungeon.floorRewards?.[currentFloor] || dungeon.rewards;
          
          if (floorReward) {
            let extraXp = floorReward.xp || 0;
            const extraGold = floorReward.gold || 0;
            const loot = floorReward.loot || floorReward.items || [];
            const materials = floorReward.materials || [];

            // Apply XP potion bonus to dungeon rewards
            if (extraXp > 0 && player.potionBuffs) {
              if (player.potionBuffs.xpRemaining && player.potionBuffs.xpRemaining > 0 && player.potionBuffs.xpBonus) {
                const bonusXp = Math.floor(extraXp * (player.potionBuffs.xpBonus / 100));
                extraXp += bonusXp;
                // Note: potion charges are decremented in CombatSystem, not here
              }
            }

            let levelUp = null;
            if (extraXp > 0) levelUp = player.addXp(extraXp);
            if (extraGold > 0) this.addGold(player, extraGold);

            const lootNames = [];
            let weaponGiven = false;
            const playerClass = player.class || player.internalClass;
            
            for (const lootItem of loot) {
              let itemId, quantity;
              if (typeof lootItem === 'string') {
                itemId = lootItem;
                quantity = 1;
              } else {
                itemId = lootItem.id;
                quantity = lootItem.quantity || 1;
              }
              
              const equipment = getEquipment(itemId);
              const item = getItemByIdDynamic(itemId);
              const material = getMaterial(itemId);

              if (equipment) {
                if (equipment.slot === 'weapon') {
                  if (weaponGiven) continue;
                  if (equipment.classRestriction && equipment.classRestriction !== playerClass) {
                    const classWeapon = this.findClassWeaponInLoot(loot, playerClass);
                    if (classWeapon) {
                      this.addCraftedItem(player, classWeapon.id, quantity);
                      lootNames.push(`${classWeapon.name} x${quantity}`);
                      weaponGiven = true;
                      continue;
                    }
                    continue;
                  }
                }
                
                this.addCraftedItem(player, equipment.id, quantity);
                lootNames.push(`${equipment.name} x${quantity}`);
                
                if (equipment.slot === 'weapon') {
                  weaponGiven = true;
                }
              } else if (item) {
                this.addCraftedItem(player, item.id, quantity);
                lootNames.push(`${item.name} x${quantity}`);
              } else if (material) {
                this.addMaterialToInventory(player, material.id, quantity);
                lootNames.push(`${material.name} x${quantity}`);
              }
            }
            
            for (const matItem of materials) {
              let matId, quantity;
              if (typeof matItem === 'string') {
                matId = matItem;
                quantity = 1;
              } else {
                matId = matItem.id;
                quantity = matItem.quantity || 1;
              }
              
              const material = getMaterial(matId);
              if (material) {
                this.addMaterialToInventory(player, material.id, quantity);
                lootNames.push(`${material.name} x${quantity}`);
              }
            }

            // Update dungeon progress stats
            if (!player.progressStats) {
              player.progressStats = {
                monstersDefeated: 0,
                gatheringActions: 0,
                materialsCollected: 0,
                craftsCompleted: 0,
                goldEarned: 0,
                criticalHits: 0,
                dungeonsCleared: 0,
                raidsCleared: 0,
              };
            }
            
            // Count as dungeon cleared if floor 3
            if (currentFloor >= 3) {
              player.progressStats.dungeonsCleared += 1;

              const dailyQuests = getAvailableDailyQuests(player.level, player.dailyQuestsCompleted);
              const weeklyQuests = getAvailableWeeklyQuests(player.level, player.weeklyQuestsCompleted);
              const claimedLimited = (player.claimedQuests || [])
                .map(id => getGuildQuestById(id))
                .filter(Boolean)
                .filter(q => !player.limitedQuestsCompleted.includes(q.id));

              if (!player.guildQuestProgress) player.guildQuestProgress = {};

              this.applyGuildQuestProgress(player, dailyQuests, weeklyQuests, claimedLimited, {
                type: 'explore',
                target: 'dungeon',
                targetName: dungeon?.name || 'Dungeon',
                count: 1,
                tags: ['dungeon'],
              });
            }

            this.persistPlayer(player);

            // Create reward summary embed
            const embed = new EmbedBuilder()
              .setColor(0x00ff00)
              .setTitle(`üí∞ ${dungeon.name} - Floor ${currentFloor} Claimed!`)
              .setDescription(`You claimed your rewards and left the dungeon safely.`);

            const rewardParts = [];
            if (extraXp > 0) rewardParts.push(`+${extraXp} XP`);
            if (extraGold > 0) rewardParts.push(`+${extraGold} Gold`);
            if (lootNames.length > 0) rewardParts.push(`**Loot:**\n${lootNames.join('\n')}`);

            if (rewardParts.length > 0) {
              embed.addFields({
                name: 'üéÅ Rewards',
                value: rewardParts.join('\n'),
                inline: false,
              });
            }

            if (levelUp && levelUp.levelsGained > 0) {
              const levelUpText = this.createLevelUpMessage(levelUp);
              if (levelUpText) {
                embed.addFields({
                  name: 'üéâ Level Up!',
                  value: levelUpText.trim(),
                  inline: false,
                });
              }
            }

            const buttons = new ActionRowBuilder().addComponents(
              new ButtonBuilder()
                .setCustomId('rpg-back')
                .setLabel('‚Üê Back to Menu')
                .setStyle(ButtonStyle.Secondary),
              new ButtonBuilder()
                .setCustomId(`rpg-redo-dungeon-${dungeonId}`)
                .setLabel('üîÑ Redo Dungeon')
                .setStyle(ButtonStyle.Primary),
              new ButtonBuilder()
                .setCustomId('rpg-hub')
                .setLabel('üè† Hub')
                .setStyle(ButtonStyle.Success)
            );

            await interaction.editReply({
              embeds: [embed],
              components: [buttons],
            });
          } else {
            await interaction.reply({ content: 'No rewards configured for this floor.', ephemeral: true });
          }
          return;
        }

        // Handle dungeon/raid redo buttons
        if (customId.startsWith('rpg-redo-dungeon-')) {
          await interaction.deferUpdate();
          
          const dungeonId = customId.replace('rpg-redo-dungeon-', '');
          const dungeon = getDungeonById(dungeonId);

          if (!dungeon) {
            await interaction.reply({ content: 'Invalid dungeon.', ephemeral: true });
            return;
          }

          if (this.combatSystem.isInCombat(player.userId)) {
            await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
            return;
          }

          // Start from floor 1
          const currentFloor = 1;
          const totalFloors = dungeon.floors || 1;
          
          // Reuse dungeon combat start logic
          let enemyName = 'Dungeon Foe';
          let enemyLevel = Math.max(1, player.level);
          let bossData = null;

          if (dungeon.bosses && dungeon.bosses.length > 0) {
            const firstBoss = dungeon.bosses[0];
            let bossId = null;
            
            if (typeof firstBoss === 'string') {
              bossId = firstBoss;
            } else if (firstBoss && typeof firstBoss === 'object') {
              enemyName = firstBoss.name || enemyName;
              enemyLevel = firstBoss.level || enemyLevel;
            }
            
            if (bossId) {
              const allWorlds = getAllWorlds();
              for (const world of allWorlds) {
                if (world.entities?.worldBosses?.[bossId]) {
                  bossData = world.entities.worldBosses[bossId];
                  enemyName = bossData.name || enemyName;
                  enemyLevel = parseInt(bossData.level) || enemyLevel;
                  break;
                }
              }
            }
          }

          let combatState;
          const combatMeta = {
            type: 'dungeon',
            dungeonId: dungeon.id,
            currentFloor: currentFloor,
            totalFloors: totalFloors,
            bossIndex: 0
          };
          
          // Dungeon difficulty multipliers
          const DUNGEON_HP_MULT = 2.5;
          const DUNGEON_STAT_MULT = 1.8;
          
          if (bossData && bossData.hp) {
            const baseHp = parseInt(bossData.hp) || 100;
            const baseStr = parseInt(bossData.strength) || 10;
            const baseDef = parseInt(bossData.constitution) || 5;
            const baseInt = parseInt(bossData.intelligence) || 5;
            const baseAgi = parseInt(bossData.dexterity) || 5;
            
            combatState = this.combatSystem.startCombatWithCustomEnemy(
              player,
              enemyName,
              enemyLevel,
              Math.floor(baseHp * DUNGEON_HP_MULT),
              {
                strength: Math.floor(baseStr * DUNGEON_STAT_MULT),
                defense: Math.floor(baseDef * DUNGEON_STAT_MULT),
                intelligence: Math.floor(baseInt * DUNGEON_STAT_MULT),
                agility: Math.floor(baseAgi * DUNGEON_STAT_MULT),
              },
              bossData.abilities || [],
              combatMeta
            );
          } else {
            combatState = this.combatSystem.startCombat(
              player,
              enemyName,
              enemyLevel,
              { meta: combatMeta }
            );
          }

          this.persistPlayer(player);

          const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
          if (totalFloors > 1) {
            embed.setFooter({ text: `Floor ${currentFloor}/${totalFloors}` });
          }
          
          const buttons = this.createCombatButtons();

          await interaction.editReply({
            embeds: [embed],
            components: buttons,
          });
          return;
        }

        if (customId.startsWith('rpg-redo-raid-')) {
          await interaction.deferUpdate();
          const raidId = customId.replace('rpg-redo-raid-', '');
          const raid = getRaidById(raidId);

          if (!raid) {
            await interaction.reply({ content: 'Invalid raid.', ephemeral: true });
            return;
          }

          if (this.combatSystem.isInCombat(player.userId)) {
            await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
            return;
          }

          if (player.level < raid.minLevel) {
            await interaction.reply({ 
              content: `You need to be level ${raid.minLevel} to attempt this raid.`, 
              ephemeral: true 
            });
            return;
          }

          // Restart raid from first boss
          const bossIndex = 0;
          const boss = raid.bosses[bossIndex];
          const enemyName = boss.name || 'Raid Boss';
          const enemyLevel = boss.level || raid.minLevel;
          const enemyHp = boss.hp || (enemyLevel * 100);
          const totalFloors = raid.floors || 1;

          console.log('[Raid] Restarting raid:', raid.name);

          // Start combat with first raid boss
          const combatState = this.combatSystem.startCombatWithCustomEnemy(
            player,
            enemyName,
            enemyLevel,
            enemyHp,
            {
              strength: enemyLevel * 2,
              defense: enemyLevel,
              intelligence: enemyLevel,
              agility: enemyLevel,
            },
            boss.abilities || [],
            { 
              type: 'raid', 
              raidId: raid.id,
              currentFloor: 1,
              totalFloors: totalFloors,
              bossIndex: bossIndex,
              totalBosses: raid.bosses.length
            }
          );

          this.persistPlayer(player);

          const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
          embed.setFooter({ text: `Boss 1/${raid.bosses.length} ‚Ä¢ Floor 1/${totalFloors}` });
          
          const buttons = this.createCombatButtons();

          await interaction.editReply({
            embeds: [embed],
            components: buttons,
          });
          return;
        }

        // Handle skill upgrade
        if (customId.startsWith('rpg-skill-upgrade-')) {
          const skillId = customId.replace('rpg-skill-upgrade-', '');
          const skill = getSkill(skillId);

          if (!skill || !player.skills.includes(skillId)) {
            await interaction.reply({ content: '‚ùå Skill not found or not learned.', ephemeral: true });
            return;
          }

          const currentLevel = player.skillLevels?.[skillId] || 1;
          const maxLevel = skill.maxLevel || 3;

          if (currentLevel >= maxLevel) {
            await interaction.reply({ content: '‚ùå Skill is already at maximum level!', ephemeral: true });
            return;
          }

          // Upgrade cost is always 1 skill point per level (separate from unlock cost)
          const upgradeCost = 1;

          if ((player.skillPoints || 0) < upgradeCost) {
            await interaction.reply({ 
              content: `‚ùå You need ${upgradeCost} skill point to upgrade this skill. You have ${player.skillPoints || 0}.`,
              ephemeral: true 
            });
            return;
          }

          // Apply upgrade
          player.skillPoints -= upgradeCost;
          player.skillLevels[skillId] = (player.skillLevels?.[skillId] || 1) + 1;
          this.persistPlayer(player);

          const newLevel = player.skillLevels[skillId];
          await interaction.reply({ 
            content: `‚úÖ **${skill.name}** upgraded to **Level ${newLevel}/${maxLevel}**! (${player.skillPoints} points remaining)`,
            ephemeral: true 
          });

          // Refresh skill detail view
          await this.handleSkillDetail(interaction, player, skillId, 'learned');
          return;
        }

        // Handle skill unlock
        if (customId.startsWith('rpg-skill-unlock-')) {
          const skillId = customId.replace('rpg-skill-unlock-', '');
          const skill = getSkill(skillId);

          if (!skill) {
            await interaction.reply({ content: '‚ùå Skill not found.', ephemeral: true });
            return;
          }

          if (player.skills.includes(skillId)) {
            await interaction.reply({ content: '‚ùå This skill is already learned!', ephemeral: true });
            return;
          }

          // Get unlock cost from skill tree
          const playerClass = player.class || player.internalClass;
          const classData = getClass(playerClass);
          let unlockCost = 1;
          let unlockLevel = 1;
          
          if (classData && classData.skillTree) {
            const skillTreeEntry = classData.skillTree.find(s => s.skillId === skillId);
            if (skillTreeEntry) {
              unlockCost = skillTreeEntry.pointCost;
              unlockLevel = skillTreeEntry.unlockLevel;
            }
          }

          if (player.level < unlockLevel) {
            await interaction.reply({ 
              content: `‚ùå You need to be level ${unlockLevel} to unlock this skill. You are level ${player.level}.`,
              ephemeral: true 
            });
            return;
          }

          if ((player.skillPoints || 0) < unlockCost) {
            await interaction.reply({ 
              content: `‚ùå You need ${unlockCost} skill points to unlock this skill. You have ${player.skillPoints || 0}.`,
              ephemeral: true 
            });
            return;
          }

          // Apply unlock
          player.skillPoints -= unlockCost;
          player.skills.push(skillId);
          player.skillLevels[skillId] = 1;
          player.skillCooldowns[skillId] = 0;
          this.persistPlayer(player);

          await interaction.reply({ 
            content: `‚úÖ **${skill.name}** unlocked! (${player.skillPoints} points remaining)`,
            ephemeral: true 
          });

          // Refresh skill detail view
          await this.handleSkillDetail(interaction, player, skillId, 'learned');
          return;
        }

        // Handle quest navigation buttons
        if (customId.startsWith('rpg-quest-navigate-')) {
          const questId = customId.replace('rpg-quest-navigate-', '');
          await this.handleGuildQuestNavigation(interaction, player, questId);
          return;
        }
        if (customId === 'rpg-guild-bounties') {
          await this.handleGuildBounties(interaction, player);
          return;
        }
        if (customId === 'rpg-guild-raids') {
          await this.handleRaids(interaction, player);
          return;
        }
        if (customId === 'rpg-create-bounty') {
          await this.handleCreateBountyModal(interaction, player);
          return;
        }
        if (customId === 'rpg-guild-rewards') {
          await this.handleGuildWeeklyRewards(interaction, player);
          return;
        }
        if (customId === 'rpg-guild-claim-weekly') {
          await this.handleClaimWeeklyReward(interaction, player);
          return;
        }

        // Quick-swap equipment sets from tabs
        if (customId.startsWith('rpg-quickswap-set-')) {
          const setIndex = parseInt(customId.replace('rpg-quickswap-set-', ''));
          const set = player.equipmentSets?.[setIndex];

          if (!set || !set.items) {
            await interaction.reply({ content: 'Equipment set not found.', ephemeral: true });
            return;
          }

          // Defer update first to prevent double-reply
          await interaction.deferUpdate();

          // Load the set
          player.equippedItems = { ...set.items };
          player.clearStatsCache();
          this.persistPlayer(player);

          // Refresh the equipment view with update
          await this.handleEquipment(interaction, player, true);
          return;
        }

        // Leaderboard button
        if (customId === 'rpg-leaderboard') {
          // Force reload player data from disk to ensure fresh data
          this.playerManager.loadAllPlayers();
          await this.handleLeaderboards(interaction);
          return;
        }

        // Repeat training dummy battle
        if (customId === 'rpg-repeat-training') {
          // Get the last combat style used from player data or combat history
          const lastTrainingStyle = player.lastTrainingStyle || null;
          await this.startTrainingCombat(interaction, player, lastTrainingStyle);
          return;
        }
        
        // Only reply if not already replied/deferred
        if (!interaction.replied && !interaction.deferred) {
          await interaction.reply({
            content: 'Unknown action',
            ephemeral: true,
          });
        }
    }
  }

  /**
   * Handle select menu interactions
   */
  async handleSelectMenuInteraction(interaction) {
    const customId = interaction.customId;
    const player = this.playerManager.getPlayer(interaction.user.id);

    if (!player) {
      await interaction.reply({
        content: 'You need to run /rpg first!',
        ephemeral: true,
      });
      return;
    }

    // Ensure auto-gathering is running if it should be
    this.autoGatherManager.ensureGatheringActive(player);

    // Handle roguelike upgrade selection
    if (customId === 'rpg-roguelike-upgrade-select') {
      const upgradeId = interaction.values?.[0];
      if (upgradeId) {
        await this.handleRoguelikeUpgradeView(interaction, player, upgradeId);
      }
      return;
    }

    // Handle dismantle item selection
    if (customId === 'rpg-dismantle-select-item') {
      const selectedItemId = interaction.values?.[0];
      if (selectedItemId) {
        await this.handleDismantleItemOverview(interaction, player, selectedItemId);
      }
      return;
    }

    if (customId === 'rpg-talents-select') {
      const talentId = interaction.values?.[0];
      const talent = getTalent(talentId);
      if (!talent) {
        await interaction.reply({ content: 'Invalid talent selection.', ephemeral: true });
        return;
      }

      const currentRank = player.talents?.[talentId] || 0;
      const maxRank = talent.maxRank || 1;
      if (currentRank >= maxRank) {
        await interaction.reply({ content: 'That talent is already maxed.', ephemeral: true });
        return;
      }

      await this.handleTalentUpgrade(interaction, player, talentId);
      return;
    }

    if (customId === 'rpg-guild-quests-select') {
      const questType = interaction.values?.[0];
      if (!questType) {
        await interaction.reply({ content: 'No quest type selected.', ephemeral: true });
        return;
      }
      
      if (questType === 'daily') {
        await this.handleGuildDailyQuests(interaction, player);
      } else if (questType === 'weekly') {
        await this.handleGuildWeeklyQuests(interaction, player);
      } else if (questType === 'limited') {
        await this.handleGuildLimitedQuests(interaction, player);
      }
      return;
    }

    if (customId === 'rpg-guild-claim-limited') {
      const questId = interaction.values?.[0];
      if (!questId) {
        await interaction.reply({ content: 'No quest selected.', ephemeral: true });
        return;
      }
      
      const claimResult = claimLimitedQuest(questId, player.userId);
      if (!claimResult.success) {
        await interaction.reply({ content: `‚ùå ${claimResult.error}`, ephemeral: true });
        return;
      }
      
      if (!player.claimedQuests) player.claimedQuests = [];
      player.claimedQuests.push(questId);
      this.persistPlayer(player);
      
      await interaction.reply({ content: `‚úÖ Quest claimed! Check your limited quests to track progress.`, ephemeral: true });
      await this.handleGuildLimitedQuests(interaction, player);
      return;
    }

    if (customId === 'rpg-guild-bounty-select') {
      const bountyId = interaction.values?.[0];
      if (!bountyId) {
        await interaction.reply({ content: 'No bounty selected.', ephemeral: true });
        return;
      }
      await this.handleGuildBountySelect(interaction, player, bountyId);
      return;
    }

    if (customId === 'rpg-guild-manage-member-role') {
      const targetUserId = interaction.values?.[0];
      if (!targetUserId) {
        await interaction.reply({ content: 'No member selected.', ephemeral: true });
        return;
      }
      await this.handleGuildMemberRoleSelect(interaction, player, targetUserId);
      return;
    }

    if (customId === 'rpg-gather-area-select-menu') {
      const areaId = interaction.values?.[0];
      if (!areaId) {
        await interaction.reply({ content: 'No area selected.', ephemeral: true });
        return;
      }
      await this.handleGatheringAreaDetails(interaction, player, areaId);
      return;
    }

    if (customId === 'rpg-arena-opponent-select') {
      const opponentId = interaction.values?.[0];
      if (!opponentId) {
        await interaction.reply({ content: 'No opponent selected.', ephemeral: true });
        return;
      }
      await this.handleArenaFightStart(interaction, player, opponentId);
      return;
    }

    if (customId === 'rpg-arena-shop-buy') {
      const itemId = interaction.values?.[0];
      if (!itemId) {
        await interaction.reply({ content: 'No item selected.', ephemeral: true });
        return;
      }
      await this.handleArenaShopPurchase(interaction, player, itemId);
      return;
    }

    if (customId === 'rpg-market-item-select') {
      const itemId = interaction.values?.[0];
      if (!itemId) {
        await interaction.reply({ content: 'No item selected.', ephemeral: true });
        return;
      }
      await this.handleMarketItemDetails(interaction, player, itemId);
      return;
    }

    if (customId === 'rpg-market-listing-select') {
      const listingId = interaction.values?.[0];
      if (!listingId) {
        await interaction.reply({ content: 'No listing selected.', ephemeral: true });
        return;
      }
      await this.handleMarketPurchase(interaction, player, listingId);
      return;
    }

    if (customId === 'rpg-market-my-listing-select') {
      const listingId = interaction.values?.[0];
      if (!listingId) {
        await interaction.reply({ content: 'No listing selected.', ephemeral: true });
        return;
      }
      await this.handleMarketCancelListing(interaction, player, listingId);
      return;
    }

    if (customId === 'rpg-select-dungeon') {
      const dungeonId = interaction.values?.[0];
      const dungeon = getDungeonById(dungeonId);

      if (!dungeon) {
        await interaction.reply({ content: 'Invalid dungeon selection.', ephemeral: true });
        return;
      }

      if (this.combatSystem.isInCombat(player.userId)) {
        await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
        return;
      }

      // Ask to choose between normal dungeon or boss encounter
      const choiceRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-dungeon-normal-${dungeonId}`)
          .setLabel('Normal Dungeon')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId(`rpg-dungeon-boss-${dungeonId}`)
          .setLabel('Boss Encounter')
          .setStyle(ButtonStyle.Danger)
      );

      const embed = new EmbedBuilder()
        .setColor(0xff8800)
        .setTitle(`${dungeon.name}`)
        .setDescription(dungeon.description || 'Enter the dungeon')
        .addFields(
          { name: 'Choose Your Challenge', value: 'Normal Dungeon - Standard enemies and rewards\nBoss Encounter - Powerful boss with greater rewards' }
        );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [choiceRow],
      });
      return;
    }

    if (customId === 'rpg-select-raid') {
      const raidId = interaction.values?.[0];
      const raid = getRaidById(raidId);

      if (!raid) {
        await interaction.reply({ content: 'Invalid raid selection.', ephemeral: true });
        return;
      }

      if (this.combatSystem.isInCombat(player.userId)) {
        await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
        return;
      }

      if (player.level < raid.minLevel) {
        await interaction.reply({ 
          content: `You need to be level ${raid.minLevel} to attempt this raid.`, 
          ephemeral: true 
        });
        return;
      }

      // Initialize raid progress
      const currentFloor = 1;
      const totalFloors = raid.floors || 1;
      const bossIndex = 0;
      
      // Get the first boss from the raid
      if (!raid.bosses || raid.bosses.length === 0) {
        await interaction.reply({ content: 'This raid has no bosses configured.', ephemeral: true });
        return;
      }

      const boss = raid.bosses[bossIndex];
      const enemyName = boss.name || 'Raid Boss';
      const enemyLevel = boss.level || raid.minLevel;
      const enemyHp = boss.hp || (enemyLevel * 100);

      console.log('[Raid] Selected raid:', raid.name);
      console.log('[Raid] Total floors:', totalFloors);
      console.log('[Raid] Boss count:', raid.bosses.length);
      console.log('[Raid] Starting boss:', enemyName);

      // Start combat with raid boss
      const combatState = this.combatSystem.startCombatWithCustomEnemy(
        player,
        enemyName,
        enemyLevel,
        enemyHp,
        {
          strength: enemyLevel * 2,
          defense: enemyLevel,
          intelligence: enemyLevel,
          agility: enemyLevel,
        },
        boss.abilities || [],
        { 
          type: 'raid', 
          raidId: raid.id,
          currentFloor: currentFloor,
          totalFloors: totalFloors,
          bossIndex: bossIndex,
          totalBosses: raid.bosses.length
        }
      );

      this.persistPlayer(player);

      const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
      const buttons = this.createCombatButtons();

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: buttons,
      });
    }

    if (customId === 'rpg-alchemy-select') {
      const value = interaction.values?.[0];
      if (!value) {
        await interaction.reply({ content: 'No selection made.', ephemeral: true });
        return;
      }
      
      // Check if viewing details
      if (value.startsWith('details-')) {
        const recipeId = value.replace('details-', '');
        await this.handlePotionDetails(interaction, player, recipeId);
        return;
      }
      
      await this.handleAlchemyCraft(interaction, player, value);
      return;
    }

    // Handle boss upgrade shop selectors
    if (customId === 'rpg-guild-boss-stats-select') {
      const statEmoji = interaction.values?.[0];
      if (statEmoji) {
        await this.handleGuildBossStatDetail(interaction, player, statEmoji);
      }
      return;
    }

    if (customId === 'rpg-guild-boss-skills-select') {
      const skillId = interaction.values?.[0];
      if (skillId) {
        await this.handleGuildBossSkillDetail(interaction, player, skillId);
      }
      return;
    }

    if (customId === 'rpg-guild-boss-talents-select') {
      const talentId = interaction.values?.[0];
      if (talentId) {
        await this.handleGuildBossTalentDetail(interaction, player, talentId);
      }
      return;
    }

    if (customId === 'rpg-guild-boss-enchants-select') {
      const recipeId = interaction.values?.[0];
      if (recipeId) {
        await this.handleGuildBossEnchantDetail(interaction, player, recipeId);
      }
      return;
    }

    if (customId === 'rpg-enchant-select') {
      const enchantId = interaction.values?.[0];
      if (!enchantId) {
        await interaction.reply({ content: 'No enchant selected.', ephemeral: true });
        return;
      }
      await this.handleEnchantCraft(interaction, player, enchantId);
      return;
    }

    if (customId === 'rpg-auto-enchant-type-select') {
      const enchantId = interaction.values?.[0];
      if (!enchantId) {
        await interaction.reply({ content: 'No enchant type selected.', ephemeral: true });
        return;
      }
      // Store selected enchant type, waiting for target level
      player.pendingAutoEnchantType = enchantId;
      this.persistPlayer(player);
      await interaction.reply({ 
        content: `Selected **${enchantId}**. Now click a target level button above.`, 
        ephemeral: true 
      });
      return;
    }

    if (customId === 'rpg-use-potion-select') {
      const potionId = interaction.values?.[0];
      if (!potionId) {
        await interaction.reply({ content: 'No potion selected.', ephemeral: true });
        return;
      }
      await this.handleUsePotionQuantity(interaction, player, potionId);
      return;
    }

    if (customId === 'rpg-open-lootbox-select') {
      const lootboxId = interaction.values?.[0];
      if (!lootboxId) {
        await interaction.reply({ content: 'No lootbox selected.', ephemeral: true });
        return;
      }
      await this.handleOpenLootboxQuantityMenu(interaction, player, lootboxId);
      return;
    }

    // Handle guild buff overview selector
    if (customId === 'rpg-guild-buff-overview') {
      const buffType = interaction.values?.[0];
      if (!buffType) return;
      await this.handleGuildBuffOverview(interaction, player, buffType);
      return;
    }

    // Handle guild buff purchase selectors
    if (customId === 'rpg-guild-buff-purchase' || customId === 'rpg-guild-buff-purchase2') {
      const action = interaction.values?.[0];
      if (!action) return;
      await this.handleGuildBuffPurchaseFromSelector(interaction, player, action);
      return;
    }

    if (customId === 'rpg-select-title') {
      const titleId = interaction.values?.[0];
      if (!titleId) {
        await interaction.reply({ content: 'No title selected.', ephemeral: true });
        return;
      }

      const title = getTitle(titleId);
      if (!title) {
        await interaction.reply({ content: '‚ùå Invalid title selected.', ephemeral: true });
        return;
      }

      // Check if player has earned this title
      const earnedTitles = getEarnedTitles(player);
      if (!earnedTitles.find(t => t.id === titleId)) {
        await interaction.reply({ content: '‚ùå You have not earned this title yet!', ephemeral: true });
        return;
      }

      // Set active title
      player.activeTitle = titleId;
      this.persistPlayer(player);

      const bonuses = [];
      if (title.activeBonus) bonuses.push(`üü¢ ${title.activeBonus.description}`);
      if (title.passiveBonus) bonuses.push(`üîµ ${title.passiveBonus.description}`);
      const bonusText = bonuses.length > 0 ? `\n\n**Bonuses:**\n${bonuses.join('\n')}` : '';

      await interaction.reply({
        content: `‚úÖ Equipped title: **${title.displayName}**${bonusText}`,
        ephemeral: true,
      });
      return;
    }

    if (customId === 'rpg-crafting-world') {
      const selectedWorldId = interaction.values?.[0];
      if (!selectedWorldId) {
        await interaction.reply({ content: 'No world selected.', ephemeral: true });
        return;
      }
      await this.handleCraftingPage(interaction, player, 0, selectedWorldId);
      return;
    }

    if (customId.startsWith('rpg-crafting-select-')) {
      const recipeId = interaction.values?.[0];
      if (!recipeId) {
        await interaction.reply({ content: 'No recipe selected.', ephemeral: true });
        return;
      }
      await this.handleCraftingOverview(interaction, player, recipeId);
    }

    if (customId === 'rpg-equip-item') {
      const rawValue = interaction.values?.[0];
      const itemId = rawValue ? rawValue.split('::')[0] : null;
      if (!itemId) {
        await interaction.reply({ content: 'No item selected.', ephemeral: true });
        return;
      }

      const equipment = getEquipment(itemId) || getItemByIdDynamic(itemId);
      const inventoryItem = player.inventory.find(item =>
        item && typeof item === 'object' && item.id === itemId
      );
      const resolvedSlot = equipment?.slot || inventoryItem?.slot || (equipment ? this.inferSlotFromCategory(equipment) : null);
      if (!equipment || !resolvedSlot) {
        await interaction.reply({ content: 'Invalid equipment selected.', ephemeral: true });
        return;
      }

      const slot = resolvedSlot;
      const currentlyEquipped = player.equippedItems?.[slot];

      // Toggle equip/unequip
      if (currentlyEquipped === itemId) {
        // Unequip - restore weapon to inventory
        delete player.equippedItems[slot];
        if (player.equipment && typeof player.equipment === 'object') {
          delete player.equipment[slot];
        }
        
        // Add the unequipped item back to inventory
        this.addInventoryItem(player, {
          id: equipment.id,
          name: equipment.name,
          type: 'equipment',
          slot: equipment.slot,
        });
        
        player.clearStatsCache();
        this.persistPlayer(player);
        await interaction.reply({
          content: `‚úÖ Unequipped **${equipment.name}** from ${slot} slot. Added to inventory.`,
          ephemeral: true,
        });
      } else {
        // Equip
        if (!player.equippedItems) player.equippedItems = {};
        if (!player.equipment || typeof player.equipment !== 'object') player.equipment = {};
        
        // If replacing an equipped item, return it to inventory
        if (currentlyEquipped && currentlyEquipped !== itemId) {
          const oldEquip = getEquipment(currentlyEquipped) || getItemByIdDynamic(currentlyEquipped);
          if (oldEquip) {
            this.addInventoryItem(player, {
              id: oldEquip.id,
              name: oldEquip.name,
              type: 'equipment',
              slot: oldEquip.slot || slot,
            });
          }
        }

        // Remove item from inventory if it's there
        const invIndex = player.inventory.findIndex(item => 
          item && typeof item === 'object' && item.id === itemId
        );
        if (invIndex !== -1) {
          const invItem = player.inventory[invIndex];
          if (invItem && invItem.quantity > 1) {
            invItem.quantity -= 1;
          } else {
            player.inventory.splice(invIndex, 1);
          }
        }
        
        player.equippedItems[slot] = itemId;
        player.equipment[slot] = equipment;
        player.clearStatsCache();
        this.persistPlayer(player);
        
        let message = `‚úÖ Equipped **${equipment.name}** to ${slot} slot.`;
        if (currentlyEquipped) {
          const oldEquip = getEquipment(currentlyEquipped);
          message += ` (Replaced ${oldEquip?.name || currentlyEquipped})`;
        }
        
        await interaction.reply({
          content: message,
          ephemeral: true,
        });
      }

      // Refresh the equipment management view
      await this.handleManageEquipment(interaction, player);
      return;
    }

    if (customId === 'rpg-dismantle-item') {
      const rawValue = interaction.values?.[0];
      const itemId = rawValue ? rawValue.split('::')[0] : null;
      if (!itemId) {
        await interaction.reply({ content: 'No item selected.', ephemeral: true });
        return;
      }

      const equipment = getEquipment(itemId) || getItemByIdDynamic(itemId);
      if (!equipment) {
        await interaction.reply({ content: 'Invalid equipment selected.', ephemeral: true });
        return;
      }

      // Check if item is equipped
      const isEquipped = Object.values(player.equippedItems || {}).includes(itemId);
      
      // Find the recipe for this item to determine materials
      const recipe = Object.values(RECIPES).find(r => r.output.item === itemId);
      
      if (!recipe || !recipe.materials) {
        await interaction.reply({ 
          content: `‚ùå Cannot dismantle **${equipment.name}** - no recipe found.`, 
          ephemeral: true 
        });
        return;
      }

      // Calculate 20% of materials (rounded down)
      const baseMaterials = this.getAdjustedMaterials(recipe.materials);
      const adjustedMaterials = this.applyCostMultiplier(baseMaterials, this.getProfessionCostMultiplier(player));
      const refundMaterials = {};
      
      for (const [matId, qty] of Object.entries(adjustedMaterials)) {
        const refundQty = Math.floor(qty * 0.2);
        if (refundQty > 0) {
          refundMaterials[matId] = refundQty;
        }
      }

      // Remove item from inventory or equipped slot
      if (isEquipped) {
        // Find which slot and unequip
        for (const [slot, equippedId] of Object.entries(player.equippedItems)) {
          if (equippedId === itemId) {
            delete player.equippedItems[slot];
            break;
          }
        }
      } else {
        // Remove from inventory
        const invItem = player.inventory.find(i => i && i.id === itemId && i.type === 'equipment');
        if (invItem) {
          if (invItem.quantity > 1) {
            invItem.quantity -= 1;
          } else {
            const index = player.inventory.indexOf(invItem);
            if (index > -1) player.inventory.splice(index, 1);
          }
        }
      }

      // Add materials back to inventory
      const refundedItems = [];
      for (const [matId, qty] of Object.entries(refundMaterials)) {
        const material = getMaterial(matId);
        this.addMaterialToInventory(player, matId, qty);
        refundedItems.push(`${material?.name || matId} x${qty}`);
      }

      player.clearStatsCache();
      this.persistPlayer(player);

      // Limit materials list to first 5, then summarize if more
      let materialsText = refundedItems.length > 0 
        ? refundedItems.slice(0, 5).join(', ')
        : 'No materials recovered (all materials < 5 units)';
      
      if (refundedItems.length > 5) {
        materialsText += ` and ${refundedItems.length - 5} more material${refundedItems.length - 5 !== 1 ? 's' : ''}`;
      }

      const refundText = refundedItems.length > 0 
        ? `\nüîß Recovered: ${materialsText}`
        : '\n‚ö†Ô∏è No materials recovered (all materials < 5 units)';

      await interaction.reply({
        content: `‚ôªÔ∏è Dismantled **${equipment.name}** for parts.${refundText}`,
        ephemeral: true,
      });
      return;
    }

    if (customId === 'rpg-load-equipment-set') {
      const setValue = interaction.values?.[0];
      if (!setValue || !setValue.startsWith('set_')) {
        await interaction.reply({ content: 'Invalid set selection.', ephemeral: true });
        return;
      }

      const setIndex = parseInt(setValue.replace('set_', ''));
      const set = player.equipmentSets?.[setIndex];

      if (!set || !set.items) {
        await interaction.reply({ content: 'Equipment set not found.', ephemeral: true });
        return;
      }

      // Load the set
      player.equippedItems = { ...set.items };
      player.clearStatsCache();
      this.persistPlayer(player);

      await interaction.reply({
        content: `‚úÖ Loaded equipment set: **${set.name}**`,
        ephemeral: true,
      });

      // Refresh the sets view
      await this.handleEquipmentSets(interaction, player);
      return;
    }

    if (customId === 'rpg-delete-equipment-set') {
      const setValue = interaction.values?.[0];
      if (!setValue || !setValue.startsWith('delete_')) {
        await interaction.reply({ content: 'Invalid set selection.', ephemeral: true });
        return;
      }

      const setIndex = parseInt(setValue.replace('delete_', ''));
      const set = player.equipmentSets?.[setIndex];

      if (!set) {
        await interaction.reply({ content: 'Equipment set not found.', ephemeral: true });
        return;
      }

      player.equipmentSets.splice(setIndex, 1);
      this.persistPlayer(player);

      await interaction.reply({
        content: `üóëÔ∏è Deleted equipment set: **${set.name}**`,
        ephemeral: true,
      });

      // Refresh the sets view
      await this.handleEquipmentSets(interaction, player);
      return;
    }

    if (customId === 'rpg-profession-initial-select') {
      const professionId = interaction.values?.[0];
      if (!professionId) {
        await interaction.reply({ content: 'No profession selected.', ephemeral: true });
        return;
      }

      if (!player.professions) player.professions = [];
      if (!player.professionLevels) player.professionLevels = {};

      player.professions.push(professionId);
      player.professionLevels[professionId] = 1;
      player.characterCreated = true;
      this.persistPlayer(player);

      // Show welcome message and continue button
      const professionNames = { blacksmith: 'Blacksmith', botanic: 'Botanic', enchanter: 'Enchanter', gathering: 'Gatherer' };
      const embed = UIBuilder.createStoryIntroEmbed();
      const continueButton = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-enter-world')
          .setLabel('Begin Adventure')
          .setStyle(ButtonStyle.Success)
      );

      await this.updateInteractionWithTracking(interaction, {
        content: `üíº Profession selected: **${professionNames[professionId]}**\n\n‚ú® Profession slots unlock at levels 15, 20, and 35.`,
        embeds: [embed],
        components: [continueButton],
      });
      return;
    }

    if (customId === 'rpg-profession-select') {
      const professionId = interaction.values?.[0];
      if (!professionId) {
        await interaction.reply({ content: 'No profession selected.', ephemeral: true });
        return;
      }

      const maxSlots = player.maxProfessions || 1;
      if ((player.professions?.length || 0) >= maxSlots) {
        await interaction.reply({ content: 'No available profession slots.', ephemeral: true });
        return;
      }

      if (!player.professions) player.professions = [];
      if (!player.professionLevels) player.professionLevels = {};

      if (!player.professions.includes(professionId)) {
        player.professions.push(professionId);
        player.professionLevels[professionId] = 1;
        this.persistPlayer(player);
      }

      await this.handleProfessions(interaction, player);
      return;
    }

    if (customId === 'rpg-profession-rewards-select') {
      const professionId = interaction.values?.[0];
      if (!professionId) {
        await interaction.reply({ content: 'No profession selected.', ephemeral: true });
        return;
      }
      await this.handleProfessionRewardsDisplay(interaction, player, professionId);
      return;
    }

    if (customId === 'rpg-talent-select') {
      const talentId = interaction.values?.[0];
      if (!talentId) {
        await interaction.reply({ content: 'No talent selected.', ephemeral: true });
        return;
      }
      await this.handleTalentUpgrade(interaction, player, talentId);
      return;
    }

    if (customId === 'rpg-skill-select') {
      const selection = interaction.values?.[0];
      if (!selection) {
        await interaction.reply({ content: 'No skill selected.', ephemeral: true });
        return;
      }
      
      // Parse selection: "learned-{skillId}" or "unlock-{skillId}"
      const parts = selection.split('-');
      const action = parts[0]; // "learned" or "unlock"
      const skillId = parts.slice(1).join('-'); // rejoin in case skillId has hyphens
      
      await this.handleSkillDetail(interaction, player, skillId, action);
      return;
    }

    if (customId === 'rpg-combat-style-select') {
      const selection = interaction.values?.[0];
      if (!selection || !selection.startsWith('style-')) {
        await interaction.reply({ content: 'No style selected.', ephemeral: true });
        return;
      }
      const styleId = selection.replace('style-', '');
      await this.startTrainingCombat(interaction, player, styleId);
      return;
    }

    if (customId === 'rpg-combat-skill-select') {
      const skillId = interaction.values?.[0];
      if (!skillId) {
        await interaction.reply({ content: 'No skill selected.', ephemeral: true });
        return;
      }
      await this.handleCombatSkillSelect(interaction, player, skillId);
      return;
    }

    if (customId === 'rpg-combat-gear-select') {
      const indexValue = interaction.values?.[0];
      if (indexValue === undefined) {
        await interaction.reply({ content: 'No gear set selected.', ephemeral: true });
        return;
      }
      const setIndex = Number(indexValue);
      await this.handleCombatGearSelect(interaction, player, setIndex);
      return;
    }

    if (customId === 'rpg-combat-stance-select') {
      const stanceId = interaction.values?.[0];
      if (!stanceId) {
        await interaction.reply({ content: 'No stance selected.', ephemeral: true });
        return;
      }
      await this.handleCombatStanceSelect(interaction, player, stanceId);
      return;
    }

    if (customId === 'rpg-boss-style-select') {
      const selection = interaction.values?.[0];
      if (!selection || !selection.startsWith('boss-style-')) {
        await interaction.reply({ content: 'No style selected.', ephemeral: true });
        return;
      }
      const parts = selection.replace('boss-style-', '').split('-');
      const bossId = parts[0];
      const styleId = parts[1];
      await this.startBossFight(interaction, player, bossId, styleId);
      return;
    }

    if (customId === 'rpg-group-style-select') {
      const selection = interaction.values?.[0];
      if (!selection || !selection.startsWith('group-style-')) {
        await interaction.reply({ content: 'No style selected.', ephemeral: true });
        return;
      }
      const parts = selection.replace('group-style-', '').split('-');
      const groupId = parts[0];
      const styleId = parts[1];
      await this.startGroupFight(interaction, player, groupId, 1, styleId);
      return;
    }

    if (customId === 'rpg-dungeon-boss-style-select') {
      const styleId = interaction.values?.[0];
      if (!styleId) {
        await interaction.reply({ content: 'No style selected.', ephemeral: true });
        return;
      }
      
      // Try memory context first, then fall back to player data (survives bot restarts)
      let dungeonContext = this.dungeonBossContext?.get(interaction.user.id);
      if (!dungeonContext && player.pendingBossDungeon) {
        dungeonContext = player.pendingBossDungeon;
      }
      
      if (!dungeonContext) {
        await interaction.reply({ content: 'Dungeon context lost. Please try again.', ephemeral: true });
        return;
      }
      
      // Get dungeon data
      const dungeon = getAvailableDungeons(player.level, player.currentWorld)
        .find(d => d.id === dungeonContext.dungeonId);
      
      if (!dungeon) {
        await interaction.reply({ content: 'Dungeon not found!', ephemeral: true });
        return;
      }

      // Start the dungeon boss fight with stored boss data
      await this.startDungeonBossFight(interaction, player, dungeon, dungeonContext.bossData, styleId);
      
      // Clear the context from both places
      this.dungeonBossContext?.delete(interaction.user.id);
      delete player.pendingBossDungeon;
      this.persistPlayer(player);
      return;
    }

    if (customId === 'rpg-achievement-select') {
      const achievementId = interaction.values?.[0];
      if (!achievementId) {
        await interaction.reply({ content: 'No achievement selected.', ephemeral: true });
        return;
      }
      await this.handleAchievementDetail(interaction, player, achievementId);
      return;
    }

    if (customId === 'rpg-party-remove-select') {
      const indexValue = interaction.values?.[0];
      if (indexValue === undefined) {
        await interaction.reply({ content: 'No party member selected.', ephemeral: true });
        return;
      }
      await this.handlePartyRemoveSelect(interaction, player, Number(indexValue));
      return;
    }

    if (customId === 'rpg-party-active-select') {
      const indexValue = interaction.values?.[0];
      if (indexValue === undefined) {
        await interaction.reply({ content: 'No party member selected.', ephemeral: true });
        return;
      }
      await this.handlePartyActiveSelect(interaction, player, Number(indexValue));
      return;
    }

    if (customId === 'rpg-quest-view-detail') {
      const questId = interaction.values?.[0];
      if (!questId) {
        await interaction.reply({ content: 'No quest selected.', ephemeral: true });
        return;
      }
      await this.handleQuestDetail(interaction, player, questId);
      return;
    }

    if (customId === 'rpg-defense-quest-select') {
      const questId = interaction.values?.[0];
      if (!questId) {
        await interaction.reply({ content: 'No quest selected.', ephemeral: true });
        return;
      }
      await this.handleDefenseQuestComplete(interaction, player, questId);
    }

    if (customId === 'rpg-guild-claim-limited') {
      // Guild quests have been removed
      await interaction.update({ content: '‚ùå Guild quests have been removed from the system.', components: [], embeds: [] });
      return;
    }

    /**
     * QOL Select Menu Handlers
     */
    
    // Boss Guide Select
    if (customId === 'rpg-boss-guide-select') {
      const bossId = interaction.values?.[0];
      if (!bossId) {
        await interaction.reply({ content: 'No boss selected.', ephemeral: true });
        return;
      }
      
      const boss = getBossTemplate(bossId);
      
      if (!boss) {
        await interaction.reply({ content: '‚ùå Boss not found.', ephemeral: true });
        return;
      }

      const embed = new EmbedBuilder()
        .setColor(0xff0000)
        .setTitle(`üëπ **${boss.name} Guide**`)
        .setDescription(boss.description || 'A powerful boss')
        .addFields(
          { name: 'üí• Element', value: boss.element || 'Unknown', inline: true },
          { name: 'üõ°Ô∏è Weakness', value: boss.weakness || 'Unknown', inline: true },
          { name: 'üî• Resistance', value: boss.resistance || 'None', inline: true }
        );

      // Add phase information
      for (let phase = 1; phase <= 3; phase++) {
        const phaseInfo = phase === 1 ? boss.phase1 : phase === 2 ? boss.phase2 : boss.phase3;
        if (phaseInfo) {
          const abilities = phaseInfo.abilities ? phaseInfo.abilities.map(a => typeof a === 'string' ? `‚Ä¢ ${a}` : `‚Ä¢ ${a.name || 'Unknown'}`).join('\n') : 'No abilities';
          embed.addFields({
            name: `Phase ${phase} (${phaseInfo.trigger || 100}% HP)`,
            value: `${phaseInfo.description || 'Special phase'}\n${abilities}`,
            inline: false
          });
        }
      }
      
      const backButton = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-qol-boss-guide')
          .setLabel('Back to Boss List')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-hub')
          .setLabel('üè† Hub')
          .setStyle(ButtonStyle.Primary)
      );

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], components: [backButton], ephemeral: true });
      return;
    }

    // Equipment Comparison Select
    if (customId === 'rpg-equipment-compare-select') {
      const slot = interaction.values?.[0];
      if (!slot) {
        await interaction.reply({ content: 'No slot selected.', ephemeral: true });
        return;
      }

      const equipped = player.equipment?.[slot];
      if (!equipped) {
        await interaction.reply({ content: `No equipment in ${slot} slot.`, ephemeral: true });
        return;
      }

      const embed = new EmbedBuilder()
        .setColor(0x00ccff)
        .setTitle(`üîÑ **${slot.toUpperCase()} Comparison**`);

      // Show current equipment
      embed.addFields({
        name: `Currently Equipped: ${equipped.name || 'Unknown'}`,
        value: `
          **Stats:**
          ‚Ä¢ Damage: ${equipped.damage || 0}
          ‚Ä¢ Defense: ${equipped.defense || 0}
          ‚Ä¢ Intelligence: ${equipped.intelligence || 0}
          ‚Ä¢ Agility: ${equipped.agility || 0}
          **Rarity:** ${equipped.rarity || 'common'}
        `,
        inline: false
      });

      embed.addFields({
        name: 'Tip',
        value: 'Use your inventory to compare with items you own.',
        inline: false
      });

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
      return;
    }

    // Environment Advantage Tool Select
    if (customId === 'rpg-env-advantage-select') {
      const envId = interaction.values?.[0];
      if (!envId) {
        await interaction.reply({ content: 'No environment selected.', ephemeral: true });
        return;
      }

      const env = getEnvironment(envId);

      if (!env) {
        await interaction.reply({ content: '‚ùå Environment not found.', ephemeral: true });
        return;
      }

      const embed = new EmbedBuilder()
        .setColor(0x00ff00)
        .setTitle(`‚öîÔ∏è **${env.name} Advantage Analysis**`)
        .setDescription(env.description || 'A battle arena');

      if (env.effects && env.effects.length > 0) {
        const hazards = env.effects.filter(e => e.type === 'hazard');
        const buffs = env.effects.filter(e => e.type === 'buff');

        if (hazards.length > 0) {
          const hazardText = hazards.map(h => `‚Ä¢ ${h.name}: ${h.description} (${h.frequency}% chance)`).join('\n');
          embed.addFields({
            name: '‚ö†Ô∏è Environmental Hazards',
            value: hazardText,
            inline: false
          });
        }

        if (buffs.length > 0) {
          const buffText = buffs.map(b => `‚Ä¢ ${b.name}: ${b.description} (${b.frequency}% chance)`).join('\n');
          embed.addFields({
            name: '‚ú® Environmental Buffs',
            value: buffText,
            inline: false
          });
        }
      }

      embed.addFields({
        name: 'üí° Strategy Tip',
        value: 'Bring elements that counter the hazards and elements that benefit from the buffs!',
        inline: false
      });

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
      return;
    }

    // Equipment Builds - Load
    if (customId === 'rpg-builds-load-select') {
      const buildName = interaction.values?.[0];
      if (!buildName) {
        await interaction.reply({ content: 'No build selected.', ephemeral: true });
        return;
      }

      const result = this.equipmentBuilds.loadBuild(player.userId, buildName);
      if (!result.success) {
        await interaction.reply({ content: `‚ùå ${result.message}`, ephemeral: true });
        return;
      }

      // Equip all items from the build
      const build = result.build;
      Object.entries(build).forEach(([slot, item]) => {
        if (item) {
          if (!player.equipment) player.equipment = {};
          player.equipment[slot] = item;
        }
      });

      this.persistPlayer(player);

      const embed = new EmbedBuilder()
        .setColor(0x00ff00)
        .setTitle('‚úÖ **Build Loaded**')
        .setDescription(`Equipped build: **${buildName}**`);

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
      return;
    }

    // Equipment Builds - Delete
    if (customId === 'rpg-builds-delete-select') {
      const buildName = interaction.values?.[0];
      if (!buildName) {
        await interaction.reply({ content: 'No build selected.', ephemeral: true });
        return;
      }

      const result = this.equipmentBuilds.deleteBuild(player.userId, buildName);
      
      const embed = new EmbedBuilder()
        .setColor(result.success ? 0xff0000 : 0xff0000)
        .setTitle(result.success ? '‚úÖ **Build Deleted**' : '‚ùå **Error**')
        .setDescription(result.message);

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
      return;
    }

    /**
     * NEW REMAINING FEATURES SELECT HANDLERS
     */

    // Profession Efficiency Select
    if (customId === 'rpg-profession-tips-select') {
      const professionId = interaction.values?.[0];
      if (!professionId) {
        await interaction.reply({ content: 'No profession selected.', ephemeral: true });
        return;
      }

      const strategy = this.professionEfficiency.getStrategyForLevel(player.level, professionId);
      const profit = this.professionEfficiency.calculateOptimalProfit(professionId, player.level, 1);
      const nextGoal = this.professionEfficiency.getNextLevelGoal(professionId, player.level);

      const embed = new EmbedBuilder()
        .setColor(0x00aa00)
        .setTitle(`üí° **${professionId.charAt(0).toUpperCase() + professionId.slice(1)} Efficiency Guide**`)
        .setDescription(`Optimized strategies for level ${player.level}`);

      if (strategy) {
        embed.addFields({
          name: 'üìç Recommended Locations',
          value: strategy.locations?.join(', ') || 'N/A',
          inline: false
        }, {
          name: 'üí∞ Hourly Profit',
          value: `~${profit.hourlyRate} gold/hour`,
          inline: true
        }, {
          name: 'üìä Yield Rate',
          value: `${profit.yield} items/hour`,
          inline: true
        }, {
          name: 'üí° Tip',
          value: strategy.tip || 'Keep improving your skills!',
          inline: false
        });
      }

      if (nextGoal) {
        embed.addFields({
          name: 'üéØ Next Level Goal',
          value: `${nextGoal.requirement} ‚Üí ${nextGoal.reward}`,
          inline: false
        });
      }

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
      return;
    }

    // Environment Predictions Select
    if (customId === 'rpg-env-predict-select') {
      const envId = interaction.values?.[0];
      if (!envId) {
        await interaction.reply({ content: 'No environment selected.', ephemeral: true });
        return;
      }

      const prediction = this.environmentPredictions.predictEffects(envId);
      const safeStrat = this.environmentPredictions.getSafeStrategy(envId);

      const embed = new EmbedBuilder()
        .setColor(0x6600ff)
        .setTitle(`üîÆ **Environmental Prediction: ${prediction.environment}**`)
        .setDescription(prediction.prediction || 'No prediction available');

      if (prediction.hazards && prediction.hazards.length > 0) {
        const hazardText = prediction.hazards
          .map(h => `‚Ä¢ ${h.name}: ${h.chance}% chance (${h.damage} damage)`)
          .join('\n');
        embed.addFields({
          name: '‚ö†Ô∏è Hazards',
          value: hazardText,
          inline: false
        });
      }

      if (prediction.buffs && prediction.buffs.length > 0) {
        const buffText = prediction.buffs
          .map(b => `‚Ä¢ ${b.name}: ${b.chance}% chance (${b.effect})`)
          .join('\n');
        embed.addFields({
          name: '‚ú® Environmental Buffs',
          value: buffText,
          inline: false
        });
      }

      if (safeStrat && safeStrat.strategy) {
        embed.addFields({
          name: 'üõ°Ô∏è Safe Strategy',
          value: safeStrat.strategy,
          inline: false
        });
      }

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
      return;
    }

    // Theme Select
    if (customId === 'rpg-theme-select') {
      const themeId = interaction.values?.[0];
      if (!themeId) {
        await interaction.reply({ content: 'No theme selected.', ephemeral: true });
        return;
      }

      const result = this.uiThemeManager.setTheme(player.userId, themeId);

      if (result.success) {
        await interaction.reply({
          content: `‚úÖ ${result.message}`,
          ephemeral: true
        });
      } else {
        await interaction.reply({
          content: `‚ùå ${result.message}`,
          ephemeral: true
        });
      }
      return;
    }

    // Guild Leaderboard Sort Select
    if (customId === 'rpg-guild-leaderboard-sort') {
      const sortType = interaction.values?.[0];
      if (!sortType) {
        await interaction.reply({ content: 'No sort type selected.', ephemeral: true });
        return;
      }

      if (!player.guildId) {
        await interaction.reply({ content: '‚ùå You\'re not in a guild!', ephemeral: true });
        return;
      }

      const leaderboard = this.guildAnalytics.getLeaderboard(player.guildId, sortType);

      const embed = new EmbedBuilder()
        .setColor(0xffaa00)
        .setTitle(`üèÜ **Guild Leaderboard - Sorted by ${sortType.toUpperCase()}**`)
        .setDescription('Top members in your guild');

      leaderboard.slice(0, 10).forEach((member, index) => {
        const rank = index + 1;
        const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : 'üîπ';
        
        let statLine = '';
        if (sortType === 'level') {
          statLine = `L${member.level}`;
        } else if (sortType === 'damage') {
          statLine = `${member.totalDamage} DMG`;
        } else if (sortType === 'bosses') {
          statLine = `${member.bossesFelled} Bosses`;
        } else if (sortType === 'dungeons') {
          statLine = `${member.dungeonsClear} Dungeons`;
        } else {
          statLine = `L${member.level} | ${member.totalDamage} DMG`;
        }

        embed.addFields({
          name: `${medal} #${rank}`,
          value: statLine,
          inline: false
        });
      });

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
      return;
    }

    // Player Leaderboard Category Select
    if (customId === 'rpg-leaderboard-select') {
      const category = interaction.values?.[0];
      if (!category) {
        await interaction.reply({ content: 'No category selected.', ephemeral: true });
        return;
      }
      // For select menus, use update() not deferReply()
      await this.handleLeaderboardViewFromSelect(interaction, category);
      return;
    }

    // Progress Tab Leaderboard Category Select
    if (customId === 'rpg-progress-leaderboard-select') {
      const category = interaction.values?.[0];
      const player = this.playerManager.getPlayer(interaction.user.id);
      if (!category) {
        await interaction.reply({ content: 'No category selected.', ephemeral: true });
        return;
      }
      // For select menus, use update() not deferReply()
      await this.handleProgressLeaderboardView(interaction, player, category);
      return;
    }
  }

  /**
   * Handle modal submit interactions
   */
  async handleModalSubmit(interaction) {
    const customId = interaction.customId;
    const player = this.playerManager.getPlayer(interaction.user.id);

    if (!player) {
      await interaction.reply({
        content: 'You need to run /rpg first!',
        ephemeral: true,
      });
      return;
    }

    if (customId === 'rpg-bounty-create-modal') {
      const title = interaction.fields.getTextInputValue('bounty_title');
      const description = interaction.fields.getTextInputValue('bounty_description');
      const target = interaction.fields.getTextInputValue('bounty_target');
      const rewardStr = interaction.fields.getTextInputValue('bounty_reward');

      const reward = parseInt(rewardStr, 10);
      if (isNaN(reward) || reward < 10 || reward > 10000) {
        await interaction.reply({
          content: '‚ùå Reward must be between 10 and 10000 gold.',
          ephemeral: true,
        });
        return;
      }

      if (!title.trim() || !description.trim() || !target.trim()) {
        await interaction.reply({
          content: '‚ùå Please fill in all fields.',
          ephemeral: true,
        });
        return;
      }

      // Create the bounty
      try {
        const newBounty = createPlayerBounty(player.userId, {
          title: title.trim(),
          description: description.trim(),
          target: target.trim(),
          creatorName: player.username,
          worldId: player.currentWorld,
          rewards: {
            gold: reward,
          },
        });

        await interaction.reply({
          content: `‚úÖ **Bounty Created!**\n\n**${newBounty.title}**\nTarget: ${newBounty.target}\nReward: ${newBounty.rewards.gold}g`,
          ephemeral: false,
        });

        // Return to bounties list
        setTimeout(() => {
          this.handleGuildBounties(interaction, player);
        }, 500);
      } catch (error) {
        console.error('Error creating bounty:', error);
        await interaction.reply({
          content: '‚ùå Failed to create bounty. Please try again.',
          ephemeral: true,
        });
      }
      return;
    }

    if (customId === 'rpg-builds-save-modal') {
      const buildName = interaction.fields.getTextInputValue('build_name');

      if (!buildName.trim()) {
        await interaction.reply({
          content: '‚ùå Build name cannot be empty.',
          ephemeral: true
        });
        return;
      }

      const result = this.equipmentBuilds.saveBuild(player.userId, buildName.trim(), player.equipment || {});

      const embed = new EmbedBuilder()
        .setColor(result.success ? 0x00ff00 : 0xff0000)
        .setTitle(result.success ? '‚úÖ **Build Saved**' : '‚ùå **Error**')
        .setDescription(result.message);

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
      return;
    }

    if (customId.startsWith('rpg-market-list-')) {
      const itemId = customId.replace('rpg-market-list-', '');
      const priceStr = interaction.fields.getTextInputValue('item_price');
      const quantityStr = interaction.fields.getTextInputValue('item_quantity') || '1';

      const price = parseInt(priceStr, 10);
      const quantity = parseInt(quantityStr, 10);

      if (isNaN(price) || price < 1) {
        await interaction.reply({
          content: '‚ùå Price must be at least 1 gold.',
          ephemeral: true,
        });
        return;
      }

      if (isNaN(quantity) || quantity < 1) {
        await interaction.reply({
          content: '‚ùå Quantity must be at least 1.',
          ephemeral: true,
        });
        return;
      }

      await this.handleMarketCreateListing(interaction, player, itemId, price, quantity);
      return;
    }

    if (customId === 'rpg-save-set-modal') {
      const setName = interaction.fields.getTextInputValue('set-name');
      
      if (!setName || setName.trim().length === 0) {
        await interaction.reply({
          content: '‚ùå Please provide a valid set name.',
          ephemeral: true,
        });
        return;
      }

      // Save the current equipment as a new set
      if (!player.equipmentSets) {
        player.equipmentSets = [];
      }

      // Check if set with same name exists
      const existingIndex = player.equipmentSets.findIndex(s => s.name === setName.trim());
      
      const newSet = {
        name: setName.trim(),
        items: { ...(player.equippedItems || {}) },
        savedAt: Date.now(),
      };

      if (existingIndex >= 0) {
        // Update existing set
        player.equipmentSets[existingIndex] = newSet;
        await interaction.reply({
          content: `‚úÖ Updated equipment set: **${setName.trim()}**`,
          ephemeral: true,
        });
      } else {
        // Add new set
        player.equipmentSets.push(newSet);
        await interaction.reply({
          content: `‚úÖ Saved new equipment set: **${setName.trim()}**`,
          ephemeral: true,
        });
      }

      this.persistPlayer(player);

      // Show the updated equipment sets view
      await this.handleEquipmentSets(interaction, player);
      return;
    }

    if (customId === 'rpg-party-add-modal') {
      const memberName = interaction.fields.getTextInputValue('member-name');
      const memberClass = interaction.fields.getTextInputValue('member-class');

      if (!memberName || memberName.trim().length === 0) {
        await interaction.reply({ content: '‚ùå Please provide a valid member name.', ephemeral: true });
        return;
      }

      if (!player.party) {
        player.party = { maxSize: 4, activeIndex: 0, members: [] };
      }

      if ((player.party.members?.length || 0) >= (player.party.maxSize || 4)) {
        await interaction.reply({ content: 'Party is full (max 4).', ephemeral: true });
        return;
      }

      player.party.members.push({
        userId: null,
        name: memberName.trim(),
        classId: memberClass?.trim() || null,
        role: 'member',
      });

      this.persistPlayer(player);
      await interaction.reply({ content: `‚úÖ Added ${memberName.trim()} to the party.`, ephemeral: true });
      await this.handlePartyMenu(interaction, player);
      return;
    }

    if (customId === 'rpg-slots-custom-modal') {
      const amountStr = interaction.fields.getTextInputValue('amount');
      const amount = parseInt(amountStr, 10);
      const playerGold = player.gold || 0;

      if (isNaN(amount) || amount < 1) {
        await interaction.reply({
          content: '‚ùå Please enter a valid amount (minimum 1 gold).',
          ephemeral: true,
        });
        return;
      }

      if (amount > playerGold) {
        await interaction.reply({
          content: `‚ùå You don't have enough gold! You have ${playerGold}, but tried to bet ${amount}.`,
          ephemeral: true,
        });
        return;
      }

      if (amount > 100000) {
        await interaction.reply({
          content: '‚ùå Maximum bet is 100,000 gold.',
          ephemeral: true,
        });
        return;
      }

      await this.playSlots(interaction, player, amount);
      return;
    }

    if (customId === 'rpg-guild-create-modal') {
      const guildName = interaction.fields.getTextInputValue('guild_name');
      const guildTag = interaction.fields.getTextInputValue('guild_tag');
      const guildDescription = interaction.fields.getTextInputValue('guild_description') || '';

      const creationCost = 10000;
      if ((player.gold || 0) < creationCost) {
        await interaction.reply({
          content: `‚ùå You need ${creationCost} gold to create a guild!`,
          ephemeral: true,
        });
        return;
      }

      const result = this.guildManager.createGuild(
        player.userId,
        guildName.trim(),
        guildTag.trim().toUpperCase(),
        guildDescription.trim(),
        { isPublic: true, minLevel: 1 }
      );

      if (!result.success) {
        await interaction.reply({
          content: `‚ùå ${result.error}`,
          ephemeral: true,
        });
        return;
      }

      // Deduct gold
      player.gold -= creationCost;
      this.trackGoldSpent(player, creationCost, 'guild');
      this.persistPlayer(player);

      await interaction.reply({
        content: `‚úÖ **Guild Created!**\n\nüè∞ **[${result.guild.tag}] ${result.guild.name}**\n\nYou are now the guild leader. Invite members and start your adventure!`,
        ephemeral: true,
      });

      setTimeout(() => {
        interaction.deleteReply().catch(() => {});
      }, 5000);

      // Show guild dashboard
      setTimeout(() => {
        this.handleGuild(interaction, player);
      }, 1000);
      return;
    }

    if (customId === 'rpg-guild-donate-modal') {
      const amountStr = interaction.fields.getTextInputValue('amount');
      const amount = parseInt(amountStr, 10);

      if (isNaN(amount) || amount < 1) {
        await interaction.reply({
          content: '‚ùå Please enter a valid amount (minimum 1 gold).',
          ephemeral: true,
        });
        return;
      }

      if ((player.gold || 0) < amount) {
        await interaction.reply({
          content: `‚ùå You don't have enough gold! You have ${player.gold}, but tried to donate ${amount}.`,
          ephemeral: true,
        });
        return;
      }

      const guild = this.guildManager.getPlayerGuild(player.userId);
      if (!guild) {
        await interaction.reply({
          content: '‚ùå You are not in a guild!',
          ephemeral: true,
        });
        return;
      }

      const result = this.guildManager.contributeGold(guild.id, player.userId, amount);
      if (!result.success) {
        await interaction.reply({
          content: `‚ùå ${result.error}`,
          ephemeral: true,
        });
        return;
      }

      player.gold -= amount;
      this.trackGoldSpent(player, amount, 'guild');
      this.persistPlayer(player);

      await interaction.reply({
        content: `‚úÖ Donated **${amount}** gold to the guild treasury!`,
        ephemeral: true,
      });

      setTimeout(() => {
        interaction.deleteReply().catch(() => {});
      }, 5000);

      // Show guild dashboard
      setTimeout(() => {
        this.handleGuild(interaction, player);
      }, 500);
      return;
    }

    if (customId === 'rpg-guild-minlevel-modal') {
      const minLevelStr = interaction.fields.getTextInputValue('min_level');
      const minLevel = parseInt(minLevelStr, 10);

      if (isNaN(minLevel) || minLevel < 1 || minLevel > 100) {
        await interaction.reply({
          content: '‚ùå Minimum level must be between 1 and 100.',
          ephemeral: true,
        });
        return;
      }

      const guild = this.guildManager.getPlayerGuild(player.userId);
      if (!guild) {
        await interaction.reply({
          content: '‚ùå You are not in a guild!',
          ephemeral: true,
        });
        return;
      }

      const member = guild.members[player.userId];
      if (member.role !== 'leader') {
        await interaction.reply({
          content: '‚ùå Only the guild leader can change settings!',
          ephemeral: true,
        });
        return;
      }

      guild.settings.minLevel = minLevel;
      this.guildManager.save();

      await interaction.reply({
        content: `‚úÖ Minimum level requirement set to **${minLevel}**!`,
        ephemeral: true,
      });

      // Refresh settings view
      setTimeout(() => {
        this.handleGuildSettings(interaction, player);
      }, 1000);
      return;
    }
  }

  /**
   * Handle stats button
   */
  async handleStats(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'stats');
    }
    const embed = UIBuilder.createPlayerStatsEmbed(player);
    const backTarget = (result.meta?.worldQuest || result.meta?.defenseQuest) ? 'rpg-quest-back' : 'rpg-back';
    const backLabel = backTarget === 'rpg-quest-back' ? '‚Üê Back to Quests' : '‚Üê Back';
    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(backTarget)
        .setLabel(backLabel)
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Helper function to filter out quests that are part of chains (child quests)
   * Only returns starting quests and standalone quests
   */
  /**
   * Get all quest chain parent IDs and build quest hierarchy
   */
  buildQuestHierarchy(quests) {
    if (!Array.isArray(quests) || quests.length === 0) return { roots: [], childToParent: new Map() };
    
    const questIds = new Set(quests.map(quest => quest.id));
    const childToParent = new Map();
    
    quests.forEach(quest => {
      // Map direct nextQuestId (linear chain progression)
      if (quest.nextQuestId) {
        childToParent.set(quest.nextQuestId, quest.id);
      }
      
      // Map branch quest IDs to their parent (choice-based progression)
      if (Array.isArray(quest.branches)) {
        quest.branches.forEach(branch => {
          if (branch.nextQuestId) {
            childToParent.set(branch.nextQuestId, quest.id);
          }
        });
      }
    });

    // Infer chain links from quest ID patterns when explicit links are missing
    quests.forEach(quest => {
      const id = quest.id;
      if (!id || childToParent.has(id)) return;

      const stepMatch = id.match(/^(.*)_step(\d+)$/);
      if (stepMatch) {
        const baseId = stepMatch[1];
        const stepNumber = Number(stepMatch[2]);
        const previousStepId = `${baseId}_step${stepNumber - 1}`;
        if (stepNumber > 1 && questIds.has(previousStepId)) {
          childToParent.set(id, previousStepId);
          return;
        }
        if (questIds.has(baseId)) {
          childToParent.set(id, baseId);
          return;
        }
      }

      const choiceMatch = id.match(/^(.*)_choice$/);
      if (choiceMatch) {
        const baseId = choiceMatch[1];
        let highestStep = null;
        let highestStepNumber = 0;
        for (const candidateId of questIds) {
          const candidateMatch = candidateId.match(new RegExp(`^${baseId.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}_step(\\d+)$`));
          if (!candidateMatch) continue;
          const candidateStepNumber = Number(candidateMatch[1]);
          if (candidateStepNumber > highestStepNumber) {
            highestStep = candidateId;
            highestStepNumber = candidateStepNumber;
          }
        }
        if (highestStep) {
          childToParent.set(id, highestStep);
          return;
        }
        if (questIds.has(baseId)) {
          childToParent.set(id, baseId);
          return;
        }
      }

      const branchMatch = id.match(/^(.*\d+)([a-z])$/i);
      if (branchMatch) {
        const baseId = branchMatch[1];
        const choiceId = `${baseId}_choice`;
        if (questIds.has(choiceId)) {
          childToParent.set(id, choiceId);
          return;
        }
        if (questIds.has(baseId)) {
          childToParent.set(id, baseId);
        }
      }
    });
    
    // Find root quests (ones that don't have a parent)
    const roots = quests.filter(quest => !childToParent.has(quest.id));
    
    return { roots, childToParent };
  }

  filterStartingQuests(quests) {
    if (!Array.isArray(quests) || quests.length === 0) return [];
    
    // Use quest hierarchy - include root quests (chains start) and standalone quests
    const { roots } = this.buildQuestHierarchy(quests);
    return roots;
  }

  inferNextQuestInChain(currentQuest, allQuests) {
    if (!currentQuest || !Array.isArray(allQuests) || allQuests.length === 0) return null;

    const questById = new Map(allQuests.map(quest => [quest.id, quest]));

    if (currentQuest.nextQuestId && questById.has(currentQuest.nextQuestId)) {
      return questById.get(currentQuest.nextQuestId);
    }

    const currentId = currentQuest.id || '';
    const stepMatch = currentId.match(/^(.*)_step(\d+)$/);
    if (stepMatch) {
      const baseId = stepMatch[1];
      const stepNumber = Number(stepMatch[2]);
      const nextStepId = `${baseId}_step${stepNumber + 1}`;
      if (questById.has(nextStepId)) return questById.get(nextStepId);

      const choiceId = `${baseId}_choice`;
      if (questById.has(choiceId)) return questById.get(choiceId);
      return null;
    }

    if (!currentId.endsWith('_choice')) {
      const step1Id = `${currentId}_step1`;
      if (questById.has(step1Id)) return questById.get(step1Id);

      const choiceId = `${currentId}_choice`;
      if (questById.has(choiceId)) return questById.get(choiceId);
    }

    return null;
  }

  /**
   * Handle quests button
   */
  async handleQuests(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'quests');
    }
    player.questTab = player.questTab || 'side'; // Default to side quests
    
    const { main, side, daily } = getQuestCategoriesByWorld(player.currentWorld);
    const weekly = getWeeklyQuests(player) || [];
    const allDefense = loadDefenseQuests();
    const playerLevel = player.level;

    // Get quests for current tab (filter out abandoned and completed quests)
    let currentQuests = [];
    let tabLabel = 'Side Quests';
    
    if (player.questTab === 'side') {
      // Filter to show only starting quests (not intermediate steps or choice branches)
      const startingQuests = this.filterStartingQuests(side || []);
      currentQuests = startingQuests.filter(q => !player.hasQuestFlag(`${q.id}_abandoned`));
      tabLabel = 'Side Quests';
    } else if (player.questTab === 'daily') {
      currentQuests = (daily || []).filter(q => !player.hasQuestFlag(`${q.id}_abandoned`));
      tabLabel = 'Daily Quests';
    } else if (player.questTab === 'weekly') {
      currentQuests = weekly;
      tabLabel = 'Weekly Quests';
    } else if (player.questTab === 'defense') {
      currentQuests = allDefense;
      tabLabel = 'Town Defence Quests';
    }

    const completedCount = currentQuests.filter(q => player.hasQuestFlag(q.id)).length;
    const totalCount = currentQuests.length;

    // Create embed for current tab
    let description = `**${tabLabel}**\n`;
    if (totalCount > 0) {
      description += `Progress: ${completedCount}/${totalCount} completed\n`;
    }

    if (player.questTab === 'daily') {
      description += '‚è±Ô∏è Daily quests reset every 24h.\n';
    }
    if (player.questTab === 'weekly') {
      description += 'üìÜ Weekly quests reset on Sunday.\n';
    }

    description += '\n';
    if (currentQuests.length > 0) {
      const sortedQuests = [...currentQuests].sort((a, b) => (a.minLevel || 1) - (b.minLevel || 1));
      description += sortedQuests.map((q, idx) => {
        const questName = q.name || q.title || `Quest ${idx + 1}`;
        const isCompleted = player.hasQuestFlag(q.id);
        const icon = isCompleted ? '‚úÖ' : 'üìã';
        const warning = q.minLevel > playerLevel ? ' ‚ö†Ô∏è' : '';
        return `${idx + 1}. **${questName}** ${icon} (Lvl ${q.minLevel || 1}${warning})`;
      }).join('\n');
    } else {
      description += 'No quests in this category.';
    }

    const embed = new EmbedBuilder()
      .setColor(0x00aa00)
      .setTitle('üìú Quests')
      .setDescription(description)
      .setTimestamp();

    const components = [];

    // Tab buttons - Only Side Quests
    const tabButtons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-quest-tab-side')
        .setLabel('Side Quests')
        .setStyle(ButtonStyle.Primary)
    );
    components.push(tabButtons);

    // Quest selector for current tab (only active quests, sorted by level)
    if (currentQuests.length > 0) {
      const selectorQuests = currentQuests
        .filter(q => !player.hasQuestFlag(q.id)) // Hide completed quests from selector
        .sort((a, b) => (a.minLevel || 1) - (b.minLevel || 1)); // Sort by level: lowest to highest
      
      if (selectorQuests.length > 0) {
        const options = selectorQuests.slice(0, 25).map(q => ({
          label: (q.name || q.title || 'Quest').slice(0, 100),
          value: q.id,
          description: `Lvl ${q.minLevel || 1}${(q.minLevel || 1) > playerLevel ? ' ‚ö†Ô∏è' : ''}`.slice(0, 100),
        }));

        const selectMenu = new ActionRowBuilder().addComponents(
          new StringSelectMenuBuilder()
            .setCustomId('rpg-quest-view-detail')
            .setPlaceholder('Select a quest to view details')
            .addOptions(options)
        );
        components.push(selectMenu);
      }
    }

    // Back button
    const backButtons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );
    components.push(backButtons);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Handle quest detail view and start quest
   */
  async handleQuestDetail(interaction, player, questId) {
    // Find the quest
    const { main, side, daily } = getQuestCategoriesByWorld(player.currentWorld);
    const weekly = getWeeklyQuests(player) || [];
    const allDefense = loadDefenseQuests();
    
    let quest = null;
    let questType = null;
    
    const allQuests = [
      ...((main || []).map(q => ({ ...q, type: 'main' }))),
      ...((side || []).map(q => ({ ...q, type: 'side' }))),
      ...((daily || []).map(q => ({ ...q, type: 'daily' }))),
      ...((weekly || []).map(q => ({ ...q, type: 'weekly' }))),
      ...(allDefense.map(q => ({ ...q, type: 'defense' })))
    ];
    
    for (const q of allQuests) {
      if (q.id === questId) {
        quest = q;
        questType = q.type;
        break;
      }
    }

    if (!quest) {
      await interaction.reply({ content: 'Quest not found.', ephemeral: true });
      return;
    }

    const questName = quest.name || quest.title || 'Quest';
    const hasStepChainStart = allQuests.some(q => q.id === `${questId}_step1`);
    
    // Check if this is a quest chain (has branches)
    const hasChain = Array.isArray(quest.branches) && quest.branches.length > 0 && !hasStepChainStart;
    
    if (hasChain) {
      // Show quest chain options
      const embed = new EmbedBuilder()
        .setColor(0x5865f2)
        .setTitle(`üìù ${questName} - Quest Line`)
        .setDescription(quest.description || 'No description');

      // Add quest chain info
      let chainInfo = `This quest line has **${quest.branches.length}** paths:\n\n`;
      quest.branches.forEach((branch, idx) => {
        chainInfo += `**Path ${idx + 1}: ${branch.choice}**\n`;
      });
      embed.addFields({
        name: 'Available Paths',
        value: chainInfo,
        inline: false,
      });

      embed.addFields({
        name: 'Recommended Level',
        value: String(quest.minLevel || 1),
        inline: true,
      });

      if (quest.reward) {
        let rewardText = `${quest.reward.xp} XP, ${quest.reward.gold} Gold`;
        if (quest.reward.items && quest.reward.items.length > 0) {
          rewardText += ', Items';
        }
        embed.addFields({
          name: 'Rewards',
          value: rewardText,
          inline: true,
        });
      }

      const components = [];

      // Show path choices directly for chain quests (only if not started)
      const isQuestStarted = player.questFlags?.[questId]?.started;
      const isQuestAbandoned = player.questFlags?.[questId]?._abandoned;
      
      if (!isQuestStarted && !isQuestAbandoned) {
        const choiceButtons = quest.branches.slice(0, 5).map((branch, idx) =>
          new ButtonBuilder()
            .setCustomId(`rpg-quest-chain-choice-${questId}-${idx}`)
            .setLabel((branch.choice || `Path ${idx + 1}`).slice(0, 80))
            .setStyle(ButtonStyle.Primary)
        );

        for (let i = 0; i < choiceButtons.length; i += 5) {
          components.push(new ActionRowBuilder().addComponents(choiceButtons.slice(i, i + 5)));
        }
      }

      // Back button
      const backButton = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-quest-back')
          .setLabel('‚Üê Back to Quests')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-hub')
          .setLabel('üè† Hub')
          .setStyle(ButtonStyle.Primary)
      );
      components.push(backButton);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components,
      });
    } else {
      // Regular single quest or child quest - check if has prerequisite
      const { roots, childToParent } = this.buildQuestHierarchy(
        questType === 'side' ? (side || []) : []
      );
      
      const parentQuestId = childToParent.get(questId);
      const parentQuest = parentQuestId ? allQuests.find(q => q.id === parentQuestId) : null;
      
      let prerequisiteWarning = '';
      if (parentQuest) {
        const parentCompleted = player.questFlags?.[parentQuestId];
        if (!parentCompleted) {
          prerequisiteWarning = `‚ö†Ô∏è **Prerequisite:** Must complete **${parentQuest.name}** first!\n\n`;
        }
      }

      const embed = new EmbedBuilder()
        .setColor(0x5865f2)
        .setTitle(`üìù ${questName}`)
        .setDescription((prerequisiteWarning || '') + (quest.description || 'No description'));

      // Add details based on type
      if (questType === 'defense' && quest.type === 'combat') {
        embed.addFields({
          name: 'Enemy',
          value: `${quest.enemy.name} (Lvl ${quest.enemy.level})`,
          inline: false,
        });
      }

      if (quest.objectives && quest.objectives.length > 0) {
        embed.addFields({
          name: 'Objectives',
          value: quest.objectives.map(o => `‚Ä¢ ${o}`).join('\n'),
          inline: false,
        });
      }

      embed.addFields({
        name: 'Recommended Level',
        value: String(quest.minLevel || 1),
        inline: true,
      });

      if (quest.reward) {
        let rewardText = `${quest.reward.xp} XP, ${quest.reward.gold} Gold`;
        if (quest.reward.unlockClass) {
          rewardText += ', üéì Class Unlock';
        }
        embed.addFields({
          name: 'Rewards',
          value: rewardText,
          inline: true,
        });
      }

      const components = [];

      // Start button (show for all quest types except already started/abandoned, and check prerequisites)
      const isQuestStarted = player.questFlags?.[questId]?.started;
      const isQuestAbandoned = player.questFlags?.[questId]?._abandoned;
      const canStart = !isQuestStarted && !isQuestAbandoned && (!parentQuest || player.questFlags?.[parentQuestId]);
      
      if (!isQuestStarted && !isQuestAbandoned) {
        const startButton = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-quest-start-${questId}`)
            .setLabel('‚öîÔ∏è Start Quest')
            .setStyle(ButtonStyle.Primary)
            .setDisabled(!canStart)
        );
        components.push(startButton);
      }

      // Back button
      const backButton = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-quest-back')
          .setLabel('‚Üê Back to Quests')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-hub')
          .setLabel('üè† Hub')
          .setStyle(ButtonStyle.Primary)
      );
      components.push(backButton);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components,
      });
    }
  }

  /**
   * Handle inventory button
   */
  async handleInventory(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'inventory');
    }
    // Organize items by type (focus on materials and consumables)
    const organized = {
      material: [],
      consumable: [],
      enchant: [],
      quest: [],
      other: [],
    };

    for (const item of player.inventory) {
      if (!item || typeof item === 'string') continue;
      // Skip equipment - that's in Equipment tab now
      if (item.type === 'equipment') continue;
      
      const type = item.type || 'other';
      let bin = organized[type];
      if (!bin) bin = organized.other;
      bin.push(item);
    }

    // Count equipment for reference
    const equipmentCount = player.inventory.filter(item => 
      item && typeof item === 'object' && item.type === 'equipment'
    ).length;
    const lootboxCount = player.inventory
      .filter(item => item && typeof item === 'object' && item.type === 'consumable' && item.subtype === 'lootbox')
      .reduce((sum, item) => sum + (item.quantity || 1), 0);

    // Build formatted strings for each category
    const formatItems = (items) => {
      if (items.length === 0) return 'None';
      return items
        .map(item => {
          const qty = item.quantity > 1 ? ` x${item.quantity}` : '';
          return `‚Ä¢ ${item.name}${qty}`;
        })
        .join('\n');
    };

    const embed = new EmbedBuilder()
      .setColor(0x00aa00)
      .setTitle('üéí Inventory')
      .setDescription(
        '**Current Items Summary:**\n' +
        `‚Ä¢ Total items: ${player.inventory.length}\n` +
        `‚Ä¢ Equipment: ${equipmentCount} (view in ‚öôÔ∏è Equipment tab)\n` +
        `‚Ä¢ Materials: ${organized.material.length}\n` +
        `‚Ä¢ Consumables: ${organized.consumable.length}\n` +
        `‚Ä¢ Lootboxes: ${lootboxCount}\n` +
        `‚Ä¢ Enchants: ${organized.enchant.length}\n` +
        `‚Ä¢ Quest Items: ${organized.quest.length}`
      );

    // Primary filter row - Item Type filters
    const typeFilterRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-filter-all')
        .setLabel('üìã All Items')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-filter-materials')
        .setLabel(`üîß Materials (${organized.material.length})`)
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(organized.material.length === 0),
      new ButtonBuilder()
        .setCustomId('rpg-filter-consumables')
        .setLabel(`üß™ Consumables (${organized.consumable.length})`)
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(organized.consumable.length === 0),
      new ButtonBuilder()
        .setCustomId('rpg-filter-enchants')
        .setLabel(`‚ú® Enchants (${organized.enchant.length})`)
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(organized.enchant.length === 0)
    );

    // Actions and navigation row
    const actionsRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-use-potion')
        .setLabel('üíä Use Potion')
        .setStyle(ButtonStyle.Success)
        .setDisabled(organized.consumable.length === 0),
      new ButtonBuilder()
        .setCustomId('rpg-open-lootbox')
        .setLabel(`üéÅ Open Lootbox (${lootboxCount})`)
        .setStyle(ButtonStyle.Primary)
        .setDisabled(lootboxCount === 0),
      new ButtonBuilder()
        .setCustomId('rpg-equipment')
        .setLabel('‚öôÔ∏è View Equipment')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    // Rarity filter - Select menu
    const raritySelectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-inventory-rarity-select')
        .setPlaceholder('üé® Filter by Rarity')
        .addOptions(
          { label: '‚ö™ Common', value: 'common', description: 'Filter common items' },
          { label: 'üü¢ Uncommon', value: 'uncommon', description: 'Filter uncommon items' },
          { label: 'üîµ Rare', value: 'rare', description: 'Filter rare items' },
          { label: 'üü£ Epic', value: 'epic', description: 'Filter epic items' }
        )
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [typeFilterRow, actionsRow, raritySelectRow],
    });
  }

  /**
   * Handle inventory filter - show only specific item types
   */
  async handleInventoryFilter(interaction, player, filterType) {
    this.trackMenuNavigation(player, 'inventory');
    
    const filtered = player.inventory.filter(item => {
      if (!item || typeof item === 'string') return false;
      return item.type === filterType;
    });

    // Sort consumables by rarity (highest to lowest)
    if (filterType === 'consumable') {
      const rarityOrder = { 'legendary': 4, 'epic': 3, 'rare': 2, 'uncommon': 1, 'basic': 0 };
      
      filtered.sort((a, b) => {
        // Get rarity from the item rarity property or parse from name
        const getRarity = (item) => {
          if (item.rarity) return item.rarity.toLowerCase();
          const rarities = ['legendary', 'epic', 'rare', 'uncommon', 'basic'];
          for (const rarity of rarities) {
            if (item.name.toLowerCase().includes(rarity)) return rarity;
          }
          return 'basic';
        };
        
        const rarityA = getRarity(a);
        const rarityB = getRarity(b);
        return (rarityOrder[rarityB] || 0) - (rarityOrder[rarityA] || 0);
      });
    }

    const formatItems = (items) => {
      if (items.length === 0) return 'None';
      return items
        .map(item => {
          const qty = item.quantity > 1 ? ` x${item.quantity}` : '';
          const rarity = item.rarity ? ` [${item.rarity}]` : '';
          return `‚Ä¢ ${item.name}${qty}${rarity}`;
        })
        .join('\n');
    };

    const typeNames = {
      material: 'üîß Crafting Materials',
      consumable: 'üß™ Consumables',
      enchant: '‚ú® Enchants',
      quest: 'üìú Quest Items',
    };

    const typeEmojis = {
      material: 'üîß',
      consumable: 'üß™',
      enchant: '‚ú®',
      quest: 'üìú',
    };

    const embed = new EmbedBuilder()
      .setColor(0x00aa00)
      .setTitle(`üéí ${typeNames[filterType] || filterType}`)
      .setDescription(
        `**Current Filter:** ${typeEmojis[filterType]} ${typeNames[filterType]}\n` +
        `**Items:** ${filtered.length}/${player.inventory.filter(i => i && typeof i === 'object' && i.type !== 'equipment').length}\n\n` +
        `Showing all ${filterType}(s) in your inventory.`
      );

    if (filtered.length > 0) {
      // Show all items in chunks
      const chunkSize = 30;
      for (let i = 0; i < Math.min(filtered.length, 90); i += chunkSize) {
        const chunk = filtered.slice(i, i + chunkSize);
        const title = i === 0 ? `${typeNames[filterType]} (Page 1)` : `${typeNames[filterType]} (Page ${Math.ceil(i / chunkSize) + 1})`;
        embed.addFields({
          name: title,
          value: formatItems(chunk),
          inline: false,
        });
      }
      
      if (filtered.length > 90) {
        embed.addFields({
          name: '...',
          value: `And ${filtered.length - 90} more items (showing first 90)`,
          inline: false,
        });
      }
    } else {
      embed.addFields({
        name: 'Empty',
        value: `You don't have any ${filterType}s.`,
        inline: false,
      });
    }

    // Type filter row - show current selection
    const filterRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-filter-all')
        .setLabel('üìã All Items')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-filter-materials')
        .setLabel('üîß Materials')
        .setStyle(filterType === 'material' ? ButtonStyle.Primary : ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-filter-consumables')
        .setLabel('üß™ Consumables')
        .setStyle(filterType === 'consumable' ? ButtonStyle.Primary : ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-filter-enchants')
        .setLabel('‚ú® Enchants')
        .setStyle(filterType === 'enchant' ? ButtonStyle.Primary : ButtonStyle.Secondary)
    );

    // Rarity filter - Select menu
    const rarityFilterRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-inventory-rarity-select')
        .setPlaceholder('üé® Filter by Rarity')
        .addOptions(
          { label: '‚ö™ Common', value: 'common', description: 'Filter common items' },
          { label: 'üü¢ Uncommon', value: 'uncommon', description: 'Filter uncommon items' },
          { label: 'üîµ Rare', value: 'rare', description: 'Filter rare items' },
          { label: 'üü£ Epic', value: 'epic', description: 'Filter epic items' }
        )
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-inventory')
        .setLabel('üìñ Back to Guide')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-equipment')
        .setLabel('‚öôÔ∏è View Equipment')
        .setStyle(ButtonStyle.Primary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [filterRow, rarityFilterRow, backRow],
    });
  }

  /**
   * Helper function to get item profession/material type
   */
  getItemProfessionType(item) {
    if (!item) return null;
    
    // Check by profession crafting materials
    const professionMaterials = {
      blacksmith: ['iron_ore', 'coal', 'copper_ore', 'leather', 'mithril_ore', 'adamantite', 'steel', 'granite', 'dragonhide'],
      botanic: ['herb', 'rare_flower', 'water', 'moonflower', 'blaze_flower', 'mystic_bark', 'arcane_essence'],
      enchanter: ['mana_crystal', 'mithril_ore', 'arcane_essence', 'adamantite'],
    };

    const itemId = (item.id || '').toLowerCase();
    for (const [profession, materials] of Object.entries(professionMaterials)) {
      if (materials.some(mat => itemId.includes(mat))) {
        return profession;
      }
    }
    return null;
  }

  /**
   * Handle inventory filter by rarity
   */
  async handleInventoryFilterByRarity(interaction, player, rarity) {
    this.trackMenuNavigation(player, 'inventory-rarity-filter');
    
    const filtered = player.inventory.filter(item => {
      if (!item || typeof item === 'string' || item.type === 'equipment') return false;
      return (item.rarity || 'common').toLowerCase() === rarity.toLowerCase();
    });

    const rarityEmojis = {
      common: '‚ö™',
      uncommon: 'üü¢',
      rare: 'üîµ',
      epic: 'üü£',
      legendary: 'üü°',
    };

    const rarityNames = {
      common: 'Common',
      uncommon: 'Uncommon',
      rare: 'Rare',
      epic: 'Epic',
      legendary: 'Legendary',
    };

    const formatItems = (items) => {
      if (items.length === 0) return 'None';
      return items
        .map(item => {
          const qty = item.quantity > 1 ? ` x${item.quantity}` : '';
          const type = item.type ? ` [${item.type}]` : '';
          return `‚Ä¢ ${item.name}${qty}${type}`;
        })
        .join('\n');
    };

    const embed = new EmbedBuilder()
      .setColor(0x00aa00)
      .setTitle(`${rarityEmojis[rarity]} ${rarityNames[rarity]} Items`)
      .setDescription(
        `**Current Filter:** ${rarityEmojis[rarity]} ${rarityNames[rarity]}\n` +
        `**Items Found:** ${filtered.length}\n\n` +
        `Showing all ${rarity} rarity items in your inventory.`
      );

    if (filtered.length > 0) {
      const chunkSize = 25;
      for (let i = 0; i < Math.min(filtered.length, 75); i += chunkSize) {
        const chunk = filtered.slice(i, i + chunkSize);
        const title = i === 0 ? `${rarityNames[rarity]} Items (Page 1)` : `${rarityNames[rarity]} Items (Page ${Math.ceil(i / chunkSize) + 1})`;
        embed.addFields({
          name: title,
          value: formatItems(chunk),
          inline: false,
        });
      }
      
      if (filtered.length > 75) {
        embed.addFields({
          name: '...',
          value: `And ${filtered.length - 75} more items (showing first 75)`,
          inline: false,
        });
      }
    } else {
      embed.addFields({
        name: 'No Items',
        value: `You don't have any ${rarity} items.`,
        inline: false,
      });
    }

    const rarityFilterRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-inventory-rarity-select')
        .setPlaceholder(`üé® Current: ${rarityNames[rarity]}`)
        .addOptions(
          { label: '‚ö™ Common', value: 'common', description: 'Filter common items', default: rarity === 'common' },
          { label: 'üü¢ Uncommon', value: 'uncommon', description: 'Filter uncommon items', default: rarity === 'uncommon' },
          { label: 'üîµ Rare', value: 'rare', description: 'Filter rare items', default: rarity === 'rare' },
          { label: 'üü£ Epic', value: 'epic', description: 'Filter epic items', default: rarity === 'epic' }
        )
    );

    const typeFilterRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-filter-all')
        .setLabel('üìã All Items')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-filter-materials')
        .setLabel('üîß Materials')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-filter-consumables')
        .setLabel('üß™ Consumables')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-inventory')
        .setLabel('üìñ Back to Guide')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [rarityFilterRow, typeFilterRow],
    });
  }

  /**
   * Handle inventory filter by profession/crafting type
   */
  async handleInventoryFilterByProfession(interaction, player, profession) {
    this.trackMenuNavigation(player, 'inventory-profession-filter');
    
    const filtered = player.inventory.filter(item => {
      if (!item || typeof item === 'string' || item.type === 'equipment') return false;
      const profType = this.getItemProfessionType(item);
      return profType === profession;
    });

    const professionIcons = {
      blacksmith: 'üõ†Ô∏è',
      botanic: 'üåø',
      enchanter: '‚ú®',
    };

    const professionNames = {
      blacksmith: 'Blacksmith',
      botanic: 'Botanic',
      enchanter: 'Enchanter',
    };

    const formatItems = (items) => {
      if (items.length === 0) return 'None';
      return items
        .map(item => {
          const qty = item.quantity > 1 ? ` x${item.quantity}` : '';
          const rarity = item.rarity ? ` [${item.rarity}]` : '';
          return `‚Ä¢ ${item.name}${qty}${rarity}`;
        })
        .join('\n');
    };

    const embed = new EmbedBuilder()
      .setColor(0x00aa00)
      .setTitle(`${professionIcons[profession]} ${professionNames[profession]} Materials`)
      .setDescription(
        `**Current Filter:** ${professionIcons[profession]} ${professionNames[profession]}\n` +
        `**Items Found:** ${filtered.length}\n\n` +
        `Showing materials useful for ${professionNames[profession]} crafting.`
      );

    if (filtered.length > 0) {
      const chunkSize = 25;
      for (let i = 0; i < Math.min(filtered.length, 75); i += chunkSize) {
        const chunk = filtered.slice(i, i + chunkSize);
        const title = i === 0 ? `${professionNames[profession]} Materials (Page 1)` : `${professionNames[profession]} Materials (Page ${Math.ceil(i / chunkSize) + 1})`;
        embed.addFields({
          name: title,
          value: formatItems(chunk),
          inline: false,
        });
      }
      
      if (filtered.length > 75) {
        embed.addFields({
          name: '...',
          value: `And ${filtered.length - 75} more items (showing first 75)`,
          inline: false,
        });
      }
    } else {
      embed.addFields({
        name: 'No Items',
        value: `You don't have any ${professionNames[profession]} materials.`,
        inline: false,
      });
    }

    const professionFilterRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-inventory-profession-select')
        .setPlaceholder(`üîß Current: ${professionNames[profession]}`)
        .addOptions(
          { label: 'üõ†Ô∏è Blacksmith', value: 'blacksmith', description: 'Blacksmith materials', default: profession === 'blacksmith' },
          { label: 'üåø Botanic', value: 'botanic', description: 'Botanic materials', default: profession === 'botanic' },
          { label: '‚ú® Enchanter', value: 'enchanter', description: 'Enchanter materials', default: profession === 'enchanter' }
        )
    );

    const typeFilterRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-filter-all')
        .setLabel('üìã All Items')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-filter-materials')
        .setLabel('üîß Materials')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-inventory')
        .setLabel('üìñ Back to Guide')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [professionFilterRow, typeFilterRow],
    });
  }
  async handleManageEquipment(interaction, player) {
    this.trackMenuNavigation(player, 'manage-equipment');
    
    // Get all equipment from inventory
    const equipmentItems = player.inventory.filter(item => {
      if (!item || typeof item === 'string' || item.type !== 'equipment') return false;
      
      const equipment = getEquipment(item.id) || getItemByIdDynamic(item.id);
      
      // Must have a slot (weapon, chest, head, legs, boots, etc.) to be real equipment
      // Check both item.slot (stored) and equipment.slot (from definition)
      const slot = item.slot || equipment?.slot;
      if (!slot) return false;
      
      const playerClass = player.class || player.internalClass;
      if (equipment && equipment.classRestriction && equipment.classRestriction !== playerClass) {
        return false;
      }
      return true;
    });

    // Also include currently equipped items (they might not be in inventory)
    const equippedIds = new Set(equipmentItems.map(item => item.id));
    if (player.equippedItems) {
      for (const [slot, itemId] of Object.entries(player.equippedItems)) {
        if (itemId && !equippedIds.has(itemId)) {
          const equipment = getEquipment(itemId) || getItemByIdDynamic(itemId);
          if (equipment) {
            const playerClass = player.class || player.internalClass;
            if (equipment.classRestriction && equipment.classRestriction !== playerClass) {
              continue;
            }
            equipmentItems.push({
              id: itemId,
              name: equipment.name,
              type: 'equipment',
              slot: equipment.slot || slot,
              quantity: 1,
            });
            equippedIds.add(itemId);
          }
        }
      }
    }

    if (equipmentItems.length === 0) {
      const embed = new EmbedBuilder()
        .setColor(0xff6600)
        .setTitle('‚öôÔ∏è Manage Equipment')
        .setDescription('No equipment available in your inventory.');

      const buttons = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-equipment')
          .setLabel('‚Üê Back to Equipment')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-hub')
          .setLabel('üè† Hub')
          .setStyle(ButtonStyle.Primary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [buttons],
      });
      return;
    }

    // Sort equipment from best to worst (by rarity, then total stats, then name)
    const rarityValues = { legendary: 5, epic: 4, rare: 3, uncommon: 2, common: 1 };
    equipmentItems.sort((a, b) => {
      const equipA = getEquipment(a.id) || getItemByIdDynamic(a.id);
      const equipB = getEquipment(b.id) || getItemByIdDynamic(b.id);
      
      // Sort by rarity first
      const rarityA = rarityValues[equipA?.rarity] || 0;
      const rarityB = rarityValues[equipB?.rarity] || 0;
      if (rarityA !== rarityB) return rarityB - rarityA;
      
      // Then by total stats
      const statsA = equipA?.stats || equipA?.bonuses || {};
      const statsB = equipB?.stats || equipB?.bonuses || {};
      const totalA = Object.values(statsA).reduce((sum, val) => sum + (typeof val === 'number' ? val : 0), 0);
      const totalB = Object.values(statsB).reduce((sum, val) => sum + (typeof val === 'number' ? val : 0), 0);
      if (totalA !== totalB) return totalB - totalA;
      
      // Finally alphabetically
      return a.name.localeCompare(b.name);
    });

    // Create select menu with equipment options
    const options = equipmentItems.slice(0, 25).map((item, index) => {
      const equipment = getEquipment(item.id) || getItemByIdDynamic(item.id);
      const isEquipped = Object.values(player.equippedItems || {}).includes(item.id);
      const slot = equipment?.slot || item.slot || 'unknown';
      const rarity = equipment?.rarity || 'common';
      
      let stats = [];
      // Check for nested stats/bonuses or direct properties
      const s = equipment?.stats || equipment?.bonuses || equipment;
      if (s) {
        if (s.damage) stats.push(`DMG+${s.damage}`);
        if (s.strength) stats.push(`STR+${s.strength}`);
        if (s.defense) stats.push(`DEF+${s.defense}`);
        if (s.agility) stats.push(`AGI+${s.agility}`);
        if (s.intelligence) stats.push(`INT+${s.intelligence}`);
        if (s.vitality) stats.push(`VIT+${s.vitality}`);
        if (s.wisdom) stats.push(`WIS+${s.wisdom}`);
      }
      
      const rarityEmoji = { legendary: '‚≠ê', epic: 'üíú', rare: 'üíô', uncommon: 'üíö', common: '‚ö™' };
      const qty = item.quantity > 1 ? ` (x${item.quantity})` : '';
      
      return {
        label: `${isEquipped ? '‚úÖ ' : ''}${item.name}${qty}`,
        value: `${item.id}::${index}`,
        description: `${rarityEmoji[rarity] || ''} ${rarity} ${slot} | ${stats.join(' ') || 'No stats'}`.substring(0, 100),
        emoji: isEquipped ? '‚öôÔ∏è' : 'üì¶',
      };
    });

    const embed = new EmbedBuilder()
      .setColor(0x00aa00)
      .setTitle('‚öôÔ∏è Manage Equipment')
      .setDescription('Select an item to equip/unequip, or dismantle for 20% materials back.')
      .addFields({
        name: 'Currently Equipped',
        value: Object.keys(player.equippedItems || {}).length > 0
          ? Object.entries(player.equippedItems).map(([slot, id]) => {
              const eq = getEquipment(id);
              return `**${slot}**: ${eq?.name || id}`;
            }).join('\\n')
          : 'Nothing equipped',
        inline: false,
      });

    const equipMenu = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-equip-item')
        .setPlaceholder('Select equipment to equip/unequip')
        .addOptions(options)
    );

    const dismantleMenu = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-dismantle-item')
        .setPlaceholder('Select equipment to dismantle (20% materials)')
        .addOptions(options)
    );

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-equipment')
        .setLabel('‚Üê Back to Equipment')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-hub')
        .setLabel('üè† Hub')
        .setStyle(ButtonStyle.Primary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [equipMenu, dismantleMenu, buttons],
    });
  }

  /**
   * Handle equipment sets - save/load equipment loadouts
   */
  async handleEquipmentSets(interaction, player) {
    this.trackMenuNavigation(player, 'equipment-sets');
    
    if (!player.equipmentSets) {
      player.equipmentSets = [];
    }

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle('üìã Equipment Sets')
      .setDescription('Save and load equipment loadouts for quick swapping.');

    if (player.equipmentSets.length > 0) {
      const setsText = player.equipmentSets.map((set, idx) => {
        const itemCount = Object.keys(set.items || {}).length;
        return `**${idx + 1}. ${set.name}** (${itemCount} items)`;
      }).join('\\n');
      
      embed.addFields({
        name: 'Saved Sets',
        value: setsText,
        inline: false,
      });
    } else {
      embed.addFields({
        name: 'No Saved Sets',
        value: 'Create your first equipment set to quickly swap between loadouts!',
        inline: false,
      });
    }

    const row1 = new ActionRowBuilder();
    const row2 = new ActionRowBuilder();
    const row3 = new ActionRowBuilder();

    // Save current equipment button
    row1.addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-save-equipment-set')
        .setLabel('üíæ Save Current Equipment')
        .setStyle(ButtonStyle.Success)
        .setDisabled(!player.equippedItems || Object.keys(player.equippedItems).length === 0)
    );

    // Load set buttons (max 5 sets)
    if (player.equipmentSets.length > 0) {
      const loadOptions = player.equipmentSets.slice(0, 25).map((set, idx) => ({
        label: `${idx + 1}. ${set.name}`,
        value: `set_${idx}`,
        description: `${Object.keys(set.items || {}).length} items`.substring(0, 100),
        emoji: '‚öôÔ∏è',
      }));

      row2.addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-load-equipment-set')
          .setPlaceholder('Load an equipment set')
          .addOptions(loadOptions)
      );

      // Delete set menu
      const deleteOptions = player.equipmentSets.slice(0, 25).map((set, idx) => ({
        label: `Delete: ${idx + 1}. ${set.name}`,
        value: `delete_${idx}`,
        description: 'Remove this set',
        emoji: 'üóëÔ∏è',
      }));

      row3.addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-delete-equipment-set')
          .setPlaceholder('Delete an equipment set')
          .addOptions(deleteOptions)
      );
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-equipment')
        .setLabel('‚Üê Back to Equipment')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-hub')
        .setLabel('üè† Hub')
        .setStyle(ButtonStyle.Primary)
    );

    const components = [row1];
    if (row2.components.length > 0) components.push(row2);
    if (row3.components.length > 0) components.push(row3);
    components.push(backButton);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Handle save equipment set - show modal for name input
   */
  async handleSaveEquipmentSet(interaction, player) {
    // Create modal for set name
    const modal = new ModalBuilder()
      .setCustomId('rpg-save-set-modal')
      .setTitle('Save Equipment Set');

    const nameInput = new TextInputBuilder()
      .setCustomId('set-name')
      .setLabel('Equipment Set Name')
      .setStyle(TextInputStyle.Short)
      .setPlaceholder('e.g., Tank Build, DPS Setup')
      .setRequired(true)
      .setMaxLength(50);

    const row = new ActionRowBuilder().addComponents(nameInput);
    modal.addComponents(row);

    await interaction.showModal(modal);
  }

  /**
   * Start multi-dismantle selection - shows equipment list with checkmarks
   */
  async handleDismantleMultipleStart(interaction, player) {
    try {
      this.trackMenuNavigation(player, 'dismantle-multiple');

      // Get all equipment items in inventory
      const seenEquipmentIds = new Set();
      const equipmentItems = player.inventory
        .filter(item => {
          if (!item || typeof item !== 'object' || item.type !== 'equipment') return false;
          if (seenEquipmentIds.has(item.id)) return false;
          seenEquipmentIds.add(item.id);
          return true;
        })
        .map((item, idx) => ({
          item,
          index: idx,
          id: item.id,
          equipment: getEquipment(item.id) || getItemByIdDynamic(item.id),
        }))
        .filter(({ equipment, id }) => {
          // Filter out items without equipment data
          if (!equipment) return false;
          // Filter out items without recipes (dungeon gear, unique items, etc.)
          const recipe = Object.values(RECIPES).find(r => r.output.item === id);
          return recipe != null;
        });

      if (equipmentItems.length === 0) {
        await interaction.reply({
          content: '‚ùå No equipment items to dismantle.',
          ephemeral: true,
        });
        return;
      }

      // Store selection state
      if (!this.dismantleSelections) this.dismantleSelections = {};
      this.dismantleSelections[player.id] = {
        queue: {}, // itemId -> quantity
        equipment: equipmentItems,
        timestamp: Date.now(),
      };

      // Create select menu with equipment items (Discord max 25 options)
      const selectOptions = equipmentItems.slice(0, 25).map(eq => {
        const count = player.inventory.filter(i => i && i.id === eq.id && i.type === 'equipment').reduce((sum, i) => sum + (i.quantity || 1), 0);
        return {
          label: `${(eq.equipment?.name || 'Unknown').substring(0, 70)} (x${count})`,
          value: eq.id,
          description: `Rarity: ${eq.equipment?.rarity || 'Common'}`.substring(0, 100),
        };
      });

      const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('rpg-dismantle-select-item')
        .setPlaceholder(`Select an item to dismantle (${Math.min(equipmentItems.length, 25)}/${equipmentItems.length})`)
        .addOptions(selectOptions)
        .setMinValues(1)
        .setMaxValues(1); // Only select ONE at a time

      const selectRow = new ActionRowBuilder().addComponents(selectMenu);

      const buttonRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-manage-equipment')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );

      const embed = new EmbedBuilder()
        .setColor(16743680) // Orange
        .setTitle('‚ôªÔ∏è Multi-Dismantle Items')
        .setDescription(`Select an item to view details and choose how many to dismantle.\n\nüì¶ ${equipmentItems.length} unique equipment items found.`);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [selectRow, buttonRow],
      });
    } catch (err) {
      console.error('Error in handleDismantleMultipleStart:', err);
      try {
        if (!interaction.replied && !interaction.deferred) {
          await interaction.reply({ content: `‚ùå Error: ${err.message}`, ephemeral: true });
        }
      } catch (e) {
        console.error('Failed to send error:', e);
      }
    }
  }

  /**
   * Display list of items as clickable buttons
   */
  async displayDismantleItemList(interaction, player) {
    const selection = this.dismantleSelections?.[player.id];
    if (!selection) return;

    const { equipment: equipmentItems, selections } = selection;
    
    // Build summary of selected items
    let selectionSummary = '';
    if (Object.keys(selections).length > 0) {
      const summaryLines = Object.entries(selections)
        .map(([itemId, qty]) => {
          const item = equipmentItems.find(e => e.id === itemId);
          const name = item?.equipment?.name || 'Unknown';
          return `‚úÖ ${name} x${qty}`;
        })
        .slice(0, 5); // Show first 5
      
      const moreCount = Object.keys(selections).length - 5;
      if (moreCount > 0) summaryLines.push(`... and ${moreCount} more`);
      
      selectionSummary = '\n\n**Selected Items:**\n' + summaryLines.join('\n');
    }

    const embed = new EmbedBuilder()
      .setColor(16743680) // Orange
      .setTitle('‚ôªÔ∏è Dismantle Multiple Items')
      .setDescription(`Click an item to select quantity${selectionSummary}`);

    // Show first 5 items as buttons (Discord has 5 buttons per row limit)
    const itemsToShow = equipmentItems.slice(0, 5);
    const rows = [];
    
    for (let i = 0; i < itemsToShow.length; i += 5) {
      const buttonChunk = itemsToShow.slice(i, i + 5);
      const row = new ActionRowBuilder();
      
      buttonChunk.forEach(equipItem => {
        const eq = equipItem.equipment;
        const name = (eq && eq.name) ? String(eq.name) : 'Unknown';
        const qty = selections[equipItem.id] || 0;
        const label = `${name.substring(0, 15)}${qty > 0 ? ` (${qty})` : ''}`.substring(0, 25);
        
        row.addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-dismantle-item-SELECT-${equipItem.id}`)
            .setLabel(label)
            .setStyle(ButtonStyle.Secondary)
        );
      });
      
      rows.push(row);
    }

    // Add confirm and cancel buttons
    const controlRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-dismantle-multiple-confirm')
        .setLabel('‚úÖ Confirm')
        .setStyle(ButtonStyle.Success)
        .setDisabled(Object.keys(selections).length === 0),
      new ButtonBuilder()
        .setCustomId('rpg-dismantle-cancel')
        .setLabel('‚ùå Cancel')
        .setStyle(ButtonStyle.Danger)
    );

    rows.push(controlRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  /**
   * Show quantity selection for a specific item
   */
  async handleDismantleItemSelect(interaction, player, itemId) {
    const selection = this.dismantleSelections?.[player.id];
    if (!selection) {
      await interaction.reply({ content: '‚ùå Selection expired. Try again.', ephemeral: true });
      return;
    }

    const item = selection.equipment.find(e => e.id === itemId);
    if (!item) {
      await interaction.reply({ content: '‚ùå Item not found.', ephemeral: true });
      return;
    }

    const eq = item.equipment;
    const name = (eq && eq.name) ? String(eq.name) : 'Unknown';
    const currentQty = selection.selections[itemId] || 0;

    const embed = new EmbedBuilder()
      .setColor(16743680) // Orange
      .setTitle(`üì¶ ${name}`)
      .setDescription(`How many would you like to dismantle?\n\nCurrently selected: ${currentQty}`);

    // Quantity buttons
    const row = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`rpg-dismantle-qty-APPLY-${itemId}-1`)
        .setLabel('1x')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId(`rpg-dismantle-qty-APPLY-${itemId}-10`)
        .setLabel('10x')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId(`rpg-dismantle-qty-APPLY-${itemId}-50`)
        .setLabel('50x')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId(`rpg-dismantle-qty-APPLY-${itemId}-max`)
        .setLabel('Max')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId(`rpg-dismantle-qty-BACK`)
        .setLabel('‚¨ÖÔ∏è Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row],
    });
  }

  /**
   * Show item overview with quantity selection buttons
   */
  async handleDismantleItemOverview(interaction, player, itemId) {
    try {
      const selection = this.dismantleSelections?.[player.id];
      if (!selection) {
        await interaction.reply({ content: '‚ùå Selection expired. Try again.', ephemeral: true });
        return;
      }

      const item = selection.equipment.find(e => e.id === itemId);
      if (!item) {
        await interaction.reply({ content: '‚ùå Item not found.', ephemeral: true });
        return;
      }

      const eq = item.equipment;
      const name = (eq && eq.name) ? String(eq.name) : 'Unknown';
      const currentQty = selection.queue[itemId] || 0;
      const ownedCount = player.inventory.filter(inv => inv && inv.id === itemId && inv.type === 'equipment').reduce((sum, i) => sum + (i.quantity || 1), 0);

      const embed = new EmbedBuilder()
        .setColor(16743680) // Orange
        .setTitle(`üì¶ ${name}`)
        .setDescription(`**Rarity:** ${eq.rarity || 'Common'}\n**Owned:** ${ownedCount}\n**In Queue:** ${currentQty}\n\nSelect quantity to add:`)
        .addFields(
          {
            name: 'Returns as Materials',
            value: '20% of crafting materials',
            inline: false,
          }
        );

      // Quantity buttons
      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-dismantle-qty-${itemId}-1`)
          .setLabel('1x')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId(`rpg-dismantle-qty-${itemId}-10`)
          .setLabel('10x')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId(`rpg-dismantle-qty-${itemId}-50`)
          .setLabel('50x')
          .setStyle(ButtonStyle.Primary)
      );

      // Max and additional options
      const invCount = player.inventory.filter(inv => inv.id === itemId && inv.type === 'equipment').reduce((sum, i) => sum + (i.quantity || 1), 0);
      const row2 = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-dismantle-qty-${itemId}-max`)
          .setLabel(`Max (${invCount})`)
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('rpg-dismantle-add-another')
          .setLabel('‚ûï Add Another Item')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-dismantle-finish')
          .setLabel('‚úÖ Confirm All')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('rpg-dismantle-multiple-start')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );

      await interaction.deferUpdate();
      await interaction.editReply({
        embeds: [embed],
        components: [row, row2],
      });
    } catch (err) {
      console.error('Error in handleDismantleItemOverview:', err);
      try {
        if (!interaction.replied && !interaction.deferred) {
          await interaction.reply({ content: '‚ùå Error loading item details.', ephemeral: true });
        }
      } catch (e) {
        console.error('Failed to send error response:', e);
      }
    }
  }

  /**
   * Handle quantity selection for item
   */
  async handleDismantleAddQuantity(interaction, player, itemId, quantity) {
    try {
      const selection = this.dismantleSelections?.[player.id];
      if (!selection) {
        await interaction.reply({ content: '‚ùå Selection expired. Try again.', ephemeral: true });
        return;
      }

      const item = selection.equipment.find(e => e.id === itemId);
      if (!item) {
        await interaction.reply({ content: '‚ùå Item not found.', ephemeral: true });
        return;
      }

      // Handle max quantity
      if (quantity === 'max') {
        quantity = player.inventory.filter(inv => inv.id === itemId && inv.type === 'equipment').reduce((sum, i) => sum + (i.quantity || 1), 0);
      } else {
        quantity = parseInt(quantity, 10);
      }

      // Add to queue
      selection.queue[itemId] = (selection.queue[itemId] || 0) + quantity;

      // Build queue summary
      const queueSummary = Object.entries(selection.queue)
        .map(([id, qty]) => {
          const itm = selection.equipment.find(e => e.id === id);
          const nm = itm?.equipment?.name || 'Unknown';
          return `üìã ${nm} x${qty}`;
        })
        .join('\n');

      const queueText = queueSummary || 'Queue is empty';

      const embed = new EmbedBuilder()
        .setColor(16743680) // Orange
        .setTitle('‚ôªÔ∏è Dismantle Queue')
        .setDescription(`**Items Ready to Dismantle:**\n\n${queueText}`)
        .addFields(
          {
            name: 'Total Items',
            value: String(Object.values(selection.queue).reduce((a, b) => a + b, 0)),
            inline: true,
          }
        );

      const selectOptions = selection.equipment.slice(0, 25).map(eq => {
        const count = player.inventory.filter(i => i && i.id === eq.id && i.type === 'equipment').reduce((sum, i) => sum + (i.quantity || 1), 0);
        return {
          label: `${(eq.equipment?.name || 'Unknown').substring(0, 70)} (x${count})`,
          value: eq.id,
          description: `Rarity: ${eq.equipment?.rarity || 'Common'}`,
        };
      });

      const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('rpg-dismantle-select-item')
        .setPlaceholder('Select another item to add')
        .addOptions(selectOptions)
        .setMinValues(1)
        .setMaxValues(1);

      const selectRow = new ActionRowBuilder().addComponents(selectMenu);

      const buttonRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-dismantle-finish')
          .setLabel('‚úÖ Dismantle All')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('rpg-dismantle-cancel')
          .setLabel('‚ùå Cancel')
          .setStyle(ButtonStyle.Danger)
      );

      await interaction.deferUpdate();
      await interaction.editReply({
        embeds: [embed],
        components: [selectRow, buttonRow],
      });
    } catch (err) {
      console.error('Error in handleDismantleAddQuantity:', err);
      try {
        if (!interaction.replied && !interaction.deferred) {
          await interaction.reply({ content: '‚ùå Error adding to queue.', ephemeral: true });
        }
      } catch (e) {
        console.error('Failed to send error response:', e);
      }
    }
  }

  /**
   * Finish and execute the dismantle
   */
  async handleDismantleFinish(interaction, player) {
    try {
      if (!interaction.deferred && !interaction.replied) {
        await interaction.deferUpdate();
      }

      const selection = this.dismantleSelections?.[player.id];
      if (!selection || !selection.queue || Object.keys(selection.queue).length === 0) {
        await interaction.followUp({
          content: '‚ùå No items queued for dismantle.',
          ephemeral: true,
        });
        return;
      }

      // Build itemsToDismantle array (repeat itemId by quantity)
      const itemsToDismantle = [];
      const itemsToDismantleList = [];

      for (const [itemId, quantity] of Object.entries(selection.queue)) {
        const item = selection.equipment.find(e => e.id === itemId);
        const name = item?.equipment?.name || 'Unknown';
        itemsToDismantleList.push(`${name} x${quantity}`);

        for (let i = 0; i < quantity; i++) {
          itemsToDismantle.push(itemId);
        }
      }

      // Execute dismantle
      const results = this.dismantleMultipleItems(player, itemsToDismantle);

      // Clean up
      delete this.dismantleSelections[player.id];

      // Build response
      let materialsText = '';
      if (Object.keys(results.totalMaterials).length > 0) {
        const matLines = Object.entries(results.totalMaterials)
          .slice(0, 10)
          .map(([matId, qty]) => `‚Ä¢ ${matId}: +${qty}`)
          .join('\n');

        const totalMats = Object.keys(results.totalMaterials).length;
        materialsText = totalMats > 10
          ? `${matLines}\n‚Ä¢ ... and ${totalMats - 10} more materials`
          : matLines;
      }

      const itemsText = itemsToDismantleList.slice(0, 5).join('\n') +
                        (itemsToDismantleList.length > 5 ? `\n... and ${itemsToDismantleList.length - 5} more` : '');

      const embed = new EmbedBuilder()
        .setColor(16743680)
        .setTitle('‚ôªÔ∏è Dismantle Complete!')
        .setDescription(`Successfully dismantled ${results.successful.length} items${results.failed.length > 0 ? ` (${results.failed.length} failed)` : ''}`)
        .addFields(
          {
            name: 'üì¶ Items',
            value: itemsText || 'None',
            inline: true,
          },
          {
            name: '‚úÖ Success',
            value: String(results.successful.length),
            inline: true,
          }
        );

      if (materialsText) {
        embed.addFields({
          name: 'üíé Materials Returned (20%)',
          value: materialsText,
          inline: false,
        });
      }

      await interaction.editReply({
        embeds: [embed],
        components: [],
      });
    } catch (err) {
      console.error('Error in handleDismantleFinish:', err);
      try {
        if (!interaction.replied && !interaction.deferred) {
          await interaction.reply({ content: '‚ùå Error executing dismantle.', ephemeral: true });
        }
      } catch (e) {
        console.error('Failed to send error response:', e);
      }
    }
  }

  /**
   * Dismantle multiple items at once - returns materials for all
   */
  dismantleMultipleItems(player, itemIds) {
    const results = {
      successful: [],
      failed: [],
      totalMaterials: {},
    };

    for (const itemId of itemIds) {
      const equipment = getEquipment(itemId) || getItemByIdDynamic(itemId);
      if (!equipment) {
        results.failed.push(`‚ùå ${itemId || 'Unknown'}: Item not found`);
        continue;
      }

      const recipe = Object.values(RECIPES).find(r => r.output.item === itemId);
      if (!recipe || !recipe.materials) {
        results.failed.push(`‚ùå ${equipment.name}: Cannot dismantle (unique/dungeon gear)`);
        continue;
      }

      // Calculate materials
      const baseMaterials = this.getAdjustedMaterials(recipe.materials);
      const adjustedMaterials = this.applyCostMultiplier(baseMaterials, this.getProfessionCostMultiplier(player));
      const refundMaterials = {};
      
      for (const [matId, qty] of Object.entries(adjustedMaterials)) {
        const refundQty = Math.floor(qty * 0.2);
        if (refundQty > 0) {
          refundMaterials[matId] = refundQty;
          results.totalMaterials[matId] = (results.totalMaterials[matId] || 0) + refundQty;
        }
      }

      // Check if equipped
      const isEquipped = Object.values(player.equippedItems || {}).includes(itemId);

      // Remove item from inventory or equipped slot
      if (isEquipped) {
        for (const [slot, equippedId] of Object.entries(player.equippedItems)) {
          if (equippedId === itemId) {
            delete player.equippedItems[slot];
            break;
          }
        }
      } else {
        const invItem = player.inventory.find(i => i && i.id === itemId && i.type === 'equipment');
        if (invItem) {
          if (invItem.quantity > 1) {
            invItem.quantity -= 1;
          } else {
            const index = player.inventory.indexOf(invItem);
            if (index > -1) player.inventory.splice(index, 1);
          }
        }
      }

      // Add materials
      for (const [matId, qty] of Object.entries(refundMaterials)) {
        this.addMaterialToInventory(player, matId, qty);
      }

      results.successful.push(`‚ôªÔ∏è ${equipment.name}`);
    }

    // Save once at the end
    player.clearStatsCache();
    this.persistPlayer(player);

    return results;
  }

  /**
   * Start the remove enchant flow - show slots with enchants
   */
  async handleRemoveEnchantStart(interaction, player) {
    // Migrate old data first
    this.migrateEnchantData(player);
    
    const enchantedSlots = [];
    
    if (player.equipmentEnchants) {
      for (const [slot, enchants] of Object.entries(player.equipmentEnchants)) {
        const equippedId = this.getResolvedEquippedItemId(player, slot);
        
        if (typeof enchants === 'object' && equippedId) {
          const equipment = getEquipment(equippedId) || getItemByIdDynamic(equippedId);
          
          // Check each enchant type
          for (const [type, level] of Object.entries(enchants)) {
            if (level > 0) {
              enchantedSlots.push({
                slot,
                type,
                level,
                itemId: equippedId,
                name: equipment?.name || 'Unknown'
              });
            }
          }
        }
      }
    }

    if (enchantedSlots.length === 0) {
      await interaction.reply({ content: 'You have no enchanted equipment.', ephemeral: true });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0x8e44ad)
      .setTitle('‚ú® Remove Enchantments')
      .setDescription('Select which enchanted item to remove enchants from.\n\n**Gold Cost:** 100 gold per enchant level (e.g., +5 enchant costs 500 gold)\nRemoving enchants is permanent and cannot be undone.');

    const slotsText = enchantedSlots
      .map(({ slot, type, level, name }) => `‚Ä¢ **${slot.toUpperCase()}** [${type} +${level}]: ${name}`)
      .join('\n');
    
    embed.addFields({
      name: 'Enchanted Equipment',
      value: slotsText,
      inline: false
    });

    // Create buttons for each enchanted slot/type
    const buttons = enchantedSlots.map((item, index) => 
      new ButtonBuilder()
        .setCustomId(`rpg-remove-enchant-confirm-${item.slot}-${item.type}`)
        .setLabel(`${item.slot.toUpperCase()} ${item.type} +${item.level} (${item.level * 100}g)`.slice(0, 80))
        .setStyle(ButtonStyle.Danger)
    );

    const rows = [];
    for (let i = 0; i < buttons.length; i += 5) {
      rows.push(new ActionRowBuilder().addComponents(...buttons.slice(i, i + 5)));
    }

    rows.push(new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-equipment')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    ));

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows
    });
  }

  /**
   * Confirm and remove enchant from a slot
   */
  async handleRemoveEnchantConfirm(interaction, player, slotAndType) {
    // Migrate old data
    this.migrateEnchantData(player);
    
    // Parse slot and type from parameter (format: "slot-type")
    const parts = slotAndType.split('-');
    const slot = parts[0];
    const type = parts.slice(1).join('-') || 'damage'; // fallback to damage for old format
    
    const enchants = player.equipmentEnchants?.[slot] || {};
    const enchantLevel = enchants[type] || 0;
    
    if (enchantLevel === 0) {
      await interaction.reply({ content: `The ${slot} slot has no ${type} enchantment.`, ephemeral: true });
      return;
    }

    const goldCost = enchantLevel * 100;
    const playerGold = player.gold || 0;

    if (playerGold < goldCost) {
      await interaction.reply({ 
        content: `‚ùå Not enough gold! You need ${goldCost} gold but only have ${playerGold} gold.`, 
        ephemeral: true 
      });
      return;
    }

    // Remove the specific enchant type and deduct gold
    player.equipmentEnchants[slot][type] = 0;
    player.gold -= goldCost;
    this.trackGoldSpent(player, goldCost, 'upgrades');
    player.clearStatsCache();
    this.persistPlayer(player);

    const equippedId = this.getResolvedEquippedItemId(player, slot);
    const equipment = getEquipment(equippedId) || getItemByIdDynamic(equippedId);
    const itemName = equipment?.name || slot;

    await interaction.reply({
      content: `‚úÖ Removed **${type} +${enchantLevel}** enchantment from **${itemName}** (${slot}).\n-${goldCost} gold`,
      ephemeral: false
    });

    // Go back to equipment menu after 3 seconds
    setTimeout(() => {
      this.handleEquipment(interaction, player, true).catch(() => {});
    }, 3000);
  }

  /**
   * Handle dungeons button
   */
  async handleDungeons(interaction, player) {
    if (player.level < 10) {
      await interaction.reply({
        content: 'üîí **Dungeons Locked**\nReach level 10 to unlock Dungeons!',
        ephemeral: true,
      });
      return;
    }
    
    this.trackMenuNavigation(player, 'dungeon');
    try {
      const dungeons = getAvailableDungeons(player.level, player.currentWorld);
      const embed = UIBuilder.createDungeonsEmbed(player.level, player.currentWorld);

      const backButton = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-combat-menu')
          .setLabel('‚Üê Back to Combat')
          .setStyle(ButtonStyle.Secondary)
      );

      if (dungeons.length === 0) {
        await this.updateInteractionWithTracking(interaction, {
          embeds: [embed],
          components: [backButton],
        });
        return;
      }

      // Validate dungeon data before creating options
      const validDungeons = dungeons.filter(d => d && d.id && d.name);
      
      if (validDungeons.length === 0) {
        await this.updateInteractionWithTracking(interaction, {
          embeds: [embed],
          components: [backButton],
        });
        return;
      }

      const options = validDungeons.map(d => {
        const floors = d.floors || 1;
        const floorText = floors > 1 ? ` ‚Ä¢ ${floors} Floors` : '';
        const label = `${d.name} (Lvl ${d.minLevel}${floorText})`.substring(0, 100);
        return {
          label: label,
          value: d.id.substring(0, 100),
          description: (d.description || 'A challenging dungeon').substring(0, 100),
        };
      });

      const selectMenu = new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-select-dungeon')
          .setPlaceholder('Select a dungeon to fight')
          .addOptions(options)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [selectMenu, backButton],
      });
    } catch (error) {
      console.error('Error in handleDungeons:', error);
      await interaction.reply({
        content: '‚ùå Error loading dungeons. Please try again.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle combat training (start combat)
   */
  async handleCombatTraining(interaction, player) {
    this.trackMenuNavigation(player, 'combat-training');
    
    // Safety check: Clear stale combat flags if no active combat exists
    this.clearStaleCombatFlag(player);
    
    // Check if player is in combat
    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({
        content: 'You are already in combat!',
        ephemeral: true,
      });
      return;
    }

    // Show combat style selection before starting
    const styles = getStylesForClass(player.class || player.internalClass);
    if (styles.length === 0) {
      // No styles available, use default combat
      await this.startTrainingCombat(interaction, player);
      return;
    }

    // Show style selection
    const options = styles.map((style, idx) => ({
      label: style.name,
      value: `style-${style.id}`,
      description: style.description,
      emoji: style.icon,
    }));

    // Add random environment option
    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-combat-style-select')
        .setPlaceholder('Choose Combat Style')
        .addOptions(options)
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-menu')
        .setLabel('‚Üê Back to Combat')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0xff6600)
      .setTitle('‚öîÔ∏è Combat Training - Choose Your Style')
      .setDescription(`Select a combat style for your Training Dummy fight (Level ${Math.max(1, player.level - 1)})`)
      .addFields(
        { name: 'üéØ Combat Styles', value: styles.map(s => `${s.icon} **${s.name}** - ${s.description}`).join('\n') }
      );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  async startTrainingCombat(interaction, player, styleId = null) {
    const style = styleId ? getCombatStyle(styleId) : null;
    
    // Create a training dummy scaled to player level (much weaker for practice)
    const dummyLevel = Math.max(1, Math.floor(player.level * 0.5)); // 50% of player level
    const combatState = this.combatSystem.startCombat(
      player,
      'Training Dummy',
      dummyLevel
    );

    // Assign combat style if selected
    if (style && combatState) {
      combatState.combatStyle = style;
      // Save the style for quick repeat
      player.lastTrainingStyle = styleId;
    }

    // Select random environment
    combatState.environment = getRandomEnvironment(true);

    this.persistPlayer(player);

    const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
    
    // Add environment info
    if (combatState.environment) {
      embed.addFields({
        name: `${combatState.environment.name}`,
        value: combatState.environment.description
      });
    }

    // Add style info
    if (style) {
      embed.addFields({
        name: `${style.icon} ${style.name}`,
        value: style.description
      });
    }

    const buttons = this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Handle combat next turn (AI-driven)
   */
  async handleCombatNextTurn(interaction, player) {
    if (this.isGuildBossCombat(player)) {
      await this.handleGuildBossCombatTurn(interaction, player, { type: 'next' });
      return;
    }

    const result = this.combatSystem.executeRound(player.userId);

    if (result.error) {
      // Combat state was lost - reset player flag
      player.isInCombat = false;
      player.currentEnemy = null;
      this.persistPlayer(player);
      
      await interaction.reply({
        content: '‚ö†Ô∏è Combat session expired. Start a new battle!',
        ephemeral: true,
      });
      return;
    }

    // Check victory/defeat FIRST (endCombat result doesn't have combatState)
    if (result.status === 'ongoing') {
      if (!result.combatState) {
        await interaction.reply({
          content: '‚ö†Ô∏è Combat state was lost. Ending battle.',
          ephemeral: true,
        });
        player.isInCombat = false;
        player.currentEnemy = null;
        this.persistPlayer(player);
        return;
      }

      const embed = UIBuilder.createCombatStateEmbed(result.combatState);
      const buttons = this.createCombatButtons();

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: buttons,
      });
      return;
    }

    if (result.status === 'victory' || result.status === 'defeat') {
      // Use the player from result if available (has combat modifications)
      const combatPlayer = result.player || player;
      await this.handleCombatResolution(interaction, combatPlayer, result);
    }
  }

  /**
   * Show combat skill selection with pagination support
   */
  async handleCombatSkillMenu(interaction, player) {
    if (!this.combatSystem.isInCombat(player.userId)) {
      const guild = this.guildManager.getPlayerGuild(player.userId);
      if (guild?.activeBoss) {
        await this.handleGuildBosses(interaction, player);
        return;
      }
      await interaction.reply({ content: 'You are not in combat.', ephemeral: true });
      return;
    }

    const skills = this.combatSystem.getAvailableSkills(player.userId);
    if (!skills || skills.length === 0) {
      await interaction.reply({ content: 'No skills available for combat.', ephemeral: true });
      return;
    }

    const combatState = this.combatSystem.getActiveCombat(player.userId);
    const bossSkillLevels = combatState?.playerSkillLevels || player.skillLevels || {};

    // Show all skills in the select menu (Discord supports up to 25 options)
    const options = skills.slice(0, 25).map((skill) => {
      // Get cooldown based on skill level
      const skillLevel = bossSkillLevels[skill.id] || 1;
      const cooldownValue = skill.getCooldown ? skill.getCooldown(skillLevel) : (skill.cooldown || 0);
      const cooldownText = cooldownValue > 0 ? `CD ${cooldownValue}t` : 'Ready';
      
      const accuracyText = `Acc ${Math.round((skill.accuracy ?? 1) * 100)}%`;
      const typeText = `Type ${skill.element || skill.type || 'normal'}`;
      const statusText = skill.canUse ? 'Ready' : `Locked: ${skill.reason}`;

      return {
        label: `${skill.name} Lv${skillLevel}`.substring(0, 100),
        value: skill.id,
        description: `${typeText} ‚Ä¢ ${accuracyText} ‚Ä¢ ${statusText}`.substring(0, 100),
        emoji: '‚ö°',
      };
    });

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-combat-skill-select')
        .setPlaceholder(`Select a skill to use (${skills.length} available)`)
        .addOptions(options)
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-refresh')
        .setLabel('‚Üê Back to Combat')
        .setStyle(ButtonStyle.Secondary)
    );

    const combatSummary = combatState ? this.combatSystem.getCombatSummary(combatState) : null;
    const embed = combatSummary
      ? UIBuilder.createCombatStateEmbed(combatSummary)
      : new EmbedBuilder().setColor(0xff6600).setTitle('‚öîÔ∏è Combat');

    embed.addFields({
      name: '‚öîÔ∏è Choose a Move',
      value: 'Pick one of your 4 moves for this turn.',
      inline: false,
    });

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  /**
   * Refresh combat state without advancing the turn
   */
  async handleCombatRefresh(interaction, player) {
    const combatState = this.combatSystem.getActiveCombat(player.userId);
    if (!combatState) {
      // Check if player is in a guild with an active boss
      const guild = this.guildManager.getPlayerGuild(player.userId);
      if (guild?.activeBoss) {
        await this.handleGuildBosses(interaction, player);
        return;
      }
      await interaction.reply({ content: 'You are not in combat.', ephemeral: true });
      return;
    }

    if (combatState.meta?.type === 'guild_boss') {
      const guild = this.guildManager.getPlayerGuild(player.userId);
      if (guild?.activeBoss) {
        this.syncGuildBossCombatState(combatState, guild.activeBoss);
      }
    }

    const combatSummary = this.combatSystem.getCombatSummary(combatState);
    const embed = UIBuilder.createCombatStateEmbed(combatSummary);
    const buttons = combatState.meta?.type === 'guild_boss'
      ? this.createGuildBossCombatButtons()
      : this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Execute a combat skill selection
   */
  async handleCombatSkillSelect(interaction, player, skillId) {
    if (this.isGuildBossCombat(player)) {
      await this.handleGuildBossCombatTurn(interaction, player, { type: 'skill', skillId });
      return;
    }

    const result = this.combatSystem.executeRoundWithSkill(player.userId, skillId);

    // Track skill usage
    if (!result.error && result.status !== 'error') {
      const skillData = getSkill ? getSkill(skillId) : null;
      const skillName = skillData?.name || skillId;
      const dmg = result.combatState?.lastPlayerDamage || result.playerDamage || 0;
      this.trackSkillUsage(player, skillName, dmg);
    }

    if (result.error) {
      await interaction.reply({ content: result.error, ephemeral: true });
      return;
    }

    if (result.status === 'error') {
      await interaction.reply({ content: result.error || 'Skill cannot be used.', ephemeral: true });
      return;
    }

    if (result.status === 'ongoing') {
      if (!result.combatState) {
        await interaction.reply({
          content: '‚ö†Ô∏è Combat state was lost. Ending battle.',
          ephemeral: true,
        });
        player.isInCombat = false;
        player.currentEnemy = null;
        this.persistPlayer(player);
        return;
      }

      const embed = UIBuilder.createCombatStateEmbed(result.combatState);
      const buttons = this.createCombatButtons(false); // Gear button removed after attack

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: buttons,
      });
      return;
    }

    if (result.status === 'victory' || result.status === 'defeat') {
      // Use the player from result if available (has combat modifications)
      const combatPlayer = result.player || player;
      await this.handleCombatResolution(interaction, combatPlayer, result);
    }
  }

  /**
   * Show gear set selection menu during combat
   */
  async handleCombatGearSet(interaction, player) {
    if (!this.combatSystem.isInCombat(player.userId)) {
      const guild = this.guildManager.getPlayerGuild(player.userId);
      if (guild?.activeBoss) {
        await this.handleGuildBosses(interaction, player);
        return;
      }
      await interaction.reply({ content: 'You are not in combat.', ephemeral: true });
      return;
    }

    // Get saved equipment sets
    const equipmentSets = player.equipmentSets || [];
    if (equipmentSets.length === 0) {
      await interaction.reply({ 
        content: 'No saved equipment sets. Create one in Equipment menu first!', 
        ephemeral: true 
      });
      return;
    }

    const options = equipmentSets.slice(0, 25).map((set, index) => ({
      label: `${index + 1}. ${set.name || `Set ${index + 1}`}`.substring(0, 100),
      value: String(index),
      description: (set.description || 'Switch to this set').substring(0, 100),
      emoji: '‚öôÔ∏è',
    }));

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-combat-gear-select')
        .setPlaceholder('Select a gear set to equip')
        .addOptions(options)
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-refresh')
        .setLabel('‚Üê Back to Combat')
        .setStyle(ButtonStyle.Secondary)
    );

    const combatState = this.combatSystem.getActiveCombat(player.userId);
    const combatSummary = combatState ? this.combatSystem.getCombatSummary(combatState) : null;
    const embed = combatSummary
      ? UIBuilder.createCombatStateEmbed(combatSummary)
      : new EmbedBuilder().setColor(0xff6600).setTitle('‚öîÔ∏è Combat');

    embed.addFields({
      name: '‚öôÔ∏è Switch Gear Set',
      value: 'Switching consumes your turn, and the enemy will act.',
      inline: false,
    });

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  /**
   * Execute gear set change
   */
  async handleCombatGearSelect(interaction, player, setIndex) {
    if (this.isGuildBossCombat(player)) {
      await this.handleGuildBossCombatTurn(interaction, player, { type: 'gear', setIndex });
      return;
    }

    const combatState = this.combatSystem.getActiveCombat(player.userId);
    if (!combatState) {
      const guild = this.guildManager.getPlayerGuild(player.userId);
      if (guild?.activeBoss) {
        await this.handleGuildBosses(interaction, player);
        return;
      }
      await interaction.reply({ content: 'You are not in combat.', ephemeral: true });
      return;
    }

    // Get the equipment set
    const equipmentSet = player.equipmentSets?.[setIndex];
    if (!equipmentSet || !equipmentSet.items) {
      await interaction.reply({ content: 'Equipment set not found.', ephemeral: true });
      return;
    }

    // Update player's equipped items
    player.equippedItems = { ...equipmentSet.items };
    player.clearStatsCache();

    // Also update the combat state player's equipment
    if (combatState.player) {
      combatState.player.equippedItems = { ...equipmentSet.items };
      if (combatState.player.clearStatsCache) {
        combatState.player.clearStatsCache();
      }
    }

    // Execute the round (consume the turn)
    const result = this.combatSystem.executeRound(player.userId);

    if (result.error) {
      await interaction.reply({ content: result.error, ephemeral: true });
      return;
    }

    if (result.status === 'ongoing') {
      if (!result.combatState) {
        await interaction.reply({
          content: '‚ö†Ô∏è Combat state was lost. Ending battle.',
          ephemeral: true,
        });
        player.isInCombat = false;
        player.currentEnemy = null;
        this.persistPlayer(player);
        return;
      }

      const embed = UIBuilder.createCombatStateEmbed(result.combatState);
      const buttons = this.createCombatButtons(); // Show all buttons on next turn

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: buttons,
      });

      // Persist the gear change
      this.persistPlayer(player);
      return;
    }

    if (result.status === 'victory' || result.status === 'defeat') {
      const combatPlayer = result.player || player;
      await this.handleCombatResolution(interaction, combatPlayer, result);
    }
  }

  /**
   * Show party switch menu
   */
  async handleCombatSwitchMenu(interaction, player) {
    const combatState = this.combatSystem.getActiveCombat(player.userId);
    if (!combatState) {
      const guild = this.guildManager.getPlayerGuild(player.userId);
      if (guild?.activeBoss) {
        await this.handleGuildBosses(interaction, player);
        return;
      }
      await interaction.reply({ content: 'You are not in combat.', ephemeral: true });
      return;
    }

    const party = combatState.party;
    if (!party || !Array.isArray(party.members) || party.members.length < 2) {
      await interaction.reply({ content: 'No party members available to switch.', ephemeral: true });
      return;
    }

    const options = party.members.slice(0, 4).map((member, index) => {
      const isActive = index === party.activeIndex;
      return {
        label: member.name || `Member ${index + 1}`,
        value: String(index),
        description: isActive ? 'Active' : 'Switch to this member',
        emoji: isActive ? '‚úÖ' : 'üîÅ',
      };
    });

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-combat-switch-select')
        .setPlaceholder('Select a party member')
        .addOptions(options)
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-refresh')
        .setLabel('‚Üê Back to Combat')
        .setStyle(ButtonStyle.Secondary)
    );

    const combatSummary = this.combatSystem.getCombatSummary(combatState);
    const embed = UIBuilder.createCombatStateEmbed(combatSummary);
    embed.addFields({
      name: 'üîÅ Switch Party Member',
      value: 'Switching consumes your turn, and the enemy will act.',
      inline: false,
    });

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  /**
   * Show combat stance selection
   */
  async handleCombatStanceMenu(interaction, player) {
    const combatState = this.combatSystem.getActiveCombat(player.userId);
    if (!combatState) {
      const guild = this.guildManager.getPlayerGuild(player.userId);
      if (guild?.activeBoss) {
        await this.handleGuildBosses(interaction, player);
        return;
      }
      await interaction.reply({ content: 'You are not in combat.', ephemeral: true });
      return;
    }

    const currentStance = combatState.playerStance || 'balanced';
    const stances = [
      { id: 'balanced', label: 'Balanced', description: 'No modifiers', emoji: '‚öñÔ∏è' },
      { id: 'aggressive', label: 'Aggressive', description: '+15% damage dealt, +10% damage taken', emoji: 'üî•' },
      { id: 'defensive', label: 'Defensive', description: '-10% damage dealt, -20% damage taken', emoji: 'üõ°Ô∏è' },
      { id: 'focused', label: 'Focused', description: '+10% accuracy and crit for skills', emoji: 'üéØ' },
      { id: 'evasive', label: 'Evasive', description: '-10% accuracy, +10% dodge chance', emoji: 'üí®' },
    ];

    const options = stances.map((stance) => ({
      label: `${stance.label}${stance.id === currentStance ? ' (Current)' : ''}`.substring(0, 100),
      value: stance.id,
      description: stance.description.substring(0, 100),
      emoji: stance.emoji,
    }));

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-combat-stance-select')
        .setPlaceholder('Choose a stance for this turn')
        .addOptions(options)
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-refresh')
        .setLabel('‚Üê Back to Combat')
        .setStyle(ButtonStyle.Secondary)
    );

    const combatSummary = this.combatSystem.getCombatSummary(combatState);
    const embed = UIBuilder.createCombatStateEmbed(combatSummary);
    embed.addFields({
      name: 'üõ°Ô∏è Choose a Stance',
      value: 'Selecting a stance uses your turn and the enemy will act.',
      inline: false,
    });

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  /**
   * Execute party switch
   */
  async handleCombatSwitchSelect(interaction, player, switchIndex) {
    if (this.isGuildBossCombat(player)) {
      await this.handleGuildBossCombatTurn(interaction, player, { type: 'switch', switchIndex });
      return;
    }

    const result = this.combatSystem.executeRoundWithSwitch(player.userId, switchIndex);

    if (result.error) {
      await interaction.reply({ content: result.error, ephemeral: true });
      return;
    }

    if (result.status === 'error') {
      await interaction.reply({ content: result.error || 'Cannot switch party member.', ephemeral: true });
      return;
    }

    if (result.status === 'ongoing') {
      if (!result.combatState) {
        await interaction.reply({
          content: '‚ö†Ô∏è Combat state was lost. Ending battle.',
          ephemeral: true,
        });
        player.isInCombat = false;
        player.currentEnemy = null;
        this.persistPlayer(player);
        return;
      }

      const embed = UIBuilder.createCombatStateEmbed(result.combatState);
      const buttons = this.createCombatButtons();

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: buttons,
      });
      return;
    }

    if (result.status === 'victory' || result.status === 'defeat') {
      // Use the player from result if available (has combat modifications)
      const combatPlayer = result.player || player;
      await this.handleCombatResolution(interaction, combatPlayer, result);
    }
  }

  /**
   * Execute stance selection
   */
  async handleCombatStanceSelect(interaction, player, stanceId) {
    if (this.isGuildBossCombat(player)) {
      await this.handleGuildBossCombatTurn(interaction, player, { type: 'stance', stanceId });
      return;
    }

    const result = this.combatSystem.executeRoundWithStance(player.userId, stanceId);

    if (result.error) {
      await interaction.reply({ content: result.error, ephemeral: true });
      return;
    }

    if (result.status === 'ongoing') {
      if (!result.combatState) {
        await interaction.reply({
          content: '‚ö†Ô∏è Combat state was lost. Ending battle.',
          ephemeral: true,
        });
        player.isInCombat = false;
        player.currentEnemy = null;
        this.persistPlayer(player);
        return;
      }

      const embed = UIBuilder.createCombatStateEmbed(result.combatState);
      const buttons = this.createCombatButtons();

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: buttons,
      });
      return;
    }

    if (result.status === 'victory' || result.status === 'defeat') {
      const combatPlayer = result.player || player;
      await this.handleCombatResolution(interaction, combatPlayer, result);
    }
  }

  /**
   * Forfeit combat and exit
   */
  async handleCombatForfeit(interaction, player) {
    const combatState = this.combatSystem.getActiveCombat(player.userId);
    
    // Allow forfeit even without active combat to help players exit combat screen
    if (combatState) {
      // End active combat without rewards
      this.combatSystem.forceEndCombat(player.userId);
    }
    
    // Restore some HP so player isn't punished too harshly
    player.hp = Math.max(player.hp, Math.floor(player.maxHp * 0.5));
    player.isInCombat = false;
    player.currentEnemy = null;
    player.currentMenu = 'combat-menu';

    const embed = new EmbedBuilder()
      .setColor(0xffa500)
      .setTitle('üèÉ Combat Forfeited')
      .setDescription(
        combatState 
          ? `You have fled from combat!\n\n` +
            `**HP Restored:** ${player.hp}/${player.maxHp}\n\n` +
            `You can start a new adventure whenever you're ready.`
          : `Combat screen cleared!\n\n` +
            `**Current HP:** ${player.hp}/${player.maxHp}\n\n` +
            `You can start a new adventure whenever you're ready.`
      );

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-menu')
        .setLabel('‚öîÔ∏è Return to Combat')
        .setStyle(ButtonStyle.Primary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backButton],
    });
  }

  /**
   * Handle combat completion and rewards
   */
  async handleCombatResolution(interaction, player, result) {
    if (result.status === 'victory' && result.meta?.type === 'worldBoss') {
      this.unlockNextWorld(player, result.meta.worldId);
    }

    // Reset menu state so back button works properly after combat
    if (result.meta?.type === 'arena') {
      player.currentMenu = 'arena';
    } else if (result.meta?.type === 'dungeon' || result.meta?.type === 'raid' || result.meta?.type === 'boss') {
      player.currentMenu = 'combat-menu';
    } else {
      player.currentMenu = 'main';
    }

    // Handle defense quest completion rewards
    let defenseQuestRewardsText = null;
    let questLevelUp = null;
    if (result.status === 'victory' && result.meta?.defenseQuest) {
      const quest = getDefenseQuestById(result.meta.defenseQuest);
      if (quest?.reward && !player.hasQuestFlag(quest.id)) {
        const reward = quest.reward;
        if (reward.xp) questLevelUp = player.addXp(reward.xp);
        if (reward.gold) this.addGold(player, reward.gold);

        const itemNames = [];
        for (const rewardItem of (reward.items || [])) {
          const { id, quantity } = rewardItem;
          const equipment = getEquipment(id);
          const item = getItemByIdDynamic(id);
          const material = getMaterial(id);

          if (equipment) {
            this.addCraftedItem(player, equipment.id, quantity || 1);
            itemNames.push(`${equipment.name} x${quantity || 1}`);
          } else if (item) {
            this.addCraftedItem(player, item.id, quantity || 1);
            itemNames.push(`${item.name} x${quantity || 1}`);
          } else if (material) {
            this.addMaterialToInventory(player, material.id, quantity || 1);
            itemNames.push(`${material.name} x${quantity || 1}`);
          }
        }

        player.setQuestFlag(quest.id, true);

        if (reward.unlockClass && !player.classUnlocked && player.internalClass) {
          const playerClass = getClass(player.internalClass);
          player.class = player.internalClass;
          player.classUnlocked = true;
          if (playerClass?.startingSkills?.length) {
            for (const skillId of playerClass.startingSkills) {
              if (!player.skills.includes(skillId)) player.skills.push(skillId);
            }
          }
        }

        const rewardParts = [];
        if (reward.xp) rewardParts.push(`+${reward.xp} XP`);
        if (reward.gold) rewardParts.push(`+${reward.gold} gold`);
        if (itemNames.length > 0) rewardParts.push(`Items: ${itemNames.join(', ')}`);
        if (reward.unlockClass) rewardParts.push('Class Unlocked');
        defenseQuestRewardsText = rewardParts.join('\n');
      }
    }

    // Handle world quest completion rewards
    let worldQuestRewardsText = null;
    let nextQuestInChain = null;
    let choiceQuestForSelection = null;
    if (result.status === 'victory' && result.meta?.worldQuest) {
      const { main, side, daily } = getQuestCategoriesByWorld(player.currentWorld);
      const allQuests = [...(main || []), ...(side || []), ...(daily || [])];
      const quest = allQuests.find(q => q.id === result.meta.worldQuest);
      
      if (quest?.reward && !player.hasQuestFlag(quest.id)) {
        const reward = quest.reward;
        if (reward.xp) player.addXp(reward.xp);
        if (reward.gold) this.addGold(player, reward.gold);

        const itemNames = [];
        for (const rewardItem of (reward.items || [])) {
          const { id, quantity } = rewardItem;
          const equipment = getEquipment(id);
          const item = getItemByIdDynamic(id);
          const material = getMaterial(id);

          if (equipment) {
            this.addCraftedItem(player, equipment.id, quantity || 1);
            itemNames.push(`${equipment.name} x${quantity || 1}`);
          } else if (item) {
            this.addCraftedItem(player, item.id, quantity || 1);
            itemNames.push(`${item.name} x${quantity || 1}`);
          } else if (material) {
            this.addMaterialToInventory(player, material.id, quantity || 1);
            itemNames.push(`${material.name} x${quantity || 1}`);
          }
        }

        player.setQuestFlag(quest.id, true);

        const rewardParts = [];
        if (reward.xp) rewardParts.push(`+${reward.xp} XP`);
        if (reward.gold) rewardParts.push(`+${reward.gold} gold`);
        if (itemNames.length > 0) rewardParts.push(`Items: ${itemNames.join(', ')}`);
        worldQuestRewardsText = `‚úÖ **${quest.name}** Complete!\n${rewardParts.join('\n')}`;
        
        // Check if there's a next quest in the chain
        if (quest.nextQuestId) {
          nextQuestInChain = allQuests.find(q => q.id === quest.nextQuestId);
        } else {
          nextQuestInChain = this.inferNextQuestInChain(quest, allQuests);
        }

        // Check if this is a choice quest with branches (only when no linear next step)
        if (!nextQuestInChain && Array.isArray(quest.branches) && quest.branches.length > 0) {
          choiceQuestForSelection = quest;
          worldQuestRewardsText += `\n\nüîÄ **Quest continues with a choice!**`;
        }
      }
    }

    let dungeonRewardsText = null;
    if (result.status === 'victory' && result.meta?.type === 'dungeon') {
      // Always give rewards after completing a floor
      const dungeon = getDungeonById(result.meta.dungeonId);
        if (dungeon) {
          const currentFloor = result.meta?.currentFloor || 1;
          
          // Use floor-specific rewards if available
          const floorReward = dungeon.floorRewards?.[currentFloor] || dungeon.rewards;
          
          if (floorReward) {
            let extraXp = floorReward.xp || 0;
            const extraGold = floorReward.gold || 0;
            const loot = floorReward.loot || floorReward.items || [];
            const materials = floorReward.materials || [];

            // Apply XP potion bonus to dungeon rewards
            if (extraXp > 0 && player.potionBuffs) {
              if (player.potionBuffs.xpRemaining && player.potionBuffs.xpRemaining > 0 && player.potionBuffs.xpBonus) {
                const bonusXp = Math.floor(extraXp * (player.potionBuffs.xpBonus / 100));
                extraXp += bonusXp;
                // Note: potion charges are decremented in CombatSystem, not here
              }
            }

            if (extraXp > 0) player.addXp(extraXp);
            if (extraGold > 0) this.addGold(player, extraGold);

            const lootNames = [];
            
            // Process loot items (can be items, equipment, or materials)
            let weaponGiven = false;
            const playerClass = player.class || player.internalClass;
            
            for (const lootItem of loot) {
              // Handle both string IDs and { id, quantity } objects
              let itemId, quantity;
              if (typeof lootItem === 'string') {
                itemId = lootItem;
                quantity = 1;
              } else {
                itemId = lootItem.id;
                quantity = lootItem.quantity || 1;
              }
              
              const equipment = getEquipment(itemId);
              const item = getItemByIdDynamic(itemId);
              const material = getMaterial(itemId);

              if (equipment) {
                // Handle class-aware weapon distribution
                if (equipment.slot === 'weapon') {
                  // Skip if we already gave a weapon from this package
                  if (weaponGiven) continue;
                  
                  // If weapon is restricted to another class, try to substitute
                  if (equipment.classRestriction && equipment.classRestriction !== playerClass) {
                    const classWeapon = this.findClassWeaponInLoot(loot, playerClass);
                    if (classWeapon) {
                      this.addCraftedItem(player, classWeapon.id, quantity);
                      lootNames.push(`${classWeapon.name} x${quantity}`);
                      weaponGiven = true;
                      continue;
                    }
                    // No class weapon available, skip this weapon
                    continue;
                  }
                }
                
                this.addCraftedItem(player, equipment.id, quantity);
                lootNames.push(`${equipment.name} x${quantity}`);
                
                if (equipment.slot === 'weapon') {
                  weaponGiven = true;
                }
              } else if (item) {
                this.addCraftedItem(player, item.id, quantity);
                lootNames.push(`${item.name} x${quantity}`);
              } else if (material) {
                this.addMaterialToInventory(player, material.id, quantity);
                lootNames.push(`${material.name} x${quantity}`);
              }
            }
            
            // Process explicit materials field
            for (const matItem of materials) {
              // Handle both string IDs and { id, quantity } objects
              let matId, quantity;
              if (typeof matItem === 'string') {
                matId = matItem;
                quantity = 1;
              } else {
                matId = matItem.id;
                quantity = matItem.quantity || 1;
              }
              
              const material = getMaterial(matId);
              if (material) {
                this.addMaterialToInventory(player, material.id, quantity);
                lootNames.push(`${material.name} x${quantity}`);
              }
            }

            const rewardParts = [];
            if (extraXp > 0) rewardParts.push(`+${extraXp} XP`);
            if (extraGold > 0) rewardParts.push(`+${extraGold} gold`);
            if (lootNames.length > 0) rewardParts.push(`Loot: ${lootNames.join(', ')}`);
            dungeonRewardsText = `**Floor ${currentFloor} Rewards:**\n${rewardParts.join('\n')}`;
          }
        }
    }

    // Handle BOSS ENCOUNTER rewards (single-floor, massive rewards)
    let bossRewardsText = null;
    if (result.status === 'victory' && result.meta?.type === 'boss') {
      const bossData = result.meta?.bossData;
      
      if (bossData) {
        const lootNames = [];
        
        // Give XP and Gold
        if (bossData.xpReward) {
          player.addXp(bossData.xpReward);
        }
        if (bossData.goldReward) {
          this.addGold(player, bossData.goldReward);
        }
        
        // Give Materials
        if (bossData.materials && Array.isArray(bossData.materials)) {
          for (const matItem of bossData.materials) {
            const material = getMaterial(matItem.id);
            if (material) {
              this.addMaterialToInventory(player, material.id, matItem.quantity || 1);
              lootNames.push(`${material.name} x${matItem.quantity || 1}`);
            } else {
              // Fallback if material not found
              this.addMaterialToInventory(player, matItem.id, matItem.quantity || 1);
              lootNames.push(`${matItem.id} x${matItem.quantity || 1}`);
            }
          }
        }
        
        // Give Potions
        if (bossData.potions && Array.isArray(bossData.potions)) {
          for (const potionItem of bossData.potions) {
            const potion = getItemByIdDynamic(potionItem.id);
            if (potion) {
              this.addCraftedItem(player, potion.id, potionItem.quantity || 1);
              lootNames.push(`${potion.name} x${potionItem.quantity || 1}`);
            } else {
              // Fallback if potion not found
              this.addCraftedItem(player, potionItem.id, potionItem.quantity || 1);
              lootNames.push(`${potionItem.id} x${potionItem.quantity || 1}`);
            }
          }
        }
        
        // Give Enchantments
        if (bossData.enchants && Array.isArray(bossData.enchants)) {
          for (const enchantItem of bossData.enchants) {
            const enchant = getItemByIdDynamic(enchantItem.id);
            if (enchant) {
              this.addCraftedItem(player, enchant.id, enchantItem.quantity || 1);
              lootNames.push(`${enchant.name} x${enchantItem.quantity || 1}`);
            } else {
              // Fallback if enchant not found
              this.addCraftedItem(player, enchantItem.id, enchantItem.quantity || 1);
              lootNames.push(`${enchantItem.id} x${enchantItem.quantity || 1}`);
            }
          }
        }
        
        // Give Equipment Loot
        if (bossData.loot && Array.isArray(bossData.loot)) {
          const playerClass = player.class || player.internalClass;
          let weaponGiven = false;
          
          for (const lootItem of bossData.loot) {
            const equipment = getEquipment(lootItem);
            const item = getItemByIdDynamic(lootItem);
            
            if (equipment) {
              // Handle class-aware weapon distribution
              if (equipment.slot === 'weapon') {
                if (weaponGiven) continue;
                
                if (equipment.classRestriction && equipment.classRestriction !== playerClass) {
                  continue;  // Skip wrong-class weapons
                }
                weaponGiven = true;
              }
              
              this.addCraftedItem(player, equipment.id, 1);
              lootNames.push(equipment.name);
            } else if (item) {
              this.addCraftedItem(player, item.id, 1);
              lootNames.push(item.name);
            } else {
              // If item still not found, still add it - addCraftedItem handles the fallback
              const fallbackName = lootItem.startsWith('item_') 
                ? `Unknown Item (${lootItem.slice(-6)})`
                : lootItem;
              this.addCraftedItem(player, lootItem, 1);
              lootNames.push(fallbackName);
            }
          }
        }

        const rewardParts = [];
        if (bossData.xpReward) rewardParts.push(`üí´ +${bossData.xpReward.toLocaleString()} XP`);
        if (bossData.goldReward) rewardParts.push(`üí∞ +${bossData.goldReward.toLocaleString()} Gold`);
        if (lootNames.length > 0) {
          rewardParts.push(`\nüéÅ **Boss Loot:**\n${lootNames.join('\n')}`);
        }
        
        if (rewardParts.length === 0) {
          rewardParts.push('No rewards found (check configuration)');
        }
        
        bossRewardsText = `üëπ **BOSS DEFEATED!**\n${rewardParts.join('\n')}`;
      } else {
        // Fallback for bosses without explicit reward data
        const bossXp = Math.floor((player.level * 200) + 1000);
        const bossGold = Math.floor((player.level * 100) + 500);
        player.addXp(bossXp);
        this.addGold(player, bossGold);
        bossRewardsText = `üëπ **BOSS DEFEATED!**\nüí´ +${bossXp.toLocaleString()} XP\nüí∞ +${bossGold.toLocaleString()} Gold`;
      }
    }

    // Track guild quest progress for combat victories
    let guildQuestUpdateText = null;
    if (result.status === 'victory' && result.enemy?.name !== 'Training Dummy') {
      // Track monsters defeated for progress stats
      if (!player.progressStats) {
        player.progressStats = {
          monstersDefeated: 0,
          gatheringActions: 0,
          materialsCollected: 0,
          craftsCompleted: 0,
          goldEarned: 0,
          criticalHits: 0,
          dungeonsCleared: 0,
          raidsCleared: 0,
        };
      }
      player.progressStats.monstersDefeated += 1;

      // Track combat result (win)
      const combatType = result.meta?.type || 'normal';
      this.trackCombatResult(player, result.enemy?.name || 'Unknown', 'victory', combatType);

      // Update guild quest progress
      const dailyQuests = getAvailableDailyQuests(player.level, player.dailyQuestsCompleted);
      const weeklyQuests = getAvailableWeeklyQuests(player.level, player.weeklyQuestsCompleted);
      const claimedLimited = (player.claimedQuests || [])
        .map(id => getGuildQuestById(id))
        .filter(Boolean)
        .filter(q => !player.limitedQuestsCompleted.includes(q.id));

      if (!player.guildQuestProgress) player.guildQuestProgress = {};
      
      const updates = [];
      const completions = [];
      const tags = [];
      
      if (result.meta?.type === 'worldBoss') {
        tags.push('boss', 'world_boss');
      }
      if (result.meta?.type === 'dungeon') {
        tags.push('dungeon');
      }
      if (result.meta?.type === 'raid') {
        tags.push('raid', 'boss');
      }

      const enemyName = result.enemy?.name || '';
      const event = {
        type: 'kill',
        target: 'enemy',
        targetName: enemyName,
        enemy: enemyName,
        count: 1,
        tags
      };

      const questResult = this.applyGuildQuestProgress(player, dailyQuests, weeklyQuests, claimedLimited, event);
      updates.push(...questResult.updates);
      completions.push(...questResult.completions);

      if (updates.length > 0) {
        guildQuestUpdateText = `üìã Guild Quest Progress:\n${updates.join('\n')}`;
      }
      if (completions.length > 0) {
        if (guildQuestUpdateText) {
          guildQuestUpdateText += `\n\n${completions.join('\n')}`;
        } else {
          guildQuestUpdateText = completions.join('\n');
        }
      }
    }

    // Handle arena points
    let arenaRewardText = null;
    if (result.status === 'victory' && result.meta?.type === 'arena') {
      const isPlayerOpponent = result.meta?.opponent === 'player';
      const opponentSnapshot = result.meta?.opponentSnapshot;
      
      // Calculate fair arena points based on level difference
      let arenaPointsGained = isPlayerOpponent ? 50 : 10;
      
      if (isPlayerOpponent && opponentSnapshot) {
        const levelDiff = opponentSnapshot.level - player.level;
        // Base 50 points, adjusted by level difference
        // +10% per level above player, -15% per level below (less fair = less points)
        const multiplier = 1 + (levelDiff * (levelDiff >= 0 ? 0.10 : -0.15));
        arenaPointsGained = Math.max(10, Math.round(50 * multiplier));
      }
      
      const oldPoints = player.arenaPoints || 0;
      player.arenaPoints = oldPoints + arenaPointsGained;
      arenaRewardText = `‚öîÔ∏è **+${arenaPointsGained} Arena Points** (Total: ${player.arenaPoints})`;
      console.log(`[Arena] ${player.username} earned ${arenaPointsGained} AP (${oldPoints} ‚Üí ${player.arenaPoints})`);
      
      // Persist immediately after arena points
      this.persistPlayer(player);
    }

    // Save last enemy for Enemy Summary feature
    if (result.enemy) {
      player.lastEnemy = {
        name: result.enemy.name,
        level: result.enemy.level,
        type: result.enemy.type,
        currentHp: result.enemy.currentHp,
        maxHp: result.enemy.maxHp,
        stats: result.enemy.stats,
        abilities: result.enemy.abilities,
        resistances: result.enemy.resistances
      };
    }

    // Persist player for other changes
    if (result.status !== 'victory' || result.meta?.type !== 'arena') {
      this.persistPlayer(player);
    }

    const embed = UIBuilder.createCombatEndEmbed(
      result.status === 'victory',
      player,
      result.enemy,
      result.xpGained
    );

    // Add improvement suggestions for defeat
    if (result.status === 'defeat') {
      // Track combat defeat + death
      const defeatType = result.meta?.type || 'normal';
      this.trackCombatResult(player, result.enemy?.name || 'Unknown', 'defeat', defeatType);
      this.trackDeath(player, result.enemy, defeatType);

      const suggestions = [];
      
      // Check if player has unspent skill/talent points
      const availableSkillPoints = player.skillPoints || 0;
      const availableTalentPoints = player.talentPoints || 0;
      const playerGold = player.gold || 0;
      
      if (availableTalentPoints > 0) {
        suggestions.push(`üåü **Upgrade Talents** - You have ${availableTalentPoints} unspent talent point${availableTalentPoints > 1 ? 's' : ''}! Click the button below.`);
      }
      
      if (availableSkillPoints > 0) {
        suggestions.push(`‚ö° **Upgrade Skills** - You have ${availableSkillPoints} skill point${availableSkillPoints > 1 ? 's' : ''} available! Click the button below.`);
      }
      
      // Check blacksmith level for crafting
      const blacksmithLevel = player.professions?.blacksmith?.level || 0;
      if (blacksmithLevel >= 1) {
        suggestions.push(`üî® **Craft Better Gear** - Your Blacksmith is level ${blacksmithLevel}. Check crafting!`);
      }
      
      // Check if player has low-quality equipment or gold to upgrade
      const equipment = player.equippedItems || {};
      const hasBasicGear = Object.values(equipment).some(item => {
        const equip = getEquipment(item);
        return equip && (!equip.rarity || equip.rarity === 'common');
      });
      
      if (hasBasicGear || Object.keys(equipment).length < 5) {
        suggestions.push(`‚öîÔ∏è **Upgrade Equipment** - Visit Equipment menu or shop for better gear!`);
      }
      
      if (playerGold >= 100) {
        suggestions.push(`üí∞ **Buy Better Gear** - You have ${playerGold} gold! Browse the shop for upgrades.`);
      }
      
      // Suggest using potions
      suggestions.push(`üß™ **Use Potions** - Health potions heal at combat start!`);
      
      // Suggest training
      suggestions.push(`üéØ **Train More** - Practice with the Training Dummy to test strategies!`);
      
      if (suggestions.length > 0) {
        embed.addFields({
          name: 'üí° Quick Improvements Available',
          value: suggestions.join('\n'),
          inline: false,
        });
      }
      
      // Show available resources
      const resourceList = [];
      if (availableTalentPoints > 0) resourceList.push(`üåü ${availableTalentPoints} Talent Point${availableTalentPoints > 1 ? 's' : ''}`);
      if (availableSkillPoints > 0) resourceList.push(`‚ö° ${availableSkillPoints} Skill Point${availableSkillPoints > 1 ? 's' : ''}`);
      if (playerGold >= 100) resourceList.push(`üí∞ ${playerGold} Gold`);
      
      if (resourceList.length > 0) {
        embed.addFields({
          name: 'üìä Your Available Resources',
          value: resourceList.join(' ‚Ä¢ '),
          inline: false,
        });
      }
    }

    // Add level-up notification if applicable
    const combatLevelUp = result.levelUp || questLevelUp;
    if (combatLevelUp && combatLevelUp.levelsGained > 0) {
      const levelUpText = this.createLevelUpMessage(combatLevelUp);
      if (levelUpText) {
        embed.addFields({
          name: 'üéâ Level Up!',
          value: levelUpText.trim(),
          inline: false,
        });
      }
    }

    if (defenseQuestRewardsText) {
      embed.addFields({
        name: 'üõ°Ô∏è Quest Rewards',
        value: defenseQuestRewardsText,
        inline: false,
      });
    }

    if (worldQuestRewardsText) {
      embed.addFields({
        name: 'üìú Quest Complete!',
        value: worldQuestRewardsText,
        inline: false,
      });
    }

    if (dungeonRewardsText) {
      embed.addFields({
        name: 'üè∞ Dungeon Rewards',
        value: dungeonRewardsText,
        inline: false,
      });
    }

    if (bossRewardsText) {
      embed.addFields({
        name: 'üëπ Boss Rewards',
        value: bossRewardsText,
        inline: false,
      });
    }

    if (arenaRewardText) {
      embed.addFields({
        name: 'üéØ Arena Rewards',
        value: arenaRewardText,
        inline: false,
      });
    }

    if (guildQuestUpdateText) {
      embed.addFields({
        name: 'üìã Guild Quest Progress',
        value: guildQuestUpdateText,
        inline: false,
      });
    }

    // Create buttons row - don't add back button yet for boss encounters (will add custom one)
    const buttons = new ActionRowBuilder();
    
    // Add improvement buttons for defeat
    if (result.status === 'defeat') {
      const availableSkillPoints = player.skillPoints || 0;
      const availableTalentPoints = player.talentPoints || 0;
      const blacksmithLevel = player.professions?.blacksmith?.level || 0;
      
      // Check if player can craft better equipment than what they have
      const canCraftBetterEquipment = () => {
        if (blacksmithLevel < 1) return false;
        
        try {
          // Load crafting recipes
          const craftingDataPath = path.join(process.cwd(), 'data', 'crafting.json');
          const craftingData = JSON.parse(fs.readFileSync(craftingDataPath, 'utf8'));
          const recipes = craftingData.recipes || {};
          
          // Get player's equipped items stats/tier
          const equippedItems = player.equippedItems || {};
          const allEquipment = getEquipment();
          
          // Find recipes player can craft
          const craftableRecipes = Object.values(recipes).filter(recipe => 
            recipe.profession === 'blacksmith' && recipe.level <= blacksmithLevel
          );
          
          // Check if any craftable item would be better than current equipment
          for (const recipe of craftableRecipes) {
            const craftableItemId = recipe.output?.item;
            if (!craftableItemId) continue;
            
            const craftableItem = allEquipment.find(item => item.id === craftableItemId);
            if (!craftableItem) continue;
            
            const slot = craftableItem.slot;
            if (!slot) continue;
            
            // If slot is empty, player can craft better equipment
            if (!equippedItems[slot]) return true;
            
            // If slot has item, check if craftable item is better
            const equippedItemId = equippedItems[slot];
            const equippedItem = allEquipment.find(item => item.id === equippedItemId);
            
            if (equippedItem && craftableItem) {
              // Simple comparison: check rarity levels
              const rarityOrder = ['common', 'uncommon', 'rare', 'epic', 'legendary', 'mythic'];
              const equippedRarity = rarityOrder.indexOf(equippedItem.rarity || 'common');
              const craftableRarity = rarityOrder.indexOf(craftableItem.rarity || 'common');
              
              if (craftableRarity > equippedRarity) return true;
              
              // If same rarity, compare total stats
              const equippedStats = Object.values(equippedItem.stats || {}).reduce((sum, val) => sum + Math.abs(val), 0);
              const craftableStats = Object.values(craftableItem.stats || {}).reduce((sum, val) => sum + Math.abs(val), 0);
              
              if (craftableStats > equippedStats) return true;
            }
          }
          
          return false;
        } catch (error) {
          console.error('Error checking craftable equipment:', error);
          return blacksmithLevel >= 1; // Fallback to just checking blacksmith level
        }
      };
      
      // Add back button first
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );
      
      // Add improvement buttons based on what's available
      if (availableTalentPoints > 0) {
        buttons.addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-talents')
            .setLabel('üåü Talents')
            .setStyle(ButtonStyle.Success)
        );
      }
      
      if (availableSkillPoints > 0) {
        buttons.addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-skills')
            .setLabel('‚ö° Skills')
            .setStyle(ButtonStyle.Success)
        );
      }
      
      if (canCraftBetterEquipment()) {
        buttons.addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-crafting')
            .setLabel('üî® Crafting')
            .setStyle(ButtonStyle.Primary)
        );
      }
      
      // Add shop button if player has enough gold
      const playerGold = player.gold || 0;
      if (playerGold >= 100 && buttons.components.length < 5) {
        buttons.addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-shop')
            .setLabel('üõí Shop')
            .setStyle(ButtonStyle.Primary)
        );
      }
      
      // Always show equipment option if space available
      if (buttons.components.length < 5) {
        buttons.addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-equipment')
            .setLabel('‚öîÔ∏è Equipment')
            .setStyle(ButtonStyle.Primary)
        );
      }
    }
    // Add back button for non-boss victories
    else if (!(result.status === 'victory' && result.meta?.type === 'boss')) {
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );
    }

    // Check if dungeon has more floors to complete
    if (result.status === 'victory' && result.meta?.type === 'dungeon') {
      const currentFloor = result.meta?.currentFloor || 1;
      const totalFloors = result.meta?.totalFloors || 3;
      const dungeonId = result.meta?.dungeonId;
      
      // If not claiming reward (just completed floor), show choice
      if (!result.meta?.claimReward) {
        if (currentFloor < totalFloors) {
          // More floors available - give player a choice
          buttons.addComponents(
            new ButtonBuilder()
              .setCustomId(`rpg-dungeon-claim-${dungeonId}-${currentFloor}`)
              .setLabel(`üí∞ Claim Floor ${currentFloor} Reward`)
              .setStyle(ButtonStyle.Success),
            new ButtonBuilder()
              .setCustomId(`rpg-dungeon-continue-${dungeonId}-${currentFloor}`)
              .setLabel(`‚¨ÜÔ∏è Risk Floor ${currentFloor + 1}/${totalFloors}`)
              .setStyle(ButtonStyle.Danger)
          );
          
          embed.setFooter({ text: `Floor ${currentFloor}/${totalFloors} Complete! Claim your reward or risk it for better loot on Floor ${currentFloor + 1}...` });
        } else {
          // Last floor - auto-claim
          buttons.addComponents(
            new ButtonBuilder()
              .setCustomId(`rpg-dungeon-claim-${dungeonId}-${currentFloor}`)
              .setLabel(`üí∞ Claim Floor ${currentFloor} Reward`)
              .setStyle(ButtonStyle.Success)
          );
          
          embed.setFooter({ text: `All ${totalFloors} floors cleared! Claim your final reward!` });
        }
      } else {
        // Reward was claimed - show redo button
        buttons.addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-redo-dungeon-${dungeonId}`)
            .setLabel('üîÑ Redo Dungeon')
            .setStyle(ButtonStyle.Primary)
        );
        
        embed.setFooter({ text: `Dungeon completed! You claimed Floor ${currentFloor} rewards.` });
      }
    }
    
    // Check if raid has more bosses to fight
    if (result.status === 'victory' && result.meta?.type === 'raid') {
      const currentBossIndex = result.meta?.bossIndex || 0;
      const totalBosses = result.meta?.totalBosses || 1;
      
      if (currentBossIndex < totalBosses - 1) {
        // More bosses to fight - add continue button
        buttons.addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-raid-continue-${result.meta?.raidId}-${currentBossIndex}`)
            .setLabel(`‚öîÔ∏è Boss ${currentBossIndex + 2}/${totalBosses}`)
            .setStyle(ButtonStyle.Primary)
        );
        
        embed.setFooter({ text: `Boss ${currentBossIndex + 1}/${totalBosses} Defeated! Continue to the next boss...` });
      } else {
        // All bosses defeated - add redo button
        buttons.addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-redo-raid-${result.meta?.raidId}`)
            .setLabel('üîÑ Redo Raid')
            .setStyle(ButtonStyle.Success)
        );
        
        embed.setFooter({ text: `All ${totalBosses} bosses defeated! Raid complete!` });
      }
    }

    // Handle boss encounter (single floor)
    if (result.status === 'victory' && result.meta?.type === 'boss') {
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('Return to Menu')
          .setStyle(ButtonStyle.Primary)
      );
      
      embed.setFooter({ text: 'üëπ Boss Defeated! Legendary rewards claimed!' });
    }

    // Handle training dummy victory - add repeat button
    if (result.status === 'victory' && result.enemy?.name === 'Training Dummy') {
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-repeat-training')
          .setLabel('üîÅ Fight Again')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );
      
      embed.setFooter({ text: '‚úÖ Training complete! Ready for another round?' });
    }

    // Add "Continue Quest Chain" button if there's a next quest
    if (nextQuestInChain && result.status === 'victory') {
      // Check if there's space in the button row
      if (buttons.components.length < 5) {
        buttons.addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-quest-view-detail-${nextQuestInChain.id}`)
            .setLabel('‚û°Ô∏è Continue Quest')
            .setStyle(ButtonStyle.Success)
        );
      }
      
      // Add notification to the embed
      embed.setFooter({ text: `‚õìÔ∏è Quest chain continues: ${nextQuestInChain.name}` });
    }

    // Add "Choose Path" button when the completed quest has branch choices
    if (!nextQuestInChain && choiceQuestForSelection && result.status === 'victory') {
      if (buttons.components.length < 5) {
        buttons.addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-quest-view-detail-${choiceQuestForSelection.id}`)
            .setLabel('üîÄ Choose Path')
            .setStyle(ButtonStyle.Success)
        );
      }

      embed.setFooter({ text: 'üîÄ Choice available: select your quest path.' });
    }

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Handle auto battle - runs combat to completion
   */
  /**
   * Handle manual combat - show action menu
   */
  async handleCombatManual(interaction, player) {
    await interaction.deferUpdate();

    if (!player.isInCombat) {
      await interaction.followUp({
        content: '‚ùå You are not in combat.',
        ephemeral: true,
      });
      return;
    }

    const combatState = this.combatSystem.activeCombats.get(player.userId);
    if (!combatState) {
      await interaction.followUp({
        content: '‚ùå Combat state not found.',
        ephemeral: true,
      });
      return;
    }

    // Show combat UI with action buttons
    await this.displayCombatUI(interaction, player, combatState);
  }

  /**
   * Display combat UI with all available actions
   */
  async displayCombatUI(interaction, player, combatState) {
    const { enemy, round, log, worldState } = combatState;

    // Create combat status embed
    const embed = new EmbedBuilder()
      .setColor(0xe74c3c)
      .setTitle(`‚öîÔ∏è Combat - Round ${round}`)
      .setDescription(
        `**${player.username}** vs **${enemy.name}** (Lvl ${enemy.level})\n\n` +
        `‚ù§Ô∏è Your HP: **${player.hp}/${player.maxHp}**\n` +
        `üëπ Enemy HP: **${enemy.hp}/${enemy.maxHp}**\n\n` +
        `**Recent Actions:**\n${log.slice(-5).join('\n')}`
      )
      .setTimestamp();

    // Add world state modifiers if any
    if (worldState?.modifiers) {
      const mods = [];
      if (worldState.modifiers.xpGain !== 1) mods.push(`XP: ${Math.round(worldState.modifiers.xpGain * 100)}%`);
      if (worldState.modifiers.goldGain !== 1) mods.push(`Gold: ${Math.round(worldState.modifiers.goldGain * 100)}%`);
      if (mods.length > 0) {
        embed.addFields({ name: 'üåç World Modifiers', value: mods.join(' | '), inline: false });
      }
    }

    // Create action buttons
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-action-attack')
        .setLabel('‚öîÔ∏è Attack')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-combat-action-defend')
        .setLabel('üõ°Ô∏è Defend')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-combat-action-skill')
        .setLabel('‚ú® Use Skill')
        .setStyle(ButtonStyle.Success)
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-action-potion')
        .setLabel('üíä Use Potion')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-combat-auto')
        .setLabel('‚ö° Switch to Auto')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-combat-forfeit')
        .setLabel('üè≥Ô∏è Forfeit')
        .setStyle(ButtonStyle.Danger)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2],
    });
  }

  /**
   * Handle combat action - attack
   */
  async handleCombatActionAttack(interaction, player) {
    await interaction.deferUpdate();

    if (!player.isInCombat) {
      await interaction.followUp({ content: '‚ùå Not in combat.', ephemeral: true });
      return;
    }

    // Execute one round with player attacking
    const result = this.combatSystem.executeRound(player.userId, 'attack');
    
    if (result.error) {
      await interaction.followUp({ content: result.error, ephemeral: true });
      return;
    }

    if (result.status === 'victory' || result.status === 'defeat') {
      await this.handleCombatResolution(interaction, result.player || player, result);
    } else {
      const combatState = this.combatSystem.activeCombats.get(player.userId);
      await this.displayCombatUI(interaction, player, combatState);
    }
  }

  /**
   * Handle combat action - defend
   */
  async handleCombatActionDefend(interaction, player) {
    await interaction.deferUpdate();

    if (!player.isInCombat) {
      await interaction.followUp({ content: '‚ùå Not in combat.', ephemeral: true });
      return;
    }

    // Execute one round with player defending
    const result = this.combatSystem.executeRound(player.userId, 'defend');
    
    if (result.error) {
      await interaction.followUp({ content: result.error, ephemeral: true });
      return;
    }

    if (result.status === 'victory' || result.status === 'defeat') {
      await this.handleCombatResolution(interaction, result.player || player, result);
    } else {
      const combatState = this.combatSystem.activeCombats.get(player.userId);
      await this.displayCombatUI(interaction, player, combatState);
    }
  }

  /**
   * Handle auto combat (existing function)
   */
  async handleCombatAuto(interaction, player) {
    await interaction.deferUpdate();

    if (this.isGuildBossCombat(player)) {
      await interaction.followUp({
        content: '‚ùå Auto battle is disabled for guild bosses. Choose your actions manually.',
        ephemeral: true,
      });
      return;
    }

    let result;
    let rounds = 0;
    const MAX_ROUNDS = 50;

    while (rounds < MAX_ROUNDS) {
      result = this.combatSystem.executeRound(player.userId);
      rounds++;

      if (result.error || result.status === 'victory' || result.status === 'defeat') {
        break;
      }
    }

    if (!result || result.error) {
      await interaction.followUp({
        content: result?.error || 'Combat error',
        ephemeral: true,
      });
      return;
    }

    if (result.status === 'victory' || result.status === 'defeat') {
      // Use the player from combat result (has XP, gold, and combat modifications)
      player = result.player || player;
      
      // Reset menu state so back button works properly after combat
      if (result.meta?.type === 'arena') {
        player.currentMenu = 'arena';
      } else if (result.meta?.type === 'dungeon' || result.meta?.type === 'raid' || result.meta?.type === 'boss') {
        player.currentMenu = 'combat-menu';
      } else {
        player.currentMenu = 'main';
      }
      
      if (result.status === 'victory' && result.meta?.type === 'worldBoss') {
        this.unlockNextWorld(player, result.meta.worldId);
      }

      // Handle defense quest completion rewards
      let defenseQuestRewardsText = null;
      if (result.status === 'victory' && result.meta?.defenseQuest) {
        const quest = getDefenseQuestById(result.meta.defenseQuest);
        if (quest?.reward && !player.hasQuestFlag(quest.id)) {
          const reward = quest.reward;
          if (reward.xp) player.addXp(reward.xp);
          if (reward.gold) this.addGold(player, reward.gold);

          const itemNames = [];
          for (const rewardItem of (reward.items || [])) {
            const { id, quantity } = rewardItem;
            const equipment = getEquipment(id);
            const item = getItemByIdDynamic(id);
            const material = getMaterial(id);

            if (equipment) {
              this.addCraftedItem(player, equipment.id, quantity || 1);
              itemNames.push(`${equipment.name} x${quantity || 1}`);
            } else if (item) {
              this.addCraftedItem(player, item.id, quantity || 1);
              itemNames.push(`${item.name} x${quantity || 1}`);
            } else if (material) {
              this.addMaterialToInventory(player, material.id, quantity || 1);
              itemNames.push(`${material.name} x${quantity || 1}`);
            }
          }

          player.setQuestFlag(quest.id, true);

          if (reward.unlockClass && !player.classUnlocked && player.internalClass) {
            const playerClass = getClass(player.internalClass);
            player.class = player.internalClass;
            player.classUnlocked = true;
            if (playerClass?.startingSkills?.length) {
              for (const skillId of playerClass.startingSkills) {
                if (!player.skills.includes(skillId)) player.skills.push(skillId);
              }
            }
          }

          const rewardParts = [];
          if (reward.xp) rewardParts.push(`+${reward.xp} XP`);
          if (reward.gold) rewardParts.push(`+${reward.gold} gold`);
          if (itemNames.length > 0) rewardParts.push(`Items: ${itemNames.join(', ')}`);
          if (reward.unlockClass) rewardParts.push('Class Unlocked');
          defenseQuestRewardsText = rewardParts.join('\n');
        }
      }

      // Handle world quest completion rewards
      let worldQuestRewardsText = null;
      let nextQuestInChain = null;
      let choiceQuestForSelection = null;
      if (result.status === 'victory' && result.meta?.worldQuest) {
        const { main, side, daily } = getQuestCategoriesByWorld(player.currentWorld);
        const allQuests = [...(main || []), ...(side || []), ...(daily || [])];
        const quest = allQuests.find(q => q.id === result.meta.worldQuest);
        
        if (quest?.reward && !player.hasQuestFlag(quest.id)) {
          const reward = quest.reward;
          if (reward.xp) player.addXp(reward.xp);
          if (reward.gold) this.addGold(player, reward.gold);

          const itemNames = [];
          for (const rewardItem of (reward.items || [])) {
            const { id, quantity } = rewardItem;
            const equipment = getEquipment(id);
            const item = getItemByIdDynamic(id);
            const material = getMaterial(id);

            if (equipment) {
              this.addCraftedItem(player, equipment.id, quantity || 1);
              itemNames.push(`${equipment.name} x${quantity || 1}`);
            } else if (item) {
              this.addCraftedItem(player, item.id, quantity || 1);
              itemNames.push(`${item.name} x${quantity || 1}`);
            } else if (material) {
              this.addMaterialToInventory(player, material.id, quantity || 1);
              itemNames.push(`${material.name} x${quantity || 1}`);
            }
          }

          player.setQuestFlag(quest.id, true);

          const rewardParts = [];
          if (reward.xp) rewardParts.push(`+${reward.xp} XP`);
          if (reward.gold) rewardParts.push(`+${reward.gold} gold`);
          if (itemNames.length > 0) rewardParts.push(`Items: ${itemNames.join(', ')}`);
          worldQuestRewardsText = `‚úÖ **${quest.name}** Complete!\n${rewardParts.join('\n')}`;

          if (quest.nextQuestId) {
            nextQuestInChain = allQuests.find(q => q.id === quest.nextQuestId);
          } else {
            nextQuestInChain = this.inferNextQuestInChain(quest, allQuests);
          }

          if (!nextQuestInChain && Array.isArray(quest.branches) && quest.branches.length > 0) {
            choiceQuestForSelection = quest;
            worldQuestRewardsText += `\n\nüîÄ **Quest continues with a choice!**`;
          }
        }
      }

      let dungeonRewardsText = null;
      if (result.status === 'victory' && result.meta?.type === 'dungeon') {
        const dungeon = getDungeonById(result.meta.dungeonId);
        if (dungeon) {
          const currentFloor = result.meta?.currentFloor || 1;
          const floorReward = dungeon.floorRewards?.[currentFloor] || dungeon.rewards;

          let extraXp = floorReward?.xp || 0;
          const extraGold = floorReward?.gold || 0;
          const loot = floorReward?.loot || floorReward?.items || [];
          const materials = floorReward?.materials || [];

          // Apply XP potion bonus to dungeon rewards
          if (extraXp > 0 && player.potionBuffs) {
            if (player.potionBuffs.xpRemaining && player.potionBuffs.xpRemaining > 0 && player.potionBuffs.xpBonus) {
              const bonusXp = Math.floor(extraXp * (player.potionBuffs.xpBonus / 100));
              extraXp += bonusXp;
              // Note: potion charges are decremented in CombatSystem, not here
            }
          }

          if (extraXp > 0) player.addXp(extraXp);
          if (extraGold > 0) this.addGold(player, extraGold);

          const lootNames = [];
          
          // Process loot items (can be items, equipment, or materials)
          let weaponGiven = false;
          const playerClass = player.class || player.internalClass;
          
          for (const lootItem of loot) {
            // Handle both string IDs and { id, quantity } objects
            let itemId, quantity;
            if (typeof lootItem === 'string') {
              itemId = lootItem;
              quantity = 1;
            } else {
              itemId = lootItem.id;
              quantity = lootItem.quantity || 1;
            }
            
            const equipment = getEquipment(itemId);
            const item = getItemByIdDynamic(itemId);
            const material = getMaterial(itemId);

            if (equipment) {
              // Handle class-aware weapon distribution
              if (equipment.slot === 'weapon') {
                // Skip if we already gave a weapon from this package
                if (weaponGiven) continue;
                
                // If weapon is restricted to another class, try to substitute
                if (equipment.classRestriction && equipment.classRestriction !== playerClass) {
                  const classWeapon = this.findClassWeaponInLoot(loot, playerClass);
                  if (classWeapon) {
                    this.addCraftedItem(player, classWeapon.id, quantity);
                    lootNames.push(`${classWeapon.name} x${quantity}`);
                    weaponGiven = true;
                    continue;
                  }
                  // No class weapon available, skip this weapon
                  continue;
                }
              }
              
              this.addCraftedItem(player, equipment.id, quantity);
              lootNames.push(`${equipment.name} x${quantity}`);
              
              if (equipment.slot === 'weapon') {
                weaponGiven = true;
              }
            } else if (item) {
              this.addCraftedItem(player, item.id, quantity);
              lootNames.push(`${item.name} x${quantity}`);
            } else if (material) {
              this.addMaterialToInventory(player, material.id, quantity);
              lootNames.push(`${material.name} x${quantity}`);
            }
          }
          
          // Process explicit materials field
          for (const matItem of materials) {
            // Handle both string IDs and { id, quantity } objects
            let matId, quantity;
            if (typeof matItem === 'string') {
              matId = matItem;
              quantity = 1;
            } else {
              matId = matItem.id;
              quantity = matItem.quantity || 1;
            }
            
            const material = getMaterial(matId);
            if (material) {
              this.addMaterialToInventory(player, material.id, quantity);
              lootNames.push(`${material.name} x${quantity}`);
            }
          }

          const rewardParts = [];
          if (extraXp > 0) rewardParts.push(`+${extraXp} XP`);
          if (extraGold > 0) rewardParts.push(`+${extraGold} gold`);
          if (lootNames.length > 0) rewardParts.push(`Loot: ${lootNames.join(', ')}`);
          dungeonRewardsText = `**Floor ${currentFloor} Rewards:**\n${rewardParts.join('\n')}`;
        }
      }

      // Handle BOSS ENCOUNTER rewards (single-floor, massive rewards)
      let bossRewardsText = null;
      if (result.status === 'victory' && result.meta?.type === 'boss') {
        const bossData = result.meta?.bossData;
        
        if (bossData) {
          const lootNames = [];
          
          // Give XP and Gold
          if (bossData.xpReward) {
            player.addXp(bossData.xpReward);
          }
          if (bossData.goldReward) {
            this.addGold(player, bossData.goldReward);
          }
          
          // Give Materials
          if (bossData.materials && Array.isArray(bossData.materials)) {
            for (const matItem of bossData.materials) {
              const material = getMaterial(matItem.id);
              if (material) {
                this.addMaterialToInventory(player, material.id, matItem.quantity || 1);
                lootNames.push(`${material.name} x${matItem.quantity || 1}`);
              } else {
                // Fallback if material not found
                this.addMaterialToInventory(player, matItem.id, matItem.quantity || 1);
                lootNames.push(`${matItem.id} x${matItem.quantity || 1}`);
              }
            }
          }
          
          // Give Potions
          if (bossData.potions && Array.isArray(bossData.potions)) {
            for (const potionItem of bossData.potions) {
              const potion = getItemByIdDynamic(potionItem.id);
              if (potion) {
                this.addCraftedItem(player, potion.id, potionItem.quantity || 1);
                lootNames.push(`${potion.name} x${potionItem.quantity || 1}`);
              } else {
                // Fallback if potion not found
                this.addCraftedItem(player, potionItem.id, potionItem.quantity || 1);
                lootNames.push(`${potionItem.id} x${potionItem.quantity || 1}`);
              }
            }
          }
          
          // Give Enchantments
          if (bossData.enchants && Array.isArray(bossData.enchants)) {
            for (const enchantItem of bossData.enchants) {
              const enchant = getItemByIdDynamic(enchantItem.id);
              if (enchant) {
                this.addCraftedItem(player, enchant.id, enchantItem.quantity || 1);
                lootNames.push(`${enchant.name} x${enchantItem.quantity || 1}`);
              } else {
                // Fallback if enchant not found
                this.addCraftedItem(player, enchantItem.id, enchantItem.quantity || 1);
                lootNames.push(`${enchantItem.id} x${enchantItem.quantity || 1}`);
              }
            }
          }
          
          // Give Equipment Loot
          if (bossData.loot && Array.isArray(bossData.loot)) {
            const playerClass = player.class || player.internalClass;
            let weaponGiven = false;
            
            for (const lootItem of bossData.loot) {
              const equipment = getEquipment(lootItem);
              const item = getItemByIdDynamic(lootItem);
              
              if (equipment) {
                // Handle class-aware weapon distribution
                if (equipment.slot === 'weapon') {
                  if (weaponGiven) continue;
                  
                  if (equipment.classRestriction && equipment.classRestriction !== playerClass) {
                    continue;  // Skip wrong-class weapons
                  }
                  weaponGiven = true;
                }
                
                this.addCraftedItem(player, equipment.id, 1);
                lootNames.push(equipment.name);
              } else if (item) {
                this.addCraftedItem(player, item.id, 1);
                lootNames.push(item.name);
              } else {
                // If item still not found, still add it - addCraftedItem handles the fallback
                const fallbackName = lootItem.startsWith('item_') 
                  ? `Unknown Item (${lootItem.slice(-6)})`
                  : lootItem;
                this.addCraftedItem(player, lootItem, 1);
                lootNames.push(fallbackName);
              }
            }
          }

          const rewardParts = [];
          if (bossData.xpReward) rewardParts.push(`üí´ +${bossData.xpReward.toLocaleString()} XP`);
          if (bossData.goldReward) rewardParts.push(`üí∞ +${bossData.goldReward.toLocaleString()} Gold`);
          if (lootNames.length > 0) {
            rewardParts.push(`\nüéÅ **Boss Loot:**\n${lootNames.join('\n')}`);
          }
          
          if (rewardParts.length === 0) {
            rewardParts.push('No rewards found (check configuration)');
          }
          
          bossRewardsText = `üëπ **BOSS DEFEATED!**\n${rewardParts.join('\n')}`;
        } else {
          // Fallback for bosses without explicit reward data
          const bossXp = Math.floor((player.level * 200) + 1000);
          const bossGold = Math.floor((player.level * 100) + 500);
          player.addXp(bossXp);
          this.addGold(player, bossGold);
          bossRewardsText = `üëπ **BOSS DEFEATED!**\nüí´ +${bossXp.toLocaleString()} XP\nüí∞ +${bossGold.toLocaleString()} Gold`;
        }
      }

      // Save last enemy for Enemy Summary feature
      if (result.enemy) {
        player.lastEnemy = {
          name: result.enemy.name,
          level: result.enemy.level,
          type: result.enemy.type,
          currentHp: result.enemy.currentHp,
          maxHp: result.enemy.maxHp,
          stats: result.enemy.stats,
          abilities: result.enemy.abilities,
          resistances: result.enemy.resistances
        };
      }

      this.persistPlayer(player);

      const embed = UIBuilder.createCombatEndEmbed(
        result.status === 'victory',
        player,
        result.enemy,
        result.xpGained
      );

      embed.setFooter({ text: `Battle completed in ${rounds} rounds` });

      if (defenseQuestRewardsText) {
        embed.addFields({
          name: 'üõ°Ô∏è Quest Rewards',
          value: defenseQuestRewardsText,
          inline: false,
        });
      }

      if (worldQuestRewardsText) {
        embed.addFields({
          name: 'üìú Quest Complete!',
          value: worldQuestRewardsText,
          inline: false,
        });
      }

      if (dungeonRewardsText) {
        embed.addFields({
          name: 'üè∞ Dungeon Rewards',
          value: dungeonRewardsText,
          inline: false,
        });
      }

      if (bossRewardsText) {
        embed.addFields({
          name: 'üëπ Boss Rewards',
          value: bossRewardsText,
          inline: false,
        });
      }

      // Handle arena points
      let arenaRewardText = null;
      if (result.status === 'victory' && result.meta?.type === 'arena') {
        const isPlayerOpponent = result.meta?.opponent === 'player';
        const opponentSnapshot = result.meta?.opponentSnapshot;
        
        // Calculate fair arena points based on level difference
        let arenaPointsGained = isPlayerOpponent ? 50 : 10;
        
        if (isPlayerOpponent && opponentSnapshot) {
          const levelDiff = opponentSnapshot.level - player.level;
          // Base 50 points, adjusted by level difference
          // +10% per level above player, -15% per level below (less fair = less points)
          const multiplier = 1 + (levelDiff * (levelDiff >= 0 ? 0.10 : -0.15));
          arenaPointsGained = Math.max(10, Math.round(50 * multiplier));
        }
        
        player.arenaPoints = (player.arenaPoints || 0) + arenaPointsGained;
        arenaRewardText = `‚öîÔ∏è **+${arenaPointsGained} Arena Points** (Total: ${player.arenaPoints})`;
        
        // Persist again with arena points
        this.persistPlayer(player);
      }

      if (arenaRewardText) {
        embed.addFields({
          name: 'üéØ Arena Rewards',
          value: arenaRewardText,
          inline: false,
        });
      }

      const backTarget = (result.meta?.worldQuest || result.meta?.defenseQuest)
        ? 'rpg-quest-back'
        : result.meta?.type === 'dungeon'
          ? 'rpg-combat-menu'
          : 'rpg-back';
      const backLabel = backTarget === 'rpg-quest-back'
        ? '‚Üê Back to Quests'
        : backTarget === 'rpg-combat-menu'
          ? '‚Üê Back to Combat'
          : '‚Üê Back';
      const buttons = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(backTarget)
          .setLabel(backLabel)
          .setStyle(ButtonStyle.Secondary)
      );

      // Check if dungeon has more floors to complete
      if (result.status === 'victory' && result.meta?.type === 'dungeon') {
        const currentFloor = result.meta?.currentFloor || 1;
        const totalFloors = result.meta?.totalFloors || 3;
        const dungeonId = result.meta?.dungeonId;
        
        // If not claiming reward (just completed floor), show choice
        if (!result.meta?.claimReward) {
          if (currentFloor < totalFloors) {
            // More floors available - give player a choice
            buttons.addComponents(
              new ButtonBuilder()
                .setCustomId(`rpg-dungeon-claim-${dungeonId}-${currentFloor}`)
                .setLabel(`üí∞ Claim Floor ${currentFloor} Reward`)
                .setStyle(ButtonStyle.Success),
              new ButtonBuilder()
                .setCustomId(`rpg-dungeon-continue-${dungeonId}-${currentFloor}`)
                .setLabel(`‚¨ÜÔ∏è Risk Floor ${currentFloor + 1}/${totalFloors}`)
                .setStyle(ButtonStyle.Danger)
            );
            
            embed.setFooter({ text: `Floor ${currentFloor}/${totalFloors} Complete! Claim your reward or risk it for better loot on Floor ${currentFloor + 1}...` });
          } else {
            // Last floor - auto-claim
            buttons.addComponents(
              new ButtonBuilder()
                .setCustomId(`rpg-dungeon-claim-${dungeonId}-${currentFloor}`)
                .setLabel(`üí∞ Claim Floor ${currentFloor} Reward`)
                .setStyle(ButtonStyle.Success)
            );
            
            embed.setFooter({ text: `All ${totalFloors} floors cleared! Claim your final reward!` });
          }
        } else {
          // Reward was claimed - show redo button
          buttons.addComponents(
            new ButtonBuilder()
              .setCustomId(`rpg-redo-dungeon-${dungeonId}`)
              .setLabel('üîÑ Redo Dungeon')
              .setStyle(ButtonStyle.Primary)
          );
          
          embed.setFooter({ text: `Dungeon completed! You claimed Floor ${currentFloor} rewards.` });
        }
      }

      if (nextQuestInChain && result.status === 'victory') {
        if (buttons.components.length < 5) {
          buttons.addComponents(
            new ButtonBuilder()
              .setCustomId(`rpg-quest-view-detail-${nextQuestInChain.id}`)
              .setLabel('‚û°Ô∏è Continue Quest')
              .setStyle(ButtonStyle.Success)
          );
        }

        embed.setFooter({ text: `‚õìÔ∏è Quest chain continues: ${nextQuestInChain.name}` });
      }

      if (!nextQuestInChain && choiceQuestForSelection && result.status === 'victory') {
        if (buttons.components.length < 5) {
          buttons.addComponents(
            new ButtonBuilder()
              .setCustomId(`rpg-quest-view-detail-${choiceQuestForSelection.id}`)
              .setLabel('üîÄ Choose Path')
              .setStyle(ButtonStyle.Success)
          );
        }

        embed.setFooter({ text: 'üîÄ Choice available: select your quest path.' });
      }

      await interaction.editReply({
        embeds: [embed],
        components: [buttons],
      });
    }
  }

  /**
   * Handle back button (return to main menu)
   */
  /**
   * Update interaction and track the message for auto-deletion
   */
  async updateInteractionWithTracking(interaction, options) {
    const startTime = Date.now();
    
    try {
      // Check if interaction is already replied or deferred
      if (interaction.replied) {
        await interaction.editReply(options);
      } else if (interaction.deferred) {
        await interaction.editReply(options);
      } else {
        await interaction.update(options);
      }
      
      // Always track ownership; auto-delete tracking remains optional
      this.trackMenuMessage(interaction.user.id, interaction);
      
      // Track performance metrics
      const responseTime = Date.now() - startTime;
      this.updatePerformanceMetrics(responseTime);
      
      // Log slow requests for debugging
      if (responseTime > 1000) {
        console.warn(`[Performance] Slow interaction: ${responseTime}ms - ${interaction.customId}`);
      }
    } catch (err) {
      // Gracefully handle expired interactions (15 minute timeout)
      if (err.code === 10062 || err.message?.includes('Unknown interaction')) {
        console.warn(`[Interaction] Expired interaction ignored: ${interaction.customId || 'unknown'}`);
        return; // Silently ignore - user was clicking old message
      }
      console.error('[Performance] Interaction update failed:', err);
      throw err;
    }
  }
  
  /**
   * Update performance metrics
   */
  updatePerformanceMetrics(responseTime) {
    this.performanceMetrics.totalRequests++;
    if (responseTime > 2000) {
      this.performanceMetrics.slowRequests++;
    }
    
    // Calculate rolling average
    const { avgResponseTime, totalRequests } = this.performanceMetrics;
    this.performanceMetrics.avgResponseTime = 
      ((avgResponseTime * (totalRequests - 1)) + responseTime) / totalRequests;
  }
  
  /**
   * Get performance statistics
   */
  getPerformanceStats() {
    const { totalRequests, slowRequests, avgResponseTime } = this.performanceMetrics;
    return {
      totalRequests,
      slowRequests,
      slowRequestRate: totalRequests > 0 ? (slowRequests / totalRequests * 100).toFixed(1) + '%' : '0%',
      avgResponseTime: avgResponseTime.toFixed(0) + 'ms',
      cacheSize: this.dataCache.size,
      playerCacheSize: this.playerCache.size
    };
  }

  /**
   * Track menu for auto-deletion on next interaction
   */
  trackMenuMessage(userId, interaction) {
    const messageId = interaction.message?.id;
    
    // Track by user ID for auto-deletion only when detailed tracking is enabled
    if (this.enableDetailedTracking) {
      this.activeMenus.set(userId, {
        messageId: messageId,
        channelId: interaction.channel?.id,
        timestamp: Date.now(),
      });
    }
    
    // Also track ownership by message ID to prevent other users from clicking
    if (messageId) {
      this.activeMenus.set(messageId, {
        ownerId: userId,
        timestamp: Date.now(),
      });
    }
  }

  /**
   * Track navigation when entering a menu
   */
  trackMenuNavigation(player, menuName) {
    // Skip tracking if disabled for performance
    if (!this.enableDetailedTracking) {
      player.currentMenu = menuName;
      return;
    }
    
    if (!player.menuHistory) player.menuHistory = [];
    if (!player.currentMenu) player.currentMenu = 'main';
    
    // Only add to history if different from current
    if (player.currentMenu !== menuName) {
      // Don't add duplicate consecutive entries
      const lastInHistory = player.menuHistory[player.menuHistory.length - 1];
      if (lastInHistory !== player.currentMenu) {
        player.menuHistory.push(player.currentMenu);
      }
      player.currentMenu = menuName;
      
      // Limit history to prevent infinite loops (max 10 levels deep)
      if (player.menuHistory.length > 10) {
        player.menuHistory = player.menuHistory.slice(-10);
      }
    }
  }

  /**
   * Get previous menu from history
   */
  getPreviousMenu(player) {
    if (!player.menuHistory || player.menuHistory.length === 0) {
      return 'main';
    }
    return player.menuHistory.pop();
  }

  async handleBackButton(interaction, player) {
    if (!player.characterCreated) {
      const embed = UIBuilder.createClassSelectionEmbed();
      const buttons = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-narrative-defender')
          .setLabel('1. Stand Your Ground')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-narrative-striker')
          .setLabel('2. Strike First')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('rpg-narrative-tactician')
          .setLabel('3. Study Patterns')
          .setStyle(ButtonStyle.Success)
      );

      await this.updateInteractionWithTracking(interaction, {
        content: 'Create your character by choosing a starter path:',
        embeds: [embed],
        components: [buttons],
      });
      return;
    }

    // Sub-menus that should go back to their parent menu
    const subMenuMap = {
      // Equipment sub-menus
      'manage-equipment': 'equipment',
      'equipment-sets': 'equipment',
      'upgrade': 'equipment',
      // Inventory sub-menus
      'inventory-rarity-filter': 'inventory',
      'inventory-profession-filter': 'inventory',
      // Professions sub-menus
      'alchemy': 'professions',
      'enchant': 'professions',
      // Skills sub-menus
      'skill-detail': 'skills',
      // Gathering sub-menus - gather goes to main since it's on the main menu
      'gather': 'main',
      'gather-area-select': 'gather',
      'gather-area-details': 'gather',
      'gather-area-drops': 'gather',
      'gather-rewards': 'gather',
      'autogather': 'gather',
      'gathering-tools': 'gather',
      'daily-rewards': 'main',
      // Stats sub-menus
      'stats-talents': 'stats',
      // Combat sub-menus (single parents - always come from combat-menu)
      'dungeon': 'combat-menu',
      'raids': 'combat-menu',
      'combat-training': 'combat-menu',
      'world-boss': 'combat-menu',
      // Arena sub-menus
      'arena': 'combat-menu',
      'arena-shop': 'arena',
      // Player sub-menus (character, skills, equipment, talents are sub-menus of player)
      'character': 'player',
      'skills': 'player',
      'equipment': 'player',
      'talents': 'player',
      'progress': 'main',
      'achievements': 'progress',
      'collectibles': 'progress',
      'collectibles-view': 'collectibles',
      'session-stats': 'progress',
      'story-log': 'player',
      // NOTE: Removed 'arena' from subMenuMap because it can be accessed from multiple parents
      // (combat-menu, economy, player, etc.). It now relies on history tracking for proper back navigation.
      // NOTE: Removed 'alchemy', 'enchant', 'professions' from subMenuMap because they have multiple parents:
      // - alchemy/enchant: accessible from both Crafting AND Professions menus
      // - professions: accessible from Crafting, Player, and Economy menus
      // These now rely on history stack for proper back navigation
    };

    // If current menu is a sub-menu, go to parent
    if (subMenuMap[player.currentMenu]) {
      const parentMenu = subMenuMap[player.currentMenu];
      
      // Remove the parent from history if it's at the end (prevents loops)
      if (player.menuHistory && player.menuHistory.length > 0 && 
          player.menuHistory[player.menuHistory.length - 1] === parentMenu) {
        player.menuHistory.pop();
      }
      
      player.currentMenu = parentMenu;
      
      // Call handler with skipTracking to prevent adding to history
      return await this.navigateToMenu(interaction, player, parentMenu, true);
    }

    // Get previous menu from history
    if (!player.menuHistory || player.menuHistory.length === 0) {
      // No history, go to main menu
      player.currentMenu = 'main';
      player.menuHistory = [];
      const embed = UIBuilder.createMainMenuEmbed(player, interaction.user);
      const buttons = this.createMainMenuButtons();
      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: buttons,
      });
      return;
    }

    const previousMenu = this.getPreviousMenu(player);
    
    // If going back to main, clear history
    if (previousMenu === 'main') {
      player.currentMenu = 'main';
      player.menuHistory = [];
      const embed = UIBuilder.createMainMenuEmbed(player, interaction.user);
      const buttons = this.createMainMenuButtons();
      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: buttons,
      });
      return;
    }

    // Route to the previous menu based on what it was
    player.currentMenu = previousMenu;
    return await this.navigateToMenu(interaction, player, previousMenu, true);
  }

  /**
   * Navigate to a specific menu
   */
  async navigateToMenu(interaction, player, menuName, skipTracking = false) {
    switch(menuName) {
      case 'main':
        player.currentMenu = 'main';
        player.menuHistory = [];
        const mainEmbed = UIBuilder.createMainMenuEmbed(player, interaction.user);
        const mainButtons = this.createMainMenuButtons();
        await this.updateInteractionWithTracking(interaction, {
          embeds: [mainEmbed],
          components: mainButtons,
        });
        return;
      case 'player':
        return await this.handlePlayerMenu(interaction, player, skipTracking);
      case 'character':
        return await this.handleCharacterSheet(interaction, player, skipTracking);
      case 'inventory':
        return await this.handleInventory(interaction, player, skipTracking);
      case 'skills':
        return await this.handleSkills(interaction, player, skipTracking);
      case 'equipment':
        return await this.handleEquipment(interaction, player, skipTracking);
      case 'talents':
        return await this.handleTalents(interaction, player, skipTracking);
      case 'stats':
        return await this.handleStats(interaction, player, skipTracking);
      case 'quests':
        return await this.handleQuests(interaction, player, skipTracking);
      case 'goals':
        return await this.handleGoals(interaction, player, skipTracking);
      case 'crafting':
        return await this.handleCrafting(interaction, player, skipTracking);
      case 'professions':
        return await this.handleProfessions(interaction, player, skipTracking);
      case 'alchemy':
        return await this.handleAlchemy(interaction, player, skipTracking);
      case 'enchant':
        return await this.handleEnchant(interaction, player, skipTracking);
      case 'shop':
        return await this.handleShop(interaction, player, skipTracking);
      case 'adventure':
        return await this.handleAdventure(interaction, player, skipTracking);
      case 'gather':
        return await this.handleGatherMenu(interaction, player, skipTracking);
      case 'gather-area-select':
        return await this.handleGatheringAreaSelect(interaction, player, skipTracking);
      case 'dungeon':
        return await this.handleDungeons(interaction, player, skipTracking);
      case 'raids':
        return await this.handleRaids(interaction, player, skipTracking);
      case 'combat-menu':
        return await this.handleCombatMenu(interaction, player, skipTracking);
      case 'guild':
        return await this.handleGuild(interaction, player, skipTracking);
      case 'economy':
        return await this.handleEconomyMenu(interaction, player, skipTracking);
      case 'party':
        return await this.handlePartyMenu(interaction, player, skipTracking);
      case 'progress':
        return await this.handleProgressMenu(interaction, player, skipTracking);
      case 'achievements':
        return await this.handleAchievements(interaction, player, skipTracking);
      case 'collectibles':
        return await this.handleCollectibles(interaction, player, skipTracking);
      case 'help':
        return await this.handleHelpMenu(interaction, player, skipTracking);
      case 'story-log':
        return await this.handleStoryLog(interaction, player, skipTracking);
      default:
        // Fall back to main menu
        player.currentMenu = 'main';
        player.menuHistory = [];
        const embed = UIBuilder.createMainMenuEmbed(player, interaction.user);
        const buttons = this.createMainMenuButtons();
        await this.updateInteractionWithTracking(interaction, {
          embeds: [embed],
          components: buttons,
        });
        return;
    }
  }

  async handleBackToHub(interaction, player) {
    if (!player.characterCreated) {
      return await this.handleBackButton(interaction, player);
    }

    player.currentMenu = 'main';
    player.menuHistory = [];
    const embed = UIBuilder.createMainMenuEmbed(player, interaction.user);
    const buttons = this.createMainMenuButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Create combat action buttons
   */
  createCombatButtons(allowGearSwitch = true) {
    const row1Components = [
      new ButtonBuilder()
        .setCustomId('rpg-combat-next-turn')
        .setLabel('‚ö° Next Turn')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-combat-skill-menu')
        .setLabel('‚öîÔ∏è Skills')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-combat-stance-menu')
        .setLabel('üõ°Ô∏è Stance')
        .setStyle(ButtonStyle.Primary),
    ];

    if (allowGearSwitch) {
      row1Components.push(
        new ButtonBuilder()
          .setCustomId('rpg-combat-gear-set')
          .setLabel('‚öôÔ∏è Gear Set')
          .setStyle(ButtonStyle.Secondary)
      );
    }

    row1Components.push(
      new ButtonBuilder()
        .setCustomId('rpg-combat-auto')
        .setLabel('‚öîÔ∏è Auto')
        .setStyle(ButtonStyle.Secondary)
    );

    const row1 = new ActionRowBuilder().addComponents(row1Components);
    
    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-forfeit')
        .setLabel('üèÉ Forfeit & Exit')
        .setStyle(ButtonStyle.Danger)
    );

    return [row1, row2];
  }

  createGuildBossCombatButtons(allowGearSwitch = true) {
    const components = [
      new ButtonBuilder()
        .setCustomId('rpg-combat-next-turn')
        .setLabel('‚ö° Next Turn')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-combat-skill-menu')
        .setLabel('‚öîÔ∏è Skills')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-combat-stance-menu')
        .setLabel('üõ°Ô∏è Stance')
        .setStyle(ButtonStyle.Primary),
    ];

    if (allowGearSwitch) {
      components.push(
        new ButtonBuilder()
          .setCustomId('rpg-combat-gear-set')
          .setLabel('‚öôÔ∏è Gear Set')
          .setStyle(ButtonStyle.Secondary)
      );
    }

    components.push(
      new ButtonBuilder()
        .setCustomId('rpg-combat-refresh')
        .setLabel('üîÑ Refresh')
        .setStyle(ButtonStyle.Secondary)
    );

    const row1 = new ActionRowBuilder().addComponents(components);
    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-boss-attack')
        .setLabel('‚Üê Back to Boss')
        .setStyle(ButtonStyle.Secondary)
    );
    return [row1, row2];
  }

  /**
   * Handle class selection
   */
  async handleClassSelection(interaction, player) {
    const embed = UIBuilder.createClassSelectionEmbed();
    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-narrative-defender')
        .setLabel('1. Stand Your Ground')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-narrative-striker')
        .setLabel('2. Strike First')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-narrative-tactician')
        .setLabel('3. Study Patterns')
        .setStyle(ButtonStyle.Success)
    );

    const back = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons, back],
    });
  }

  async handleNarrativeChoice(interaction, player) {
    const choiceId = interaction.customId.replace('rpg-narrative-', '');
    const choice = getNarrativeChoice(choiceId);
    if (!choice) {
      await interaction.reply({
        content: 'Invalid choice.',
        ephemeral: true,
      });
      return;
    }

    player.applyNarrativeChoice(choiceId);
    player.characterCreated = false; // Still need to select actual class
    this.persistPlayer(player);

    // Show class selection
    const embed = new EmbedBuilder()
      .setColor(0x5865f2)
      .setTitle('üéì Choose Your Class')
      .setDescription(`Your narrative path: **${choice.title}**\n\nNow select your combat class:\n\n**Warrior** - High HP, strong defense, melee attacks\n**Mage** - High mana, powerful spells, ranged damage\n**Rogue** - High agility, critical strikes, swift attacks\n**Paladin** - Balanced fighter with healing abilities`);

    const classButtons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-select-warrior')
        .setLabel('‚öîÔ∏è Warrior')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-select-mage')
        .setLabel('üîÆ Mage')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-select-rogue')
        .setLabel('üó°Ô∏è Rogue')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-select-paladin')
        .setLabel('‚ú® Paladin')
        .setStyle(ButtonStyle.Primary)
    );

    await this.updateInteractionWithTracking(interaction, {
      content: `‚ú® Your path is chosen: **${choice.title}**`,
      embeds: [embed],
      components: [classButtons],
    });
  }

  /**
   * Handle class selection
   */
  async handleClassSelect(interaction, player) {
    const classId = interaction.customId.replace('rpg-select-', '');
    const classData = getClass(classId);
    
    if (!classData) {
      await interaction.reply({
        content: 'Invalid class selected.',
        ephemeral: true,
      });
      return;
    }

    // Apply class to player
    player.class = classId;
    player.classUnlocked = true;
    
    // Add starting skills
    if (classData.startingSkills) {
      player.skills = [...classData.startingSkills];
      // Initialize skill levels to 1 for starting skills
      for (const skillId of classData.startingSkills) {
        player.skillLevels[skillId] = 1;
      }
    }
    
    this.persistPlayer(player);

    const embed = UIBuilder.createStoryIntroEmbed();
    const continueButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-select-profession')
        .setLabel('Choose Profession')
        .setStyle(ButtonStyle.Success)
    );

    await this.updateInteractionWithTracking(interaction, {
      content: `‚öîÔ∏è Class selected: **${classData.name}**`,
      embeds: [embed],
      components: [continueButton],
    });
  }

  /**
   * Handle initial profession selection during character creation
   */
  async handleProfessionSelect(interaction, player) {
    const embed = new EmbedBuilder()
      .setColor('#9370DB')
      .setTitle('‚öôÔ∏è Choose Your First Profession')
      .setDescription(
        'Professions allow you to craft items, gather materials, and earn rewards. You can select another profession at level 10.\n\n' +
        '**Blacksmith** - Craft weapons and armor\n' +
        '**Botanic** - Craft potions and herbal remedies\n' +
        '**Enchanter** - Enhance equipment with magical properties'
      );

    const professions = [
      { label: 'Blacksmith', value: 'blacksmith', emoji: 'üî®' },
      { label: 'Botanic', value: 'botanic', emoji: 'üåø' },
      { label: 'Enchanter', value: 'enchanter', emoji: '‚ú®' },
    ];

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-profession-initial-select')
        .setPlaceholder('Choose your profession')
        .addOptions(professions.map((p) => ({
          label: p.label,
          value: p.value,
          emoji: p.emoji,
        })))
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow],
    });
  }

  /**
   * Enter the current world (Tier 1)
   */
  async handleEnterWorld(interaction, player) {
    if (!player.characterCreated) {
      await this.handleClassSelection(interaction, player);
      return;
    }

    const embed = UIBuilder.createMainMenuEmbed(player, interaction.user);
    const buttons = this.createMainMenuButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Handle character sheet
   */
  async handleCharacterSheet(interaction, player) {
    this.trackMenuNavigation(player, 'character');
    const embed = UIBuilder.createCharacterSheetEmbed(player);
    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Handle skills and talents
   */
  async handleSkills(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'skills');
    }

    const playerClass = player.class || player.internalClass;
    const classData = getClass(playerClass);
    
    const embed = new EmbedBuilder()
      .setColor('#9b59b6')
      .setTitle('‚ú® Skills & Talents')
      .setDescription(
        `Class: **${playerClass || 'None'}**\n` +
        `Level: **${player.level}** | Skill Points: **${player.skillPoints || 0}** üîµ`
      );

    // Show learned skills with current level
    if (player.skills && player.skills.length > 0) {
      const skillsList = player.skills
        .slice(0, 15)
        .map((skillId) => {
          const skill = getSkill(skillId);
          if (!skill) return `‚Ä¢ ${skillId}`;
          
          const currentLevel = player.skillLevels?.[skillId] || 1;
          const maxLevel = skill.maxLevel || 3;
          const levelText = `Lv ${currentLevel}/${maxLevel}`;
          const cooldown = skill.getCooldown ? skill.getCooldown(currentLevel) : skill.cooldown || 0;
          const cdText = cooldown > 0 ? ` [CD: ${cooldown} turns]` : '';
          
          let upgradeIcon = '';
          if (currentLevel < maxLevel && (player.skillPoints || 0) > 0) {
            upgradeIcon = ' üîº'; // Can upgrade
          }
          
          return `‚Ä¢ **${skill.name}** ${levelText}${cdText}${upgradeIcon}`;
        })
        .join('\n');

      const remaining = player.skills.length > 15 ? `\n+(${player.skills.length - 15} more)` : '';
      embed.addFields({
        name: '‚öîÔ∏è Learned Skills',
        value: skillsList + remaining,
        inline: false,
      });
    } else {
      embed.addFields({
        name: '‚öîÔ∏è Learned Skills',
        value: 'No skills learned yet. You start with 2 free skills!',
        inline: false,
      });
    }

    // Show unlockable skills from skill tree
    if (classData && classData.skillTree) {
      const unlockable = classData.skillTree
        .filter(entry => !player.skills.includes(entry.skillId))
        .filter(entry => player.level >= entry.unlockLevel)
        .slice(0, 8);

      if (unlockable.length > 0) {
        const unlockableList = unlockable.map(entry => {
          const skill = getSkill(entry.skillId);
          const canAfford = (player.skillPoints || 0) >= entry.pointCost;
          const icon = canAfford ? 'üîì' : 'üîí';
          const name = skill?.name || entry.skillId;
          return `${icon} **${name}** (Lv${entry.unlockLevel}, ${entry.pointCost} pts)`;
        }).join('\n');

        embed.addFields({
          name: 'üåü Available Skills',
          value: unlockableList,
          inline: false,
        });
      }
    }

    embed.addFields({
      name: 'üí° Tip',
      value: 'Select a skill to view details, upgrade, or unlock. You gain 1 skill point every 2 levels.',
      inline: false,
    });

    const rows = [];

    // Skill selection menu (learned + unlockable)
    const allSkillOptions = [];
    
    // Add learned skills
    if (player.skills && player.skills.length > 0) {
      player.skills.slice(0, 15).forEach(skillId => {
        const skill = getSkill(skillId);
        if (skill) {
          const currentLevel = player.skillLevels?.[skillId] || 1;
          allSkillOptions.push({
            label: `${skill.name} Lv${currentLevel}`.substring(0, 100),
            value: `learned-${skillId}`,
            description: (skill.description || 'No description').substring(0, 100),
            emoji: '‚öîÔ∏è',
          });
        }
      });
    }

    // Add unlockable skills
    if (classData && classData.skillTree) {
      const unlockable = classData.skillTree
        .filter(entry => !player.skills.includes(entry.skillId))
        .filter(entry => player.level >= entry.unlockLevel)
        .slice(0, 25 - allSkillOptions.length);

      unlockable.forEach(entry => {
        const skill = getSkill(entry.skillId);
        if (skill) {
          const canAfford = (player.skillPoints || 0) >= entry.pointCost;
          allSkillOptions.push({
            label: `üîí ${skill.name} (${entry.pointCost} pts)`.substring(0, 100),
            value: `unlock-${entry.skillId}`,
            description: (skill.description || 'No description').substring(0, 100),
            emoji: canAfford ? 'üîì' : 'üîí',
          });
        }
      });
    }

    if (allSkillOptions.length > 0) {
      const selectRow = new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-skill-select')
          .setPlaceholder('Select a skill to view or manage')
          .addOptions(allSkillOptions)
      );
      rows.push(selectRow);
    }

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );
    rows.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  /**
   * Calculate equipment score (sum of all stats for ranking)
   */
  calculateEquipmentScore(equipment) {
    if (!equipment) return 0;
    const stats = equipment.stats || equipment.bonuses || equipment;
    let score = 0;
    // Weight positive stats heavily, negative stats reduce score
    const statKeys = [
      'strength', 'defense', 'agility', 'intelligence', 'vitality', 'wisdom',
      'damage', 'hp', 'maxHp', 'mana', 'maxMana', 'damageBonus', 'spellPower',
      'critChance', 'critDamage', 'dodgeChance', 'blockChance', 'damageReduction',
      'hpRegen', 'luck', 'luckBonus'
    ];
    statKeys.forEach(key => {
      const value = stats[key];
      if (typeof value === 'number') {
        score += Math.abs(value) * (value > 0 ? 1 : 0.5);
      }
    });
    const rarityValues = { common: 1, uncommon: 2, rare: 3, epic: 4, legendary: 5, mythic: 6 };
    const rarityValue = rarityValues[String(equipment.rarity || '').toLowerCase()] || 0;
    if (rarityValue > 0) {
      score *= 1 + (rarityValue * 0.08);
    }
    return score;
  }

  /**
   * Find the best weapon/equipment overall
   */
  findBestEquipment(equipmentItems) {
    if (!equipmentItems || equipmentItems.length === 0) return null;
    
    let bestItem = null;
    let bestScore = -1;
    
    for (const item of equipmentItems) {
      const equipment = getEquipment(item.id) || getItemByIdDynamic(item.id);
      const slot = equipment?.slot || item.slot || (equipment ? this.inferSlotFromCategory(equipment) : null);
      const hasDamage = typeof equipment?.damage === 'number' && equipment.damage > 0;
      if (equipment && (slot === 'weapon' || hasDamage)) {
        const score = this.calculateEquipmentScore(equipment);
        if (score > bestScore) {
          bestScore = score;
          bestItem = { item, equipment, score };
        }
      }
    }
    
    return bestItem;
  }

  /**
   * Generate boss loot based on enemy level
   */
  generateBossLoot(bossLevel, rarity = 'rare') {
    const lootTable = {
      common: {
        0: ['iron_sword', 'copper_dagger'],
        1: ['iron_greatsword', 'wooden_bow'],
        2: ['steel_sword', 'steel_dagger'],
      },
      rare: {
        0: ['iron_sword', 'copper_dagger'],
        1: ['iron_greatsword', 'wooden_bow'],
        2: ['steel_sword', 'steel_dagger', 'mithril_blade'],
        3: ['mithril_blade', 'demonic_blade', 'iron_greatsword'],
        4: ['demonic_blade', 'tyrfing', 'infernal_armor'],
        5: ['tyrfing', 'harpe'],
      },
      epic: {
        0: ['iron_greatsword', 'wooden_bow'],
        1: ['steel_sword', 'steel_dagger', 'mithril_blade'],
        2: ['mithril_blade', 'demonic_blade'],
        3: ['demonic_blade', 'tyrfing', 'infernal_armor'],
        4: ['tyrfing', 'harpe', 'crown_darkness'],
        5: ['harpe', 'crown_darkness', 'hellfire_ring'],
      },
      legendary: {
        0: ['mithril_blade', 'demonic_blade'],
        1: ['demonic_blade', 'tyrfing', 'infernal_armor'],
        2: ['tyrfing', 'harpe', 'crown_darkness'],
        3: ['harpe', 'crown_darkness', 'hellfire_ring'],
        4: ['crown_darkness', 'hellfire_ring', 'deathbringer'],
        5: ['hellfire_ring', 'deathbringer', 'void_staff'],
      },
    };
    
    const tierIndex = Math.min(Math.floor(bossLevel / 8), 5);
    const rarityTable = lootTable[rarity] || lootTable.rare;
    const lootPool = rarityTable[tierIndex] || rarityTable[5];
    
    // Random variation: drop 2-4 items instead of always the same number
    const itemCount = Math.max(1, Math.floor(bossLevel / 8) + Math.floor(Math.random() * 3) + 1);
    const selectedLoot = [];
    
    for (let i = 0; i < itemCount; i++) {
      const randomItem = lootPool[Math.floor(Math.random() * lootPool.length)];
      if (!selectedLoot.includes(randomItem)) {
        selectedLoot.push(randomItem);
      }
    }
    
    return selectedLoot.length > 0 ? selectedLoot : [lootPool[0]];
  }

  /**
   * Generate boss materials based on enemy level
   */
  generateBossMaterials(bossLevel) {
    const materials = [];
    const tierIndex = Math.floor(bossLevel / 5);
    
    // Increase quantity based on level
    const quantity = Math.ceil(bossLevel / 3);
    
    // Select materials based on tier
    const tierMaterials = [
      [{ id: 'herb', quantity }, { id: 'wood', quantity }],
      [{ id: 'copper_ore', quantity: quantity * 2 }, { id: 'iron_ore', quantity }],
      [{ id: 'granite', quantity }, { id: 'lumber', quantity: quantity * 2 }],
      [{ id: 'mithril_ore', quantity: quantity * 2 }, { id: 'dragonstone', quantity }],
      [{ id: 'adamantite', quantity: quantity * 3 }, { id: 'moonflower', quantity }],
      [{ id: 'phoenix_feather', quantity: quantity * 2 }, { id: 'dragonstone', quantity: quantity * 2 }],
    ];
    
    return tierMaterials[Math.min(tierIndex, 5)] || tierMaterials[5];
  }

  /**
   * Generate boss potions based on enemy level
   */
  generateBossPotions(bossLevel) {
    const potions = [];
    const tierIndex = Math.floor(bossLevel / 5) + 1; // Potions are 1 tier ahead
    const potionTier = Math.min(Math.max(tierIndex, 1), 4);
    
    potions.push({ id: `health_potion_t${potionTier}`, quantity: Math.ceil(bossLevel / 4) });
    potions.push({ id: `xp_potion_t${potionTier}`, quantity: Math.ceil(bossLevel / 6) });
    potions.push({ id: `gold_potion_t${potionTier}`, quantity: Math.ceil(bossLevel / 8) });
    
    if (bossLevel >= 15) {
      potions.push({ id: `gathering_potion_t${Math.min(potionTier, 3)}`, quantity: 2 });
    }
    
    return potions;
  }

  /**
   * Generate boss enchants based on enemy level
   */
  generateBossEnchants(bossLevel) {
    const enchants = [];
    const tierIndex = Math.floor(bossLevel / 8) + 1;
    const enchantTier = Math.min(Math.max(tierIndex, 1), 3);
    
    if (bossLevel >= 5) {
      enchants.push({ id: `damage_enchant_t${enchantTier}`, quantity: 1 });
    }
    if (bossLevel >= 10) {
      enchants.push({ id: `xp_enchant_t${enchantTier}`, quantity: 1 });
    }
    if (bossLevel >= 15) {
      enchants.push({ id: `loot_enchant_t${enchantTier}`, quantity: 1 });
    }
    
    return enchants;
  }

  async handleEquipment(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'equipment');
    }
    
    // Get all equipment from inventory
    const equipmentItems = player.inventory.filter(item => {
      if (!item || typeof item === 'string' || item.type !== 'equipment') return false;
      
      const equipment = getEquipment(item.id) || getItemByIdDynamic(item.id);
      
      // Must have a slot (weapon, chest, head, legs, boots, etc.) to be real equipment
      // Check both item.slot (stored) and equipment.slot (from definition)
      const slot = item.slot || equipment?.slot;
      if (!slot) return false;
      
      const playerClass = player.class || player.internalClass;
      if (equipment && equipment.classRestriction && equipment.classRestriction !== playerClass) {
        return false;
      }
      return true;
    });

    // Also include currently equipped items (they might not be in inventory)
    const equippedIds = new Set(equipmentItems.map(item => item.id));
    if (player.equippedItems) {
      for (const [slot, itemId] of Object.entries(player.equippedItems)) {
        if (itemId && !equippedIds.has(itemId)) {
          const equipment = getEquipment(itemId) || getItemByIdDynamic(itemId);
          if (equipment) {
            const playerClass = player.class || player.internalClass;
            if (equipment.classRestriction && equipment.classRestriction !== playerClass) {
              continue;
            }
            equipmentItems.push({
              id: itemId,
              name: equipment.name,
              type: 'equipment',
              slot: equipment.slot || slot,
              quantity: 1,
            });
            equippedIds.add(itemId);
          }
        }
      }
    }

    // Include currently equipped weapon for comparison (may not be in inventory)
    const allCandidates = [...equipmentItems];
    const equippedWeaponId = player.equippedItems?.weapon;
    if (equippedWeaponId && !equipmentItems.some(item => item.id === equippedWeaponId)) {
      const equippedWeapon = getEquipment(equippedWeaponId) || getItemByIdDynamic(equippedWeaponId);
      if (equippedWeapon) {
        allCandidates.push({
          id: equippedWeaponId,
          name: equippedWeapon.name,
          type: 'equipment',
          slot: equippedWeapon.slot || 'weapon',
          quantity: 1,
        });
      }
    }

    // Find the best weapon
    const bestWeapon = this.findBestEquipment(allCandidates);
    const currentWeapon = player.equippedItems?.weapon;
    const isCurrentlyEquippedBest = currentWeapon === bestWeapon?.item?.id;

    // Build embed with better formatting
    const embed = new EmbedBuilder()
      .setColor(0xffd700)
      .setTitle('üó°Ô∏è Equipment Management')
      .setDescription('Manage your equipment, save loadouts, and find the best gear.');

    // Show currently equipped items with stats
    if (player.equippedItems && Object.keys(player.equippedItems).length > 0) {
      const equippedText = Object.entries(player.equippedItems)
        .map(([slot, itemId]) => {
          const equipment = getEquipment(itemId);
          const name = equipment?.name || itemId;
          const upgradeLevel = player.equipmentUpgrades?.[slot] || 0;
          const enchantLevel = player.equipmentEnchants?.[slot] || 0;
          const upgradeText = upgradeLevel > 0 ? ` +${upgradeLevel}` : '';
          const enchantText = enchantLevel > 0 ? ` ‚ú®${enchantLevel}` : '';
          
          let statsText = '';
          const stats = equipment?.stats || equipment?.bonuses || equipment;
          if (stats) {
            const statsList = [];
            if (stats.damage) statsList.push(`DMG ${stats.damage > 0 ? '+' : ''}${stats.damage}`);
            if (stats.strength) statsList.push(`STR ${stats.strength > 0 ? '+' : ''}${stats.strength}`);
            if (stats.defense) statsList.push(`DEF ${stats.defense > 0 ? '+' : ''}${stats.defense}`);
            if (stats.agility) statsList.push(`AGI ${stats.agility > 0 ? '+' : ''}${stats.agility}`);
            if (stats.intelligence) statsList.push(`INT ${stats.intelligence > 0 ? '+' : ''}${stats.intelligence}`);
            if (stats.vitality) statsList.push(`VIT ${stats.vitality > 0 ? '+' : ''}${stats.vitality}`);
            if (stats.wisdom) statsList.push(`WIS ${stats.wisdom > 0 ? '+' : ''}${stats.wisdom}`);
            if (statsList.length > 0) {
              statsText = ` [${statsList.join(' | ')}]`;
            }
          }
          
          return `‚Ä¢ **${slot}**: ${name}${upgradeText}${enchantText}${statsText}`;
        })
        .join('\n');
      embed.addFields({
        name: '‚öôÔ∏è Currently Equipped',
        value: equippedText,
        inline: false,
      });
    } else {
      embed.addFields({
        name: '‚öôÔ∏è Currently Equipped',
        value: 'üì≠ Nothing equipped',
        inline: false,
      });
    }

    // Show available equipment summary
    if (equipmentItems.length > 0) {
      const weaponCount = equipmentItems.filter(item => {
        const eq = getEquipment(item.id) || getItemByIdDynamic(item.id);
        return eq?.slot === 'weapon';
      }).length;
      
      const armorCount = equipmentItems.filter(item => {
        const eq = getEquipment(item.id) || getItemByIdDynamic(item.id);
        return eq?.slot && eq.slot !== 'weapon';
      }).length;

      const availableSummary = `üó°Ô∏è ${weaponCount} weapon${weaponCount !== 1 ? 's' : ''} | üõ°Ô∏è ${armorCount} armor piece${armorCount !== 1 ? 's' : ''}`;
      embed.addFields({
        name: 'üì¶ Available Equipment',
        value: availableSummary,
        inline: false,
      });
    } else {
      embed.addFields({
        name: 'üì¶ Available Equipment',
        value: 'üì≠ No equipment in inventory',
        inline: false,
      });
    }

    // Show saved sets count
    const setsCount = player.equipmentSets?.length || 0;
    if (setsCount > 0) {
      embed.addFields({
        name: 'üìã Saved Equipment Sets',
        value: `${setsCount} loadout${setsCount > 1 ? 's' : ''} saved`,
        inline: false,
      });
    }

    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-manage-equipment')
        .setLabel('‚öôÔ∏è Equip/Unequip')
        .setStyle(ButtonStyle.Primary)
        .setDisabled(equipmentItems.length === 0),
      new ButtonBuilder()
        .setCustomId('rpg-equip-best-weapon')
        .setLabel('‚≠ê Equip Best')
        .setStyle(ButtonStyle.Success)
        .setDisabled(!bestWeapon || isCurrentlyEquippedBest),
      new ButtonBuilder()
        .setCustomId('rpg-upgrade-weapon')
        .setLabel('üîß Upgrade')
        .setStyle(ButtonStyle.Secondary)
    );

    // Check if any equipped item has enchants
    const hasEnchants = player.equipmentEnchants && Object.values(player.equipmentEnchants).some(level => level > 0);

    const row1b = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-equipment-sets')
        .setLabel('üìã Equipment Sets')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-dismantle-multiple-start')
        .setLabel('‚ôªÔ∏è Dismantle Multiple')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-remove-enchant-start')
        .setLabel('‚ú® Remove Enchant')
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(!hasEnchants),
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    // Add quick-swap tabs for saved equipment sets
    const components = [row1, row1b];
    const savedSets = player.equipmentSets || [];
    if (savedSets.length > 0) {
      const quickSwapRow = new ActionRowBuilder();
      for (let i = 0; i < Math.min(savedSets.length, 5); i++) {
        quickSwapRow.addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-quickswap-set-${i}`)
            .setLabel(savedSets[i].name.substring(0, 15))
            .setStyle(ButtonStyle.Primary)
            .setEmoji('‚ö°')
        );
      }
      components.push(quickSwapRow);
    }

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Equip the best weapon found in inventory
   */
  async handleEquipBestWeapon(interaction, player) {
    // Get all equipment from inventory
    const equipmentItems = player.inventory.filter(item => {
      if (!item || typeof item === 'string' || item.type !== 'equipment') return false;
      const equipment = getEquipment(item.id) || getItemByIdDynamic(item.id);
      const playerClass = player.class || player.internalClass;
      if (equipment && equipment.classRestriction && equipment.classRestriction !== playerClass) {
        return false;
      }
      return true;
    });

    // Find the best weapon
    const bestWeapon = this.findBestEquipment(equipmentItems);

    if (!bestWeapon) {
      await interaction.reply({
        content: '‚ùå No weapons found in your inventory!',
        ephemeral: true,
      });
      return;
    }

    // Check if already equipped
    if (player.equippedItems?.weapon === bestWeapon.item.id) {
      await interaction.reply({
        content: '‚úÖ You already have the best weapon equipped!',
        ephemeral: true,
      });
      return;
    }

    // Equip the best weapon
    if (!player.equippedItems) player.equippedItems = {};
    if (!player.equipment || typeof player.equipment !== 'object') player.equipment = {};
    const oldWeapon = player.equippedItems.weapon;

    if (oldWeapon && oldWeapon !== bestWeapon.item.id) {
      const oldEquip = getEquipment(oldWeapon) || getItemByIdDynamic(oldWeapon);
      if (oldEquip) {
        this.addInventoryItem(player, {
          id: oldEquip.id,
          name: oldEquip.name,
          type: 'equipment',
          slot: oldEquip.slot || 'weapon',
        });
      }
    }

    // Remove the newly equipped weapon from inventory if present
    const bestIndex = player.inventory.findIndex(item => 
      item && typeof item === 'object' && item.id === bestWeapon.item.id
    );
    if (bestIndex !== -1) {
      const invItem = player.inventory[bestIndex];
      if (invItem && invItem.quantity > 1) {
        invItem.quantity -= 1;
      } else {
        player.inventory.splice(bestIndex, 1);
      }
    }

    player.equippedItems.weapon = bestWeapon.item.id;
    player.equipment.weapon = bestWeapon.item;
    player.clearStatsCache();
    this.persistPlayer(player);

    let message = `‚≠ê **${bestWeapon.item.name}** equipped as your best weapon!`;
    if (oldWeapon) {
      const oldEq = getEquipment(oldWeapon);
      message += `\n(Replaced ${oldEq?.name || oldWeapon})`;
    }

    await interaction.reply({
      content: message,
      ephemeral: true,
    });

    // Refresh the equipment view
    await this.handleEquipment(interaction, player, true);
  }

  /**
   * Handle talents
   */
  async handleTalents(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'talents');
    }
    
    if (!player.talents) player.talents = {};
    if (!Number.isFinite(player.level)) player.level = 1;
    if (!Number.isFinite(player.talentPoints)) player.talentPoints = 0;
    const spentPoints = Object.values(player.talents).reduce((sum, value) => sum + (Number(value) || 0), 0);
    const expectedPoints = Math.max(0, (player.level || 1) - 1 - spentPoints);
    if (player.talentPoints < expectedPoints) {
      player.talentPoints = expectedPoints;
      this.persistPlayer(player);
    }
    // Use cached talents data for better performance
    const talentList = this.getCachedData('talents', getTalents);
    const points = player.talentPoints || 0;

    // Pagination: 12 talents per page
    const talentsPerPage = 12;
    const page = player.currentTalentPage || 1;
    const pageNum = Math.max(1, Math.min(page, Math.ceil(talentList.length / talentsPerPage)));
    const startIdx = (pageNum - 1) * talentsPerPage;
    const endIdx = startIdx + talentsPerPage;
    const pagetalents = talentList.slice(startIdx, endIdx);

    const lines = pagetalents.map((talent) => {
      const rank = player.talents?.[talent.id] || 0;
      const maxRank = talent.maxRank || 1;
      const bonusText = Object.entries(talent.bonuses || {})
        .map(([stat, value]) => {
          const numericValue = Number(value);
          if (!Number.isFinite(numericValue)) return null;
          return `${numericValue > 0 ? '+' : ''}${numericValue} ${stat.toUpperCase()}`;
        })
        .filter(Boolean)
        .join(', ');
      const description = talent.description ? `${talent.description}` : 'No description';
      return `**${talent.name}** (${rank}/${maxRank})\n‚îî ${description}`;
    });

    // Filter out maxed talents from selector
    const availableTalents = talentList.filter((talent) => {
      const rank = player.talents?.[talent.id] || 0;
      const maxRank = talent.maxRank || 1;
      return rank < maxRank;
    });

    const selectableTalents = availableTalents.slice(0, 25);
    const totalPages = Math.ceil(talentList.length / talentsPerPage);

    const embed = new EmbedBuilder()
      .setColor(0x8e44ad)
      .setTitle('üß† Talents')
      .setDescription(`Talent Points Available: **${points}**\n\n${lines.join('\n')}`)
      .setFooter({ text: `Page ${pageNum}/${totalPages} ‚Ä¢ ${talentList.length} total talents ‚Ä¢ ${availableTalents.length} upgradeable` })
      .setTimestamp();

    const options = selectableTalents.map((talent) => {
      const rank = player.talents?.[talent.id] || 0;
      const maxRank = talent.maxRank || 1;
      return {
        label: `${talent.name} (${rank}/${maxRank})`,
        value: talent.id,
        description: (talent.description || '').slice(0, 100),
      };
    });

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-talents-select')
        .setPlaceholder(points > 0 && options.length > 0 ? 'Spend a talent point' : options.length === 0 ? 'All talents maxed!' : 'No talent points available')
        .addOptions(options.length > 0 ? options : [{ label: 'No talents available', value: 'none', description: 'All talents maxed' }])
        .setDisabled(points <= 0 || options.length === 0)
    );

    const buttonRow = new ActionRowBuilder();
    
    // Add page navigation buttons if there are multiple pages
    if (totalPages > 1) {
      if (pageNum > 1) {
        buttonRow.addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-talents-page-1`)
            .setLabel('‚óÄÔ∏è Page 1')
            .setStyle(ButtonStyle.Primary)
        );
      }
      
      buttonRow.addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );
      
      if (pageNum < totalPages) {
        buttonRow.addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-talents-page-${pageNum + 1}`)
            .setLabel(`Page ${pageNum + 1} ‚ñ∂Ô∏è`)
            .setStyle(ButtonStyle.Primary)
        );
      }
    } else {
      buttonRow.addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );
    }

    const components = points > 0 ? [selectRow, buttonRow] : [buttonRow];

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Handle gear upgrades for all equipment slots
   */
  async handleUpgradeWeapon(interaction, player) {
    await this.handleUpgradeGear(interaction, player);
  }

  async handleUpgradeGear(interaction, player) {
    this.trackMenuNavigation(player, 'upgrade');
    
    // Check which slots are equipped
    const equippedSlots = this.getResolvedEquippedSlots(player);
    if (equippedSlots.length === 0) {
      await interaction.reply({ content: 'You have no gear equipped.', ephemeral: true });
      return;
    }

    // If multiple slots equipped, ask player to select which one to upgrade (unless confirming)
    if (equippedSlots.length > 1 && !player.selectedUpgradeSlot && !player.confirmUpgrade) {
      const slotButtons = equippedSlots.map(slot => {
        const equippedId = this.getResolvedEquippedItemId(player, slot);
        const equipment = getEquipment(equippedId) || getItemByIdDynamic(equippedId);
        const upgradeLevel = player.equipmentUpgrades?.[slot] || 0;
        return new ButtonBuilder()
          .setCustomId(`rpg-upgrade-slot-${slot}`)
          .setLabel(`${slot.toUpperCase()} +${upgradeLevel} (${equipment?.name || 'Unknown'})`)
          .setStyle(ButtonStyle.Primary);
      });

      const rows = [];
      for (let i = 0; i < slotButtons.length; i += 5) {
        rows.push(new ActionRowBuilder().addComponents(...slotButtons.slice(i, i + 5)));
      }

      rows.push(new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      ));

      await this.updateInteractionWithTracking(interaction, {
        content: 'Select which gear piece to upgrade:',
        components: rows,
      });
      return;
    }

    // Get the slot to upgrade (from confirmation data if confirming, otherwise from selection)
    const slot = player.confirmUpgrade?.slot || player.selectedUpgradeSlot || equippedSlots[0];
    delete player.selectedUpgradeSlot; // Clear selection
    
    const itemId = this.getResolvedEquippedItemId(player, slot);
    if (!itemId) {
      await interaction.reply({ content: `You have no ${slot} equipped.`, ephemeral: true });
      return;
    }

    const equipment = getEquipment(itemId) || getItemByIdDynamic(itemId);
    const upgradeLevel = player.equipmentUpgrades?.[slot] || 0;
    const nextLevel = upgradeLevel + 1;
    const maxUpgrade = 10;
    if (upgradeLevel >= maxUpgrade) {
      await interaction.reply({ content: `Your ${slot} is already at max upgrade (+${maxUpgrade}).`, ephemeral: true });
      return;
    }

    const bonuses = equipment?.bonuses || equipment?.stats || {};
    const currentMult = 1 + (upgradeLevel * 0.1);
    const nextMult = 1 + (nextLevel * 0.1);
    const previewLines = Object.keys(bonuses).length > 0
      ? Object.entries(bonuses).map(([stat, value]) => {
          const currentValue = Math.round((Number(value) || 0) * currentMult);
          const nextValue = Math.round((Number(value) || 0) * nextMult);
          const format = (num) => (num >= 0 ? `+${num}` : `${num}`);
          return `${stat.toUpperCase()}: ${format(currentValue)} ‚Üí ${format(nextValue)}`;
        })
      : ['No stat bonuses.'];
    const previewText = previewLines.join('\n');

    const blacksmithLevel = player.professionLevels?.blacksmith || 0;
    const baseBreakChance = Math.min(0.25 + (upgradeLevel * 0.07), 0.85);
    const reduction = blacksmithLevel * 0.03;
    const breakChance = Math.max(baseBreakChance - reduction, 0.03);
    const cost = 100 * nextLevel;

    // Show confirmation dialog
    if (!player.confirmUpgrade) {
      const embed = new EmbedBuilder()
        .setColor(0xf1c40f)
        .setTitle(`üîß ${slot.toUpperCase()} Upgrade Preview`)
        .setDescription(`**${equipment?.name || itemId}** ‚ûî +${nextLevel}`)
        .addFields(
          { name: 'üìä Stat Changes', value: previewText, inline: false },
          { name: 'üí∞ Cost', value: `${cost} gold`, inline: true },
          { name: '‚ö†Ô∏è Break Chance', value: `${(breakChance * 100).toFixed(1)}%`, inline: true },
          { name: 'üî® Blacksmith Level', value: `${blacksmithLevel} (-${(reduction * 100).toFixed(1)}% break chance)`, inline: true },
          { name: '‚ö° Success Rate', value: `${((1 - breakChance) * 100).toFixed(1)}%`, inline: true }
        )
        .setFooter({ text: '‚ö†Ô∏è WARNING: Failed upgrades will destroy your gear!' })
        .setTimestamp();

      const confirmRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-upgrade-confirm')
          .setLabel('‚úÖ Confirm Upgrade')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚ùå Cancel')
          .setStyle(ButtonStyle.Danger)
      );

      player.confirmUpgrade = { slot, cost, breakChance, nextLevel };
      this.persistPlayer(player);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [confirmRow],
      });
      return;
    }

    // Execute upgrade
    const upgradeData = player.confirmUpgrade;
    delete player.confirmUpgrade;
    
    if (player.gold < upgradeData.cost) {
      await interaction.reply({ content: `You need ${upgradeData.cost} gold to upgrade.`, ephemeral: true });
      return;
    }

    player.gold -= upgradeData.cost;
    this.trackGoldSpent(player, upgradeData.cost, 'upgrades');
    const roll = Math.random();
    let resultText = '';

    if (roll < upgradeData.breakChance) {
      // Equipment breaks
      delete player.equippedItems[upgradeData.slot];
      if (player.equipment && typeof player.equipment === 'object') {
        delete player.equipment[upgradeData.slot];
      }
      if (player.equipmentUpgrades) delete player.equipmentUpgrades[upgradeData.slot];
      player.clearStatsCache();
      resultText = `‚ùå Upgrade failed! Your ${upgradeData.slot} broke and was destroyed. (Break chance: ${(upgradeData.breakChance * 100).toFixed(1)}%)`;
    } else {
      if (!player.equipmentUpgrades) player.equipmentUpgrades = {};
      player.equipmentUpgrades[upgradeData.slot] = upgradeData.nextLevel;
      player.clearStatsCache();
      resultText = `‚úÖ Upgrade success! ${upgradeData.slot.toUpperCase()} is now +${upgradeData.nextLevel}. (Break chance: ${(upgradeData.breakChance * 100).toFixed(1)}%)`;
    }

    this.persistPlayer(player);

    const embed = new EmbedBuilder()
      .setColor(roll < upgradeData.breakChance ? 0xff0000 : 0x00ff00)
      .setTitle(`üîß ${upgradeData.slot.toUpperCase()} Upgrade Result`)
      .setDescription(resultText)
      .addFields(
        { name: 'Gold Spent', value: `${upgradeData.cost}`, inline: true },
        { name: 'Blacksmith Level', value: `${blacksmithLevel}`, inline: true }
      )
      .setTimestamp();

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-upgrade-return')
        .setLabel('üîß Back to Upgrades')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Main Menu')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backRow],
    });
  }

  /**
   * Handle professions
   */
  /**
   * View professions tab with rewards and progression
   */
  async handleProfessions(interaction, player) {
    this.trackMenuNavigation(player, 'professions');
    const professionNames = { blacksmith: 'Blacksmith', botanic: 'Botanic', enchanter: 'Enchanter', gathering: 'Gatherer' };
    const professionEmojis = { blacksmith: 'üî®', botanic: 'üåø', enchanter: '‚ú®', gathering: '‚õèÔ∏è' };

    // Fix maxProfessions for existing high-level players
    if (player.level >= 35 && player.maxProfessions < 4) {
      player.maxProfessions = 4;
      this.persistPlayer(player);
    } else if (player.level >= 20 && player.maxProfessions < 3) {
      player.maxProfessions = 3;
      this.persistPlayer(player);
    } else if (player.level >= 15 && player.maxProfessions < 2) {
      player.maxProfessions = 2;
      this.persistPlayer(player);
    }

    this.applyMissingGatheringRewards(player);

    const embed = new EmbedBuilder()
      .setColor('#9370DB')
      .setTitle('üíº Professions')
      .setDescription('Master crafting professions to create powerful items and earn rewards.');

    // Show current professions with levels and XP
    if (player.professions && player.professions.length > 0) {
      // Fix any accumulated gathering XP that hasn't been processed into levels
      if (player.professions.includes('gathering') && player.professionXp?.gathering >= 100) {
        const xpToProcess = player.professionXp.gathering;
        player.professionXp.gathering = 0;
        addGatheringProfessionXp(player, xpToProcess);
        this.persistPlayer(player);
      }

      const professionList = player.professions
        .map((prof) => {
          const level = player.professionLevels?.[prof] || 1;
          const currentXp = player.professionXp?.[prof] || 0;
          // XP formulas: Gathering 200+(level*100), Blacksmith 400, others 100
          let xpNeeded;
          if (prof === 'gathering') {
            xpNeeded = 200 + level * 100;
          } else if (prof === 'blacksmith') {
            xpNeeded = 400;
          } else {
            xpNeeded = 100;
          }
          const xpToNextLevel = xpNeeded - currentXp;
          return `${professionEmojis[prof] || 'üìå'} **${professionNames[prof]}** - Level ${level}\n   ‚îî XP: ${currentXp}/${xpNeeded} (${xpToNextLevel} to next level)`;
        })
        .join('\n');
      embed.addFields({ name: 'Your Professions', value: professionList });
    }

    // Show profession rewards
    const rewards = {
      blacksmith: 'üî® Craft weapons and armor\nüéÅ Earn crafting XP\nüí∞ Sell items for gold\n‚ö° Unlock rare recipes at higher levels',
      botanic: 'üåø Craft potions and remedies\nüéÅ Earn gathering XP\nüíö Restore health and mana\n‚ö° Unlock rare potions at higher levels',
      enchanter: '‚ú® Enhance equipment with magic\nüéÅ Earn enchanting XP\nüí´ Increase item power\n‚ö° Unlock powerful enchants at higher levels',
      gathering: '‚õèÔ∏è Craft gathering tools & buffs\nüéÅ Earn massive stat bonuses\nüíé Unlock better gathering areas\n‚ö° Specialized tools at higher levels',
    };

    // Show available professions to add
    const availableSlots = (player.maxProfessions || 1) - (player.professions?.length || 0);
    const availableProfessions = ['blacksmith', 'botanic', 'enchanter', 'gathering'].filter((id) => !player.professions?.includes(id));

    if (availableProfessions.length > 0) {
      const rewardsList = availableProfessions
        .map((prof) => `**${professionNames[prof]}**\n${rewards[prof]}`)
        .join('\n\n');
      embed.addFields({
        name: `Available Professions (${availableSlots} slot${availableSlots !== 1 ? 's' : ''} remaining)`,
        value: rewardsList,
      });
    }

    // Show level progression
    let nextSlotLevel = null;
    if (player.maxProfessions === 1) {
      nextSlotLevel = 15;
    } else if (player.maxProfessions === 2) {
      nextSlotLevel = 20;
    } else if (player.maxProfessions === 3) {
      nextSlotLevel = 35;
    }

    if (nextSlotLevel && player.level < nextSlotLevel) {
      const targetSlot = player.maxProfessions + 1;
      const remainder = targetSlot % 100;
      let suffix = 'th';
      if (remainder < 11 || remainder > 13) {
        const last = targetSlot % 10;
        if (last === 1) suffix = 'st';
        else if (last === 2) suffix = 'nd';
        else if (last === 3) suffix = 'rd';
      }
      embed.addFields({
        name: 'üéØ Next Milestone',
        value: `Reach level ${nextSlotLevel} to unlock your ${targetSlot}${suffix} profession slot`,
      });
    }

    // Add XP info
    embed.addFields({
      name: 'üìä XP System',
      value: '‚Ä¢ Craft items to gain profession XP\n‚Ä¢ XP gain = Recipe Level √ó 10\n‚Ä¢ **Blacksmith**: 400 XP per level\n‚Ä¢ **Others**: 100 XP per level\n‚Ä¢ **Gathering**: Scaling (200 + level√ó100)',
      inline: false,
    });
    
    // Show Master Blacksmith info if applicable
    const hasAsgardAccess = (player.worldsUnlocked || []).includes('world_1770519709022');
    const hasBlacksmith = (player.professions || []).includes('blacksmith');
    const blacksmithLevel = player.professionLevels?.blacksmith || 0;
    
    if (hasBlacksmith && player.masterBlacksmith) {
      embed.addFields({
        name: 'üî• Master Blacksmith Status',
        value: '‚úÖ **ACTIVE** - Gem crafting and socketing unlocked!',
        inline: false,
      });
    } else if (hasBlacksmith && hasAsgardAccess && blacksmithLevel >= 25) {
      embed.addFields({
        name: 'üî• Master Blacksmith Upgrade Available!',
        value: `Unlock gem crafting and socketing for **50,000 gold**\n‚úÖ Level ${blacksmithLevel}/25\n‚úÖ Asgard Unlocked`,
        inline: false,
      });
    } else if (hasBlacksmith && blacksmithLevel < 25) {
      embed.addFields({
        name: 'üî• Master Blacksmith',
        value: `Reach Blacksmith Level 25 and unlock Asgard to access the Master upgrade!\nCurrent: Level ${blacksmithLevel}/25`,
        inline: false,
      });
    }

    const rows = [];

    // Show rewards for current professions
    if (player.professions && player.professions.length > 0) {
      const rewardsRow = new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-profession-rewards-select')
          .setPlaceholder('View profession rewards')
          .addOptions(
            player.professions.map((id) => ({
              label: `${professionNames[id]} Rewards`,
              value: id,
              emoji: professionEmojis[id],
            }))
          )
      );
      rows.push(rewardsRow);
    }

    // Only show profession select if slots available
    if (availableSlots > 0 && availableProfessions.length > 0) {
      const selectRow = new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-profession-select')
          .setPlaceholder('Choose a profession to add')
          .addOptions(
            availableProfessions.map((id) => ({
              label: professionNames[id],
              value: id,
              emoji: professionEmojis[id],
            }))
          )
      );
      rows.push(selectRow);
    }

    const tabsRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-alchemy')
        .setLabel('üß™ Alchemy')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-enchant')
        .setLabel('‚ú® Enchant')
        .setStyle(ButtonStyle.Primary)
    );
    rows.push(tabsRow);
    
    // Master Blacksmith row (show if player has Asgard access and blacksmith)
    if (hasBlacksmith) {
      const masterRow = new ActionRowBuilder();
      
      if (!player.masterBlacksmith && hasAsgardAccess && blacksmithLevel >= 25) {
        masterRow.addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-master-blacksmith-upgrade')
            .setLabel('üî• Upgrade to Master Blacksmith (50,000g)')
            .setStyle(ButtonStyle.Success)
            .setDisabled((player.gold || 0) < 50000)
        );
      }
      
      if (player.masterBlacksmith) {
        masterRow.addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-gem-socketing')
            .setLabel('üíé Socket Gems')
            .setStyle(ButtonStyle.Success),
          new ButtonBuilder()
            .setCustomId('rpg-crafting-upgrade')
            .setLabel('‚¨ÜÔ∏è Upgrade')
            .setStyle(ButtonStyle.Primary)
        );
      } else {
        masterRow.addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-crafting-upgrade')
            .setLabel('‚¨ÜÔ∏è Upgrade')
            .setStyle(ButtonStyle.Primary)
        );
      }
      
      if (masterRow.components.length > 0) {
        rows.push(masterRow);
      }
    }

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );
    rows.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  /**
   * Handle profession rewards display
   */
  async handleProfessionRewardsDisplay(interaction, player, professionId) {
    const profession = getProfessionRewards(professionId);
    if (!profession) {
      await interaction.reply({ content: 'Profession not found.', ephemeral: true });
      return;
    }

    const level = player.professionLevels?.[professionId] || 1;

    const embed = new EmbedBuilder()
      .setColor('#9370DB')
      .setTitle(`${profession.icon} ${profession.name} Rewards`)
      .setDescription(profession.description)
      .addFields({
        name: 'üìä Current Level',
        value: `Level ${level}`,
        inline: true,
      })
      .addFields({
        name: 'üìñ Passive Ability',
        value: profession.passive,
        inline: false,
      });

    // Build all 30 levels progression
    const allLevels = [];
    for (let lv = 1; lv <= 30; lv++) {
      let levelInfo = `**Lvl ${lv}**`;
      if (lv <= level) {
        levelInfo += ' ‚úÖ';
      }
      allLevels.push(levelInfo);
    }

    // Split into chunks for readability
    const chunk1 = allLevels.slice(0, 10).join(' ‚Ä¢ ');
    const chunk2 = allLevels.slice(10, 20).join(' ‚Ä¢ ');
    const chunk3 = allLevels.slice(20, 30).join(' ‚Ä¢ ');

    embed.addFields({
      name: 'üìà Level Progression (1-10)',
      value: chunk1,
      inline: false,
    });

    embed.addFields({
      name: 'üìà Level Progression (11-20)',
      value: chunk2,
      inline: false,
    });

    embed.addFields({
      name: 'üìà Level Progression (21-30)',
      value: chunk3,
      inline: false,
    });

    // Show major milestone rewards
    const milestones = [5, 10, 15, 20, 25, 30];
    let rewardsText = '';
    
    for (const milestone of milestones) {
      const rewards = profession.unlocks[milestone];
      if (rewards) {
        const isUnlocked = level >= milestone ? '‚úÖ' : 'üîí';
        rewardsText += `${isUnlocked} **Level ${milestone}**: ${rewards.rewards.join(', ')}\n`;
      }
    }

    if (rewardsText) {
      embed.addFields({
        name: 'üéÅ Major Milestone Rewards',
        value: rewardsText,
        inline: false,
      });
    }

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backRow],
    });
  }

  /**
   * Handle talent upgrade/selection
   */
  async handleTalentUpgrade(interaction, player, talentId) {
    const talent = getTalent(talentId);
    if (!talent) {
      await interaction.reply({ content: 'Talent not found.', ephemeral: true });
      return;
    }

    const currentRank = player.talents?.[talentId] || 0;
    const maxRank = talent.maxRank || 1;
    const embed = new EmbedBuilder()
      .setColor('#FFD700')
      .setTitle(`üíé ${talent.name}`)
      .setDescription(talent.description || 'No description')
      .addFields({
        name: 'Current Rank',
        value: `${currentRank}/${maxRank}`,
        inline: true,
      });

    // Show talent bonuses
    if (talent.bonuses && Object.keys(talent.bonuses).length > 0) {
      const bonusText = Object.entries(talent.bonuses)
        .map(([stat, value]) => {
          const numericValue = Number(value);
          if (!Number.isFinite(numericValue)) return null;
          const sign = numericValue >= 0 ? '+' : '';
          return `${sign}${numericValue} ${stat.charAt(0).toUpperCase() + stat.slice(1)}`;
        })
        .filter(Boolean)
        .join('\n');
      embed.addFields({
        name: 'Stat Bonuses per Rank',
        value: bonusText || 'No bonuses',
        inline: true,
      });
    }

    // Show current effect
    if (talent.effect) {
      embed.addFields({
        name: '‚ö° Effect',
        value: talent.effect.replace(/_/g, ' '),
        inline: false,
      });
    }

    // Show class restriction if any
    if (talent.classRestriction) {
      embed.addFields({
        name: 'üîí Class Requirement',
        value: talent.classRestriction.charAt(0).toUpperCase() + talent.classRestriction.slice(1),
        inline: false,
      });
    }

    const pointsAvailable = Number(player.talentPoints || 0);
    const ranksRemaining = Math.max(0, maxRank - currentRank);
    const maxSpend = Math.min(pointsAvailable, ranksRemaining);

    embed.addFields({
      name: 'üéØ Talent Points Overview',
      value: `Points Available: **${pointsAvailable}**\n` +
        `Ranks Remaining: **${ranksRemaining}**\n` +
        `Can Upgrade: **+${maxSpend} rank${maxSpend === 1 ? '' : 's'}**`,
      inline: false,
    });

    const rows = [];

    // Upgrade/downgrade buttons
    if (currentRank < maxRank) {
      const upgradeButton = new ButtonBuilder()
        .setCustomId(`rpg-talent-upgrade-${talentId}`)
        .setLabel('‚¨ÜÔ∏è Upgrade 1')
        .setStyle(ButtonStyle.Success)
        .setDisabled(pointsAvailable <= 0);

      if (!rows[0]) rows[0] = new ActionRowBuilder();
      rows[0].addComponents(upgradeButton);

      if (maxSpend > 1) {
        const maxButton = new ButtonBuilder()
          .setCustomId(`rpg-talent-upgrade-max-${talentId}`)
          .setLabel(`‚¨ÜÔ∏è Upgrade Max (+${maxSpend})`)
          .setStyle(ButtonStyle.Primary)
          .setDisabled(pointsAvailable <= 0);
        rows[0].addComponents(maxButton);
      }
    }

    if (currentRank > 0) {
      const downgradeButton = new ButtonBuilder()
        .setCustomId(`rpg-talent-downgrade-${talentId}`)
        .setLabel(`‚¨áÔ∏è Downgrade to Rank ${currentRank - 1}`)
        .setStyle(ButtonStyle.Danger);
      
      if (!rows[0]) rows[0] = new ActionRowBuilder();
      rows[0].addComponents(downgradeButton);
    }

    // Back button
    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );
    rows.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows.filter(r => r && r.components.length > 0),
    });
  }

  /**
   * Handle skill detail viewer
   */
  async handleSkillDetail(interaction, player, skillId, action = 'learned') {
    this.trackMenuNavigation(player, 'skill-detail');
    const skill = getSkill(skillId);
    
    if (!skill) {
      await interaction.reply({
        content: `‚ùå Skill not found: ${skillId}`,
        ephemeral: true,
      });
      return;
    }

    const isLearned = player.skills.includes(skillId);
    const currentLevel = player.skillLevels?.[skillId] || 1;
    const maxLevel = skill.maxLevel || 3;
    
    // Get class data to find this skill in skill tree
    const playerClass = player.class || player.internalClass;
    const classData = getClass(playerClass);
    let skillTreeEntry = null;
    let unlockCost = 1;
    
    if (classData && classData.skillTree) {
      skillTreeEntry = classData.skillTree.find(s => s.skillId === skillId);
      if (skillTreeEntry) {
        unlockCost = skillTreeEntry.pointCost;
      }
    }
    
    // Upgrade cost is always 1 skill point per level
    const upgradeCost = 1;
    
    // Check if can upgrade (must have enough points for the upgrade cost)
    const canUpgrade = isLearned && currentLevel < maxLevel && (player.skillPoints || 0) >= upgradeCost;

    const embed = new EmbedBuilder()
      .setColor(isLearned ? 0x2ecc71 : 0xff9800)
      .setTitle(`‚öîÔ∏è ${skill.name}`)
      .setDescription(skill.description || 'No description available');

    // Add skill level and status
    embed.addFields({
      name: 'üìä Skill Status',
      value: isLearned 
        ? `‚úÖ **Learned** | Level: **${currentLevel}/${maxLevel}**`
        : `üîí **Not Learned** | Requires Level ${skillTreeEntry?.unlockLevel || '?'} (Cost: ${unlockCost} points)`,
      inline: false,
    });

    // Show different stats based on skill level
    if (skill.levels && skill.levels[currentLevel]) {
      const levelData = skill.levels[currentLevel];
      const statsText = [];
      
      if (levelData.damage) {
        const dmgValue = typeof levelData.damage === 'function' 
          ? levelData.damage(player).toFixed(1)
          : (levelData.damage * player.strength).toFixed(1);
        statsText.push(`üí• Damage: **${dmgValue}**`);
      }
      if (levelData.cooldown !== undefined) {
        statsText.push(`‚è±Ô∏è Cooldown: **${levelData.cooldown}** turns`);
      }
      if (levelData.healPercent) {
        const healValue = Math.floor(player.maxHp * levelData.healPercent);
        statsText.push(`üíö Heal: **${healValue}** HP (${(levelData.healPercent * 100).toFixed(0)}%)`);
      }
      if (levelData.duration) {
        statsText.push(`‚åõ Duration: **${levelData.duration}** turns`);
      }
      
      if (skill.type) statsText.push(`üéØ Type: **${skill.type}**`);
      if (skill.element) statsText.push(`‚ö° Element: **${skill.element}**`);
      
      if (statsText.length > 0) {
        embed.addFields({
          name: `üìã Level ${currentLevel} Stats`,
          value: statsText.join('\n'),
          inline: false,
        });
      }

      // Show description for this level
      if (levelData.description) {
        embed.addFields({
          name: 'üìù Level Description',
          value: levelData.description,
          inline: false,
        });
      }
    }

    // Show upgrade preview if available
    if (currentLevel < maxLevel && skill.levels && skill.levels[currentLevel + 1]) {
      const nextLevelData = skill.levels[currentLevel + 1];
      const upgradeText = [];
      
      if (nextLevelData.damage && skill.levels[currentLevel].damage) {
        upgradeText.push(`‚Ä¢ Damage: ${(skill.levels[currentLevel].damage * 100).toFixed(0)}% ‚Üí ${(nextLevelData.damage * 100).toFixed(0)}%`);
      }
      if (nextLevelData.cooldown !== undefined && skill.levels[currentLevel].cooldown !== undefined) {
        upgradeText.push(`‚Ä¢ Cooldown: ${skill.levels[currentLevel].cooldown} ‚Üí ${nextLevelData.cooldown} turns`);
      }
      
      if (upgradeText.length > 0) {
        embed.addFields({
          name: `üîº Next Level (Lv${currentLevel + 1})`,
          value: upgradeText.join('\n'),
          inline: false,
        });
      }
    }

    // Add passive bonuses
    if (skill.passiveBonuses && Object.keys(skill.passiveBonuses).length > 0) {
      const bonusesText = Object.entries(skill.passiveBonuses)
        .map(([stat, value]) => `+${value} ${stat.charAt(0).toUpperCase() + stat.slice(1)}`)
        .join(', ');
      
      embed.addFields({
        name: 'üéÅ Passive Bonuses',
        value: bonusesText,
        inline: false,
      });
    }

    const rows = [];
    
    // Add action buttons
    const buttonRow = new ActionRowBuilder();
    
    if (isLearned && canUpgrade) {
      buttonRow.addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-skill-upgrade-${skillId}`)
          .setLabel(`üîº Upgrade (${upgradeCost} pts)`)
          .setStyle(ButtonStyle.Success)
      );
    }
    
    if (!isLearned && skillTreeEntry && (player.skillPoints || 0) >= unlockCost && player.level >= skillTreeEntry.unlockLevel) {
      buttonRow.addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-skill-unlock-${skillId}`)
          .setLabel(`üîì Unlock (${unlockCost} pts)`)
          .setStyle(ButtonStyle.Success)
      );
    }
    
    if (buttonRow.components.length > 0) {
      rows.push(buttonRow);
    }

    // Add back button
    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-skills')
        .setLabel('‚Üê Back to Skills')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-hub')
        .setLabel('üè† Hub')
        .setStyle(ButtonStyle.Primary)
    );
    rows.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  /**
   * Handle crafting
   */
  async handleCrafting(interaction, player) {
    this.trackMenuNavigation(player, 'crafting');
    await this.handleCraftingPage(interaction, player, 0, null);
  }

  async handleCraftingPage(interaction, player, page = 0, selectedWorldId = null) {
    const embed = UIBuilder.createCraftingEmbed(player);
    const components = this.buildCraftingComponents(player, page, selectedWorldId);
    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  async handleAlchemy(interaction, player) {
    this.trackMenuNavigation(player, 'alchemy');
    const hasBotanic = player.professions?.includes('botanic');
    const botanicLevel = Number(player.professionLevels?.botanic) || 0;

    const recipes = RECIPES_SORTED.filter((rec) => rec.profession === 'botanic');

    const embed = new EmbedBuilder()
      .setColor(0x2ecc71)
      .setTitle('üß™ Alchemy - Potion Brewing')
      .setDescription(
        hasBotanic
          ? `**Botanic Level: ${botanicLevel}**\n**Tier 1-2**: Accessible to all\n**Tier 3-5**: Requires Botanic profession`
          : `**No Botanic Profession**\nAccess Tier 1-2 potions. Tier 3-5 require the profession.\nCosts 50% more materials without profession.`
      );

    const options = recipes.slice(0, 25).map((rec) => {
      const recLevel = Number(rec.level) || 1;
      const recTier = Number(rec.tier) || 1;
      const playerLock = player.level < recLevel;
      const requiresProf = rec.requiresProfession && (!hasBotanic || botanicLevel < recLevel);
      const locked = playerLock || requiresProf;
      
      // Build requirement text
      let reqText = '';
      if (playerLock) {
        reqText = `‚ùå Requires Player Lvl ${recLevel}`;
      } else if (requiresProf) {
        reqText = `‚ùå Requires Botanic Lvl ${recLevel}`;
      } else {
        reqText = `‚úì Tier ${recTier}`;
      }
      
      // Build materials text
      const matText = Object.entries(rec.materials || {})
        .map(([mat, qty]) => `${Number(qty) || 1}x ${getMaterial(mat)?.name || mat}`)
        .join(', ');
      
      const lockTag = locked ? ' [üîí]' : '';
      const desc = matText ? `${reqText} ‚Ä¢ ${matText}` : reqText;
      return {
        label: `${rec.name}${lockTag}`.slice(0, 100),
        value: String(rec.id),
        description: (desc || 'Potion').slice(0, 100),
      };
    });

    // Add view details option with special prefix
    const detailOptions = recipes.slice(0, 25).map((rec) => ({
      label: `‚ÑπÔ∏è ${rec.name}`.slice(0, 100),
      value: `details-${String(rec.id)}`,
      description: 'View details'.slice(0, 100),
    }));

    const rows = [];
    if (options.length > 0) {
      // Validate and filter options
      const validOptions = options.filter(opt => opt && opt.label && opt.value);
      const validDetailOptions = detailOptions.filter(opt => opt && opt.label && opt.value);
      
      if (validOptions.length > 0 || validDetailOptions.length > 0) {
        rows.push(
          new ActionRowBuilder().addComponents(
            new StringSelectMenuBuilder()
              .setCustomId('rpg-alchemy-select')
              .setPlaceholder('Select a potion to brew or view details')
              .addOptions([...validOptions, ...validDetailOptions].slice(0, 25))
          )
        );
      }
    }

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );
    rows.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  async handleAlchemyCraft(interaction, player, recipeId) {
    const recipe = getRecipe(recipeId);
    if (!recipe || recipe.profession !== 'botanic') {
      await interaction.reply({ content: 'Invalid alchemy recipe.', ephemeral: true });
      return;
    }

    const hasBotanic = player.professions?.includes('botanic');
    const botanicLevel = player.professionLevels?.botanic || 0;
    const requiredLevel = recipe.level || 1;
    const tier = recipe.tier || 1;

    if (player.level < requiredLevel) {
      await interaction.reply({ content: `You need player level ${requiredLevel} to brew this potion.`, ephemeral: true });
      return;
    }

    // Check tier-based access
    if (recipe.requiresProfession && (!hasBotanic || botanicLevel < requiredLevel)) {
      await interaction.reply({ content: `Tier ${tier} potions require Botanic Level ${requiredLevel}.`, ephemeral: true });
      return;
    }

    const baseMaterials = this.getAdjustedMaterials(recipe.materials || {});
    const costMultiplier = this.getProfessionCostMultiplier(player) * (hasBotanic ? 1 : 1.5);
    const adjustedMaterials = this.applyCostMultiplier(baseMaterials, costMultiplier);

    // Create overview embed
    const embed = UIBuilder.createAlchemyEmbed(player, { ...recipe, materials: adjustedMaterials });

    // Add XP and failure rate information
    const xpGain = requiredLevel * 10;
    const currentXp = player.professionXp?.botanic || 0;
    const xpThreshold = 100;
    const xpNeededForNextLevel = xpThreshold - currentXp;
    const xpProgressBar = this.buildProgressBar(currentXp, xpThreshold, 10);
    
    const baseFailChance = Math.min(0.35 + (requiredLevel * 0.03), 0.8);
    const reduction = hasBotanic ? botanicLevel * 0.02 : 0;
    const penalty = hasBotanic ? 0 : 0.15;
    const failChance = Math.min(Math.max(baseFailChance - reduction + penalty, 0.05), 0.9);
    
    // Build materials status with checkmarks and Xs
    const materialStatusList = Object.entries(adjustedMaterials)
      .map(([matId, qty]) => {
        const materialName = getMaterial(matId)?.name || matId;
        const playerCount = this.getMaterialCounts(player)[matId] || 0;
        const hasEnough = playerCount >= qty;
        const icon = hasEnough ? '‚úÖ' : '‚ùå';
        return `${icon} ${materialName} x${qty}`;
      })
      .join('\n');
    
    embed.addFields(
      {
        name: 'üì¶ Required Materials',
        value: materialStatusList || 'None',
        inline: false
      },
      {
        name: '‚≠ê Profession XP',
        value: hasBotanic 
          ? `Gain: **${xpGain} XP** per craft\n` +
            `Progress: ${xpProgressBar} (${currentXp}/${xpThreshold})\n` +
            `Until Next Level: **${xpNeededForNextLevel} XP**`
          : `‚ùå Not a Botanic - No XP gained`,
        inline: false
      },
      {
        name: '‚ö†Ô∏è Failure Rate',
        value: `${(failChance * 100).toFixed(1)}% chance to waste materials${hasBotanic ? '' : ' (+15% penalty)'}`,
        inline: false
      }
    );

    // Calculate how many times they can craft
    const hasEnough1x = this.hasMaterials(player, adjustedMaterials);
    let maxCrafts = 1;
    if (hasEnough1x) {
      for (let i = 2; i <= 100; i++) {
        const multipliedMats = {};
        for (const [matId, qty] of Object.entries(adjustedMaterials)) {
          multipliedMats[matId] = qty * i;
        }
        if (!this.hasMaterials(player, multipliedMats)) {
          maxCrafts = i - 1;
          break;
        }
        if (i === 100) maxCrafts = 100;
      }
    }
    
    // Build quantity buttons
    const quantityRow = new ActionRowBuilder();
    const buttons = [
      new ButtonBuilder()
        .setCustomId(`rpg-confirm-brew-${recipeId}-1`)
        .setLabel('‚úÖ 1x')
        .setStyle(ButtonStyle.Success)
        .setDisabled(!hasEnough1x)
    ];
    
    if (maxCrafts >= 5) {
      buttons.push(
        new ButtonBuilder()
          .setCustomId(`rpg-confirm-brew-${recipeId}-5`)
          .setLabel('‚úÖ 5x')
          .setStyle(ButtonStyle.Primary)
          .setDisabled(maxCrafts < 5)
      );
    }
    
    if (maxCrafts >= 10) {
      buttons.push(
        new ButtonBuilder()
          .setCustomId(`rpg-confirm-brew-${recipeId}-10`)
          .setLabel('‚úÖ 10x')
          .setStyle(ButtonStyle.Primary)
          .setDisabled(maxCrafts < 10)
      );
    }
    
    // Add "Max" button only if max is more than 10
    if (maxCrafts > 10) {
      buttons.push(
        new ButtonBuilder()
          .setCustomId(`rpg-confirm-brew-${recipeId}-max`)
          .setLabel(`‚úÖ Max (${maxCrafts}x)`)
          .setStyle(ButtonStyle.Primary)
          .setDisabled(!hasEnough1x)
      );
    }
    
    quantityRow.addComponents(...buttons);
    const components = [quantityRow];

    // Check if missing materials for gather buttons
    const missingMats = this.getMissingMaterials(player, adjustedMaterials);

    if (missingMats.length > 0) {
      // Add gather buttons for missing materials
      const gatherButtons = [];
      const areaMap = this.getGatheringAreasByMaterials(missingMats, player.level || 1);
      const areas = Object.values(areaMap);

      if (areas.length > 0) {
        const gatherRow = new ActionRowBuilder();
        player.pendingGatherAllMaterials = missingMats.map(({ id, quantity }) => ({ id, quantity }));
        this.persistPlayer(player);

        for (const { area, materials } of areas.slice(0, 5)) {
          const matNames = materials.map(m => m.name || getMaterial(m.id)?.name || m.id);
          const label = `üåø ${area.name}: ${matNames.slice(0, 2).join(', ')}${materials.length > 2 ? ` +${materials.length - 2}` : ''}`;
          
          gatherRow.addComponents(
            new ButtonBuilder()
              .setCustomId(`rpg-autogather-area-${area.id}`)
              .setLabel(label.slice(0, 80))
              .setStyle(ButtonStyle.Primary)
          );
          
          if (gatherRow.components.length >= 5) break;
        }
        
        if (gatherRow.components.length > 0) {
          components.push(gatherRow);
        }
      }
    }

    // Add back button
    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-alchemy')
        .setLabel('‚Üê Back to Alchemy')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-hub')
        .setLabel('üè† Hub')
        .setStyle(ButtonStyle.Primary)
    );
    components.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  async handleAlchemyBrewWithQuantity(interaction, player, recipeId, quantity = 1) {
    // Defer the interaction to allow editReply and followUp later
    await interaction.deferUpdate();

    const recipe = getRecipe(recipeId);
    if (!recipe || recipe.profession !== 'botanic') {
      await interaction.followUp({ content: 'Invalid alchemy recipe.', ephemeral: true });
      return;
    }

    const hasBotanic = player.professions?.includes('botanic');
    const botanicLevel = player.professionLevels?.botanic || 0;
    const requiredLevel = recipe.level || 1;

    const baseMaterials = this.getAdjustedMaterials(recipe.materials || {});
    const costMultiplier = this.getProfessionCostMultiplier(player) * (hasBotanic ? 1 : 1.5);
    const adjustedMaterials = this.applyCostMultiplier(baseMaterials, costMultiplier);

    // Multiply materials by quantity
    const totalMaterials = {};
    for (const [matId, qty] of Object.entries(adjustedMaterials)) {
      totalMaterials[matId] = qty * quantity;
    }

    if (!this.hasMaterials(player, totalMaterials)) {
      await interaction.followUp({
        content: `‚ùå Not enough materials to brew ${quantity}x.`,
        ephemeral: true,
      });
      return;
    }

    const baseFailChance = Math.min(0.35 + (requiredLevel * 0.03), 0.8);
    const reduction = hasBotanic ? botanicLevel * 0.02 : 0;
    const penalty = hasBotanic ? 0 : 0.15;
    const failChance = Math.min(Math.max(baseFailChance - reduction + penalty, 0.05), 0.9);

    // Consume all materials upfront
    this.consumeMaterials(player, totalMaterials);

    // Get output name before loop
    const outputName = this.getItemDisplayName(recipe.output.item);

    // Process each brew attempt
    let successCount = 0;
    let failCount = 0;
    let totalOutput = 0;
    const xpThreshold = 100;
    const MAX_PROFESSION_LEVEL = 80;
    
    // Send initial progress embed that will be edited
    const initialEmbed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle(`üß™ Brewing Progress: 0/${quantity}`)
      .setDescription(
        `**Item:** ${outputName}\n` +
        `**Success:** 0 | **Failed:** 0\n` +
        `**Botanic Level:** ${botanicLevel}/${MAX_PROFESSION_LEVEL}\n` +
        `**XP Gained:** 0 XP\n` +
        `**Progress:** 0/${quantity}`
      );

    let progressMessage = await interaction.editReply({ embeds: [initialEmbed] });

    for (let i = 0; i < quantity; i++) {
      const roll = Math.random();
      if (roll < failChance) {
        failCount++;
      } else {
        successCount++;
        totalOutput += recipe.output.quantity;
      }

      // Update overview embed to show progress every craft (or every 5 for large batches)
      const shouldUpdate = quantity <= 10 || (i + 1) % 5 === 0 || i === quantity - 1;
      if (shouldUpdate) {
        const xpGainCurrent = requiredLevel * 10 * successCount;
        const currentBotanicLevel = player.professionLevels.botanic || 1;
        const currentXp = player.professionXp?.botanic || 0;
        const xpProgress = currentXp % xpThreshold;
        const xpNeeded = xpThreshold - xpProgress;
        const xpProgressBar = this.buildProgressBar(xpProgress, xpThreshold, 10);

        const updatedEmbed = new EmbedBuilder()
          .setColor(0x3498db)
          .setTitle(`üß™ Brewing Progress: ${i + 1}/${quantity}`)
          .setDescription(
            `**Item:** ${outputName}\n` +
            `**Success:** ${successCount} | **Failed:** ${failCount}\n` +
            `**Botanic Level:** ${currentBotanicLevel}/${MAX_PROFESSION_LEVEL}\n` +
            `**XP Progress:** ${xpProgressBar} (${xpProgress}/${xpThreshold})\n` +
            `**XP Gained:** ${xpGainCurrent} XP\n` +
            `**Until Next Level:** ${xpNeeded} XP`
          );

        try {
          await interaction.editReply({ embeds: [updatedEmbed] });
        } catch (err) {
          // Silently fail if edit rate limit hit
        }
      }
    }

    // Add all successful brews to inventory
    let craftResult = { equipped: [], added: [] };
    if (totalOutput > 0) {
      craftResult = this.addCraftedItem(player, recipe.output.item, totalOutput);
    }

    // Award XP for successful brews
    if (hasBotanic && successCount > 0) {
      const xpGain = requiredLevel * 10 * successCount;
      player.professionXp = player.professionXp || {};
      player.professionLevels = player.professionLevels || {};
      
      if (botanicLevel < MAX_PROFESSION_LEVEL) {
        player.professionXp.botanic = (player.professionXp.botanic || 0) + xpGain;
        while (player.professionXp.botanic >= xpThreshold && (player.professionLevels.botanic || 1) < MAX_PROFESSION_LEVEL) {
          player.professionXp.botanic -= xpThreshold;
          player.professionLevels.botanic = (player.professionLevels.botanic || 1) + 1;
        }
        // Cap excess XP at max level
        if ((player.professionLevels.botanic || 1) >= MAX_PROFESSION_LEVEL) {
          player.professionXp.botanic = 0;
        }
      }
    }

    this.persistPlayer(player);

    // Show final result message
    let resultMessage = '';
    if (successCount > 0) {
      resultMessage += `‚úÖ Successfully brewed **${outputName} x${totalOutput}**`;
      if (failCount > 0) {
        resultMessage += `\n‚ùå ${failCount} brew(s) failed (wasted materials)`;
      }
    } else {
      resultMessage = `‚ùå All ${quantity} brew(s) failed! Materials wasted. (Fail chance: ${(failChance * 100).toFixed(1)}%)`;
    }

    const response = await interaction.followUp({
      content: resultMessage,
      ephemeral: false,
      fetchReply: true,
    });
    
    // Delete the result message after 5 seconds
    setTimeout(() => {
      response.delete().catch(() => {});
    }, 5000);
  }

  async handlePotionDetails(interaction, player, recipeId) {
    const recipe = getRecipe(recipeId);
    if (!recipe || recipe.profession !== 'botanic') {
      await interaction.reply({ content: 'Invalid potion recipe.', ephemeral: true });
      return;
    }

    const getPotionEffect = (itemId) => {
      if (itemId.includes('xp_potion')) {
        const tier = parseInt(itemId.match(/t(\d+)/)?.[1] || 1);
        const bonus = [10, 20, 35, 50, 75][tier - 1] || 10;
        return `+${bonus}% XP gain for the next combat or quest`;
      }
      if (itemId.includes('gold_potion')) {
        const tier = parseInt(itemId.match(/t(\d+)/)?.[1] || 1);
        const bonus = [10, 20, 35, 50, 75][tier - 1] || 10;
        return `+${bonus}% Gold earned for the next combat or quest`;
      }
      if (itemId.includes('health_potion')) {
        const tier = parseInt(itemId.match(/t(\d+)/)?.[1] || 1);
        const heal = [50, 100, 200, 350, 500][tier - 1] || 50;
        return `Restores ${heal} HP instantly`;
      }
      if (itemId.includes('gathering_potion')) {
        const tier = parseInt(itemId.match(/t(\d+)/)?.[1] || 1);
        const bonus = [15, 25, 40, 60, 80][tier - 1] || 15;
        return `+${bonus}% gathering yield for 30 minutes`;
      }
      if (itemId.includes('loot_potion')) {
        const tier = parseInt(itemId.match(/t(\d+)/)?.[1] || 1);
        const bonus = [10, 20, 30, 45, 60][tier - 1] || 10;
        return `+${bonus}% rare loot chance for next 5 combats`;
      }
      return 'Unknown effect';
    };

    const effect = getPotionEffect(recipe.output.item);
    const tier = recipe.tier || 1;
    const tierNames = ['', 'Basic', 'Uncommon', 'Rare', 'Epic', 'Legendary'];
    
    // Build materials status with checkmarks and Xs
    const baseMaterials = this.getAdjustedMaterials(recipe.materials || {});
    const costMultiplier = this.getProfessionCostMultiplier(player) * (player.professions?.includes('botanic') ? 1 : 1.5);
    const adjustedMaterials = this.applyCostMultiplier(baseMaterials, costMultiplier);
    
    const matList = Object.entries(adjustedMaterials)
      .map(([matId, qty]) => {
        const materialName = getMaterial(matId)?.name || matId;
        const playerCount = this.getMaterialCounts(player)[matId] || 0;
        const hasEnough = playerCount >= qty;
        const icon = hasEnough ? '‚úÖ' : '‚ùå';
        return `${icon} ${materialName} x${qty}`;
      })
      .join('\n');

    const embed = new EmbedBuilder()
      .setColor(0x2ecc71)
      .setTitle(`üß™ ${recipe.name}`)
      .setDescription(`**Tier ${tier}** - ${tierNames[tier] || 'Unknown'}`)
      .addFields(
        { name: '‚ú® Effect', value: effect, inline: false },
        { name: 'üìä Output', value: `${recipe.output.quantity}x potions per craft`, inline: true },
        { name: '‚è±Ô∏è Craft Time', value: `${recipe.craftTime || 2} seconds`, inline: true },
        { name: 'üì¶ Required Materials', value: matList || 'None', inline: false }
      );

    if (recipe.requiresProfession) {
      embed.addFields({
        name: 'üîí Requirements',
        value: `Requires Botanic profession (Level ${recipe.level || 1}+)`,
        inline: false
      });
    }

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-alchemy')
        .setLabel('‚Üê Back to Alchemy')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * POTION BONUS CAPS (to prevent exploit via stacking 500+ potions):
   * - XP Bonus: 500% max (50x multiplier)
   * - Gold Bonus: 500% max (50x multiplier)
   * - Loot Bonus: 200% max (3x drop rate)
   * - Health Pre-heal: 5000 HP max
   * - Gathering Duration: 24 hours max
   */
  async handleUsePotionSelector(interaction, player) {
    const consumables = player.inventory.filter(
      item => item && typeof item === 'object' && item.type === 'consumable' && item.subtype !== 'lootbox'
    );

    if (consumables.length === 0) {
      await interaction.reply({
        content: 'üß™ You have no potions to use!',
        ephemeral: true,
      });
      return;
    }

    // Sort consumables by rarity (highest to lowest)
    const rarityOrder = { 'legendary': 4, 'epic': 3, 'rare': 2, 'uncommon': 1, 'basic': 0 };
    
    consumables.sort((a, b) => {
      // Get rarity from the item rarity property or parse from name
      const getRarity = (item) => {
        if (item.rarity) return item.rarity.toLowerCase();
        const rarities = ['legendary', 'epic', 'rare', 'uncommon', 'basic'];
        for (const rarity of rarities) {
          if (item.name.toLowerCase().includes(rarity)) return rarity;
        }
        return 'basic';
      };
      
      const rarityA = getRarity(a);
      const rarityB = getRarity(b);
      return (rarityOrder[rarityB] || 0) - (rarityOrder[rarityA] || 0);
    });

    const options = consumables.slice(0, 25).map(item => ({
      label: `${item.name} x${item.quantity || 1}`.slice(0, 100),
      value: item.id,
      description: `Use this potion`.slice(0, 100),
    }));

    // Build active buffs summary
    let buffsStatus = this.getPotionBuffsSummary(player);
    let descriptionText = 'üß™ **Potion Bonus Caps:**\n' +
      '‚Ä¢ XP/Gold: 500% max | Loot: 200% max | Health: 5000 HP max\n' +
      '‚Ä¢ Gathering: 24 hours max\n\n' +
      'Potions at cap will be wasted!';
    
    if (buffsStatus) {
      descriptionText += `\n\n**Your Active Buffs:**\n${buffsStatus}`;
    }

    const embed = new EmbedBuilder()
      .setColor(0x2ecc71)
      .setTitle('üíä Use Potion')
      .setDescription(descriptionText);

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-use-potion-select')
        .setPlaceholder('Select a potion to use')
        .addOptions(options)
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-inventory')
        .setLabel('‚Üê Back to Inventory')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  async handleUsePotionQuantity(interaction, player, potionId) {
    // Find the potion in inventory
    const potion = player.inventory.find(
      item => item && typeof item === 'object' && item.type === 'consumable' && item.id === potionId
    );

    if (!potion || !potion.quantity) {
      await interaction.reply({
        content: '‚ùå Potion not found in inventory!',
        ephemeral: true,
      });
      return;
    }

    const maxQuantity = potion.quantity;
    const quantities = [1, 5, 10, 25, 50, 100].filter(q => q <= maxQuantity);

    // Add "Use All" option if there's a quantity not covered
    if (maxQuantity > 1 && !quantities.includes(maxQuantity)) {
      quantities.push(maxQuantity);
    }
    quantities.sort((a, b) => a - b);

    const buttons = quantities.map(qty =>
      new ButtonBuilder()
        .setCustomId(`rpg-use-potion-qty-${potionId}-${qty}`)
        .setLabel(`Use ${qty}x`)
        .setStyle(ButtonStyle.Primary)
    );

    // Add cancel button
    buttons.push(
      new ButtonBuilder()
        .setCustomId('rpg-inventory')
        .setLabel('‚Üê Cancel')
        .setStyle(ButtonStyle.Secondary)
    );

    // Get current buff info for this potion type
    let currentBuffInfo = '';
    const pb = player.potionBuffs || {};
    
    if (potionId.includes('xp_potion')) {
      const current = pb.xpBonus || 0;
      const cap = 500;
      const remaining = cap - current;
      currentBuffInfo = `\n\nüìä **Current:** ${current}% / ${cap}% (${remaining}% until cap)`;
      if (current >= cap) currentBuffInfo += `\n‚ö†Ô∏è **Already at maximum!** Potions will be wasted.`;
    } else if (potionId.includes('gold_potion')) {
      const current = pb.goldBonus || 0;
      const cap = 500;
      const remaining = cap - current;
      currentBuffInfo = `\n\nüìä **Current:** ${current}% / ${cap}% (${remaining}% until cap)`;
      if (current >= cap) currentBuffInfo += `\n‚ö†Ô∏è **Already at maximum!** Potions will be wasted.`;
    } else if (potionId.includes('loot_potion')) {
      const current = pb.lootBonus || 0;
      const cap = 200;
      const remaining = cap - current;
      currentBuffInfo = `\n\nüìä **Current:** ${current}% / ${cap}% (${remaining}% until cap)`;
      if (current >= cap) currentBuffInfo += `\n‚ö†Ô∏è **Already at maximum!** Potions will be wasted.`;
    } else if (potionId.includes('health_potion')) {
      const current = pb.nextCombatHeal || 0;
      const cap = 5000;
      const remaining = cap - current;
      currentBuffInfo = `\n\nüìä **Current:** ${current} HP / ${cap} HP (${remaining} HP until cap)`;
      if (current >= cap) currentBuffInfo += `\n‚ö†Ô∏è **Already at maximum!** Potions will be wasted.`;
    }

    const embed = new EmbedBuilder()
      .setColor(0x2ecc71)
      .setTitle('üíä Select Quantity')
      .setDescription(`**${potion.name}**\n\nYou have **${maxQuantity}x** available.\nSelect how many to use:${currentBuffInfo}`)
      .addFields({ name: 'Current Stock', value: `${maxQuantity} potions`, inline: true });

    // Split buttons into rows (5 per row max)
    const rows = [];
    for (let i = 0; i < buttons.length; i += 5) {
      rows.push(new ActionRowBuilder().addComponents(buttons.slice(i, i + 5)));
    }

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  async handleUsePotion(interaction, player, potionId) {
    // Find the potion in inventory
    const potionIndex = player.inventory.findIndex(
      item => item && typeof item === 'object' && item.type === 'consumable' && item.id === potionId
    );

    if (potionIndex === -1) {
      await interaction.reply({
        content: '‚ùå Potion not found in inventory!',
        ephemeral: true,
      });
      return;
    }

    const potion = player.inventory[potionIndex];
    let effectMessage = '';

    // Apply potion effects
    if (potionId.includes('health_potion')) {
      const tier = parseInt(potionId.match(/t(\d+)/)?.[1] || 1);
      const heal = [50, 100, 200, 350, 500][tier - 1] || 50;
      
      // Note: Since there's no HP tracking in non-combat, store this as a buff
      player.potionBuffs = player.potionBuffs || {};
      const currentHeal = player.potionBuffs.nextCombatHeal || 0;
      const HEALTH_CAP = 5000; // Maximum 5000 HP pre-heal
      
      if (currentHeal >= HEALTH_CAP) {
        effectMessage = `‚ö†Ô∏è Pre-combat heal is already at maximum (${HEALTH_CAP} HP)! Potion wasted.`;
      } else {
        const newHeal = Math.min(currentHeal + heal, HEALTH_CAP);
        const actualHeal = newHeal - currentHeal;
        player.potionBuffs.nextCombatHeal = newHeal;
        effectMessage = `üíö You will restore ${actualHeal} HP at the start of your next combat! (Total: ${newHeal} HP)`;
        if (newHeal === HEALTH_CAP) effectMessage += ` **[CAPPED]**`;
      }
    }
    else if (potionId.includes('xp_potion')) {
      const tier = parseInt(potionId.match(/t(\d+)/)?.[1] || 1);
      const bonus = [10, 20, 35, 50, 75][tier - 1] || 10;
      
      player.potionBuffs = player.potionBuffs || {};
      const currentBonus = player.potionBuffs.xpBonus || 0;
      const XP_CAP = 500; // Maximum 500% XP bonus
      
      if (currentBonus >= XP_CAP) {
        effectMessage = `‚ö†Ô∏è XP bonus is already at maximum (${XP_CAP}%)! Potion wasted.`;
      } else {
        const newBonus = Math.min(currentBonus + bonus, XP_CAP);
        const actualBonus = newBonus - currentBonus;
        player.potionBuffs.xpBonus = newBonus;
        player.potionBuffs.xpRemaining = (player.potionBuffs.xpRemaining || 0) + 1;
        effectMessage = `‚ú® +${actualBonus}% XP bonus for your next combat or quest! (Total: ${newBonus}%)`;
        if (newBonus === XP_CAP) effectMessage += ` **[CAPPED]**`;
      }
    }
    else if (potionId.includes('gold_potion')) {
      const tier = parseInt(potionId.match(/t(\d+)/)?.[1] || 1);
      const bonus = [10, 20, 35, 50, 75][tier - 1] || 10;
      
      player.potionBuffs = player.potionBuffs || {};
      const currentBonus = player.potionBuffs.goldBonus || 0;
      const GOLD_CAP = 500; // Maximum 500% Gold bonus
      
      if (currentBonus >= GOLD_CAP) {
        effectMessage = `‚ö†Ô∏è Gold bonus is already at maximum (${GOLD_CAP}%)! Potion wasted.`;
      } else {
        const newBonus = Math.min(currentBonus + bonus, GOLD_CAP);
        const actualBonus = newBonus - currentBonus;
        player.potionBuffs.goldBonus = newBonus;
        player.potionBuffs.goldRemaining = (player.potionBuffs.goldRemaining || 0) + 1;
        effectMessage = `üí∞ +${actualBonus}% Gold bonus for your next combat or quest! (Total: ${newBonus}%)`;
        if (newBonus === GOLD_CAP) effectMessage += ` **[CAPPED]**`;
      }
    }
    else if (potionId.includes('gathering_potion')) {
      const tier = parseInt(potionId.match(/t(\d+)/)?.[1] || 1);
      const bonus = [15, 25, 40, 60, 80][tier - 1] || 15;
      const duration = 30 * 60 * 1000; // 30 minutes
      
      player.potionBuffs = player.potionBuffs || {};
      player.potionBuffs.gatheringBonus = bonus;
      player.potionBuffs.gatheringExpires = Date.now() + duration;
      effectMessage = `‚õèÔ∏è +${bonus}% gathering yield for 30 minutes!`;
    }
    else if (potionId.includes('loot_potion')) {
      const tier = parseInt(potionId.match(/t(\d+)/)?.[1] || 1);
      const bonus = [10, 20, 30, 45, 60][tier - 1] || 10;
      
      player.potionBuffs = player.potionBuffs || {};
      const currentBonus = player.potionBuffs.lootBonus || 0;
      const LOOT_CAP = 200; // Maximum 200% Loot bonus
      
      if (currentBonus >= LOOT_CAP) {
        effectMessage = `‚ö†Ô∏è Loot bonus is already at maximum (${LOOT_CAP}%)! Potion wasted.`;
      } else {
        const newBonus = Math.min(currentBonus + bonus, LOOT_CAP);
        const actualBonus = newBonus - currentBonus;
        player.potionBuffs.lootBonus = newBonus;
        player.potionBuffs.lootRemaining = (player.potionBuffs.lootRemaining || 0) + 5;
        effectMessage = `üéÅ +${actualBonus}% rare loot chance for next 5 combats! (Total: ${newBonus}%)`;
        if (newBonus === LOOT_CAP) effectMessage += ` **[CAPPED]**`;
      }
    }
    else {
      effectMessage = '‚úÖ Potion consumed!';
    }

    // Remove one potion from inventory (only if not wasted)
    let potionWasted = effectMessage.includes('already at maximum');
    
    if (!potionWasted) {
      if (potion.quantity > 1) {
        potion.quantity -= 1;
      } else {
        player.inventory.splice(potionIndex, 1);
      }
    }

    this.persistPlayer(player);

    // Build active buffs summary
    let buffsStatus = this.getPotionBuffsSummary(player);
    let statusText = buffsStatus ? `\n\n**Active Buffs:**\n${buffsStatus}` : '';

    const reply = await interaction.reply({
      content: `üß™ **Used ${potion.name}!**\n${effectMessage}${statusText}`,
      ephemeral: false,
    });

    // Auto-delete after 8 seconds (longer to read)
    setTimeout(() => {
      reply.delete().catch(() => {});
    }, 8000);
  }

  async handleUsePotionMultiple(interaction, player, potionId, quantity) {
    // Find the potion in inventory
    const potionIndex = player.inventory.findIndex(
      item => item && typeof item === 'object' && item.type === 'consumable' && item.id === potionId
    );

    if (potionIndex === -1) {
      await interaction.reply({
        content: '‚ùå Potion not found in inventory!',
        ephemeral: true,
      });
      return;
    }

    const potion = player.inventory[potionIndex];
    
    // Check if we have enough potions
    if (!potion.quantity || potion.quantity < quantity) {
      await interaction.reply({
        content: `‚ùå You don't have enough potions! (Need ${quantity}, Have ${potion.quantity || 1})`,
        ephemeral: true,
      });
      return;
    }

    let totalEffectMessage = '';
    let totalHeal = 0;
    let totalXpBonus = 0;
    let totalGoldBonus = 0;
    let totalLootBonus = 0;
    let gatheringBonus = 0;

    // Apply potion effects for each potion consumed
    for (let i = 0; i < quantity; i++) {
      if (potionId.includes('health_potion')) {
        const tier = parseInt(potionId.match(/t(\d+)/)?.[1] || 1);
        const heal = [50, 100, 200, 350, 500][tier - 1] || 50;
        totalHeal += heal;
      }
      else if (potionId.includes('xp_potion')) {
        const tier = parseInt(potionId.match(/t(\d+)/)?.[1] || 1);
        const bonus = [10, 20, 35, 50, 75][tier - 1] || 10;
        totalXpBonus += bonus;
      }
      else if (potionId.includes('gold_potion')) {
        const tier = parseInt(potionId.match(/t(\d+)/)?.[1] || 1);
        const bonus = [10, 20, 35, 50, 75][tier - 1] || 10;
        totalGoldBonus += bonus;
      }
      else if (potionId.includes('gathering_potion')) {
        const tier = parseInt(potionId.match(/t(\d+)/)?.[1] || 1);
        const bonus = [15, 25, 40, 60, 80][tier - 1] || 15;
        gatheringBonus = bonus; // Use the highest bonus (it stacks in duration, not value)
      }
      else if (potionId.includes('loot_potion')) {
        const tier = parseInt(potionId.match(/t(\d+)/)?.[1] || 1);
        const bonus = [10, 20, 30, 45, 60][tier - 1] || 10;
        totalLootBonus += bonus;
      }
    }

    // Apply consolidated buffs
    player.potionBuffs = player.potionBuffs || {};
    
    if (totalHeal > 0) {
      const currentHeal = player.potionBuffs.nextCombatHeal || 0;
      const HEALTH_CAP = 5000;
      const newHeal = Math.min(currentHeal + totalHeal, HEALTH_CAP);
      const actualHeal = newHeal - currentHeal;
      
      player.potionBuffs.nextCombatHeal = newHeal;
      totalEffectMessage += `üíö +${actualHeal} HP at next combat start (Total: ${newHeal} HP)`;
      if (newHeal === HEALTH_CAP) totalEffectMessage += ` **[CAPPED]**`;
      totalEffectMessage += `\n`;
    }
    if (totalXpBonus > 0) {
      const currentBonus = player.potionBuffs.xpBonus || 0;
      const XP_CAP = 500;
      const newBonus = Math.min(currentBonus + totalXpBonus, XP_CAP);
      const actualBonus = newBonus - currentBonus;
      
      player.potionBuffs.xpBonus = newBonus;
      player.potionBuffs.xpRemaining = (player.potionBuffs.xpRemaining || 0) + quantity;
      totalEffectMessage += `‚ú® +${actualBonus}% XP bonus for next ${quantity} actions (Total: ${newBonus}%)`;
      if (newBonus === XP_CAP) totalEffectMessage += ` **[CAPPED]**`;
      totalEffectMessage += `\n`;
    }
    if (totalGoldBonus > 0) {
      const currentBonus = player.potionBuffs.goldBonus || 0;
      const GOLD_CAP = 500;
      const newBonus = Math.min(currentBonus + totalGoldBonus, GOLD_CAP);
      const actualBonus = newBonus - currentBonus;
      
      player.potionBuffs.goldBonus = newBonus;
      player.potionBuffs.goldRemaining = (player.potionBuffs.goldRemaining || 0) + quantity;
      totalEffectMessage += `üí∞ +${actualBonus}% Gold bonus for next ${quantity} actions (Total: ${newBonus}%)`;
      if (newBonus === GOLD_CAP) totalEffectMessage += ` **[CAPPED]**`;
      totalEffectMessage += `\n`;
    }
    if (gatheringBonus > 0) {
      const DURATION_CAP = 24 * 60 * 60 * 1000; // Cap at 24 hours
      const duration = Math.min(30 * 60 * 1000 * quantity, DURATION_CAP); // 30 minutes per potion
      const minutes = Math.floor(duration / 60000);
      
      player.potionBuffs.gatheringBonus = gatheringBonus;
      player.potionBuffs.gatheringExpires = Date.now() + duration;
      totalEffectMessage += `‚õèÔ∏è +${gatheringBonus}% gathering yield for ${minutes} minutes`;
      if (duration === DURATION_CAP) totalEffectMessage += ` **[CAPPED at 24h]**`;
      totalEffectMessage += `\n`;
    }
    if (totalLootBonus > 0) {
      const currentBonus = player.potionBuffs.lootBonus || 0;
      const LOOT_CAP = 200;
      const newBonus = Math.min(currentBonus + totalLootBonus, LOOT_CAP);
      const actualBonus = newBonus - currentBonus;
      
      player.potionBuffs.lootBonus = newBonus;
      player.potionBuffs.lootRemaining = (player.potionBuffs.lootRemaining || 0) + (5 * quantity);
      totalEffectMessage += `üéÅ +${actualBonus}% rare loot chance for next ${5 * quantity} combats (Total: ${newBonus}%)`;
      if (newBonus === LOOT_CAP) totalEffectMessage += ` **[CAPPED]**`;
      totalEffectMessage += `\n`;
    }

    // Remove potions from inventory
    potion.quantity -= quantity;
    if (potion.quantity <= 0) {
      player.inventory.splice(potionIndex, 1);
    }

    this.persistPlayer(player);

    // Build active buffs summary
    let buffsStatus = this.getPotionBuffsSummary(player);
    let statusText = buffsStatus ? `\n\n**Active Buffs:**\n${buffsStatus}` : '';

    const quantityText = quantity > 1 ? `${quantity}x ` : '';
    const reply = await interaction.reply({
      content: `üß™ **Used ${quantityText}${potion.name}!**\n${totalEffectMessage || '‚úÖ Potions consumed!'}${statusText}`,
      ephemeral: false,
    });

    // Auto-delete after 8 seconds (longer to read)
    setTimeout(() => {
      reply.delete().catch(() => {});
    }, 8000);
  }

  /**
   * Get summary of active potion buffs for display
   */
  getPotionBuffsSummary(player) {
    if (!player.potionBuffs) return '';
    
    const buffs = [];
    const pb = player.potionBuffs;
    
    if (pb.xpBonus && pb.xpRemaining > 0) {
      const capIndicator = pb.xpBonus >= 500 ? ' üî¥' : '';
      buffs.push(`‚ú® **+${pb.xpBonus}%** XP (${pb.xpRemaining} uses left)${capIndicator}`);
    }
    
    if (pb.goldBonus && pb.goldRemaining > 0) {
      const capIndicator = pb.goldBonus >= 500 ? ' üî¥' : '';
      buffs.push(`üí∞ **+${pb.goldBonus}%** Gold (${pb.goldRemaining} uses left)${capIndicator}`);
    }
    
    if (pb.lootBonus && pb.lootRemaining > 0) {
      const capIndicator = pb.lootBonus >= 200 ? ' üî¥' : '';
      buffs.push(`üéÅ **+${pb.lootBonus}%** Loot (${pb.lootRemaining} combats)${capIndicator}`);
    }
    
    if (pb.nextCombatHeal > 0) {
      const capIndicator = pb.nextCombatHeal >= 5000 ? ' üî¥' : '';
      buffs.push(`üíö **${pb.nextCombatHeal} HP** heal ready${capIndicator}`);
    }
    
    if (pb.gatheringBonus && pb.gatheringExpires > Date.now()) {
      const minutesLeft = Math.ceil((pb.gatheringExpires - Date.now()) / 60000);
      const hoursLeft = Math.floor(minutesLeft / 60);
      const timeStr = hoursLeft > 0 ? `${hoursLeft}h ${minutesLeft % 60}m` : `${minutesLeft}m`;
      buffs.push(`‚õèÔ∏è **+${pb.gatheringBonus}%** Gathering (${timeStr} left)`);
    }
    
    if (buffs.length === 0) return '';
    
    return buffs.join('\n') + '\nüî¥ = Capped (max bonus reached)';
  }

  /**
   * Extract enchant type from recipe ID (e.g., "damage_enchant_t3" -> "damage")
   */
  getEnchantType(enchantId) {
    if (!enchantId) return 'unknown';
    const match = enchantId.match(/^([a-z]+)_enchant/);
    return match ? match[1] : 'unknown';
  }

  /**
   * Migrate old enchant data structure (number) to new structure (object with types)
   * Old: { weapon: 5 } -> New: { weapon: { damage: 5 } }
   */
  migrateEnchantData(player) {
    if (!player.equipmentEnchants) {
      player.equipmentEnchants = {};
      return;
    }

    // Check if migration is needed (old structure has numbers as values)
    let needsMigration = false;
    for (const [slot, value] of Object.entries(player.equipmentEnchants)) {
      if (typeof value === 'number') {
        needsMigration = true;
        break;
      }
    }

    if (!needsMigration) return;

    // Migrate: assume old enchants were "damage" type (most common)
    const migratedEnchants = {};
    for (const [slot, level] of Object.entries(player.equipmentEnchants)) {
      if (typeof level === 'number' && level > 0) {
        migratedEnchants[slot] = { damage: level };
      } else if (typeof level === 'object') {
        migratedEnchants[slot] = level; // Already migrated
      } else {
        migratedEnchants[slot] = {}; // Empty enchants
      }
    }

    player.equipmentEnchants = migratedEnchants;
    this.persistPlayer(player);
  }

  /**
   * Perform auto-enchanting until target level or materials run out
   */
  async performAutoEnchant(player, slot, enchantType, recipe, targetLevel, hasEnchanter, enchanterLevel, requiredLevel) {
    const startLevel = (player.equipmentEnchants[slot][enchantType] || 0);
    let currentLevel = startLevel;
    let attempts = 0;
    let successes = 0;
    let failures = 0;
    const maxEnchant = 10;

    const baseMaterials = this.getAdjustedMaterials(recipe.materials || {});
    const costMultiplier = this.getProfessionCostMultiplier(player) * (hasEnchanter ? 1 : 1.6);
    const adjustedMaterials = this.applyCostMultiplier(baseMaterials, costMultiplier);

    const baseFailChance = Math.min(0.4 + (requiredLevel * 0.04), 0.85);
    const reduction = hasEnchanter ? enchanterLevel * 0.02 : 0;
    const penalty = hasEnchanter ? 0 : 0.2;
    const failChance = Math.min(Math.max(baseFailChance - reduction + penalty, 0.05), 0.9);

    let stopReason = '';
    const MAX_ATTEMPTS = 1000; // Safety limit

    while (currentLevel < targetLevel && currentLevel < maxEnchant && attempts < MAX_ATTEMPTS) {
      attempts++;

      // Check materials
      if (!this.hasMaterials(player, adjustedMaterials)) {
        stopReason = 'Out of materials';
        break;
      }

      // Consume materials
      this.consumeMaterials(player, adjustedMaterials);

      // Roll for success
      const roll = Math.random();
      if (roll < failChance) {
        failures++;
      } else {
        currentLevel++;
        successes++;
        player.equipmentEnchants[slot][enchantType] = currentLevel;

        // Award profession XP
        if (hasEnchanter) {
          const xpGain = requiredLevel * 10;
          player.professionXp = player.professionXp || {};
          player.professionLevels = player.professionLevels || {};
          const MAX_PROFESSION_LEVEL = 80;
          const currentProfLevel = player.professionLevels.enchanter || 1;
          
          if (currentProfLevel < MAX_PROFESSION_LEVEL) {
            player.professionXp.enchanter = (player.professionXp.enchanter || 0) + xpGain;
            while (player.professionXp.enchanter >= 100 && (player.professionLevels.enchanter || 1) < MAX_PROFESSION_LEVEL) {
              player.professionXp.enchanter -= 100;
              player.professionLevels.enchanter = (player.professionLevels.enchanter || 1) + 1;
            }
            if ((player.professionLevels.enchanter || 1) >= MAX_PROFESSION_LEVEL) {
              player.professionXp.enchanter = 0;
            }
          }
        }
      }
    }

    player.clearStatsCache();
    this.persistPlayer(player);

    return {
      startLevel,
      endLevel: currentLevel,
      attempts,
      successes,
      failures,
      reachedTarget: currentLevel >= targetLevel,
      stopReason: stopReason || (currentLevel >= maxEnchant ? 'Max enchant level reached' : '')
    };
  }

  async handleEnchant(interaction, player) {
    this.trackMenuNavigation(player, 'enchant');
    const hasEnchanter = player.professions?.includes('enchanter');
    const enchanterLevel = Number(player.professionLevels?.enchanter) || 0;

    const recipes = RECIPES_SORTED.filter((rec) => rec.profession === 'enchanter');

    // Migrate old enchant data if needed
    this.migrateEnchantData(player);

    // Check equipped items
    const equippedSlots = this.getResolvedEquippedSlots(player);
    const enchantInfo = {
      damage: '+5% attack damage per level',
      xp: '+10% XP gain per level',
      loot: '+8% item drop rate per level',
      doublehit: '+3% chance to hit twice per level'
    };

    // Build enchant overview
    let enchantOverview = '';
    if (equippedSlots.length > 0) {
      const slotEnchants = equippedSlots.map(slot => {
        const enchants = player.equipmentEnchants?.[slot] || {};
        const enchantStrings = Object.entries(enchants)
          .filter(([type, level]) => level > 0)
          .map(([type, level]) => `${type} +${level}`)
          .join(', ');
        return `**${slot.toUpperCase()}**: ${enchantStrings || 'None'}`;
      });
      enchantOverview = '\n\n**Current Enchants:**\n' + slotEnchants.join('\n');
    }

    const embed = new EmbedBuilder()
      .setColor(0x8e44ad)
      .setTitle('‚ú® Enchantment - Gear Enhancement')
      .setDescription(
        hasEnchanter
          ? `**Enchanter Level: ${enchanterLevel}**\n**Tier 1-2**: Accessible to all\n**Tier 3-5**: Requires Enchanter profession\n\n**NEW**: Up to 2 different enchants per slot (max +10 each)\n**NEW**: Auto-enchant to target level!${enchantOverview}`
          : `**No Enchanter Profession**\nAccess Tier 1-2 enchants. Tier 3-5 require the profession.\nCosts 60% more materials without profession.\n\n**NEW**: Up to 2 different enchants per slot (max +10 each)\n**NEW**: Auto-enchant to target level!${enchantOverview}`
      )
      .addFields([
        { name: 'üî• Damage Enchant', value: enchantInfo.damage, inline: true },
        { name: '‚≠ê XP Enchant', value: enchantInfo.xp, inline: true },
        { name: 'üíé Loot Enchant', value: enchantInfo.loot, inline: true },
        { name: '‚ö° Double Hit Enchant', value: enchantInfo.doublehit, inline: true },
      ]);

    if (equippedSlots.length === 0) {
      await interaction.reply({ content: 'You need to equip some gear first!', ephemeral: true });
      return;
    }

    const options = recipes.slice(0, 25).map((rec) => {
      const recLevel = Number(rec.level) || 1;
      const recTier = Number(rec.tier) || 1;
      const playerLock = player.level < recLevel;
      const requiresProf = rec.requiresProfession && (!hasEnchanter || enchanterLevel < recLevel);
      
      // Check if boss damage enchant t4/t5 requires shop unlock
      const requiresBossShopUnlock = (rec.id === 'boss_damage_enchant_t4' || rec.id === 'boss_damage_enchant_t5');
      const hasShopUnlock = requiresBossShopUnlock 
        ? (player.bossEnchantRecipesUnlocked || []).includes(rec.id) 
        : true;
      
      const locked = playerLock || requiresProf || (requiresBossShopUnlock && !hasShopUnlock);
      
      // Build requirement text
      let reqText = '';
      if (playerLock) {
        reqText = `‚ùå Requires Player Lvl ${recLevel}`;
      } else if (requiresProf) {
        reqText = `‚ùå Requires Enchanter Lvl ${recLevel}`;
      } else if (requiresBossShopUnlock && !hasShopUnlock) {
        reqText = `‚ùå Purchase from Boss Shop`;
      } else {
        reqText = `‚úì Tier ${recTier}`;
      }
      
      // Build materials text
      const matText = Object.entries(rec.materials || {})
        .map(([mat, qty]) => `${Number(qty) || 1}x ${getMaterial(mat)?.name || mat}`)
        .join(', ');
      
      const lockTag = locked ? ' [üîí]' : '';
      const desc = matText ? `${reqText} ‚Ä¢ ${matText}` : reqText;
      return {
        label: `${rec.name}${lockTag}`.slice(0, 100),
        value: String(rec.id),
        description: (desc || 'Enchant').slice(0, 100),
      };
    });

    const rows = [];
    if (options.length > 0) {
      // Validate and filter options
      const validOptions = options.filter(opt => opt && opt.label && opt.value);
      
      if (validOptions.length > 0) {
        rows.push(
          new ActionRowBuilder().addComponents(
            new StringSelectMenuBuilder()
              .setCustomId('rpg-enchant-select')
              .setPlaceholder('Select an enchantment')
              .addOptions(validOptions)
          )
        );
      }
    }

    // Add auto-enchant button
    const autoEnchantRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-auto-enchant-menu')
        .setLabel('üîÑ Auto-Enchant to Target +')
        .setStyle(ButtonStyle.Primary)
    );
    rows.push(autoEnchantRow);

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );
    rows.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  async handleAutoEnchantMenu(interaction, player) {
    this.trackMenuNavigation(player, 'auto-enchant');
    const hasEnchanter = player.professions?.includes('enchanter');
    const enchanterLevel = Number(player.professionLevels?.enchanter) || 0;

    const recipes = RECIPES_SORTED.filter((rec) => rec.profession === 'enchanter');

    // Migrate old enchant data
    this.migrateEnchantData(player);

    const embed = new EmbedBuilder()
      .setColor(0x8e44ad)
      .setTitle('üîÑ Auto-Enchant')
      .setDescription(
        'Select enchant type and target level.\\n\\n' +
        '**How it works:**\\n' +
        '1. Choose an enchant type\\n' +
        '2. Enter target level (1-10)\\n' +
        '3. Select which gear slot\\n' +
        '4. System automatically crafts until target is reached or materials run out\\n\\n' +
        '**Target Level Options:**'
      );

    // Create buttons for common target levels
    const targetButtons = [3, 5, 7, 10].map(level => 
      new ButtonBuilder()
        .setCustomId(`rpg-auto-enchant-target-${level}`)
        .setLabel(`Target +${level}`)
        .setStyle(ButtonStyle.Primary)
    );

    const rows = [];
    
    // Add target level buttons
    rows.push(new ActionRowBuilder().addComponents(...targetButtons));

    // Add enchant type select
    const enchantOptions = recipes.slice(0, 25).map((rec) => {
      const recLevel = Number(rec.level) || 1;
      const recTier = Number(rec.tier) || 1;
      const playerLock = player.level < recLevel;
      const requiresProf = rec.requiresProfession && (!hasEnchanter || enchanterLevel < recLevel);
      const locked = playerLock || requiresProf;
      
      let reqText = locked ? '‚ùå Locked' : `‚úì T${recTier}`;
      
      return {
        label: `${rec.name} ${locked ? '[üîí]' : ''}`.slice(0, 100),
        value: String(rec.id),
        description: reqText.slice(0, 100),
      };
    });

    const validOptions = enchantOptions.filter(opt => opt && opt.label && opt.value);
    if (validOptions.length > 0) {
      rows.push(
        new ActionRowBuilder().addComponents(
          new StringSelectMenuBuilder()
            .setCustomId('rpg-auto-enchant-type-select')
            .setPlaceholder('Select enchant type')
            .addOptions(validOptions)
        )
      );
    }

    rows.push(new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-enchant')
        .setLabel('‚Üê Back to Enchanting')
        .setStyle(ButtonStyle.Secondary)
    ));

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  async handleEnchantCraft(interaction, player, enchantId, targetLevel = null) {
    const recipe = getRecipe(enchantId);
    if (!recipe || recipe.profession !== 'enchanter') {
      await interaction.reply({ content: 'Invalid enchantment recipe.', ephemeral: true });
      return;
    }

    const hasEnchanter = player.professions?.includes('enchanter');
    const enchanterLevel = player.professionLevels?.enchanter || 0;
    const requiredLevel = recipe.level || 1;
    const tier = recipe.tier || 1;

    if (player.level < requiredLevel) {
      await interaction.reply({ content: `You need player level ${requiredLevel} to use this enchantment.`, ephemeral: true });
      return;
    }

    // Check tier-based access
    if (recipe.requiresProfession && (!hasEnchanter || enchanterLevel < requiredLevel)) {
      await interaction.reply({ content: `Tier ${tier} enchants require Enchanter Level ${requiredLevel}.`, ephemeral: true });
      return;
    }

    // Check if boss damage enchant t4/t5 requires shop unlock
    const requiresBossShopUnlock = (enchantId === 'boss_damage_enchant_t4' || enchantId === 'boss_damage_enchant_t5');
    if (requiresBossShopUnlock) {
      const hasShopUnlock = (player.bossEnchantRecipesUnlocked || []).includes(enchantId);
      if (!hasShopUnlock) {
        await interaction.reply({ content: `‚ùå This recipe must be purchased from the Boss Shop first!`, ephemeral: true });
        return;
      }
    }

    // Check which slots are equipped
    const equippedSlots = this.getResolvedEquippedSlots(player);
    if (equippedSlots.length === 0) {
      await interaction.reply({ content: 'You need equipped gear to enchant.', ephemeral: true });
      return;
    }

    // If target level is specified, ask for confirmation
    if (targetLevel && !player.confirmedAutoEnchant) {
      const enchantType = this.getEnchantType(enchantId);
      const embed = new EmbedBuilder()
        .setColor(0x8e44ad)
        .setTitle('üîÑ Auto-Enchant Confirmation')
        .setDescription(`You're about to auto-enchant **${enchantType}** to **+${targetLevel}**.\n\nThis will automatically craft enchants until the target level is reached or you run out of materials.`);

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-auto-enchant-confirm-${enchantId}-${targetLevel}`)
          .setLabel('‚úÖ Confirm Auto-Enchant')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('rpg-enchant')
          .setLabel('‚ùå Cancel')
          .setStyle(ButtonStyle.Danger)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row]
      });
      return;
    }

    // If multiple slots equipped, ask player to select which one to enchant
    if (equippedSlots.length > 1 && !player.selectedEnchantSlot) {
      const enchantType = this.getEnchantType(enchantId);
      const slotButtons = equippedSlots.map(slot => {
        const equippedId = this.getResolvedEquippedItemId(player, slot);
        const equipment = getEquipment(equippedId) || getItemByIdDynamic(equippedId);
        const enchants = player.equipmentEnchants?.[slot] || {};
        const enchantLevel = enchants[enchantType] || 0;
        const enchantCount = Object.keys(enchants).filter(t => enchants[t] > 0).length;
        const label = `${slot.toUpperCase()} ${enchantType}+${enchantLevel} (${enchantCount}/2 types)`;
        return new ButtonBuilder()
          .setCustomId(`rpg-enchant-slot-${slot}-${enchantId}${targetLevel ? `-target${targetLevel}` : ''}`)
          .setLabel(label.slice(0, 80))
          .setStyle(ButtonStyle.Primary);
      });

      const rows = [];
      for (let i = 0; i < slotButtons.length; i += 5) {
        rows.push(new ActionRowBuilder().addComponents(...slotButtons.slice(i, i + 5)));
      }

      rows.push(new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-enchant')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      ));

      await this.updateInteractionWithTracking(interaction, {
        content: 'Select which gear piece to enchant:',
        components: rows,
      });
      return;
    }

    // Get the slot to enchant
    const slot = player.selectedEnchantSlot || equippedSlots[0];
    delete player.selectedEnchantSlot; // Clear selection
    delete player.confirmedAutoEnchant; // Clear auto-enchant confirmation
    
    const equippedItem = this.getResolvedEquippedItemId(player, slot);
    if (!equippedItem) {
      await interaction.reply({ content: `You need an equipped ${slot} to enchant.`, ephemeral: true });
      return;
    }

    // Migrate old enchant data
    this.migrateEnchantData(player);

    // Get enchant type from recipe ID
    const enchantType = this.getEnchantType(enchantId);
    player.equipmentEnchants = player.equipmentEnchants || {};
    player.equipmentEnchants[slot] = player.equipmentEnchants[slot] || {};
    
    // Check if we can add this enchant type (max 2 different types per slot)
    const currentEnchants = player.equipmentEnchants[slot];
    const enchantTypes = Object.keys(currentEnchants).filter(t => currentEnchants[t] > 0);
    
    if (!currentEnchants[enchantType] && enchantTypes.length >= 2) {
      await interaction.reply({ 
        content: `‚ùå Max of 2 different enchant types per slot! This slot already has: ${enchantTypes.join(', ')}.\nRemove an enchant first to add a different type.`, 
        ephemeral: true 
      });
      return;
    }

    const currentEnchantLevel = currentEnchants[enchantType] || 0;
    const maxEnchant = 10;

    // Check if already at max
    if (currentEnchantLevel >= maxEnchant) {
      await interaction.reply({ 
        content: `‚úÖ This ${slot} ${enchantType} enchant is already at max level (+${maxEnchant})!`, 
        ephemeral: true 
      });
      return;
    }

    // Auto-enchant logic
    if (targetLevel) {
      const targetLevelNum = parseInt(targetLevel);
      if (isNaN(targetLevelNum) || targetLevelNum < 1 || targetLevelNum > maxEnchant) {
        await interaction.reply({ content: `Invalid target level. Must be between 1 and ${maxEnchant}.`, ephemeral: true });
        return;
      }

      if (currentEnchantLevel >= targetLevelNum) {
        await interaction.reply({ 
          content: `‚úÖ ${slot} ${enchantType} enchant is already at +${currentEnchantLevel} (target: +${targetLevelNum})!`, 
          ephemeral: true 
        });
        return;
      }

      // Perform auto-enchanting
      const results = await this.performAutoEnchant(player, slot, enchantType, recipe, targetLevelNum, hasEnchanter, enchanterLevel, requiredLevel);
      
      const embed = new EmbedBuilder()
        .setColor(results.reachedTarget ? 0x00ff00 : 0xff9900)
        .setTitle('üîÑ Auto-Enchant Results')
        .setDescription(
          `**Slot:** ${slot.toUpperCase()}\n` +
          `**Enchant:** ${enchantType}\n` +
          `**Starting Level:** +${results.startLevel}\n` +
          `**Ending Level:** +${results.endLevel}\n` +
          `**Target:** +${targetLevelNum}\n\n` +
          `**Attempts:** ${results.attempts}\n` +
          `**Successes:** ${results.successes}\n` +
          `**Failures:** ${results.failures}\n\n` +
          (results.reachedTarget 
            ? `‚úÖ **Target reached!**` 
            : `‚ö†Ô∏è **Stopped:** ${results.stopReason}`)
        );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [
          new ActionRowBuilder().addComponents(
            new ButtonBuilder()
              .setCustomId('rpg-enchant')
              .setLabel('‚Üê Back to Enchanting')
              .setStyle(ButtonStyle.Secondary)
          )
        ]
      });
      return;
    }

    const baseMaterials = this.getAdjustedMaterials(recipe.materials || {});
    const costMultiplier = this.getProfessionCostMultiplier(player) * (hasEnchanter ? 1 : 1.6);
    const adjustedMaterials = this.applyCostMultiplier(baseMaterials, costMultiplier);

    if (!this.hasMaterials(player, adjustedMaterials)) {
      const missingMats = this.getMissingMaterials(player, adjustedMaterials);
      const missing = missingMats
        .map(({ name, quantity }) => `${name} x${quantity}`)
        .join(', ');

      // Show enchant menu with gather buttons
      const embed = UIBuilder.createEnchantmentEmbed(player, { ...recipe, materials: adjustedMaterials });
      const materialCounts = this.getMaterialCounts(player);
      const overviewLines = Object.entries(adjustedMaterials).map(([matId, qty]) => {
        const mat = getMaterial(matId);
        const name = mat?.name || matId;
        const have = materialCounts[matId] || 0;
        const ok = have >= qty;
        const missingQty = Math.max(0, qty - have);
        const missingText = ok ? '' : ` (missing ${missingQty})`;
        return `${ok ? '‚úÖ' : '‚ùå'} ${name}: ${have}/${qty}${missingText}`;
      });
      if (overviewLines.length > 0) {
        embed.addFields({
          name: 'Missing Materials Overview',
          value: overviewLines.join('\n'),
          inline: false,
        });
      }
      
      const rows = [];
      const backRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-enchant')
          .setLabel('‚Üê Back to Enchanting')
          .setStyle(ButtonStyle.Secondary)
      );

      // Add buttons to go to gathering - grouped by area
      const areaMap = this.getGatheringAreasByMaterials(missingMats, player.level || 1);
      const areas = Object.values(areaMap);

      if (areas.length > 0) {
        player.pendingGatherAllMaterials = missingMats.map(({ id, quantity }) => ({ id, quantity }));
        this.persistPlayer(player);

        const gatherButtons = [];

        // Add area-based gather buttons
        for (const { area, materials } of areas) {
          const matNames = materials.map(m => m.name || getMaterial(m.id)?.name || m.id);
          const label = `‚õèÔ∏è ${area.name}: ${matNames.slice(0, 2).join(', ')}${materials.length > 2 ? ` +${materials.length - 2}` : ''}`;
          
          gatherButtons.push(new ButtonBuilder()
            .setCustomId(`rpg-autogather-area-${area.id}`)
            .setLabel(label.slice(0, 80))
            .setStyle(ButtonStyle.Primary)
          );
        }

        if (gatherButtons.length > 0 && rows.length < 5) {
          rows.push(new ActionRowBuilder().addComponents(...gatherButtons));
        }
      } else {
        player.pendingGatherAllMaterials = null;
      }

      rows.push(backRow);

      await this.updateInteractionWithTracking(interaction, {
        content: `Missing materials: ${missing || 'Unknown materials'}.`,
        embeds: [embed],
        components: rows,
      });
      return;
    }

    const baseFailChance = Math.min(0.4 + (requiredLevel * 0.04), 0.85);
    const reduction = hasEnchanter ? enchanterLevel * 0.02 : 0;
    const penalty = hasEnchanter ? 0 : 0.2;
    const failChance = Math.min(Math.max(baseFailChance - reduction + penalty, 0.05), 0.9);

    this.consumeMaterials(player, adjustedMaterials);

    const roll = Math.random();
    if (roll < failChance) {
      this.persistPlayer(player);
      await interaction.reply({
        content: `‚ùå ${enchantType} enchant failed. (Fail chance: ${(failChance * 100).toFixed(1)}%)`,
        ephemeral: true,
      });
      return;
    }

    // Apply the enchant (new structure supports multiple types)
    player.equipmentEnchants[slot][enchantType] = Math.min((currentEnchants[enchantType] || 0) + 1, maxEnchant);
    player.clearStatsCache();

    if (hasEnchanter) {
      const xpGain = requiredLevel * 10;
      player.professionXp = player.professionXp || {};
      player.professionLevels = player.professionLevels || {};
      const MAX_PROFESSION_LEVEL = 80;
      const currentLevel = player.professionLevels.enchanter || 1;
      
      if (currentLevel < MAX_PROFESSION_LEVEL) {
        player.professionXp.enchanter = (player.professionXp.enchanter || 0) + xpGain;
        while (player.professionXp.enchanter >= 100 && (player.professionLevels.enchanter || 1) < MAX_PROFESSION_LEVEL) {
          player.professionXp.enchanter -= 100;
          player.professionLevels.enchanter = (player.professionLevels.enchanter || 1) + 1;
        }
        // Cap excess XP at max level
        if ((player.professionLevels.enchanter || 1) >= MAX_PROFESSION_LEVEL) {
          player.professionXp.enchanter = 0;
        }
      }
    }

    this.persistPlayer(player);

    const newLevel = player.equipmentEnchants[slot][enchantType];
    const allEnchants = Object.entries(player.equipmentEnchants[slot])
      .filter(([t, l]) => l > 0)
      .map(([t, l]) => `${t} +${l}`)
      .join(', ');

    const response = await interaction.reply({
      content: `‚úÖ ${recipe.name} succeeded! ${slot.toUpperCase()} ${enchantType} is now +${newLevel}\n**All enchants on ${slot}:** ${allEnchants}`,
      ephemeral: false,
      fetchReply: true,
    });

    // Delete the completion message after 5 seconds
    setTimeout(() => {
      response.delete().catch(() => {});
    }, 5000);
  }

  getAsgardWorldId(worlds = null) {
    const list = Array.isArray(worlds) ? worlds : getAllWorlds();
    const asgard = list.find(w => String(w?.name || '').toLowerCase() === 'asgard');
    return asgard?.id || 'world_1770519709022';
  }

  buildCraftingComponents(player, page = 0, selectedWorldId = null) {
    const RECIPES_PER_PAGE = 25; // select menu limit
    const blacksmithLevel = player.professionLevels?.blacksmith || 0;
    const hasMasterBlacksmith = player.masterBlacksmith === true;

    const worlds = getAllWorlds();
    const worldList = Array.isArray(worlds) ? worlds : [];
    const worldById = new Map(worldList.map(w => [String(w.id), w]));
    const resolvedWorldId = selectedWorldId && worldById.has(String(selectedWorldId))
      ? String(selectedWorldId)
      : null;
    const asgardWorldId = this.getAsgardWorldId(worldList);
    const isAsgardSelection = resolvedWorldId && String(resolvedWorldId) === String(asgardWorldId);
    const playerInAsgard = String(player.currentWorld) === String(asgardWorldId);

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    const rows = [];
    if (worldList.length > 0) {
      const worldOptions = worldList.slice(0, RECIPES_PER_PAGE).map(world => {
        const minLevel = Number(world.minLevel) || 0;
        const maxLevel = Number(world.maxLevel) || 0;
        const levelText = minLevel || maxLevel ? `Lvl ${minLevel}-${maxLevel || minLevel}` : 'World';
        return {
          label: String(world.name || world.id).slice(0, 100),
          value: String(world.id),
          description: levelText.slice(0, 100),
        };
      });

      if (worldOptions.length > 0) {
        rows.push(new ActionRowBuilder().addComponents(
          new StringSelectMenuBuilder()
            .setCustomId('rpg-crafting-world')
            .setPlaceholder(
              resolvedWorldId && worldById.has(String(resolvedWorldId))
                ? `World: ${worldById.get(String(resolvedWorldId)).name || resolvedWorldId}`
                : 'Choose a world'
            )
            .addOptions(worldOptions)
        ));
      }

      if (!resolvedWorldId) {
        rows.push(backRow);
        return rows;
      }
    }

    // Filter recipes by:
    // 1. Output item must exist in equipment or items data (dashboard items included)
    // 2. Item/recipe must not have a class restriction for a different class
    // 3. Exclude potions (botanic) and enchantments - they have their own menus
    const playerClass = player.class || player.internalClass;
    const availableRecipes = RECIPES_SORTED.filter(recipe => {
      // Exclude potions and enchantments - they're crafted through their own menus
      if (recipe.profession === 'botanic' || recipe.profession === 'enchanter') {
        return false;
      }

      // Check if output item exists
      const outputItem = getEquipment(recipe.output.item) || getItemByIdDynamic(recipe.output.item);
      if (!outputItem) {
        return false;
      }
      // Check if recipe has class restriction
      if (recipe.classRestriction && recipe.classRestriction !== playerClass) {
        return false;
      }
      // Check if output item has class restriction
      if (outputItem && outputItem.classRestriction && outputItem.classRestriction !== playerClass) {
        return false; // Hide recipes that output items for other classes
      }

      return true;
    });

    const materialGeneral = new Set();
    const materialWorlds = new Map();
    for (const area of Object.values(GATHERING_AREAS || {})) {
      const commonMats = area?.materials?.common || [];
      const rareMats = area?.materials?.rare || [];
      const mats = [...commonMats, ...rareMats].filter(Boolean);
      if (area?.requiredWorld) {
        for (const mat of mats) {
          if (!materialWorlds.has(mat)) {
            materialWorlds.set(mat, new Set());
          }
          materialWorlds.get(mat).add(String(area.requiredWorld));
        }
      } else {
        mats.forEach(mat => materialGeneral.add(mat));
      }
    }

    const defaultWorldId = worldList[0]?.id || player.currentWorld;
    const getRecipeWorldIds = (recipe) => {
      const mats = Object.keys(recipe.materials || {});
      const worldSet = new Set();
      for (const matId of mats) {
        const worldIds = materialWorlds.get(matId);
        if (worldIds && !materialGeneral.has(matId)) {
          worldIds.forEach(id => worldSet.add(String(id)));
        }
      }
      if (worldSet.size === 0) {
        return [String(defaultWorldId)];
      }
      return [...worldSet];
    };

    const worldFilteringEnabled = worldList.length > 0 && resolvedWorldId;
    const filteredRecipes = worldFilteringEnabled
      ? availableRecipes.filter(recipe => {
          const outputItem = getEquipment(recipe.output.item) || getItemByIdDynamic(recipe.output.item) || {};
          const isGemRecipe = recipe.requiresMasterBlacksmith || outputItem.category === 'gem';
          if (isGemRecipe) {
            return true;
          }
          const recipeWorldIds = getRecipeWorldIds(recipe);
          return recipeWorldIds.includes(String(resolvedWorldId));
        })
      : availableRecipes;

    const categorized = {
      weapons: [],
      armor: [],
      gems: [],
      items: [],
    };

    const armorSlots = ['chest', 'head', 'legs', 'boots', 'gloves', 'shield'];

    for (const recipe of filteredRecipes) {
      const outputItem = getEquipment(recipe.output.item) || getItemByIdDynamic(recipe.output.item) || {};
      let category = 'items';

      if (outputItem.slot === 'weapon' || (outputItem.category === 'weapon' && !armorSlots.includes(outputItem.slot))) {
        category = 'weapons';
      } else if (armorSlots.includes(outputItem.slot) || outputItem.category === 'armor') {
        category = 'armor';
      } else if (outputItem.category === 'gem') {
        category = 'gems';
      } else if (outputItem.category === 'consumable' || outputItem.heals || outputItem.restoresMana) {
        category = 'items';
      }

      categorized[category].push(recipe);
    }

    const allCount = categorized.weapons.length + categorized.armor.length + categorized.gems.length + categorized.items.length;
    if (allCount === 0) {
      rows.push(backRow);
      return rows;
    }

    const isGemWorldLocked = worldFilteringEnabled ? !isAsgardSelection : !playerInAsgard;
    const buildOptions = (list) => list.slice(0, RECIPES_PER_PAGE).map((rec) => {
      const outputName = this.getItemDisplayName(rec.output.item);
      let label = `Craft ${outputName}`;
      const requiredLevel = rec.level || 1;
      const masterLocked = rec.requiresMasterBlacksmith && !hasMasterBlacksmith;
      const asgardLocked = rec.requiresMasterBlacksmith && isGemWorldLocked;
      if (blacksmithLevel < requiredLevel || masterLocked || asgardLocked) {
        label += ' [Locked]';
      }
      return {
        label: label.slice(0, 100),
        value: String(rec.id),
        description: this.formatRecipeDescription(rec, blacksmithLevel, {
          hasMasterBlacksmith,
          isAsgardWorld: worldFilteringEnabled ? isAsgardSelection : playerInAsgard,
        }).slice(0, 100),
      };
    });

    const weaponOptions = buildOptions(categorized.weapons);
    if (weaponOptions.length > 0 && Array.isArray(weaponOptions)) {
      const validWeapons = weaponOptions.filter(opt => opt && opt.label && opt.value);
      if (validWeapons.length > 0) {
        rows.push(new ActionRowBuilder().addComponents(
          new StringSelectMenuBuilder()
            .setCustomId('rpg-crafting-select-weapons')
            .setPlaceholder('Weapons')
            .addOptions(validWeapons)
        ));
      }
    }

    const armorOptions = buildOptions(categorized.armor);
    if (armorOptions.length > 0 && Array.isArray(armorOptions)) {
      const validArmor = armorOptions.filter(opt => opt && opt.label && opt.value);
      if (validArmor.length > 0) {
        rows.push(new ActionRowBuilder().addComponents(
          new StringSelectMenuBuilder()
            .setCustomId('rpg-crafting-select-armor')
            .setPlaceholder('Armor')
            .addOptions(validArmor)
        ));
      }
    }

    const gemOptions = buildOptions(categorized.gems);
    if (gemOptions.length > 0 && Array.isArray(gemOptions)) {
      const validGems = gemOptions.filter(opt => opt && opt.label && opt.value);
      if (validGems.length > 0) {
        rows.push(new ActionRowBuilder().addComponents(
          new StringSelectMenuBuilder()
            .setCustomId('rpg-crafting-select-gems')
            .setPlaceholder('üíé Gems (Asgard)')
            .addOptions(validGems)
        ));
      }
    }

    rows.push(backRow);
    return rows;
  }

  formatRecipeDescription(recipe, blacksmithLevel = 0, options = {}) {
    const requiredLevel = recipe.level || 1;
    const parts = [`Lvl ${requiredLevel}`];

    const needsMaster = recipe.requiresMasterBlacksmith === true;
    const masterLocked = needsMaster && !options.hasMasterBlacksmith;
    const asgardLocked = needsMaster && options.isAsgardWorld === false;
    if (blacksmithLevel < requiredLevel || masterLocked || asgardLocked) {
      parts.push('Locked');
    }
    if (masterLocked) {
      parts.push('Master');
    }
    if (asgardLocked) {
      parts.push('Asgard');
    }

    const equipment = getEquipment(recipe.output.item);
    const item = getItemByIdDynamic(recipe.output.item);
    const stats = equipment?.bonuses || equipment?.stats || item?.stats;

    if (stats) {
      const statText = Object.entries(stats)
        .filter(([, val]) => typeof val === 'number' && val !== 0)
        .map(([key, val]) => `${key.slice(0, 3).toUpperCase()} ${val > 0 ? '+' : ''}${val}`)
        .slice(0, 2)
        .join(' ');
      if (statText) parts.push(statText);
    }

    const mats = this.getAdjustedMaterials(recipe.materials || {});
    const matText = Object.entries(mats)
      .slice(0, 2)
      .map(([id, qty]) => {
        const mat = getMaterial(id);
        const gem = mat ? null : getGem(id);
        const matName = mat?.name || gem?.name || id;
        return `${qty}x ${matName}`;
      })
      .join(', ');
    if (matText) parts.push(matText);

    let description = parts.join(' ‚Ä¢ ');
    if (description.length > 100) {
      description = description.slice(0, 97) + '...';
    }
    return description;
  }

  async handleCraftingOverview(interaction, player, recipeId) {
    const recipe = getRecipe(recipeId);
    if (!recipe) {
      await interaction.reply({
        content: 'Unknown recipe.',
        ephemeral: true,
      });
      return;
    }

    if (recipe.requiresMasterBlacksmith) {
      const asgardWorldId = this.getAsgardWorldId();
      const playerInAsgard = String(player.currentWorld) === String(asgardWorldId);
      if (!player.masterBlacksmith || !playerInAsgard) {
        await interaction.reply({
          content: 'Gem crafting requires Master Blacksmith and access to Asgard.',
          ephemeral: true,
        });
        return;
      }
    }

    // Check class restriction
    const playerClass = player.class || player.internalClass;
    if (recipe.classRestriction && recipe.classRestriction !== playerClass) {
      await interaction.reply({
        content: `This recipe is only available to **${recipe.classRestriction}** class.`,
        ephemeral: true,
      });
      return;
    }

    // Check if output item has class restriction
    const outputItem = getEquipment(recipe.output.item) || getItemByIdDynamic(recipe.output.item);
    if (outputItem && outputItem.classRestriction && outputItem.classRestriction !== playerClass) {
      await interaction.reply({
        content: `This item is only available to **${outputItem.classRestriction}** class.`,
        ephemeral: true,
      });
      return;
    }

    // Check blacksmith level
    const blacksmithLevel = player.professionLevels?.blacksmith || 0;
    const requiredLevel = recipe.level || 1;
    if (blacksmithLevel < requiredLevel) {
      await interaction.reply({
        content: `You need Blacksmith Level ${requiredLevel} to craft **${recipe.name}**. (Current: ${blacksmithLevel})`,
        ephemeral: true,
      });
      return;
    }

    // Get materials
    const baseMaterials = this.getAdjustedMaterials(recipe.materials);
    const adjustedMaterials = this.applyCostMultiplier(baseMaterials, this.getProfessionCostMultiplier(player));

    // Create overview embed using the crafting embed
    const embed = UIBuilder.createCraftingEmbed(player, { ...recipe, materials: adjustedMaterials });

    // Add XP information
    const xpGain = (recipe.level || 1) * 10;
    const currentXp = player.professionXp?.blacksmith || 0;
    const xpThreshold = 250; // Blacksmith requires 250 XP per level
    const xpNeededForNextLevel = xpThreshold - currentXp;
    const xpProgressBar = this.buildProgressBar(currentXp, xpThreshold, 10);
    
    // Build materials status with checkmarks and Xs
    const materialStatusList = Object.entries(adjustedMaterials)
      .map(([matId, qty]) => {
        const materialName = getMaterial(matId)?.name || matId;
        const playerCount = this.getMaterialCounts(player)[matId] || 0;
        const hasEnough = playerCount >= qty;
        const icon = hasEnough ? '‚úÖ' : '‚ùå';
        return `${icon} ${materialName} x${qty}`;
      })
      .join('\n');
    
    embed.addFields(
      {
        name: 'üì¶ Required Materials',
        value: materialStatusList || 'None',
        inline: false
      },
      {
        name: '‚≠ê Profession XP',
        value: `Gain: **${xpGain} XP** per craft\n` +
               `Progress: ${xpProgressBar} (${currentXp}/${xpThreshold})\n` +
               `Until Next Level: **${xpNeededForNextLevel} XP**`,
        inline: false
      }
    );

    // Build buttons with quantity options
    const quantityRow = new ActionRowBuilder();
    
    // Check if player has enough materials for different quantities
    const hasEnough1x = this.hasMaterials(player, adjustedMaterials);
    
    // Calculate how many times they can craft
    let maxCrafts = 1;
    if (hasEnough1x) {
      for (let i = 2; i <= 100; i++) {
        const multipliedMats = {};
        for (const [matId, qty] of Object.entries(adjustedMaterials)) {
          multipliedMats[matId] = qty * i;
        }
        if (!this.hasMaterials(player, multipliedMats)) {
          maxCrafts = i - 1;
          break;
        }
        if (i === 100) maxCrafts = 100;
      }
    }
    
    // Add quantity buttons (avoid duplicate IDs by using 'all' suffix)
    const buttons = [
      new ButtonBuilder()
        .setCustomId(`rpg-confirm-craft-${recipeId}-1`)
        .setLabel('‚úÖ 1x')
        .setStyle(ButtonStyle.Success)
        .setDisabled(!hasEnough1x)
    ];
    
    // Only add 5x button if it's different from maxCrafts
    if (maxCrafts >= 5) {
      buttons.push(
        new ButtonBuilder()
          .setCustomId(`rpg-confirm-craft-${recipeId}-5`)
          .setLabel('‚úÖ 5x')
          .setStyle(ButtonStyle.Primary)
          .setDisabled(maxCrafts < 5)
      );
    }
    
    // Only add 25x button if it's different from maxCrafts
    if (maxCrafts >= 25) {
      buttons.push(
        new ButtonBuilder()
          .setCustomId(`rpg-confirm-craft-${recipeId}-25`)
          .setLabel('‚úÖ 25x')
          .setStyle(ButtonStyle.Primary)
          .setDisabled(maxCrafts < 25)
      );
    }
    
    // Add "All" button with unique ID - only if maxCrafts is not already covered
    if (maxCrafts !== 1 && maxCrafts !== 5 && maxCrafts !== 25) {
      buttons.push(
        new ButtonBuilder()
          .setCustomId(`rpg-confirm-craft-${recipeId}-all`)
          .setLabel(`‚úÖ All (${maxCrafts}x)`)
          .setStyle(ButtonStyle.Primary)
          .setDisabled(!hasEnough1x)
      );
    } else if (maxCrafts === 1 || maxCrafts === 5 || maxCrafts === 25) {
      // If maxCrafts matches one of the quantity buttons, make that button show "(All)"
      const lastButton = buttons[buttons.length - 1];
      const currentLabel = lastButton.data.label;
      buttons[buttons.length - 1] = ButtonBuilder.from(lastButton).setLabel(currentLabel.replace('‚úÖ', '‚úÖ All'));
    }
    
    quantityRow.addComponents(...buttons);

    // Build components array
    const components = [quantityRow];

    // If missing materials, add gather buttons in row 2
    const missingMats = this.getMissingMaterials(player, adjustedMaterials);
    if (missingMats.length > 0) {
      const gatherButtons = [];
      const areaMap = this.getGatheringAreasByMaterials(missingMats, player.level || 1);
      const areas = Object.values(areaMap);

      if (areas.length > 0) {
        player.pendingGatherAllMaterials = missingMats.map(({ id, quantity }) => ({ id, quantity }));
        this.persistPlayer(player);

        for (const { area, materials } of areas.slice(0, 5)) {
          const matNames = materials.map(m => m.name || getMaterial(m.id)?.name || m.id);
          const label = `‚õèÔ∏è ${area.name}: ${matNames.slice(0, 2).join(', ')}${materials.length > 2 ? ` +${materials.length - 2}` : ''}`;
          
          gatherButtons.push(new ButtonBuilder()
            .setCustomId(`rpg-autogather-area-${area.id}`)
            .setLabel(label.slice(0, 80))
            .setStyle(ButtonStyle.Primary)
          );
        }
      } else {
        // Fallback: Create buttons by gathering type
        const skillMap = {};
        for (const mat of missingMats) {
          const skillId = this.getGatheringTypeForMaterial(mat);
          if (skillId && !skillMap[skillId]) {
            skillMap[skillId] = [];
          }
          if (skillId) {
            skillMap[skillId].push(mat);
          }
        }

        player.pendingGatherAllMaterials = missingMats.map(({ id, quantity }) => ({ id, quantity }));
        this.persistPlayer(player);

        for (const [skillId, mats] of Object.entries(skillMap)) {
          const skill = getGatheringSkill(skillId);
          if (!skill) continue;

          const matNames = mats.map(m => m.name || m.id).slice(0, 2);
          const label = `${skill.icon} ${skill.name}: ${matNames.join(', ')}${mats.length > 2 ? ` +${mats.length - 2}` : ''}`;
          
          gatherButtons.push(new ButtonBuilder()
            .setCustomId(`rpg-autogather-${skillId}`)
            .setLabel(label.slice(0, 80))
            .setStyle(ButtonStyle.Primary)
          );
        }
      }

      // Add gather button rows (up to 5 buttons per row)
      for (let i = 0; i < gatherButtons.length; i += 5) {
        components.push(new ActionRowBuilder().addComponents(...gatherButtons.slice(i, i + 5)));
      }
    }

    // Add back button as final row
    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-crafting')
        .setLabel('‚Üê Back to Crafting')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-hub')
        .setLabel('üè† Hub')
        .setStyle(ButtonStyle.Primary)
    );
    components.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  async handleCraftRecipe(interaction, player, recipeId, quantity = 1) {
    // Defer the interaction to allow editReply and followUp later
    await interaction.deferUpdate();

    const recipe = getRecipe(recipeId);
    if (!recipe) {
      await interaction.followUp({
        content: 'Unknown recipe.',
        ephemeral: true,
      });
      return;
    }

    if (recipe.requiresMasterBlacksmith) {
      const asgardWorldId = this.getAsgardWorldId();
      const playerInAsgard = String(player.currentWorld) === String(asgardWorldId);
      if (!player.masterBlacksmith || !playerInAsgard) {
        await interaction.followUp({
          content: 'Gem crafting requires Master Blacksmith and access to Asgard.',
          ephemeral: true,
        });
        return;
      }
    }

    // Ensure quantity is a valid number
    quantity = Math.max(1, Math.min(quantity, 100));

    // Check class restriction on both recipe and output item
    const playerClass = player.class || player.internalClass;
    if (recipe.classRestriction && recipe.classRestriction !== playerClass) {
      await interaction.followUp({
        content: `This recipe is only available to **${recipe.classRestriction}** class.`,
        ephemeral: true,
      });
      return;
    }

    // Also check if the output item has a class restriction
    const outputItem = getEquipment(recipe.output.item) || getItemByIdDynamic(recipe.output.item);
    if (outputItem && outputItem.classRestriction && outputItem.classRestriction !== playerClass) {
      await interaction.followUp({
        content: `This item is only available to **${outputItem.classRestriction}** class.`,
        ephemeral: true,
      });
      return;
    }

    const blacksmithLevel = player.professionLevels?.blacksmith || 0;
    const requiredLevel = recipe.level || 1;
    if (blacksmithLevel < requiredLevel) {
      const embed = UIBuilder.createCraftingEmbed(player, recipe);
      const components = this.buildCraftingComponents(player, 0);

      await this.updateInteractionWithTracking(interaction, {
        content: `You need Blacksmith Level ${requiredLevel} to craft **${recipe.name}**.`,
        embeds: [embed],
        components,
      });
      return;
    }

    const baseMaterials = this.getAdjustedMaterials(recipe.materials);
    const adjustedMaterials = this.applyCostMultiplier(baseMaterials, this.getProfessionCostMultiplier(player));
    
    // Multiply materials by quantity
    const totalMaterialsNeeded = {};
    for (const [matId, qty] of Object.entries(adjustedMaterials)) {
      totalMaterialsNeeded[matId] = qty * quantity;
    }

    if (!this.hasMaterials(player, totalMaterialsNeeded)) {
      const missingMats = this.getMissingMaterials(player, totalMaterialsNeeded);
      const missing = missingMats
        .map(({ name, quantity }) => `${name} x${quantity}`)
        .join(', ');
      const embed = UIBuilder.createCraftingEmbed(player, { ...recipe, materials: adjustedMaterials });

      // Build gather buttons
      const gatherButtons = [];
      const areaMap = this.getGatheringAreasByMaterials(missingMats, player.level || 1);
      const areas = Object.values(areaMap);

      if (areas.length > 0) {
        player.pendingGatherAllMaterials = missingMats.map(({ id, quantity }) => ({ id, quantity }));
        this.persistPlayer(player);

        for (const { area, materials } of areas.slice(0, 5)) {
          const matNames = materials.map(m => m.name || getMaterial(m.id)?.name || m.id);
          const label = `‚õèÔ∏è ${area.name}: ${matNames.slice(0, 2).join(', ')}${materials.length > 2 ? ` +${materials.length - 2}` : ''}`;
          
          gatherButtons.push(new ButtonBuilder()
            .setCustomId(`rpg-autogather-area-${area.id}`)
            .setLabel(label.slice(0, 80))
            .setStyle(ButtonStyle.Primary)
          );
        }
      } else {
        // Fallback: Create buttons by gathering type
        const skillMap = {};
        for (const mat of missingMats) {
          const skillId = this.getGatheringTypeForMaterial(mat);
          if (skillId && !skillMap[skillId]) {
            skillMap[skillId] = [];
          }
          if (skillId) {
            skillMap[skillId].push(mat);
          }
        }

        player.pendingGatherAllMaterials = missingMats.map(({ id, quantity }) => ({ id, quantity }));
        this.persistPlayer(player);

        for (const [skillId, mats] of Object.entries(skillMap)) {
          const skill = getGatheringSkill(skillId);
          if (!skill) continue;

          const matNames = mats.map(m => m.name || m.id).slice(0, 2);
          const label = `${skill.icon} ${skill.name}: ${matNames.join(', ')}${mats.length > 2 ? ` +${mats.length - 2}` : ''}`;
          
          gatherButtons.push(new ButtonBuilder()
            .setCustomId(`rpg-autogather-${skillId}`)
            .setLabel(label.slice(0, 80))
            .setStyle(ButtonStyle.Primary)
          );
        }
      }

      // Build components with gather buttons
      const components = [];
      
      // Add gather button rows (up to 5 buttons per row)
      for (let i = 0; i < gatherButtons.length; i += 5) {
        components.push(new ActionRowBuilder().addComponents(...gatherButtons.slice(i, i + 5)));
      }
      
      // Add back button row
      components.push(new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      ));

      await this.updateInteractionWithTracking(interaction, {
        content: `Missing materials: ${missing || 'Unknown materials'}.`,
        embeds: [embed],
        components,
      });
      return;
    }

    // Consume all materials at once
    this.consumeMaterials(player, totalMaterialsNeeded);

    // Get output name before loop
    const outputName = this.getItemDisplayName(recipe.output.item);

    // Craft item(s) quantity times
    let totalQuantityCrafted = recipe.output.quantity * quantity;
    const craftResults = [];
    const xpThreshold = 250; // Blacksmith requires 250 XP per level
    const MAX_PROFESSION_LEVEL = 80;

    // Send initial progress embed that will be edited
    const initialEmbed = new EmbedBuilder()
      .setColor(0xe74c3c)
      .setTitle(`‚öíÔ∏è Crafting Progress: 0/${quantity}`)
      .setDescription(
        `**Item:** ${outputName}\n` +
        `**Blacksmith Level:** ${blacksmithLevel}/${MAX_PROFESSION_LEVEL}\n` +
        `**XP Gained:** 0 XP\n` +
        `**Progress:** 0/${quantity}`
      );

    let progressMessage = await interaction.editReply({ embeds: [initialEmbed] });

    for (let i = 0; i < quantity; i++) {
      const craftResult = this.addCraftedItem(player, recipe.output.item, recipe.output.quantity);
      craftResults.push(craftResult);

      // Update overview embed to show progress every craft (or every 5 for large batches)
      const shouldUpdate = quantity <= 10 || (i + 1) % 5 === 0 || i === quantity - 1;
      if (shouldUpdate) {
        const xpGainCurrent = (recipe.level || 1) * 10 * (i + 1);
        const currentBlacksmithLevel = player.professionLevels.blacksmith || 1;
        const currentXp = player.professionXp?.blacksmith || 0;
        const xpProgress = currentXp % xpThreshold;
        const xpNeeded = xpThreshold - xpProgress;
        const xpProgressBar = this.buildProgressBar(xpProgress, xpThreshold, 10);

        const updatedEmbed = new EmbedBuilder()
          .setColor(0xe74c3c)
          .setTitle(`‚öíÔ∏è Crafting Progress: ${i + 1}/${quantity}`)
          .setDescription(
            `**Item:** ${outputName}\n` +
            `**Blacksmith Level:** ${currentBlacksmithLevel}/${MAX_PROFESSION_LEVEL}\n` +
            `**XP Progress:** ${xpProgressBar} (${xpProgress}/${xpThreshold})\n` +
            `**XP Gained:** ${xpGainCurrent} XP\n` +
            `**Until Next Level:** ${xpNeeded} XP`
          );

        try {
          await interaction.editReply({ embeds: [updatedEmbed] });
        } catch (err) {
          // Silently fail if edit rate limit hit
        }
      }
    }

    // Track all unique crafted items as collectibles
    if (outputItem) {
      if (!player.collectibles) player.collectibles = [];
      const collectibleId = `crafted_${recipe.output.item}`;
      if (!player.collectibles.includes(collectibleId)) {
        player.collectibles.push(collectibleId);
      }
    }

    const craftedText = `Crafted **${outputName} x${totalQuantityCrafted}**.`;
    
    // Summarize equipped and added items (avoid long lists)
    const equippedItems = craftResults.flatMap(r => r.equipped);
    const addedItems = craftResults.flatMap(r => r.added);
    let equipText = '';
    
    if (equippedItems.length > 0) {
      if (equippedItems.length <= 3) {
        equipText = ` Auto-equipped: ${equippedItems.join(', ')}.`;
      } else {
        // Show first item and count instead of full list
        const firstItem = equippedItems[0];
        equipText = ` Auto-equipped: ${firstItem} and ${equippedItems.length - 1} more.`;
      }
    } else if (addedItems.length > 0 && quantity <= 5) {
      // Only show added items for small batches
      equipText = ` Added to inventory: ${addedItems.slice(0, 3).join(', ')}${addedItems.length > 3 ? ` and ${addedItems.length - 3} more` : ''}.`;
    } else if (addedItems.length > 0) {
      // For large bulk crafts, just mention they were added
      equipText = ` Added ${addedItems.length} item${addedItems.length > 1 ? 's' : ''} to inventory.`;
    }

    // Track crafts completed for progress stats
    if (!player.progressStats) {
      player.progressStats = {
        monstersDefeated: 0,
        gatheringActions: 0,
        materialsCollected: 0,
        craftsCompleted: 0,
        goldEarned: 0,
        criticalHits: 0,
        dungeonsCleared: 0,
        raidsCleared: 0,
      };
    }
    player.progressStats.craftsCompleted += quantity;

    // Award profession XP for crafting
    const professionId = recipe.profession || 'blacksmith';
    const xpGain = (recipe.level || 1) * 10 * quantity; // XP based on recipe level and quantity
    // Blacksmith requires 250 XP per level (2.5x harder than other professions at 100 XP per level)
    const profXpThreshold = professionId === 'blacksmith' ? 250 : 100;
    
    if (!player.professionXp) player.professionXp = {};
    
    let professionLevelUpText = '';
    let levelUpsCount = 0;
    const startLevel = player.professionLevels[professionId] || 1;
    
    // Only award XP if not at max level
    if (startLevel < MAX_PROFESSION_LEVEL) {
      player.professionXp[professionId] = (player.professionXp[professionId] || 0) + xpGain;
      
      while (player.professionXp[professionId] >= profXpThreshold && (player.professionLevels[professionId] || 1) < MAX_PROFESSION_LEVEL) {
        player.professionXp[professionId] -= profXpThreshold;
        player.professionLevels[professionId] = (player.professionLevels[professionId] || 1) + 1;
        levelUpsCount++;
      }
      
      // Cap excess XP at max level
      if ((player.professionLevels[professionId] || 1) >= MAX_PROFESSION_LEVEL) {
        player.professionXp[professionId] = 0;
      }
    }
    
    // Summarize level ups to avoid message overflow
    if (levelUpsCount > 0) {
      const newLevel = player.professionLevels[professionId];
      const professionName = professionId.charAt(0).toUpperCase() + professionId.slice(1);
      if (levelUpsCount === 1) {
        professionLevelUpText = `\n‚ú® **${professionName} reached level ${newLevel}**!`;
      } else {
        professionLevelUpText = `\n‚ú® **${professionName} leveled up ${levelUpsCount} times!** (Level ${startLevel} ‚Üí ${newLevel})`;
      }
    }

    // Track guild quest progress for crafting
    const dailyQuests = getAvailableDailyQuests(player.level, player.dailyQuestsCompleted);
    const weeklyQuests = getAvailableWeeklyQuests(player.level, player.weeklyQuestsCompleted);
    const claimedLimited = (player.claimedQuests || [])
      .map(id => getGuildQuestById(id))
      .filter(Boolean)
      .filter(q => !player.limitedQuestsCompleted.includes(q.id));

    if (!player.guildQuestProgress) player.guildQuestProgress = {};

    const event = {
      type: 'craft',
      target: 'item',
      count: quantity,
      tags: []
    };

    this.applyGuildQuestProgress(player, dailyQuests, weeklyQuests, claimedLimited, event);

    this.persistPlayer(player);

    // Construct final message
    let finalMessage = `${craftedText}${equipText}${professionLevelUpText}`;

    const response = await interaction.followUp({
      content: finalMessage,
      ephemeral: false,
      fetchReply: true,
    });
    
    // Delete the result message after 5 seconds
    setTimeout(() => {
      response.delete().catch(() => {});
    }, 5000);
  }

  getItemDisplayName(itemId) {
    const equipment = getEquipment(itemId);
    if (equipment) return equipment.name;
    const item = getItemByIdDynamic(itemId);
    if (item) return item.name;
    return itemId;
  }

  buildProgressBar(current, max, segments = 10) {
    // Safety checks to prevent invalid values
    const safeCurrent = Math.max(0, Number(current) || 0);
    const safeMax = Math.max(1, Number(max) || 1);
    const safeSegments = Math.max(1, Math.min(50, Number(segments) || 10)); // Cap at 50 segments
    
    const filled = Math.floor((safeCurrent / safeMax) * safeSegments);
    const empty = safeSegments - filled;
    return '‚ñà'.repeat(Math.max(0, filled)) + '‚ñë'.repeat(Math.max(0, empty));
  }

  getMaterialCounts(player) {
    const counts = {};
    if (!player.inventory) return counts;
    for (const item of player.inventory) {
      if (!item || typeof item !== 'object') continue;
      const isGem = item.id ? getGem(item.id) : null;
      if (item.type === 'material' || isGem) {
        counts[item.id] = (counts[item.id] || 0) + (item.quantity || 1);
      }
    }
    return counts;
  }

  /**
   * Create recipe button rows - cached and reused across crafting flow
   * Uses pre-sorted RECIPES_SORTED to avoid sorting on every craft attempt
   */
  createRecipeButtonRows(player) {
    return this.buildCraftingComponents(player, 0);
  }

  getAdjustedMaterials(materials) {
    const balance = loadBalanceData();
    const multiplier = Number(balance.craftingCostMultiplier) || 1;
    const minQty = Number(balance.craftingCostMin) || 1;
    const adjusted = {};
    for (const [id, qty] of Object.entries(materials || {})) {
      const scaled = Math.ceil(Number(qty) * multiplier);
      adjusted[id] = Math.max(minQty, scaled);
    }
    return adjusted;
  }

  getProfessionCostMultiplier(player) {
    const levels = Object.values(player.professionLevels || {}).map((val) => Number(val) || 0);
    const totalLevels = levels.reduce((sum, val) => sum + val, 0);
    const reduction = Math.min(totalLevels * 0.01, 0.3);
    return Math.max(0.7, 1 - reduction);
  }

  applyCostMultiplier(materials, multiplier = 1) {
    const adjusted = {};
    for (const [id, qty] of Object.entries(materials || {})) {
      adjusted[id] = Math.max(1, Math.ceil(Number(qty) * multiplier));
    }
    return adjusted;
  }

  hasMaterials(player, materials) {
    const counts = this.getMaterialCounts(player);
    for (const [id, qty] of Object.entries(materials)) {
      if ((counts[id] || 0) < qty) return false;
    }
    return true;
  }

  getMissingMaterials(player, materials) {
    const counts = this.getMaterialCounts(player);
    const missing = [];
    for (const [id, qty] of Object.entries(materials)) {
      const have = counts[id] || 0;
      if (have < qty) {
        const mat = getMaterial(id);
        const gem = mat ? null : getGem(id);
        missing.push({ id, name: mat?.name || gem?.name || id, quantity: qty - have });
      }
    }
    return missing;
  }

  /**
   * Find the best gathering activity for the given missing materials
   * Returns the gathering type that can gather the most missing materials
   */
  getBestGatheringForMaterials(missingMaterials) {
    if (!missingMaterials || missingMaterials.length === 0) return null;

    const gatheringCounts = {
      mining: 0,
      chopping: 0,
      gathering: 0,
    };

    // Comprehensive hardcoded map: materialId -> gathering type
    // Covers ALL known materials from GATHERING_SKILLS, BASE_MATERIALS, and recipes
    const MATERIAL_GATHER_MAP = {
      // Mining materials
      iron_ore: 'mining', copper_ore: 'mining', coal: 'mining', granite: 'mining',
      mana_crystal: 'mining', mithril_ore: 'mining', adamantite: 'mining',
      dragonstone: 'mining', bronze_ore: 'mining', world_essence_ore: 'mining',
      mythril_ore: 'mining',
      // Chopping materials
      wood: 'chopping', lumber: 'chopping', leather: 'chopping',
      hardwood: 'chopping', dragonhide: 'chopping', mystic_bark: 'chopping',
      ash_wood: 'chopping', pine_wood: 'chopping', yew_wood: 'chopping',
      ancient_wood: 'chopping', storm_touched_wood: 'chopping', divine_wood: 'chopping',
      stormhide: 'chopping', 'godbeast-hide': 'chopping', treated_leather: 'chopping',
      // Gathering / Herbing materials
      herb: 'gathering', water: 'gathering', rare_flower: 'gathering',
      moonflower: 'gathering', arcane_essence: 'gathering', phoenix_feather: 'gathering',
      wild_herbs: 'gathering', medicinal_herbs: 'gathering',
      sacred_herbs: 'gathering', ambrosia_bloom: 'gathering', fatebound_fang: 'gathering',
      pure_water: 'gathering',
    };

    // Also build a lookup from GATHERING_SKILLS for any we missed
    for (const [skillId, skill] of Object.entries(GATHERING_SKILLS)) {
      for (const mat of (skill.baseMaterials || [])) {
        if (!MATERIAL_GATHER_MAP[mat.id]) MATERIAL_GATHER_MAP[mat.id] = skillId;
      }
      for (const mat of (skill.rareMaterials || [])) {
        if (!MATERIAL_GATHER_MAP[mat.id]) MATERIAL_GATHER_MAP[mat.id] = skillId;
      }
    }

    const normalizeGatheringType = (value) => {
      if (!value) return null;
      const raw = String(value).toLowerCase();
      if (raw.includes('mine') || raw === 'mining') return 'mining';
      if (raw.includes('chop') || raw === 'chopping') return 'chopping';
      if (raw.includes('gather') || raw.includes('forage') || raw === 'gathering' || raw.includes('herb')) return 'gathering';
      return null;
    };

    // Guess gathering type from material name if all else fails
    const guessFromName = (name) => {
      if (!name) return null;
      const n = name.toLowerCase();
      if (n.includes('ore') || n.includes('crystal') || n.includes('stone') || n.includes('granite') || n.includes('coal') || n.includes('adamant') || n.includes('mithril')) return 'mining';
      if (n.includes('wood') || n.includes('lumber') || n.includes('bark') || n.includes('hide') || n.includes('leather')) return 'chopping';
      if (n.includes('herb') || n.includes('water') || n.includes('flower') || n.includes('essence') || n.includes('feather') || n.includes('bloom') || n.includes('potion')) return 'gathering';
      return null;
    };

    // Count which gathering type can provide each material
    for (const missingMat of missingMaterials) {
      const type = this.getGatheringTypeForMaterial(missingMat, {
        MATERIAL_GATHER_MAP,
        normalizeGatheringType,
        guessFromName,
      });
      if (type) gatheringCounts[type]++;
    }

    // Find the gathering type with the most materials
    let bestType = null;
    let maxCount = 0;
    for (const [type, count] of Object.entries(gatheringCounts)) {
      if (count > maxCount) {
        maxCount = count;
        bestType = type;
      }
    }

    return maxCount > 0 ? bestType : null;
  }

  getGatheringTypeForMaterial(missingMat, helpers = null) {
    if (!missingMat) return null;

    const buildHelpers = () => {
      const MATERIAL_GATHER_MAP = {
        // Mining materials
        iron_ore: 'mining', copper_ore: 'mining', coal: 'mining', granite: 'mining',
        mana_crystal: 'mining', mithril_ore: 'mining', adamantite: 'mining',
        dragonstone: 'mining', bronze_ore: 'mining', world_essence_ore: 'mining',
        mythril_ore: 'mining',
        // Chopping materials
        wood: 'chopping', lumber: 'chopping', leather: 'chopping',
        hardwood: 'chopping', dragonhide: 'chopping', mystic_bark: 'chopping',
        ash_wood: 'chopping', pine_wood: 'chopping', yew_wood: 'chopping',
        ancient_wood: 'chopping', storm_touched_wood: 'chopping', divine_wood: 'chopping',
        stormhide: 'chopping', 'godbeast-hide': 'chopping', treated_leather: 'chopping',
        // Gathering / Herbing materials
        herb: 'gathering', water: 'gathering', rare_flower: 'gathering',
        moonflower: 'gathering', arcane_essence: 'gathering', phoenix_feather: 'gathering',
        wild_herbs: 'gathering', medicinal_herbs: 'gathering',
        sacred_herbs: 'gathering', ambrosia_bloom: 'gathering', fatebound_fang: 'gathering',
        pure_water: 'gathering',
      };

      for (const [skillId, skill] of Object.entries(GATHERING_SKILLS)) {
        for (const mat of (skill.baseMaterials || [])) {
          if (!MATERIAL_GATHER_MAP[mat.id]) MATERIAL_GATHER_MAP[mat.id] = skillId;
        }
        for (const mat of (skill.rareMaterials || [])) {
          if (!MATERIAL_GATHER_MAP[mat.id]) MATERIAL_GATHER_MAP[mat.id] = skillId;
        }
      }

      const normalizeGatheringType = (value) => {
        if (!value) return null;
        const raw = String(value).toLowerCase();
        if (raw.includes('mine') || raw === 'mining') return 'mining';
        if (raw.includes('chop') || raw === 'chopping') return 'chopping';
        if (raw.includes('gather') || raw.includes('forage') || raw === 'gathering' || raw.includes('herb')) return 'gathering';
        return null;
      };

      const guessFromName = (name) => {
        if (!name) return null;
        const n = name.toLowerCase();
        if (n.includes('ore') || n.includes('crystal') || n.includes('stone') || n.includes('granite') || n.includes('coal') || n.includes('adamant') || n.includes('mithril')) return 'mining';
        if (n.includes('wood') || n.includes('lumber') || n.includes('bark') || n.includes('hide') || n.includes('leather')) return 'chopping';
        if (n.includes('herb') || n.includes('water') || n.includes('flower') || n.includes('essence') || n.includes('feather') || n.includes('bloom') || n.includes('potion')) return 'gathering';
        return null;
      };

      return { MATERIAL_GATHER_MAP, normalizeGatheringType, guessFromName };
    };

    const { MATERIAL_GATHER_MAP, normalizeGatheringType, guessFromName } = helpers || buildHelpers();
    const matId = missingMat.id;

    if (MATERIAL_GATHER_MAP[matId]) {
      return MATERIAL_GATHER_MAP[matId];
    }

    const material = getMaterial(matId);
    const gatherType = normalizeGatheringType(material?.gatheringType);
    if (gatherType) return gatherType;

    return guessFromName(material?.name || missingMat.name || matId);
  }

  formatGatherButtonLabel(skillId, mats) {
    const icons = { mining: '‚õèÔ∏è', chopping: 'ü™ì', gathering: 'üåø', all: 'üåü' };
    const names = (mats || []).map((mat) => mat.name || getMaterial(mat.id)?.name || mat.id);

    const maxNames = skillId === 'all' ? 3 : 2;
    const shown = names.slice(0, maxNames);
    const extra = names.length - shown.length;
    const suffix = extra > 0 ? ` +${extra}` : '';

    const prefix = skillId === 'all' ? 'Gather All' : 'Gather';
    const label = `${icons[skillId] || '‚õèÔ∏è'} ${prefix}: ${shown.join(', ')}${suffix}`;
    return label.length > 80 ? label.slice(0, 77) + '...' : label;
  }

  /**best multi-skill area for materials from multiple gathering types
   */
  getBestMultiSkillAreaForMaterials(missingMaterials, playerLevel = 1, worldsUnlocked = []) {
    if (!missingMaterials || missingMaterials.length === 0) return null;

    const missingIds = new Set(missingMaterials.map(mat => mat.id));
    const neededSkills = new Set();

    // Determine which skills are needed
    for (const mat of missingMaterials) {
      const type = this.getGatheringTypeForMaterial(mat);
      if (type) neededSkills.add(type);
    }

    // Find areas that support all needed skills
    const areas = getUnlockedAreas(playerLevel, worldsUnlocked).filter(area => {
      if (!area.skillTypes) return false;
      for (const skill of neededSkills) {
        if (!area.skillTypes.includes(skill)) return false;
      }
      return true;
    });

    if (areas.length === 0) return null;

    // Find area with best material coverage
    let bestArea = null;
    let bestScore = 0;

    for (const area of areas) {
      const common = area.materials?.common || [];
      const rare = area.materials?.rare || [];

      let matches = 0;
      for (const id of missingIds) {
        if (common.includes(id) || rare.includes(id)) matches++;
      }

      // Only consider areas that have ALL materials
      if (matches < missingIds.size) continue;

      const score = matches + (area.rarity * 10);

      if (score > bestScore) {
        bestScore = score;
        bestArea = area;
      }
    }

    return bestArea;
  }

  /**
   * Find 
   * Find the best gathering area for missing materials
   * Prefers unlocked areas that contain more of the missing items
   */
  getBestGatheringAreaForMaterials(missingMaterials, skillId, playerLevel = 1, worldsUnlocked = []) {
    if (!missingMaterials || missingMaterials.length === 0 || !skillId) return null;

    const areas = getUnlockedAreas(playerLevel, worldsUnlocked).filter(area =>
      area.skillTypes && area.skillTypes.includes(skillId)
    );
    if (areas.length === 0) return null;

    const missingIds = new Set(missingMaterials.map(mat => mat.id));

    let bestArea = null;
    let bestScore = 0;

    for (const area of areas) {
      const common = area.materials?.common || [];
      const rare = area.materials?.rare || [];

      let commonMatches = 0;
      let rareMatches = 0;

      for (const id of common) {
        if (missingIds.has(id)) commonMatches += 1;
      }
      for (const id of rare) {
        if (missingIds.has(id)) rareMatches += 1;
      }

      const totalMatches = commonMatches + rareMatches;
      if (totalMatches < missingIds.size) {
        continue;
      }

      const score = (commonMatches * 3) + rareMatches;

      if (score > bestScore) {
        bestScore = score;
        bestArea = area;
      } else if (score > 0 && score === bestScore && bestArea) {
        if ((area.rarity || 0) > (bestArea.rarity || 0)) {
          bestArea = area;
        } else if ((area.baseXp || 0) > (bestArea.baseXp || 0)) {
          bestArea = area;
        }
      }
    }

    return bestScore > 0 ? bestArea : null;
  }

  /**
   * Group missing materials by their best gathering areas
   * Returns { areaId: { area, materials: [...] }, ... }
   */
  getGatheringAreasByMaterials(missingMaterials, playerLevel = 1) {
    if (!missingMaterials || missingMaterials.length === 0) return {};

    const areaMap = {}; // areaId -> { area, materials }

    for (const mat of missingMaterials) {
      const skillId = this.getGatheringTypeForMaterial(mat);
      if (!skillId) continue;

      // Find best area for this individual material
      const bestArea = this.getBestGatheringAreaForMaterials([mat], skillId, playerLevel, []);
      if (!bestArea) continue;

      const areaId = bestArea.id;
      if (!areaMap[areaId]) {
        areaMap[areaId] = { area: bestArea, materials: [] };
      }
      areaMap[areaId].materials.push(mat);
    }

    return areaMap;
  }

  consumeMaterials(player, materials) {
    for (const [id, qty] of Object.entries(materials)) {
      this.removeMaterialFromInventory(player, id, qty);
    }
  }

  removeMaterialFromInventory(player, materialId, quantity) {
    let remaining = quantity;
    // Use splice loop instead of map+filter for better performance
    for (let i = player.inventory.length - 1; i >= 0; i--) {
      const item = player.inventory[i];
      if (!item || typeof item !== 'object' || item.id !== materialId) {
        continue;
      }
      const isGem = item.id ? getGem(item.id) : null;
      if (item.type !== 'material' && !isGem) continue;
      const currentQty = item.quantity || 1;
      if (remaining <= 0) break;
      
      if (currentQty > remaining) {
        item.quantity = currentQty - remaining;
        remaining = 0;
        break;
      }
      
      remaining -= currentQty;
      player.inventory.splice(i, 1);
    }
    this.persistPlayer(player);
  }

  // Helper to track gold earnings for progress stats
  addGold(player, amount) {
    if (amount <= 0) return;
    player.gold += amount;
    if (!player.progressStats) {
      player.progressStats = {
        monstersDefeated: 0,
        gatheringActions: 0,
        materialsCollected: 0,
        craftsCompleted: 0,
        goldEarned: 0,
        criticalHits: 0,
        dungeonsCleared: 0,
        raidsCleared: 0,
      };
    }
    player.progressStats.goldEarned += amount;
  }

  // Helper to track gold spending by category
  trackGoldSpent(player, amount, category = 'other') {
    if (amount <= 0) return;
    if (!player.goldSpentTotal) player.goldSpentTotal = 0;
    if (!player.goldSpentBreakdown) player.goldSpentBreakdown = { shop: 0, crafting: 0, gambling: 0, guild: 0, upgrades: 0, marketplace: 0, other: 0 };
    player.goldSpentTotal += amount;
    player.goldSpentBreakdown[category] = (player.goldSpentBreakdown[category] || 0) + amount;
  }

  // Helper to record combat result
  trackCombatResult(player, enemyName, status, combatType = 'normal') {
    if (!player.combatRecord) player.combatRecord = { totalWins: 0, totalLosses: 0, totalForfeits: 0, byEnemy: {}, byType: { normal: {wins:0,losses:0}, boss: {wins:0,losses:0}, worldBoss: {wins:0,losses:0}, dungeon: {wins:0,losses:0}, arena: {wins:0,losses:0}, guildBoss: {wins:0,losses:0}, raid: {wins:0,losses:0} } };
    const isWin = status === 'victory';
    if (isWin) player.combatRecord.totalWins++; else player.combatRecord.totalLosses++;
    if (!player.combatRecord.byEnemy[enemyName]) player.combatRecord.byEnemy[enemyName] = { wins: 0, losses: 0 };
    if (isWin) player.combatRecord.byEnemy[enemyName].wins++; else player.combatRecord.byEnemy[enemyName].losses++;
    if (!player.combatRecord.byType[combatType]) player.combatRecord.byType[combatType] = { wins: 0, losses: 0 };
    if (isWin) player.combatRecord.byType[combatType].wins++; else player.combatRecord.byType[combatType].losses++;
  }

  // Helper to log player death
  trackDeath(player, enemy, combatType = 'normal') {
    if (!player.deathLog) player.deathLog = [];
    player.deathLog.push({ enemy: enemy?.name || 'Unknown', enemyLevel: enemy?.level || 0, playerLevel: player.level || 1, timestamp: Date.now(), type: combatType });
    if (player.deathLog.length > 50) player.deathLog = player.deathLog.slice(-50);
  }

  // Helper to track skill usage
  trackSkillUsage(player, skillName, damage = 0) {
    if (!player.skillUsageStats) player.skillUsageStats = {};
    if (!player.skillUsageStats[skillName]) player.skillUsageStats[skillName] = { timesUsed: 0, totalDamage: 0 };
    player.skillUsageStats[skillName].timesUsed++;
    player.skillUsageStats[skillName].totalDamage += damage;
  }

  addMaterialToInventory(player, materialId, quantity) {
    const material = getMaterial(materialId);
    if (!material) return;
    const existing = player.inventory.find(
      (item) => item && typeof item === 'object' && item.id === materialId && item.type === 'material'
    );
    if (existing) {
      existing.quantity = (existing.quantity || 1) + quantity;
      if (!player.progressStats) {
        player.progressStats = {
          monstersDefeated: 0,
          gatheringActions: 0,
          materialsCollected: 0,
          craftsCompleted: 0,
          goldEarned: 0,
          criticalHits: 0,
          dungeonsCleared: 0,
          raidsCleared: 0,
        };
      }
      player.progressStats.materialsCollected += quantity;
      this.persistPlayer(player);
      return;
    }
    player.inventory.push({
      id: materialId,
      name: material.name,
      type: 'material',
      quantity,
    });
    if (!player.progressStats) {
      player.progressStats = {
        monstersDefeated: 0,
        gatheringActions: 0,
        materialsCollected: 0,
        craftsCompleted: 0,
        goldEarned: 0,
        criticalHits: 0,
        dungeonsCleared: 0,
        raidsCleared: 0,
      };
    }
    player.progressStats.materialsCollected += quantity;
    this.persistPlayer(player);
  }

  findClassWeaponInLoot(loot, playerClass) {
    // Find a weapon in loot array that matches the player's class
    for (const lootItem of loot) {
      let itemId = typeof lootItem === 'string' ? lootItem : lootItem.id;
      const equipment = getEquipment(itemId);
      if (equipment && equipment.slot === 'weapon' && 
          (!equipment.classRestriction || equipment.classRestriction === playerClass)) {
        return equipment;
      }
    }
    return null;
  }

  /**
   * Distribute raid layer rewards with team package sharing
   * Processes items/materials with class-aware weapons
   */
  distributeRaidLayerRewards(player, rewardPackage) {
    const lootNames = [];
    let weaponGiven = false;
    const playerClass = player.class || player.internalClass;
    
    if (!rewardPackage) return lootNames;

    // Process items with class awareness
    const items = rewardPackage.items || [];
    for (const item of items) {
      let itemId, quantity;
      if (typeof item === 'string') {
        itemId = item;
        quantity = 1;
      } else {
        itemId = item.id;
        quantity = item.quantity || 1;
      }

      const equipment = getEquipment(itemId);
      const itemObj = getItemByIdDynamic(itemId);
      const material = getMaterial(itemId);

      if (equipment) {
        // Handle class-aware weapon distribution
        if (equipment.slot === 'weapon') {
          // Only one weapon per package
          if (weaponGiven) continue;

          // If weapon is restricted to another class, try to substitute
          if (equipment.classRestriction && equipment.classRestriction !== playerClass) {
            const classWeapon = this.findClassWeaponInLoot(items, playerClass);
            if (classWeapon) {
              this.addCraftedItem(player, classWeapon.id, quantity);
              lootNames.push(`${classWeapon.name} x${quantity}`);
              weaponGiven = true;
              continue;
            }
            // No class weapon available, skip this weapon
            continue;
          }
        }

        this.addCraftedItem(player, equipment.id, quantity);
        lootNames.push(`${equipment.name} x${quantity}`);

        if (equipment.slot === 'weapon') {
          weaponGiven = true;
        }
      } else if (itemObj) {
        this.addCraftedItem(player, itemObj.id, quantity);
        lootNames.push(`${itemObj.name} x${quantity}`);
      } else if (material) {
        this.addMaterialToInventory(player, material.id, quantity);
        lootNames.push(`${material.name} x${quantity}`);
      }
    }

    // Process materials
    const materials = rewardPackage.materials || [];
    for (const mat of materials) {
      let matId, quantity;
      if (typeof mat === 'string') {
        matId = mat;
        quantity = 1;
      } else {
        matId = mat.id;
        quantity = mat.quantity || 1;
      }

      const material = getMaterial(matId);
      if (material) {
        this.addMaterialToInventory(player, material.id, quantity);
        lootNames.push(`${material.name} x${quantity}`);
      }
    }

    return lootNames;
  }

  /**
   * Infer equipment slot from item category and type
   */
  inferSlotFromCategory(item) {
    // If item already has a slot, use it
    if (item.slot) return item.slot;
    
    const category = item.category?.toLowerCase() || '';
    const itemType = item.itemType?.toLowerCase() || '';
    
    // Map category/itemType to slots
    if (category === 'weapon' || itemType === 'sword' || itemType === 'axe' || itemType === 'mace' || itemType === 'bow' || itemType === 'staff' || itemType === 'dagger') {
      return 'weapon';
    }
    if (category === 'armor' || category === 'chest' || itemType === 'chest' || itemType === 'body' || itemType === 'cuirass') {
      return 'chest';
    }
    if (itemType === 'helm' || itemType === 'head' || itemType === 'crown') {
      return 'head';
    }
    if (itemType === 'legs' || itemType === 'greaves' || itemType === 'pants') {
      return 'legs';
    }
    if (itemType === 'boots' || itemType === 'feet' || itemType === 'shoes') {
      return 'boots';
    }
    if (itemType === 'shield') {
      return 'shield';
    }
    if (itemType === 'ring') {
      return 'ring';
    }
    if (itemType === 'amulet' || itemType === 'necklace' || itemType === 'pendant') {
      return 'amulet';
    }
    
    // Default based on damage/defense stats
    if ((item.damage || 0) > 0) {
      return 'weapon';
    }
    if ((item.defense || 0) > 0) {
      return 'chest';
    }
    
    // Fallback default
    return 'weapon';
  }

  getResolvedEquippedSlots(player) {
    const slots = new Set();
    const addSlots = (source) => {
      if (!source || typeof source !== 'object') return;
      for (const [slot, value] of Object.entries(source)) {
        const itemId = typeof value === 'string' ? value : value?.id || value?.itemId;
        if (slot && itemId) slots.add(slot);
      }
    };

    addSlots(player.equippedItems);
    addSlots(player.equipment);
    return [...slots];
  }

  getResolvedEquippedItemId(player, slot) {
    const fromEquippedItems = player.equippedItems?.[slot];
    if (typeof fromEquippedItems === 'string') return fromEquippedItems;
    if (fromEquippedItems && typeof fromEquippedItems === 'object') {
      return fromEquippedItems.id || fromEquippedItems.itemId || null;
    }

    const fromLegacyEquipment = player.equipment?.[slot];
    if (typeof fromLegacyEquipment === 'string') return fromLegacyEquipment;
    if (fromLegacyEquipment && typeof fromLegacyEquipment === 'object') {
      return fromLegacyEquipment.id || fromLegacyEquipment.itemId || null;
    }

    return null;
  }

  addCraftedItem(player, itemId, quantity) {
    const equipped = [];
    const added = [];
    for (let i = 0; i < quantity; i += 1) {
      // First, check if it's equipment (weapons/armor with slots)
      const equipment = getEquipment(itemId);
      if (equipment) {
        // Check class restriction (use internalClass since class is only set after quest unlock)
        const playerClass = player.class || player.internalClass;
        const slot = equipment.slot || 'weapon';
        
        // If item has class restriction and player doesn't match, add to inventory (can't auto-equip)
        if (equipment.classRestriction && equipment.classRestriction !== playerClass) {
          this.addInventoryItem(player, {
            id: equipment.id,
            name: equipment.name,
            type: 'equipment',
            slot: equipment.slot,
          });
          added.push(equipment.name);
          continue;
        }
        
        // If slot is empty and player can use it, auto-equip
        if (!player.equippedItems[slot]) {
          player.equippedItems[slot] = equipment.id;
          equipped.push(equipment.name);
          continue;
        }
        
        // Slot has an item - compare stats and auto-equip if better
        const currentEquippedId = player.equippedItems[slot];
        const currentEquipment = getEquipment(currentEquippedId) || getItemByIdDynamic(currentEquippedId);
        
        if (currentEquipment) {
          const currentScore = this.calculateEquipmentScore(currentEquipment);
          const newScore = this.calculateEquipmentScore(equipment);
          
          // If new equipment is better, equip it and add old to inventory
          if (newScore > currentScore) {
            player.equippedItems[slot] = equipment.id;
            equipped.push(`${equipment.name} (replaced ${currentEquipment.name})`);
            this.addInventoryItem(player, {
              id: currentEquipment.id,
              name: currentEquipment.name,
              type: 'equipment',
              slot: currentEquipment.slot,
            });
            continue;
          }
        }
        
        // Otherwise add to inventory
        this.addInventoryItem(player, {
          id: equipment.id,
          name: equipment.name,
          type: 'equipment',
          slot: equipment.slot,
        });
        added.push(equipment.name);
        continue;
      }

      // If not equipment, check if it's a consumable or other item
      const item = getItemByIdDynamic(itemId);
      if (item) {
        // Determine type: equipment if it has combat stats or a slot designation
        let itemType = 'consumable';
        let itemSlot = undefined;
        
        if (item.damage > 0 || item.defense > 0 || item.slot || item.classRestriction) {
          itemType = 'equipment'; // Weapons and armor have stats/slots or class restrictions
          itemSlot = this.inferSlotFromCategory(item); // Infer slot from category
        }
        
        this.addInventoryItem(player, {
          id: item.id,
          name: item.name,
          type: itemType,
          slot: itemSlot,
        });
        added.push(item.name);
      } else {
        // Fallback: item not found, but still add it with a generated name
        // This ensures items are never lost even if definitions are missing
        const fallbackName = itemId.startsWith('item_') 
          ? `Unknown Item (${itemId.slice(-6)})` 
          : itemId.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
        
        this.addInventoryItem(player, {
          id: itemId,
          name: fallbackName,
          type: 'consumable',
        });
        added.push(fallbackName);
        
        // Log warning for debugging
        console.warn(`‚ö†Ô∏è Item not found in system: ${itemId} - added with fallback name`);
      }
    }
    
    player.clearStatsCache(); // Clear cache after crafting (equipment bonuses changed)
    this.persistPlayer(player);
    return { equipped, added };
  }

  applyMissingGatheringRewards(player) {
    const hasGathering = player.professions?.includes('gathering') || Number(player.professionLevels?.gathering) > 0;
    if (!hasGathering) return false;

    const gatheringLevel = getGatheringProfessionLevel(player);
    const safeLevel = Math.max(1, Number(gatheringLevel) || 1);
    const claimedLevel = Math.max(0, Number(player.gatheringRewardsClaimedLevel) || 0);
    if (safeLevel <= claimedLevel) return false;

    for (let level = claimedLevel + 1; level <= safeLevel; level += 1) {
      const reward = getGatheringReward(level);
      if (!reward || !Array.isArray(reward.items)) continue;
      for (const itemId of reward.items) {
        this.addCraftedItem(player, itemId, 1);
      }
    }

    player.gatheringRewardsClaimedLevel = safeLevel;
    this.persistPlayer(player);
    return true;
  }

  /**
   * Handle combat menu group
   */
  async handleCombatMenu(interaction, player) {
    this.trackMenuNavigation(player, 'combat-menu');
    
    const isTier2Plus = player && player.worldsUnlocked && player.worldsUnlocked.length >= 2;
    const roguelikeLine = isTier2Plus ? 'üé≤ **Roguelike Dungeon** - Challenge a procedurally-generated dungeon. Test your skills through 26 floors.\n' : '';

    const embed = new EmbedBuilder()
      .setColor(0xe74c3c)
      .setTitle('‚öîÔ∏è Combat Menu')
      .setDescription(
        '**Choose a combat challenge:**\n\n' +
        '‚öîÔ∏è **Training** - Practice fights. No risk, consistent rewards.\n' +
        'üè∞ **Dungeons** - Multi-enemy instances, escalating difficulty. (Lv 10+)\n' +
        'üëπ **World Boss** - Rare powerful boss. High risk, high reward.\n' +
        'üèüÔ∏è **Arena** - Competitive 1v1 matches. Earn Arena Points. (Lv 5+)\n' +
        roguelikeLine
      );

    const buttons = this.createCombatMenuButtons(player);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Handle quests menu group
   */
  async handleQuestsMenu(interaction, player) {
    this.trackMenuNavigation(player, 'quests');
    const embed = new EmbedBuilder()
      .setColor(0xf39c12)
      .setTitle('üìú Quests & Objectives')
      .setDescription('Your journey and goals');

    const buttons = this.createQuestsMenuButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Handle economy hub menu
   */
  async handleEconomyMenu(interaction, player) {
    this.trackMenuNavigation(player, 'economy');
    const embed = new EmbedBuilder()
      .setColor(0x2ecc71)
      .setTitle('üí∞ Economy Hub')
      .setDescription('Manage crafting, inventory, professions, and shopping.');

    const buttons = this.createEconomyMenuButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Handle gambling menu
   */
  async handleGambling(interaction, player) {
    this.trackMenuNavigation(player, 'gambling');
    const playerGold = player.gold || 0;
    
    const embed = new EmbedBuilder()
      .setColor(0xe74c3c)
      .setTitle('üé∞ Gambling Hall')
      .setDescription(
        `**Try your luck and win big!** ‚ö°\n\n` +
        `Your Gold: **${playerGold}**\n\n` +
        `**Games Available:**\n` +
        `üé∞ **Slots** - Spin the reels, match symbols to win!\n` +
        `ü™ô **Coinflip** - Choose heads or tails, double your money!\n\n` +
        `‚ö†Ô∏è *House Edge: 5% per bet*`
      );

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-slots')
        .setLabel('üé∞ Play Slots')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-coinflip')
        .setLabel('ü™ô Play Coinflip')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-economy-menu')
        .setLabel('‚Üê Back to Economy')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Show slots betting menu
   */
  async handleSlots(interaction, player) {
    const playerGold = player.gold || 0;
    
    const embed = new EmbedBuilder()
      .setColor(0xf39c12)
      .setTitle('üé∞ Slot Machine')
      .setDescription(
        `**Choose your bet amount!**\n\n` +
        `Available Gold: **${playerGold}**\n\n` +
        `üí° **Regular Bets:**\n` +
        `üçíüçíüçí - Triple Match = 5x Payout\n` +
        `üçíüçí or üé∞üé∞ etc - Double Match = 2x Payout\n\n` +
        `üíé **All-In (100% of gold):**\n` +
        `üçíüçíüçí - Triple Match = 10x Payout\n` +
        `üçíüçí or üé∞üé∞ etc - Double Match = 4x Payout\n\n` +
        `Select a bet amount below:`
      );

    const betAmounts = [100, 500, 1000, 5000];
    const buttons = new ActionRowBuilder();

    for (const amount of betAmounts) {
      const canAfford = playerGold >= amount;
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-slots-bet-${amount}`)
          .setLabel(`üí∞ ${amount}`)
          .setStyle(ButtonStyle.Primary)
          .setDisabled(!canAfford)
      );
    }

    const customButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-slots-custom')
        .setLabel('üíµ Custom Amount')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-slots-allin')
        .setLabel('üíé All-In (100%)')
        .setStyle(ButtonStyle.Danger)
        .setDisabled(playerGold === 0)
    );

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-gambling')
        .setLabel('‚Üê Back to Gambling')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons, customButton, backButton],
    });
  }

  /**
   * Play slots game
   */
  async playSlots(interaction, player, betAmount, isAllIn = false) {
    const playerGold = player.gold || 0;

    if (playerGold < betAmount) {
      await interaction.reply({
        content: `‚ùå You don't have enough gold! Need ${betAmount}, have ${playerGold}.`,
        ephemeral: true,
      });
      return;
    }

    // Deduct bet and store last bet amount
    player.gold -= betAmount;
    this.trackGoldSpent(player, betAmount, 'gambling');
    player.lastSlotsBet = betAmount;

    // Slot symbols
    const symbols = ['üçí', 'üçä', 'üçã', 'üé∞', 'üíé'];
    
    // Final result
    const finalReels = [
      symbols[Math.floor(Math.random() * symbols.length)],
      symbols[Math.floor(Math.random() * symbols.length)],
      symbols[Math.floor(Math.random() * symbols.length)],
    ];

    // Show spinning animation
    const spinFrames = 8;
    const spinEmbed = new EmbedBuilder()
      .setColor(0xf39c12)
      .setTitle('üé∞ Slots')
      .setDescription(`**Spinning${isAllIn ? ' (ALL-IN)' : ''}...**\n\nüé∞ üé∞ üé∞\n\nBet: **${betAmount}** gold`);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [spinEmbed],
      components: [],
    });

    // Animate the spinning
    for (let i = 0; i < spinFrames; i++) {
      await new Promise(resolve => setTimeout(resolve, 200));
      
      const randomReels = [
        symbols[Math.floor(Math.random() * symbols.length)],
        symbols[Math.floor(Math.random() * symbols.length)],
        symbols[Math.floor(Math.random() * symbols.length)],
      ];

      const animEmbed = new EmbedBuilder()
        .setColor(0xf39c12)
        .setTitle('üé∞ Slots')
        .setDescription(`**Spinning${isAllIn ? ' (ALL-IN)' : ''}...**\n\n${randomReels.join(' ')}\n\nBet: **${betAmount}** gold`);

      await interaction.editReply({
        embeds: [animEmbed],
        components: [],
      });
    }

    // Wait a moment before showing result
    await new Promise(resolve => setTimeout(resolve, 300));

    // Calculate winnings (multipliers change based on all-in)
    let winAmount = 0;
    let resultMessage = `**Final Spin:** ${finalReels.join(' ')}\n\n`;
    const tripleMultiplier = isAllIn ? 10 : 5;
    const doubleMultiplier = isAllIn ? 4 : 2;

    // Check for triple match
    if (finalReels[0] === finalReels[1] && finalReels[1] === finalReels[2]) {
      winAmount = Math.floor(betAmount * tripleMultiplier);
      resultMessage += `üéâ **TRIPLE MATCH!** üéâ\n`;
      if (isAllIn) {
        resultMessage += `üî• **ALL-IN JACKPOT!** üî•\n`;
      }
      resultMessage += `You won **${winAmount}** gold!`;
    }
    // Check for double match (any two positions match)
    else if (finalReels[0] === finalReels[1] || finalReels[1] === finalReels[2] || finalReels[0] === finalReels[2]) {
      winAmount = Math.floor(betAmount * doubleMultiplier);
      resultMessage += `‚ú® **Double Match!** ‚ú®\n`;
      if (isAllIn) {
        resultMessage += `üî• **ALL-IN BONUS!** üî•\n`;
      }
      resultMessage += `You won **${winAmount}** gold!`;
    }
    // House edge - 5% lose
    else {
      const houseEdge = Math.floor(betAmount * 0.05);
      resultMessage += `‚ùå No match...\n`;
      resultMessage += `House took **${houseEdge}** gold (5% house edge).`;
      if (isAllIn) {
        resultMessage += `\nüíî **Lost your entire bankroll!**`;
      }
    }

    // Add winnings
    player.gold += winAmount;

    // Track gambling stats
    if (!player.progressStats) {
      player.progressStats = {
        monstersDefeated: 0,
        gatheringActions: 0,
        materialsCollected: 0,
        craftsCompleted: 0,
        goldEarned: 0,
        criticalHits: 0,
        dungeonsCleared: 0,
        raidsCleared: 0,
      };
    }

    if (!player.gamblingStats) {
      player.gamblingStats = {
        totalBet: 0,
        totalWon: 0,
        totalLost: 0,
        slotsPlayed: 0,
        coinflipsPlayed: 0,
      };
    }

    player.gamblingStats.slotsPlayed += 1;
    player.gamblingStats.totalBet += betAmount;
    if (winAmount > 0) {
      player.gamblingStats.totalWon += winAmount;
      player.progressStats.goldEarned += winAmount;
    } else {
      player.gamblingStats.totalLost += betAmount;
    }

    this.persistPlayer(player);

    const embed = new EmbedBuilder()
      .setColor(winAmount > 0 ? 0x2ecc71 : 0xe74c3c)
      .setTitle('üé∞ Slots Result')
      .setDescription(resultMessage)
      .addFields({
        name: 'üí∞ Balance',
        value: `**${player.gold}** gold`,
        inline: false,
      });

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-slots-play-again')
        .setLabel(`üé∞ Play Again (${betAmount})`)
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-slots')
        .setLabel('üí∞ Change Bet')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-gambling')
        .setLabel('‚Üê Back to Gambling')
        .setStyle(ButtonStyle.Secondary)
    );

    await interaction.editReply({
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Show coinflip betting menu
   */
  async handleCoinflip(interaction, player) {
    const playerGold = player.gold || 0;

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle('ü™ô Coinflip')
      .setDescription(
        `**Choose heads or tails!**\n\n` +
        `Available Gold: **${playerGold}**\n\n` +
        `üí° **How to Win:**\n` +
        `Guess correctly: Win 2x your bet\n` +
        `Guess wrong: Lose your bet\n\n` +
        `Select your bet amount:`
      );

    const betAmounts = [100, 500, 1000, 5000];
    const betsRow = new ActionRowBuilder();

    for (const amount of betAmounts) {
      const canAfford = playerGold >= amount;
      betsRow.addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-coinflip-choice-${amount}`)
          .setLabel(`üí∞ ${amount}`)
          .setStyle(ButtonStyle.Primary)
          .setDisabled(!canAfford)
      );
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-gambling')
        .setLabel('‚Üê Back to Gambling')
        .setStyle(ButtonStyle.Secondary)
    );

    // Store the bet amount in player data for next interaction
    player.pendingCoinflipBet = null;

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [betsRow, backButton],
    });
  }

  /**
   * Handle coinflip choice (heads/tails)
   */
  async handleCoinflipChoice(interaction, player, betAmount) {
    const playerGold = player.gold || 0;

    if (playerGold < betAmount) {
      await interaction.reply({
        content: `‚ùå You don't have enough gold! Need ${betAmount}, have ${playerGold}.`,
        ephemeral: true,
      });
      return;
    }

    // Store bet amount for the next click
    player.pendingCoinflipBet = betAmount;
    this.persistPlayer(player);

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle('ü™ô Choose Your Side')
      .setDescription(
        `**Bet Amount: ${betAmount} gold**\n\n` +
        `Pick heads or tails and test your luck!`
      );

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`rpg-coinflip-bet-${betAmount}-heads`)
        .setLabel('ü™ô Heads')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId(`rpg-coinflip-bet-${betAmount}-tails`)
        .setLabel('ü™ô Tails')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-gambling')
        .setLabel('‚Üê Cancel')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Play coinflip game
   */
  async playCoinflip(interaction, player, betAmount, playerChoice) {
    const playerGold = player.gold || 0;

    if (playerGold < betAmount) {
      await interaction.reply({
        content: `‚ùå You don't have enough gold! Need ${betAmount}, have ${playerGold}.`,
        ephemeral: true,
      });
      return;
    }

    // Deduct bet
    player.gold -= betAmount;
    this.trackGoldSpent(player, betAmount, 'gambling');

    // Flip coin
    const flip = Math.random() < 0.5 ? 'heads' : 'tails';
    const won = flip === playerChoice;

    let resultMessage = `**Coin lands on: ${flip === 'heads' ? 'ü™ô Heads' : 'ü™ô Tails'}**\n\n`;
    const houseEdgeAmount = Math.floor(betAmount * 0.05);

    let winAmount = 0;
    if (won) {
      winAmount = Math.floor(betAmount * 2) - houseEdgeAmount;
      resultMessage += `üéâ **You Won!** üéâ\n`;
      resultMessage += `Prize: **${winAmount}** gold (after 5% house edge)`;
    } else {
      resultMessage += `‚ùå You Lost...\n`;
      resultMessage += `Better luck next time!`;
    }

    // Add winnings
    player.gold += winAmount;

    // Track gambling stats
    if (!player.progressStats) {
      player.progressStats = {
        monstersDefeated: 0,
        gatheringActions: 0,
        materialsCollected: 0,
        craftsCompleted: 0,
        goldEarned: 0,
        criticalHits: 0,
        dungeonsCleared: 0,
        raidsCleared: 0,
      };
    }

    if (!player.gamblingStats) {
      player.gamblingStats = {
        totalBet: 0,
        totalWon: 0,
        totalLost: 0,
        slotsPlayed: 0,
        coinflipsPlayed: 0,
      };
    }

    player.gamblingStats.coinflipsPlayed += 1;
    player.gamblingStats.totalBet += betAmount;
    if (won) {
      player.gamblingStats.totalWon += winAmount;
      player.progressStats.goldEarned += winAmount;
    } else {
      player.gamblingStats.totalLost += betAmount;
    }

    this.persistPlayer(player);

    const embed = new EmbedBuilder()
      .setColor(won ? 0x2ecc71 : 0xe74c3c)
      .setTitle('ü™ô Coinflip Result')
      .setDescription(resultMessage)
      .addFields({
        name: 'üí∞ Balance',
        value: `**${player.gold}** gold`,
        inline: false,
      });

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-coinflip')
        .setLabel('ü™ô Play Again')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-gambling')
        .setLabel('‚Üê Back to Gambling')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Handle party menu
   */
  async handlePartyMenu(interaction, player) {
    this.trackMenuNavigation(player, 'party');

    const party = player.party || { members: [] };
    const activeIndex = party.activeIndex ?? 0;
    const memberLines = (party.members || []).map((member, index) => {
      const activeTag = index === activeIndex ? '‚≠ê' : '‚Ä¢';
      const classLabel = member.classId ? ` (${member.classId})` : '';
      return `${activeTag} ${member.name || `Member ${index + 1}`}${classLabel}`;
    });

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle('üë• Party')
      .setDescription(
        memberLines.length > 0
          ? memberLines.join('\n')
          : 'No party members yet.'
      );

    embed.addFields({
      name: 'Party Size',
      value: `${party.members?.length || 0}/${party.maxSize || 4}`,
      inline: true,
    });

    const actions = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-party-add')
        .setLabel('‚ûï Add Member')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-party-remove')
        .setLabel('‚ûñ Remove Member')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-party-active')
        .setLabel('‚≠ê Set Active')
        .setStyle(ButtonStyle.Secondary)
    );

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('üè† Back to Hub')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [actions, buttons],
    });
  }

  /**
   * Show modal to add a party member
   */
  async handlePartyAdd(interaction, player) {
    const party = player.party || { maxSize: 4, members: [] };
    if ((party.members?.length || 0) >= (party.maxSize || 4)) {
      await interaction.reply({ content: 'Party is full (max 4).', ephemeral: true });
      return;
    }

    const modal = new ModalBuilder()
      .setCustomId('rpg-party-add-modal')
      .setTitle('Add Party Member');

    const nameInput = new TextInputBuilder()
      .setCustomId('member-name')
      .setLabel('Member Name')
      .setStyle(TextInputStyle.Short)
      .setPlaceholder('e.g., Aria the Scout')
      .setRequired(true)
      .setMaxLength(40);

    const classInput = new TextInputBuilder()
      .setCustomId('member-class')
      .setLabel('Class (optional)')
      .setStyle(TextInputStyle.Short)
      .setPlaceholder('warrior / mage / rogue / paladin')
      .setRequired(false)
      .setMaxLength(20);

    modal.addComponents(
      new ActionRowBuilder().addComponents(nameInput),
      new ActionRowBuilder().addComponents(classInput)
    );

    await interaction.showModal(modal);
  }

  /**
   * Show remove member selector
   */
  async handlePartyRemoveMenu(interaction, player) {
    const party = player.party || { members: [] };
    const removable = (party.members || []).filter((_, index) => index > 0);

    if (removable.length === 0) {
      await interaction.reply({ content: 'No removable party members.', ephemeral: true });
      return;
    }

    const options = removable.map((member, index) => {
      const actualIndex = index + 1;
      return {
        label: member.name || `Member ${actualIndex + 1}`,
        value: String(actualIndex),
        description: member.classId ? `Class: ${member.classId}` : 'No class',
      };
    });

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-party-remove-select')
        .setPlaceholder('Select a member to remove')
        .addOptions(options)
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-party-menu')
        .setLabel('‚Üê Back to Party')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [new EmbedBuilder().setColor(0xe67e22).setTitle('‚ûñ Remove Party Member')],
      components: [selectRow, backRow],
    });
  }

  /**
   * Show set active member selector
   */
  async handlePartyActiveMenu(interaction, player) {
    const party = player.party || { members: [] };
    const options = (party.members || []).map((member, index) => {
      const isActive = index === (party.activeIndex ?? 0);
      return {
        label: member.name || `Member ${index + 1}`,
        value: String(index),
        description: isActive ? 'Active' : (member.classId ? `Class: ${member.classId}` : 'No class'),
      };
    });

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-party-active-select')
        .setPlaceholder('Select active member')
        .addOptions(options)
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-party-menu')
        .setLabel('‚Üê Back to Party')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [new EmbedBuilder().setColor(0x3498db).setTitle('‚≠ê Set Active Member')],
      components: [selectRow, backRow],
    });
  }

  /**
   * Remove selected party member
   */
  async handlePartyRemoveSelect(interaction, player, index) {
    const party = player.party || { members: [] };
    if (!party.members || index <= 0 || index >= party.members.length) {
      await interaction.reply({ content: 'Invalid party member.', ephemeral: true });
      return;
    }

    party.members.splice(index, 1);
    if (party.activeIndex >= party.members.length) {
      party.activeIndex = Math.max(0, party.members.length - 1);
    }

    player.party = party;
    this.persistPlayer(player);
    await this.handlePartyMenu(interaction, player);
  }

  /**
   * Set active party member
   */
  async handlePartyActiveSelect(interaction, player, index) {
    const party = player.party || { members: [] };
    if (!party.members || index < 0 || index >= party.members.length) {
      await interaction.reply({ content: 'Invalid party member.', ephemeral: true });
      return;
    }

    party.activeIndex = index;
    player.party = party;
    this.persistPlayer(player);
    await this.handlePartyMenu(interaction, player);
  }

  /**
   * Handle progress menu
   */
  async handleProgressMenu(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'progress');
    } else {
      player.currentMenu = 'progress';
    }

    const questFlags = Object.keys(player.questFlags || {}).filter(
      key => !key.endsWith('_abandoned') && !key.endsWith('_completed_at')
    );

    // Ensure progressStats exists
    if (!player.progressStats) {
      player.progressStats = {
        monstersDefeated: 0,
        gatheringActions: 0,
        materialsCollected: 0,
        craftsCompleted: 0,
        goldEarned: 0,
        criticalHits: 0,
        dungeonsCleared: 0,
        raidsCleared: 0,
      };
    }

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle('üìà Progress & Statistics')
      .setDescription('Track your journey and achievements.');

    // Basic progress
    embed.addFields(
      { name: 'üìä Character Info', value: `Level: **${player.level}** | XP: **${player.xp}**/${player.xpToNextLevel}\nGold: **${player.gold.toLocaleString()}** | World: **${getWorld(player.currentWorld)?.name || 'Unknown'}**`, inline: false },
      { name: 'üéØ Quest Progress', value: `Quests Completed: **${questFlags.length}**\nWorld Bosses Defeated: **${player.worldBossesDefeated?.length || 0}**`, inline: true },
      { name: 'üèõÔ∏è Guild & Skills', value: `Guild Rank: **${player.guildRank || 'F'}**\nSkills Learned: **${player.skills?.length || 0}**\nTalent Points: **${player.talentPoints || 0}**`, inline: true },
      { name: 'üì¶ Inventory & Professions', value: `Inventory Items: **${player.inventory?.length || 0}**\nProfessions: **${player.professions?.length || 0}**/${player.maxProfessions || 1}`, inline: true }
    );

    // Lifetime Stats
    const stats = player.progressStats;
    embed.addFields({
      name: '‚öîÔ∏è Lifetime Statistics',
      value: [
        `üó°Ô∏è Monsters Defeated: **${stats.monstersDefeated.toLocaleString()}**`,
        `‚õèÔ∏è Gathering Actions: **${stats.gatheringActions.toLocaleString()}**`,
        `üì¶ Materials Collected: **${stats.materialsCollected.toLocaleString()}**`,
        `üî® Items Crafted: **${stats.craftsCompleted.toLocaleString()}**`,
        `üí∞ Gold Earned: **${stats.goldEarned.toLocaleString()}**`,
        `üí• Critical Hits: **${stats.criticalHits.toLocaleString()}**`,
        `üè∞ Dungeons Cleared: **${stats.dungeonsCleared.toLocaleString()}**`,
        `üêâ Raids Cleared: **${stats.raidsCleared.toLocaleString()}**`
      ].join('\n'),
      inline: false
    });

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-achievements')
        .setLabel('üèÖ Achievements')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-collectibles')
        .setLabel('üìö Collectibles')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-titles-badges')
        .setLabel('üéñÔ∏è Titles & Badges')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-progress-leaderboards')
        .setLabel('üèÜ Leaderboards')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Handle achievements menu
   */
  async handleAchievements(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'achievements');
    } else {
      player.currentMenu = 'achievements';
    }

    const achievements = this.getAchievementData(player);

    const embed = new EmbedBuilder()
      .setColor(0xf1c40f)
      .setTitle('üèÖ Achievements')
      .setDescription('Progress toward milestones.');

    achievements.forEach(a => {
      const completedTiers = a.tiers.filter(t => a.progressValue >= t.target).length;
      const totalTiers = a.tiers.length;
      const maxTarget = a.tiers[a.tiers.length - 1].target;
      const nextTier = a.tiers.find(t => a.progressValue < t.target);
      const nextLine = nextTier ? ` ‚Ä¢ Next: ${nextTier.name} (${nextTier.target})` : ' ‚Ä¢ All tiers complete';
      embed.addFields({
        name: a.name,
        value: `${Math.min(a.progressValue, maxTarget)}/${maxTarget} ‚Ä¢ Tiers: ${completedTiers}/${totalTiers}${nextLine}`,
        inline: false,
      });
    });

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-achievement-select')
        .setPlaceholder('View achievement details')
        .addOptions(
          achievements.map(a => ({
            label: a.name.substring(0, 100),
            value: a.id,
            description: a.description.substring(0, 100),
          }))
        )
    );

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, buttons],
    });
  }

  /**
   * Handle leaderboards in progress tab
   */
  async handleProgressLeaderboards(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'progress_leaderboards');
    } else {
      player.currentMenu = 'progress_leaderboards';
    }

    const embed = new EmbedBuilder()
      .setColor(0xffe700)
      .setTitle('üèÜ Player Leaderboards')
      .setDescription(
        `View how you rank against other players!\n\n` +
        `üìä Select a category to see the top players and your ranking.`
      );

    const row = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-progress-leaderboard-select')
        .setPlaceholder('Select a leaderboard category')
        .addOptions(
          { label: 'üåü Overall Score', value: 'overall', emoji: 'üåü', description: 'Top players by combined level and experience' },
          { label: '‚≠ê Level / Experience', value: 'level', emoji: '‚≠ê', description: 'Top players by character level and total XP' },
          { label: 'üí∞ Total Gold', value: 'gold', emoji: 'üí∞', description: 'Richest players by total gold owned' },
          { label: 'üîÆ Boss Essence', value: 'essence', emoji: 'üîÆ', description: 'Players with most Boss Essence' },
          { label: '‚öîÔ∏è Equipment Power', value: 'equipment', emoji: '‚öîÔ∏è', description: 'Highest average equipment rating' },
          { label: 'üè∞ Guild Leadership', value: 'guild', emoji: 'üè∞', description: 'Top guild leaders and officers' },
          { label: 'ü•ä Arena Wins', value: 'arena', emoji: 'ü•ä', description: 'Players with most arena victories' }
        )
    );

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row, buttons],
    });
  }

  /**
   * Build achievement data with tiered rewards
   */
  getAchievementData(player) {
    const questsCompleted = Object.keys(player.questFlags || {}).filter(
      key => !key.endsWith('_abandoned') && !key.endsWith('_completed_at')
    ).length;
    const bossesDefeated = player.worldBossesDefeated?.length || 0;
    const skillsLearned = player.skills?.length || 0;
    const craftedItems = player.inventory?.filter(i => i?.type === 'equipment').length || 0;

    // Progress stats (with fallback for legacy players)
    const stats = player.progressStats || {
      monstersDefeated: 0,
      gatheringActions: 0,
      materialsCollected: 0,
      craftsCompleted: 0,
      goldEarned: 0,
      criticalHits: 0,
      dungeonsCleared: 0,
      raidsCleared: 0,
    };

    return [
      {
        id: 'first_steps',
        name: 'First Steps',
        description: 'Reach level 5.',
        progressValue: player.level,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 3, reward: { xp: 50, gold: 25 } },
          { id: 'silver', name: 'Silver', target: 4, reward: { xp: 75, gold: 40 } },
          { id: 'gold', name: 'Gold', target: 5, reward: { xp: 120, gold: 60 } },
        ],
      },
      {
        id: 'questing',
        name: 'Questing',
        description: 'Complete 10 quests.',
        progressValue: questsCompleted,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 3, reward: { xp: 60, gold: 40 } },
          { id: 'silver', name: 'Silver', target: 6, reward: { xp: 90, gold: 70 } },
          { id: 'gold', name: 'Gold', target: 10, reward: { xp: 150, gold: 120 } },
        ],
      },
      {
        id: 'boss_hunter',
        name: 'Boss Hunter',
        description: 'Defeat 5 world bosses.',
        progressValue: bossesDefeated,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 1, reward: { xp: 80, gold: 80 } },
          { id: 'silver', name: 'Silver', target: 3, reward: { xp: 140, gold: 140 } },
          { id: 'gold', name: 'Gold', target: 5, reward: { xp: 220, gold: 220 } },
        ],
      },
      {
        id: 'skill_collector',
        name: 'Skill Collector',
        description: 'Learn 12 skills.',
        progressValue: skillsLearned,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 4, reward: { xp: 60, gold: 30 } },
          { id: 'silver', name: 'Silver', target: 8, reward: { xp: 110, gold: 70 } },
          { id: 'gold', name: 'Gold', target: 12, reward: { xp: 180, gold: 120 } },
        ],
      },
      {
        id: 'crafter',
        name: 'Crafter',
        description: 'Craft 20 equipment items.',
        progressValue: craftedItems,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 5, reward: { xp: 70, gold: 50 } },
          { id: 'silver', name: 'Silver', target: 12, reward: { xp: 120, gold: 90 } },
          { id: 'gold', name: 'Gold', target: 20, reward: { xp: 200, gold: 150 } },
        ],
      },
      // New achievements based on progress stats
      {
        id: 'monster_slayer',
        name: 'Monster Slayer',
        description: 'Defeat 1000 monsters.',
        progressValue: stats.monstersDefeated,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 100, reward: { xp: 150, gold: 100 } },
          { id: 'silver', name: 'Silver', target: 500, reward: { xp: 400, gold: 300 } },
          { id: 'gold', name: 'Gold', target: 1000, reward: { xp: 800, gold: 600 } },
        ],
      },
      {
        id: 'gatherer',
        name: 'Master Gatherer',
        description: 'Complete 5000 gathering actions.',
        progressValue: stats.gatheringActions,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 1000, reward: { xp: 200, gold: 150 } },
          { id: 'silver', name: 'Silver', target: 2500, reward: { xp: 500, gold: 400 } },
          { id: 'gold', name: 'Gold', target: 5000, reward: { xp: 1000, gold: 800 } },
        ],
      },
      {
        id: 'material_hoarder',
        name: 'Material Hoarder',
        description: 'Collect 10,000 materials.',
        progressValue: stats.materialsCollected,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 1000, reward: { xp: 180, gold: 120 } },
          { id: 'silver', name: 'Silver', target: 5000, reward: { xp: 450, gold: 350 } },
          { id: 'gold', name: 'Gold', target: 10000, reward: { xp: 900, gold: 700 } },
        ],
      },
      {
        id: 'master_crafter',
        name: 'Master Crafter',
        description: 'Craft 500 items.',
        progressValue: stats.craftsCompleted,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 50, reward: { xp: 150, gold: 100 } },
          { id: 'silver', name: 'Silver', target: 200, reward: { xp: 400, gold: 300 } },
          { id: 'gold', name: 'Gold', target: 500, reward: { xp: 800, gold: 600 } },
        ],
      },
      {
        id: 'gold_magnate',
        name: 'Gold Magnate',
        description: 'Earn 1,000,000 gold lifetime.',
        progressValue: stats.goldEarned,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 10000, reward: { xp: 200, gold: 500 } },
          { id: 'silver', name: 'Silver', target: 100000, reward: { xp: 500, gold: 1500 } },
          { id: 'gold', name: 'Gold', target: 1000000, reward: { xp: 1000, gold: 5000 } },
        ],
      },
      {
        id: 'crit_master',
        name: 'Critical Master',
        description: 'Land 1000 critical hits.',
        progressValue: stats.criticalHits,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 100, reward: { xp: 150, gold: 100 } },
          { id: 'silver', name: 'Silver', target: 500, reward: { xp: 400, gold: 300 } },
          { id: 'gold', name: 'Gold', target: 1000, reward: { xp: 800, gold: 600 } },
        ],
      },
      {
        id: 'dungeon_explorer',
        name: 'Dungeon Explorer',
        description: 'Clear 100 dungeons.',
        progressValue: stats.dungeonsCleared,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 10, reward: { xp: 200, gold: 150 } },
          { id: 'silver', name: 'Silver', target: 50, reward: { xp: 500, gold: 400 } },
          { id: 'gold', name: 'Gold', target: 100, reward: { xp: 1000, gold: 800 } },
        ],
      },
      {
        id: 'raid_conqueror',
        name: 'Raid Conqueror',
        description: 'Complete 50 raid floors.',
        progressValue: stats.raidsCleared,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 5, reward: { xp: 300, gold: 250 } },
          { id: 'silver', name: 'Silver', target: 20, reward: { xp: 700, gold: 600 } },
          { id: 'gold', name: 'Gold', target: 50, reward: { xp: 1500, gold: 1200 } },
        ],
      },
      {
        id: 'completionist',
        name: 'Completionist',
        description: 'Complete 50 quests.',
        progressValue: questsCompleted,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 15, reward: { xp: 250, gold: 200 } },
          { id: 'silver', name: 'Silver', target: 30, reward: { xp: 600, gold: 500 } },
          { id: 'gold', name: 'Gold', target: 50, reward: { xp: 1200, gold: 1000 } },
        ],
      },
      {
        id: 'world_champion',
        name: 'World Champion',
        description: 'Defeat 15 world bosses.',
        progressValue: bossesDefeated,
        tiers: [
          { id: 'bronze', name: 'Bronze', target: 7, reward: { xp: 350, gold: 300 } },
          { id: 'silver', name: 'Silver', target: 12, reward: { xp: 800, gold: 700 } },
          { id: 'gold', name: 'Gold', target: 15, reward: { xp: 1500, gold: 1300 } },
        ],
      },
    ];
  }

  /**
   * Handle achievement detail view
   */
  async handleAchievementDetail(interaction, player, achievementId) {
    const achievements = this.getAchievementData(player);
    const achievement = achievements.find(a => a.id === achievementId);
    if (!achievement) {
      await interaction.reply({ content: 'Achievement not found.', ephemeral: true });
      return;
    }

    const claimed = player.achievementRewardsClaimed?.[achievement.id] || {};
    const tierLines = achievement.tiers.map(tier => {
      const completed = achievement.progressValue >= tier.target;
      const isClaimed = !!claimed[tier.id];
      const status = isClaimed ? '‚úÖ Claimed' : completed ? 'üéÅ Claimable' : 'üîí Locked';
      return `‚Ä¢ ${tier.name} (${tier.target}) ‚Äî ${status} (+${tier.reward.xp} XP, +${tier.reward.gold} gold)`;
    });

    const nextClaimable = achievement.tiers.find(tier => achievement.progressValue >= tier.target && !claimed[tier.id]);

    const embed = new EmbedBuilder()
      .setColor(0xf1c40f)
      .setTitle(`üèÖ ${achievement.name}`)
      .setDescription(achievement.description)
      .addFields(
        {
          name: 'Progress',
          value: `${achievement.progressValue}/${achievement.tiers[achievement.tiers.length - 1].target}`,
          inline: true,
        },
        {
          name: 'Tiers',
          value: tierLines.join('\n'),
          inline: false,
        }
      );

    const rows = [];
    if (nextClaimable) {
      rows.push(
        new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-achievement-claim-${achievement.id}-${nextClaimable.id}`)
            .setLabel(`üéÅ Claim ${nextClaimable.name}`)
            .setStyle(ButtonStyle.Success)
        )
      );
    }

    rows.push(
      new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-achievements')
          .setLabel('‚Üê Back to Achievements')
          .setStyle(ButtonStyle.Secondary)
      )
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  /**
   * Claim achievement tier reward
   */
  async handleAchievementClaim(interaction, player, achievementId, tierId) {
    const achievements = this.getAchievementData(player);
    const achievement = achievements.find(a => a.id === achievementId);
    if (!achievement) {
      await interaction.reply({ content: 'Achievement not found.', ephemeral: true });
      return;
    }

    const tier = achievement.tiers.find(t => t.id === tierId);
    if (!tier) {
      await interaction.reply({ content: 'Achievement tier not found.', ephemeral: true });
      return;
    }

    if (achievement.progressValue < tier.target) {
      await interaction.reply({ content: 'Tier not completed yet.', ephemeral: true });
      return;
    }

    if (!player.achievementRewardsClaimed) player.achievementRewardsClaimed = {};
    if (!player.achievementRewardsClaimed[achievement.id]) player.achievementRewardsClaimed[achievement.id] = {};
    if (player.achievementRewardsClaimed[achievement.id][tier.id]) {
      await interaction.reply({ content: 'Reward already claimed.', ephemeral: true });
      return;
    }

    player.achievementRewardsClaimed[achievement.id][tier.id] = true;
    if (tier.reward?.xp) player.addXp(tier.reward.xp);
    if (tier.reward?.gold) this.addGold(player, tier.reward.gold);
    this.persistPlayer(player);

    await interaction.reply({ content: `‚úÖ Claimed ${tier.name} reward!`, ephemeral: true });
    await this.handleAchievementDetail(interaction, player, achievement.id);
  }

  /**
   * Handle collectibles menu
   */
  async handleCollectibles(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'collectibles');
    } else {
      player.currentMenu = 'collectibles';
    }

    if (!player.collectibles) player.collectibles = [];
    
    const collectedCount = player.collectibles.length;
    const claimedMilestones = player.claimedCollectibleMilestones || [];
    const nextMilestone = getNextMilestone(collectedCount, claimedMilestones);

    let milestoneText = '';
    if (nextMilestone) {
      milestoneText = `\n\nüéØ **Next Milestone:** ${nextMilestone.count} collectibles\nüí∞ Reward: ${nextMilestone.rewards.gold}g + ${nextMilestone.rewards.xp} XP`;
    }

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle('üìö Collectibles Collection')
      .setDescription(
        `You have collected **${collectedCount}** unique collectibles.${milestoneText}\n\n` +
        `Collectibles are rare items found throughout your adventures. Collect them to earn exclusive rewards!`
      );

    // Show progress towards milestones with rewards
    const milestones = Object.values(COLLECTIBLE_MILESTONES);
    const milestoneProgress = milestones.map(m => {
      const claimed = claimedMilestones.includes(m.count);
      const reached = collectedCount >= m.count;
      const status = claimed ? '‚úÖ' : reached ? 'üéÅ' : 'üîí';
      const rewards = `${m.rewards.gold}g + ${m.rewards.xp}XP` + (m.rewards.items?.length > 0 ? ` + Items` : '');
      return `${status} **${m.count}** - ${m.title}\n    ‚îî Rewards: ${rewards}`;
    }).join('\n');

    embed.addFields({ name: 'üèÜ Milestones & Rewards', value: milestoneProgress, inline: false });

    // Show some collected items
    if (player.collectibles.length > 0) {
      const recentCollectibles = player.collectibles.slice(-5).map(id => {
        const collectible = getCollectible(id);
        if (collectible) {
          return `${collectible.icon} ${collectible.name}`;
        }
        // Check if it's a crafted item
        if (id.startsWith('crafted_')) {
          const itemId = id.replace('crafted_', '');
          const item = getEquipment(itemId) || getItemByIdDynamic(itemId);
          if (item) {
            return `üõ†Ô∏è ${item.name}`;
          }
        }
        return id;
      }).join('\n');
      embed.addFields({ name: 'üìù Recent Collectibles', value: recentCollectibles, inline: false });
    }

    const buttons = new ActionRowBuilder().addComponents(
      nextMilestone ? new ButtonBuilder()
        .setCustomId('rpg-claim-collectible-milestone')
        .setLabel(`üéÅ Claim ${nextMilestone.count} Reward`)
        .setStyle(ButtonStyle.Success) : new ButtonBuilder()
        .setCustomId('rpg-collectibles-view')
        .setLabel('üìñ View All')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-progress-menu')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Handle viewing all collectibles
   */
  async handleCollectiblesViewAll(interaction, player) {
    this.trackMenuNavigation(player, 'collectibles-view');

    if (!player.collectibles) player.collectibles = [];

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle('üìö All Collectibles')
      .setDescription(`You have collected **${player.collectibles.length}** unique items.`);

    if (player.collectibles.length > 0) {
      // Show all collectibles grouped
      const collectiblesList = player.collectibles.map(id => {
        const collectible = getCollectible(id);
        if (collectible) {
          return `${collectible.icon} **${collectible.name}** - ${collectible.rarity}`;
        }
        // Check if it's a crafted item
        if (id.startsWith('crafted_')) {
          const itemId = id.replace('crafted_', '');
          const item = getEquipment(itemId) || getItemByIdDynamic(itemId);
          if (item) {
            return `üõ†Ô∏è **${item.name}** (Crafted) - ${item.rarity || 'Unknown'}`;
          }
        }
        return `‚ùì ${id}`;
      }).join('\n');

      // Split into chunks if too long
      const maxLength = 1024;
      if (collectiblesList.length > maxLength) {
        const chunks = [];
        let currentChunk = '';
        const lines = collectiblesList.split('\n');
        
        for (const line of lines) {
          if ((currentChunk + line + '\n').length > maxLength) {
            chunks.push(currentChunk);
            currentChunk = line + '\n';
          } else {
            currentChunk += line + '\n';
          }
        }
        if (currentChunk) chunks.push(currentChunk);

        chunks.forEach((chunk, i) => {
          embed.addFields({ 
            name: i === 0 ? 'üì¶ Your Collection' : `üì¶ Collection (cont.)`, 
            value: chunk, 
            inline: false 
          });
        });
      } else {
        embed.addFields({ name: 'üì¶ Your Collection', value: collectiblesList, inline: false });
      }
    } else {
      embed.addFields({ 
        name: 'üì¶ Your Collection', 
        value: 'No collectibles yet. Keep adventuring to find them!', 
        inline: false 
      });
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-collectibles')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backButton],
    });
  }

  /**
   * Handle titles and badges menu
   */
  async handleTitlesAndBadges(interaction, player) {
    this.trackMenuNavigation(player, 'titles-badges');

    const earnedTitles = getEarnedTitles(player);
    const earnedBadges = getEarnedBadges(player);
    const activeTitle = player.activeTitle ? getTitle(player.activeTitle) : null;
    const allTitles = Object.values(TITLES);
    const allBadges = Object.values(BADGES);

    let activeTitleInfo = activeTitle ? activeTitle.displayName : 'None';
    if (activeTitle) {
      const bonuses = [];
      if (activeTitle.activeBonus) bonuses.push(`üü¢ ${activeTitle.activeBonus.description}`);
      if (activeTitle.passiveBonus) bonuses.push(`üîµ ${activeTitle.passiveBonus.description}`);
      if (bonuses.length > 0) {
        activeTitleInfo += `\n${bonuses.join(' | ')}`;
      }
    }

    const embed = new EmbedBuilder()
      .setColor(0xf1c40f)
      .setTitle('üéñÔ∏è Titles & Badges')
      .setDescription(
        `Display your achievements with titles and badges!\n\n` +
        `**Active Title:**\n${activeTitleInfo}\n\n` +
        `**Progress:** ${earnedTitles.length}/${allTitles.length} Titles | ${earnedBadges.length}/${allBadges.length} Badges\n\n` +
        `**Bonus Types:**\nüü¢ Active Bonus (only when title equipped) | üîµ Passive Bonus (always active)`
      );

    // Show recent earned titles
    const recentTitles = earnedTitles.slice(0, 5).map(t => `${t.displayName}`).join(', ');
    embed.addFields({ 
      name: `üèÜ Recent Titles (${earnedTitles.length} total)`, 
      value: recentTitles || 'No titles earned yet', 
      inline: false 
    });

    // Show recent earned badges
    const recentBadges = earnedBadges.slice(0, 5).map(b => `${b.icon} ${b.name}`).join(', ');
    embed.addFields({ 
      name: `üéñÔ∏è Recent Badges (${earnedBadges.length} total)`, 
      value: recentBadges || 'No badges earned yet', 
      inline: false 
    });

    const components = [];
    
    if (earnedTitles.length > 0) {
      const titleOptions = earnedTitles.slice(0, 25).map(t => ({
        label: t.name.substring(0, 100),
        value: t.id,
        description: t.description.substring(0, 100),
      }));
      components.push(new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-select-title')
          .setPlaceholder('Select a title to equip')
          .addOptions(titleOptions)
      ));
    }

    // Add 4 buttons for viewing all titles/badges
    components.push(new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-titles-earned')
        .setLabel(`Earned Titles (${earnedTitles.length})`)
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-titles-unearned')
        .setLabel(`Locked Titles (${allTitles.length - earnedTitles.length})`)
        .setStyle(ButtonStyle.Secondary)
    ));

    components.push(new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-badges-earned')
        .setLabel(`Earned Badges (${earnedBadges.length})`)
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-badges-unearned')
        .setLabel(`Locked Badges (${allBadges.length - earnedBadges.length})`)
        .setStyle(ButtonStyle.Secondary)
    ));

    components.push(new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-progress-menu')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    ));

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Handle viewing all earned titles
   */
  async handleTitlesEarned(interaction, player) {
    const earnedTitles = getEarnedTitles(player);
    const activeTitle = player.activeTitle;

    const embed = new EmbedBuilder()
      .setColor(0x2ecc71)
      .setTitle('üèÜ Earned Titles')
      .setDescription(
        `You have earned ${earnedTitles.length} titles!\n\n` +
        `**Bonus Types:** üü¢ Active (equipped only) | üîµ Passive (always active)`
      );

    if (earnedTitles.length > 0) {
      const titlesList = earnedTitles.map(t => {
        const isActive = t.id === activeTitle ? '‚úÖ ' : '';
        const bonuses = [];
        if (t.activeBonus) bonuses.push(`üü¢ ${t.activeBonus.description}`);
        if (t.passiveBonus) bonuses.push(`üîµ ${t.passiveBonus.description}`);
        const bonusText = bonuses.length > 0 ? `\n    ‚îî ${bonuses.join(' | ')}` : '';
        return `${isActive}${t.displayName} - _${t.description}_${bonusText}`;
      }).join('\n\n');

      // Split into chunks if too long
      const maxLength = 1024;
      if (titlesList.length > maxLength) {
        const chunks = [];
        let currentChunk = '';
        const lines = titlesList.split('\n\n');
        
        for (const line of lines) {
          if ((currentChunk + line + '\n\n').length > maxLength) {
            chunks.push(currentChunk);
            currentChunk = line + '\n\n';
          } else {
            currentChunk += line + '\n\n';
          }
        }
        if (currentChunk) chunks.push(currentChunk);

        chunks.forEach((chunk, i) => {
          embed.addFields({ 
            name: i === 0 ? 'üéñÔ∏è Your Titles' : `üéñÔ∏è Your Titles (cont.)`, 
            value: chunk, 
            inline: false 
          });
        });
      } else {
        embed.addFields({ name: 'üéñÔ∏è Your Titles', value: titlesList, inline: false });
      }
    } else {
      embed.addFields({ name: 'üéñÔ∏è Your Titles', value: 'No titles earned yet. Keep playing to earn them!', inline: false });
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-titles-badges')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backButton],
    });
  }

  /**
   * Handle viewing all unearned titles
   */
  async handleTitlesUnearned(interaction, player) {
    const earnedTitles = getEarnedTitles(player);
    const earnedIds = new Set(earnedTitles.map(t => t.id));
    const allTitles = Object.values(TITLES);
    const unearnedTitles = allTitles.filter(t => !earnedIds.has(t.id));

    const embed = new EmbedBuilder()
      .setColor(0x95a5a6)
      .setTitle('üîí Locked Titles')
      .setDescription(
        `${unearnedTitles.length} titles remaining to unlock.\n\n` +
        `**Bonus Types:** üü¢ Active (equipped only) | üîµ Passive (always active)`
      );

    if (unearnedTitles.length > 0) {
      const titlesList = unearnedTitles.map(t => {
        const bonuses = [];
        if (t.activeBonus) bonuses.push(`üü¢ ${t.activeBonus.description}`);
        if (t.passiveBonus) bonuses.push(`üîµ ${t.passiveBonus.description}`);
        const bonusText = bonuses.length > 0 ? `\n    ‚îî ${bonuses.join(' | ')}` : '';
        return `üîí ${t.displayName} - _${t.description}_${bonusText}`;
      }).join('\n\n');

      // Split into chunks if too long
      const maxLength = 1024;
      if (titlesList.length > maxLength) {
        const chunks = [];
        let currentChunk = '';
        const lines = titlesList.split('\n\n');
        
        for (const line of lines) {
          if ((currentChunk + line + '\n\n').length > maxLength) {
            chunks.push(currentChunk);
            currentChunk = line + '\n\n';
          } else {
            currentChunk += line + '\n\n';
          }
        }
        if (currentChunk) chunks.push(currentChunk);

        chunks.forEach((chunk, i) => {
          embed.addFields({ 
            name: i === 0 ? 'üéØ Locked Titles' : `üéØ Locked Titles (cont.)`, 
            value: chunk, 
            inline: false 
          });
        });
      } else {
        embed.addFields({ name: 'üéØ Locked Titles', value: titlesList, inline: false });
      }
    } else {
      embed.addFields({ name: 'üéØ Locked Titles', value: 'You have earned all available titles! Congratulations!', inline: false });
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-titles-badges')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backButton],
    });
  }

  /**
   * Handle viewing all earned badges
   */
  async handleBadgesEarned(interaction, player) {
    const earnedBadges = getEarnedBadges(player);

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle('üéñÔ∏è Earned Badges')
      .setDescription(`You have earned ${earnedBadges.length} badges!`);

    if (earnedBadges.length > 0) {
      const badgesList = earnedBadges.map(b => 
        `${b.icon} **${b.name}** - _${b.description}_`
      ).join('\n');

      // Split into chunks if too long
      const maxLength = 1024;
      if (badgesList.length > maxLength) {
        const chunks = [];
        let currentChunk = '';
        const lines = badgesList.split('\n');
        
        for (const line of lines) {
          if ((currentChunk + line + '\n').length > maxLength) {
            chunks.push(currentChunk);
            currentChunk = line + '\n';
          } else {
            currentChunk += line + '\n';
          }
        }
        if (currentChunk) chunks.push(currentChunk);

        chunks.forEach((chunk, i) => {
          embed.addFields({ 
            name: i === 0 ? 'üèÖ Your Badges' : `üèÖ Your Badges (cont.)`, 
            value: chunk, 
            inline: false 
          });
        });
      } else {
        embed.addFields({ name: 'üèÖ Your Badges', value: badgesList, inline: false });
      }
    } else {
      embed.addFields({ name: 'üèÖ Your Badges', value: 'No badges earned yet. Keep playing to earn them!', inline: false });
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-titles-badges')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backButton],
    });
  }

  /**
   * Handle viewing all unearned badges
   */
  async handleBadgesUnearned(interaction, player) {
    const earnedBadges = getEarnedBadges(player);
    const earnedIds = new Set(earnedBadges.map(b => b.id));
    const allBadges = Object.values(BADGES);
    const unearnedBadges = allBadges.filter(b => !earnedIds.has(b.id));

    const embed = new EmbedBuilder()
      .setColor(0x7f8c8d)
      .setTitle('üîí Locked Badges')
      .setDescription(`${unearnedBadges.length} badges remaining to unlock.`);

    if (unearnedBadges.length > 0) {
      const badgesList = unearnedBadges.map(b => 
        `üîí ${b.icon} **${b.name}** - _${b.description}_`
      ).join('\n');

      // Split into chunks if too long
      const maxLength = 1024;
      if (badgesList.length > maxLength) {
        const chunks = [];
        let currentChunk = '';
        const lines = badgesList.split('\n');
        
        for (const line of lines) {
          if ((currentChunk + line + '\n').length > maxLength) {
            chunks.push(currentChunk);
            currentChunk = line + '\n';
          } else {
            currentChunk += line + '\n';
          }
        }
        if (currentChunk) chunks.push(currentChunk);

        chunks.forEach((chunk, i) => {
          embed.addFields({ 
            name: i === 0 ? 'üéØ Locked Badges' : `üéØ Locked Badges (cont.)`, 
            value: chunk, 
            inline: false 
          });
        });
      } else {
        embed.addFields({ name: 'üéØ Locked Badges', value: badgesList, inline: false });
      }
    } else {
      embed.addFields({ name: 'üéØ Locked Badges', value: 'You have earned all available badges! Congratulations!', inline: false });
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-titles-badges')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backButton],
    });
  }

  /**
   * Handle guild achievements
   */
  async handleGuildAchievements(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
      return;
    }

    const earnedAchievements = getEarnedGuildAchievements(guild);
    const unclaimedAchievements = earnedAchievements.filter(a => !a.claimed);
    const allAchievements = Object.values(GUILD_ACHIEVEMENTS);

    // Debug info - add guild age to description
    const guildAge = Math.floor((Date.now() - (guild.createdAt || Date.now())) / (24 * 60 * 60 * 1000));

    const embed = new EmbedBuilder()
      .setColor(0xf1c40f)
      .setTitle(`üèÖ [${guild.tag}] Guild Achievements`)
      .setDescription(
        `Collective achievements for your guild!\n\n` +
        `**Earned:** ${earnedAchievements.length} / ${allAchievements.length}\n` +
        `**Unclaimed:** ${unclaimedAchievements.length}\n` +
        `**Guild Age:** ${guildAge} days\n` +
        `**Members:** ${Object.keys(guild.members || {}).length}\n` +
        `**Level:** ${getGuildLevel(guild.xp || 0).level}`
      );

    // Show unclaimed achievements first
    if (unclaimedAchievements.length > 0) {
      const unclaimedList = unclaimedAchievements.map(a =>
        `${a.icon} **${a.name}** - _${a.description}_\nüí∞ Reward: ${a.rewards.gold}g + ${a.rewards.xp} XP`
      ).join('\n\n');
      embed.addFields({ name: 'üéÅ Unclaimed Achievements', value: unclaimedList, inline: false });
    }

    // Show recent earned achievements
    const recentEarned = earnedAchievements.filter(a => a.claimed).slice(0, 5);
    if (recentEarned.length > 0) {
      const earnedList = recentEarned.map(a =>
        `‚úÖ ${a.icon} ${a.name}`
      ).join('\n');
      embed.addFields({ name: '‚úÖ Recently Earned', value: earnedList, inline: false });
    }

    // Show all achievement categories
    if (earnedAchievements.length < allAchievements.length) {
      const unearnedAchievements = allAchievements.filter(ach => 
        !earnedAchievements.some(e => e.id === ach.id)
      );
      
      // Categorize achievements
      const categories = {
        'Members': [],
        'Guild Level': [],
        'Bosses': [],
        'Treasury': [],
        'Activities': [],
        'Milestones': []
      };

      unearnedAchievements.forEach(a => {
        let progress = '';
        const req = a.requirement;
        
        switch (req.type) {
          case 'memberCount':
            progress = `(${Object.keys(guild.members || {}).length}/${req.value})`;
            categories['Members'].push(`üîí ${a.icon} **${a.name}** ${progress}`);
            break;
          case 'level':
            const guildLevel = getGuildLevel(guild.xp || 0);
            progress = `(${guildLevel.level}/${req.value})`;
            categories['Guild Level'].push(`üîí ${a.icon} **${a.name}** ${progress}`);
            break;
          case 'bossesDefeated':
            progress = `(${(guild.bossHistory?.length || 0)}/${req.value})`;
            categories['Bosses'].push(`üîí ${a.icon} **${a.name}** ${progress}`);
            break;
          case 'treasuryGold':
            progress = `(${guild.gold || 0}/${req.value})`;
            categories['Treasury'].push(`üîí ${a.icon} **${a.name}** ${progress}`);
            break;
          case 'questsCompleted':
          case 'dungeonsCleared':
            const current = req.type === 'questsCompleted' ? 
              (guild.stats?.questsCompleted || 0) : 
              (guild.stats?.dungeonsCleared || 0);
            progress = `(${current}/${req.value})`;
            categories['Activities'].push(`üîí ${a.icon} **${a.name}** ${progress}`);
            break;
          case 'age':
            const daysRequired = Math.floor(req.value / (24 * 60 * 60 * 1000));
            const daysElapsed = Math.floor((Date.now() - (guild.createdAt || Date.now())) / (24 * 60 * 60 * 1000));
            progress = `(${daysElapsed}/${daysRequired} days)`;
            categories['Milestones'].push(`üîí ${a.icon} **${a.name}** ${progress}`);
            break;
        }
      });

      // Add fields for each category that has achievements
      for (const [category, achievements] of Object.entries(categories)) {
        if (achievements.length > 0) {
          embed.addFields({ 
            name: `üéØ ${category}`, 
            value: achievements.join('\n'), 
            inline: false 
          });
        }
      }
    }

    const components = [];
    
    // Add select menu for viewing achievement details
    if (allAchievements.length > 0) {
      const selectOptions = allAchievements
        .slice(0, 25) // Discord limit
        .map(ach => {
          const isEarned = earnedAchievements.some(e => e.id === ach.id);
          const isClaimed = isEarned && earnedAchievements.find(e => e.id === ach.id)?.claimed;
          let emoji = 'üîí';
          if (isClaimed) emoji = '‚úÖ';
          else if (isEarned) emoji = 'üéÅ';
          
          return {
            label: ach.name,
            value: ach.id,
            description: ach.description.substring(0, 100),
            emoji: emoji
          };
        });

      components.push(new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-guild-achievement-details')
          .setPlaceholder('üìñ View Achievement Details')
          .addOptions(selectOptions)
      ));
    }
    
    if (unclaimedAchievements.length > 0) {
      components.push(new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-guild-claim-achievements')
          .setLabel(`üéÅ Claim All (${unclaimedAchievements.length})`)
          .setStyle(ButtonStyle.Success)
      ));
    }

    components.push(new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    ));

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Handle claiming guild achievements
   */
  async handleClaimGuildAchievements(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
      return;
    }

    const earnedAchievements = getEarnedGuildAchievements(guild);
    const unclaimedAchievements = earnedAchievements.filter(a => !a.claimed);

    if (unclaimedAchievements.length === 0) {
      await interaction.reply({ content: '‚ùå No achievements to claim!', ephemeral: true });
      return;
    }

    // Mark all as claimed and distribute rewards
    let totalGold = 0;
    let totalXP = 0;
    const claimedNames = [];

    for (const achievement of unclaimedAchievements) {
      // Mark as claimed in guild data
      if (!guild.claimedAchievements) guild.claimedAchievements = [];
      guild.claimedAchievements.push(achievement.id);
      
      totalGold += achievement.rewards.gold || 0;
      totalXP += achievement.rewards.xp || 0;
      claimedNames.push(achievement.name);
    }

    // Add to guild treasury
    guild.gold = (guild.gold || 0) + totalGold;
    guild.xp = (guild.xp || 0) + totalXP;
    
    this.guildManager.save();

    const embed = new EmbedBuilder()
      .setColor(0x00ff00)
      .setTitle('üéÅ Guild Achievements Claimed!')
      .setDescription(
        `Successfully claimed ${unclaimedAchievements.length} achievement${unclaimedAchievements.length > 1 ? 's' : ''}!\n\n` +
        `**Achievements:**\n${claimedNames.map(n => `‚úÖ ${n}`).join('\n')}\n\n` +
        `**Total Rewards:**\nüí∞ ${totalGold} gold added to guild treasury\n‚≠ê ${totalXP} guild XP gained`
      );

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-achievements')
        .setLabel('‚Üê Back to Achievements')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backButton],
    });
  }

  /**
   * Handle viewing individual achievement details
   */
  async handleGuildAchievementDetails(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.update({ content: '‚ùå You are not in a guild!', components: [], embeds: [] });
      return;
    }

    const achievementId = interaction.values[0];
    const achievement = GUILD_ACHIEVEMENTS[achievementId];
    
    if (!achievement) {
      await interaction.update({ content: '‚ùå Achievement not found!', components: [], embeds: [] });
      return;
    }

    const isClaimed = (guild.claimedAchievements || []).includes(achievementId);
    
    // Check if earned and get current progress
    const checkResult = checkGuildAchievement(achievementId, guild);
    const isEarned = checkResult.earned;
    
    // Build progress string based on requirement type
    let currentProgress = '';
    if (achievement.requirement.type === 'memberCount') {
      const memberCount = Object.keys(guild.members || {}).length;
      currentProgress = `Members: ${memberCount}/${achievement.requirement.value}`;
    } else if (achievement.requirement.type === 'level') {
      const guildLevel = getGuildLevel(guild.xp || 0).level;
      currentProgress = `Guild Level: ${guildLevel}/${achievement.requirement.value}`;
    } else if (achievement.requirement.type === 'bossesDefeated') {
      const bossCount = guild.stats?.bossesDefeated || 0;
      currentProgress = `Bosses Defeated: ${bossCount}/${achievement.requirement.value}`;
    } else if (achievement.requirement.type === 'treasuryGold') {
      currentProgress = `Treasury: ${(guild.gold || 0).toLocaleString()}/${achievement.requirement.value.toLocaleString()} gold`;
    } else if (achievement.requirement.type === 'questsCompleted') {
      const questCount = guild.stats?.questsCompleted || 0;
      currentProgress = `Quests: ${questCount}/${achievement.requirement.value}`;
    } else if (achievement.requirement.type === 'dungeonsCleared') {
      const dungeonCount = guild.stats?.dungeonsCleared || 0;
      currentProgress = `Dungeons: ${dungeonCount}/${achievement.requirement.value}`;
    } else if (achievement.requirement.type === 'age') {
      const ageInDays = Math.floor((Date.now() - guild.createdAt) / (1000 * 60 * 60 * 24));
      currentProgress = `Guild Age: ${Math.max(0, ageInDays)}/${achievement.requirement.value} days`;
    }

    // Determine status
    let statusEmoji = 'üîí';
    let statusText = 'Locked';
    if (isClaimed) {
      statusEmoji = '‚úÖ';
      statusText = 'Claimed';
    } else if (isEarned) {
      statusEmoji = 'üéÅ';
      statusText = 'Ready to Claim';
    }

    // Build rewards string
    const rewardParts = [];
    if (achievement.rewards.gold) rewardParts.push(`üí∞ ${achievement.rewards.gold.toLocaleString()} gold`);
    if (achievement.rewards.xp) rewardParts.push(`‚≠ê ${achievement.rewards.xp.toLocaleString()} XP`);
    const rewardsText = rewardParts.length > 0 ? rewardParts.join('\n') : 'None';

    const embed = new EmbedBuilder()
      .setTitle(`${statusEmoji} ${achievement.name}`)
      .setDescription(achievement.description)
      .addFields(
        { name: 'üìä Status', value: statusText, inline: true },
        { name: 'üìà Progress', value: currentProgress, inline: true },
        { name: 'üéÅ Rewards', value: rewardsText, inline: false }
      )
      .setColor(isClaimed ? 0x00FF00 : isEarned ? 0xFFD700 : 0x808080);

    const backButton = new ButtonBuilder()
      .setCustomId('rpg-guild-achievements')
      .setLabel('‚Üê Back to Achievements')
      .setStyle(ButtonStyle.Secondary);

    const row = new ActionRowBuilder().addComponents(backButton);

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], components: [row] });
  }

  /**
   * Handle guild rankings
   */
  async handleGuildRankings(interaction, player) {
    const allGuilds = Object.values(this.guildManager.guilds);
    
    // Sort by XP
    const topGuilds = allGuilds.sort((a, b) => (b.xp || 0) - (a.xp || 0)).slice(0, 10);

    const embed = new EmbedBuilder()
      .setColor(0xe67e22)
      .setTitle('üìä Guild Rankings')
      .setDescription('Top guilds by experience');

    const rankingsList = topGuilds.map((g, i) => {
      const levelInfo = getGuildLevel(g.xp || 0);
      const memberCount = Object.keys(g.members || {}).length;
      return `${i + 1}. **[${g.tag}] ${g.name}**\n‚îî Level ${levelInfo.level} | ${memberCount} members | ${g.xp || 0} XP`;
    }).join('\n\n');

    embed.addFields({ name: 'üèÜ Top Guilds', value: rankingsList || 'No guilds yet', inline: false });

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Handle guild announcements
   */
  /**
   * Handle guild roles management
   */
  async handleGuildRoles(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
      return;
    }

    const member = guild.members[player.userId];
    const isOfficer = member.role === 'officer' || member.role === 'leader';

    if (!isOfficer) {
      await interaction.reply({ content: '‚ùå Only officers and leaders can manage roles!', ephemeral: true });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle(`üëë [${guild.tag}] Role Management`)
      .setDescription(
        `Manage guild member roles and permissions.\n\n` +
        `**üëë Leader:** Full control over the guild\n` +
        `**‚≠ê Officer:** Can manage buffs, invite members, kick members\n` +
        `**üë§ Member:** Regular guild member`
      );

    // Show members by role
    const members = Object.values(guild.members);
    const leaders = members.filter(m => m.role === 'leader');
    const officers = members.filter(m => m.role === 'officer');
    const regularMembers = members.filter(m => m.role === 'member');

    embed.addFields(
      { name: `üëë Leaders (${leaders.length})`, value: leaders.map(m => `<@${m.userId}>`).join(', ') || 'None', inline: false },
      { name: `‚≠ê Officers (${officers.length})`, value: officers.map(m => `<@${m.userId}>`).join(', ') || 'None', inline: false },
      { name: `üë§ Members (${regularMembers.length})`, value: regularMembers.length > 0 ? `${regularMembers.length} members` : 'None', inline: false }
    );

    // Fetch usernames for members
    const memberOptions = [];
    const membersToShow = members.filter(m => m.userId !== player.userId).slice(0, 25);
    
    for (const m of membersToShow) {
      try {
        const user = await this.client.users.fetch(m.userId);
        const roleIcon = m.role === 'leader' ? 'üëë' : m.role === 'officer' ? '‚≠ê' : 'üë§';
        memberOptions.push({
          label: `${roleIcon} ${user.username}`,
          value: m.userId,
          description: `Current role: ${m.role}`,
        });
      } catch (err) {
        // Fallback if user fetch fails
        memberOptions.push({
          label: `User ${m.userId}`,
          value: m.userId,
          description: `Current role: ${m.role}`,
        });
      }
    }

    const components = [];
    
    if (memberOptions.length > 0) {
      components.push(new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-guild-manage-member-role')
          .setPlaceholder('Select a member to promote/demote')
          .addOptions(memberOptions)
      ));
    }

    components.push(new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    ));

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Handle guild member role selection
   */
  async handleGuildMemberRoleSelect(interaction, player, targetUserId) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.update({ content: '‚ùå You are not in a guild!', components: [], embeds: [] });
      return;
    }

    const member = guild.members[player.userId];
    const targetMember = guild.members[targetUserId];

    if (!targetMember) {
      await interaction.update({ content: '‚ùå Member not found!', components: [], embeds: [] });
      return;
    }

    const isLeader = member.role === 'leader';
    if (!isLeader && member.role !== 'officer') {
      await interaction.update({ content: '‚ùå Only officers and leaders can manage roles!', components: [], embeds: [] });
      return;
    }

    // Fetch target user info
    let targetUsername = `User ${targetUserId}`;
    try {
      const targetUser = await this.client.users.fetch(targetUserId);
      targetUsername = targetUser.username;
    } catch (err) {
      // Use fallback
    }

    const roleIcon = targetMember.role === 'leader' ? 'üëë' : targetMember.role === 'officer' ? '‚≠ê' : 'üë§';

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle(`üëë Manage Role: ${targetUsername}`)
      .setDescription(
        `**Current Role:** ${roleIcon} ${targetMember.role}\n\n` +
        `**Contributed:** ${targetMember.contributedXP || 0} XP | ${targetMember.contributedGold || 0}g\n\n` +
        `Select an action below:`
      );

    const buttons = new ActionRowBuilder();

    // Can't demote/promote leaders, officers can't promote to officer
    if (targetMember.role === 'member' && isLeader) {
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-guild-promote-${targetUserId}`)
          .setLabel('‚≠ê Promote to Officer')
          .setStyle(ButtonStyle.Success)
      );
    } else if (targetMember.role === 'officer' && isLeader) {
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-guild-demote-${targetUserId}`)
          .setLabel('üë§ Demote to Member')
          .setStyle(ButtonStyle.Primary)
      );
    }

    // Kick button (officers can kick members, leaders can kick anyone except themselves)
    if (isLeader || (member.role === 'officer' && targetMember.role === 'member')) {
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-guild-kick-${targetUserId}`)
          .setLabel('üö™ Kick from Guild')
          .setStyle(ButtonStyle.Danger)
      );
    }

    const components = [];
    if (buttons.components.length > 0) {
      components.push(buttons);
    }

    components.push(new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-roles')
        .setLabel('‚Üê Back to Roles')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-hub')
        .setLabel('üè† Hub')
        .setStyle(ButtonStyle.Primary)
    ));

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Handle help menu
   */
  async handleHelpMenu(interaction, player) {
    this.trackMenuNavigation(player, 'help');

    const world = getWorld(player.currentWorld);
    const worldBoss = getWorldBoss(player.currentWorld);
    const bossStatus = worldBoss
      ? `${worldBoss.name} (Lvl ${worldBoss.level}) ‚Ä¢ Defeated: ${
          (player.worldBossesDefeated || []).map(String).includes(String(player.currentWorld)) ? '‚úÖ' : '‚ùå'
        }`
      : 'No boss data';

    const embed = new EmbedBuilder()
      .setColor(0x95a5a6)
      .setTitle('‚ùì Help, Tips & Objectives')
      .setDescription('Everything you need to know to progress faster.');

    embed.addFields(
      { name: 'üéØ Objectives', value: `World: ${world?.name || 'Unknown'}\nWorld Boss: ${bossStatus}`, inline: false },
      { name: '‚öîÔ∏è Combat', value: 'Use ‚öîÔ∏è Skills to select skills, manage cooldowns, and exploit type advantages. Access Arena for quick PvP battles (Lv 5+).', inline: false },
      { name: 'üìú Quests', value: 'Complete daily quests, world quests, and defense quests. World quests unlock new areas and progress the story.', inline: false },
      { name: '‚õèÔ∏è Gathering & Crafting', value: 'Gather materials from your current world. Use Professions to craft gear, consumables, and upgrades. Level professions to unlock better recipes.', inline: false },
      { name: 'üèõÔ∏è Guild', value: 'Join or create a guild. Complete guild quests for Guild XP. Higher guild ranks provide weekly rewards and powerful buffs. Check guild leaderboard and growth in QOL menu.', inline: false },
      { name: 'üìà Progression', value: 'Level up to unlock features: Dungeons (Lv 10), Arena (Lv 5), Raids (Lv 20). Use QOL Menu for advanced features like Enemy Encyclopedia, Loot Analytics, and Damage Tracker.', inline: false },
      { name: 'üí° Pro Tips', value: 'Equip best gear sets, spend talent points wisely, check Achievements for passive bonuses. Use Quick Swap in combat to change gear sets. Track boss weaknesses in Boss Analyzer.', inline: false },
      { name: 'üé® Quality of Life', value: 'Access QOL menu for 60+ features: Gear Compare, Favorites, Auto-Sell, Notifications, UI Themes, Timezone Settings, and much more!', inline: false }
    );

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('üè† Back to Hub')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Handle combined stats and talents view
   */
  async handleStatsAndTalents(interaction, player) {
    this.trackMenuNavigation(player, 'stats-talents');
    const embed = UIBuilder.createPlayerStatsEmbed(player);

    const talentEntries = Object.entries(player.talents || {});
    if (talentEntries.length > 0) {
      const talentLines = talentEntries.map(([talentId, rank]) => {
        const talent = getTalent(talentId);
        return `‚Ä¢ ${talent?.name || talentId} (Rank ${rank})`;
      });
      embed.addFields({
        name: 'üß† Talents',
        value: talentLines.join('\n'),
        inline: false,
      });
    } else {
      embed.addFields({
        name: 'üß† Talents',
        value: 'No talents learned yet.',
        inline: false,
      });
    }

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-talents')
        .setLabel('üß† Manage Talents')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Handle story log
   */
  async handleStoryLog(interaction, player) {
    this.trackMenuNavigation(player, 'story-log');

    const flagEntries = Object.entries(player.questFlags || {})
      .filter(([, value]) => typeof value === 'number')
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    const lines = flagEntries.map(([questId, timestamp], index) => {
      const quest = getQuestById(questId) || getDefenseQuestById(questId);
      const questName = quest?.name || quest?.title || questId;
      const dateLabel = new Date(timestamp).toLocaleDateString();
      return `${index + 1}. **${questName}** ‚Äî ${dateLabel}`;
    });

    const embed = new EmbedBuilder()
      .setColor(0x1abc9c)
      .setTitle('üìñ Story Log')
      .setDescription(lines.length > 0 ? lines.join('\n') : 'No story entries yet.');

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Get guild rank info by XP
   */
  getGuildRank(guildXP) {
    return getRankByXP(guildXP || 0);
  }

  /**
   * Arena mode (single battle)
   */
  async handleArena(interaction, player) {
    this.trackMenuNavigation(player, 'arena');
    
    if (player.level < 5) {
      await interaction.reply({
        content: 'üîí **Arena Locked**\nReach level 5 to unlock Arena mode!',
        ephemeral: true,
      });
      return;
    }
    
    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
      return;
    }

    // Show choice: Fight Bot vs Challenge Player vs Arena Shop
    const embed = new EmbedBuilder()
      .setColor(0xff6b6b)
      .setTitle('‚öîÔ∏è Arena Mode')
      .setDescription(
        '**Choose your path:**\n\n' +
        `**Your Arena Points:** ${player.arenaPoints || 0} AP\n` +
        `**Rank:** ${this.getArenaRank(player.arenaPoints || 0)}`
      )
      .addFields(
        {
          name: 'ü§ñ Fight Bot',
          value: '+10 Arena Points for victory',
          inline: false,
        },
        {
          name: 'üë• Challenge Player',
          value: '+50 Arena Points for victory\nFight against player snapshots',
          inline: false,
        },
        {
          name: 'üè™ Arena Shop',
          value: 'Spend Arena Points on potions and rare materials',
          inline: false,
        }
      );

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-arena-bot')
        .setLabel('ü§ñ Fight Bot')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-arena-player')
        .setLabel('üë• Challenge Player')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-arena-shop')
        .setLabel('üè™ Arena Shop')
        .setStyle(ButtonStyle.Secondary)
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons, backRow],
    });
  }

  /**
   * Get arena rank based on points
   */
  getArenaRank(points) {
    if (points >= 5000) return 'üëë Champion';
    if (points >= 2500) return 'üíé Master';
    if (points >= 1000) return '‚öîÔ∏è Gladiator';
    if (points >= 500) return 'üõ°Ô∏è Warrior';
    if (points >= 250) return '‚ö° Fighter';
    if (points >= 100) return 'üî∞ Apprentice';
    return 'üå± Novice';
  }

  async handleArenaBotFight(interaction, player) {
    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
      return;
    }

    const enemyNames = ['Arena Challenger', 'Wild Stalker', 'Savage Raider', 'Forest Spirit', 'Cave Brute'];
    const enemyName = enemyNames[Math.floor(Math.random() * enemyNames.length)];

    const combatState = this.combatSystem.startCombat(
      player,
      enemyName,
      Math.max(1, player.level + 1),
      { meta: { type: 'arena', opponent: 'bot' } }
    );

    this.persistPlayer(player);

    const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
    const buttons = this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  async handleArenaPlayerFight(interaction, player) {
    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
      return;
    }

    // Get snapshots of all other players
    await this.updateArenaSnapshots(player);

    // Get arena snapshots (excluding current player)
    const allSnapshots = (player.arenaSnapshots || []).filter(s => s.userId !== player.userId);

    if (allSnapshots.length === 0) {
      await interaction.reply({
        content: '‚ùå No opponents available yet. Arena snapshots are generated as players progress!',
        ephemeral: true,
      });
      return;
    }

    // Group opponents by level ranges relative to player
    const playerLevel = player.level;
    const levelRanges = [
      { label: '‚öñÔ∏è Exact Level', min: playerLevel, max: playerLevel },
      { label: 'üìä Close Range (¬±3)', min: playerLevel - 3, max: playerLevel + 3 },
      { label: 'üéØ Medium Range (¬±7)', min: playerLevel - 7, max: playerLevel + 7 },
      { label: 'üåê Wide Range (¬±15)', min: playerLevel - 15, max: playerLevel + 15 },
      { label: 'üîì Any Level', min: 1, max: 999 },
    ];

    let selectedOpponents = [];
    let selectedRange = null;

    // Find first range with available opponents
    for (const range of levelRanges) {
      const inRange = allSnapshots.filter(
        s => s.level >= Math.max(1, range.min) && s.level <= range.max
      );
      if (inRange.length > 0) {
        selectedOpponents = inRange;
        selectedRange = range;
        break;
      }
    }

    if (selectedOpponents.length === 0) {
      await interaction.reply({
        content: '‚ùå No opponents available.',
        ephemeral: true,
      });
      return;
    }

    // Sort by level difference (closest first)
    selectedOpponents.sort((a, b) => {
      const diffA = Math.abs(a.level - playerLevel);
      const diffB = Math.abs(b.level - playerLevel);
      return diffA - diffB;
    });

    // Limit to top 25 for select menu
    const displayOpponents = selectedOpponents.slice(0, 25);

    const embed = new EmbedBuilder()
      .setColor(0xff6b6b)
      .setTitle('üë• Arena Matchmaking')
      .setDescription(
        `**Your Level:** ${playerLevel}\n` +
        `**Matchmaking Range:** ${selectedRange.label}\n` +
        `**Opponents Found:** ${selectedOpponents.length}\n\n` +
        `Select an opponent to challenge. Closer level = Fair fight!`
      );

    // Add top opponents preview
    const topOpponents = displayOpponents.slice(0, 10).map(s => {
      const levelDiff = s.level - playerLevel;
      const diffText = levelDiff > 0 ? `+${levelDiff}` : levelDiff < 0 ? `${levelDiff}` : '=';
      return `‚Ä¢ **${s.username}** (Lvl ${s.level}) [${diffText}] - ${s.classId || 'adventurer'}`;
    }).join('\n');

    embed.addFields({
      name: 'Available Opponents',
      value: topOpponents + (displayOpponents.length > 10 ? `\n...and ${displayOpponents.length - 10} more` : ''),
      inline: false,
    });

    // Create select menu
    const selectOptions = displayOpponents.map(s => {
      const levelDiff = s.level - playerLevel;
      const diffText = levelDiff > 0 ? `+${levelDiff}` : levelDiff < 0 ? `${levelDiff}` : '=';
      return {
        label: `${s.username} (Lvl ${s.level})`.substring(0, 100),
        value: s.userId,
        description: `Level ${diffText} | ${s.classId || 'adventurer'} | HP: ${s.maxHp}`.substring(0, 100),
        emoji: this.getClassEmoji(s.classId),
      };
    });

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-arena-opponent-select')
      .setPlaceholder('Choose your opponent...')
      .addOptions(selectOptions);

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-arena')
        .setLabel('‚Üê Back to Arena')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  /**
   * Get class emoji for display
   */
  getClassEmoji(classId) {
    const emojis = {
      warrior: '‚öîÔ∏è',
      mage: '‚ú®',
      rogue: 'üó°Ô∏è',
      ranger: 'üèπ',
      paladin: 'üõ°Ô∏è',
    };
    return emojis[classId] || '‚öîÔ∏è';
  }

  /**
   * Update arena snapshots - saves current stats of all players
   */
  async updateArenaSnapshots(player) {
    const allPlayers = this.playerManager.getAllPlayers();
    const snapshots = [];

    for (const p of allPlayers) {
      if (p.userId === player.userId) continue; // Don't snapshot self

      const opponentClass = p.class || p.internalClass || 'adventurer';
      let opponentTypes = ['physical'];
      if (opponentClass === 'mage') opponentTypes = ['arcane'];
      if (opponentClass === 'rogue') opponentTypes = ['shadow'];
      if (opponentClass === 'ranger') opponentTypes = ['physical', 'nature'];
      if (opponentClass === 'paladin') opponentTypes = ['holy'];

      snapshots.push({
        userId: p.userId,
        username: p.username,
        level: p.level || 1,
        classId: opponentClass,
        maxHp: p.maxHp || 100,
        strength: p.strength || 10,
        defense: p.defense || 10,
        intelligence: p.intelligence || 10,
        agility: p.agility || 10,
        skills: [...(p.skills || [])],
        types: opponentTypes,
        lastUpdated: Date.now(),
      });
    }

    // Save snapshots to player's data
    player.arenaSnapshots = snapshots;
    this.persistPlayer(player);
  }

  /**
   * Start arena fight with selected opponent
   */
  async handleArenaFightStart(interaction, player, opponentId) {
    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
      return;
    }

    // Find opponent snapshot
    const opponentSnapshot = (player.arenaSnapshots || []).find(s => s.userId === opponentId);
    if (!opponentSnapshot) {
      await interaction.reply({
        content: '‚ùå Opponent snapshot not found. Try refreshing the arena.',
        ephemeral: true,
      });
      return;
    }

    // Start combat with snapshot stats
    const combatState = this.combatSystem.startCombatWithCustomEnemy(
      player,
      opponentSnapshot.username,
      opponentSnapshot.level,
      opponentSnapshot.maxHp,
      {
        strength: opponentSnapshot.strength,
        defense: opponentSnapshot.defense,
        intelligence: opponentSnapshot.intelligence,
        agility: opponentSnapshot.agility,
        types: opponentSnapshot.types,
      },
      opponentSnapshot.skills,
      { type: 'arena', opponent: 'player', opponentId: opponentSnapshot.userId, opponentSnapshot }
    );

    this.persistPlayer(player);

    const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
    const levelDiff = opponentSnapshot.level - player.level;
    const diffText = levelDiff > 0 ? `+${levelDiff}` : levelDiff < 0 ? `${levelDiff}` : '=';
    
    embed.addFields({
      name: 'üë• Arena PvP Battle',
      value: `Facing: **${opponentSnapshot.username}** (Level ${opponentSnapshot.level} [${diffText}])\n` +
             `Class: ${opponentSnapshot.classId || 'adventurer'}\n` +
             `Reward: **+50 Arena Points** on victory`,
      inline: false,
    });
    
    const buttons = this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Handle Arena Shop
   */
  async handleArenaShop(interaction, player) {
    this.trackMenuNavigation(player, 'arena-shop');
    
    const arenaPoints = player.arenaPoints || 0;

    const shopItems = [
      // Potions
      { id: 'health_potion_t3', name: 'Rare Health Potion', cost: 500, type: 'potion', emoji: '‚ù§Ô∏è' },
      { id: 'xp_potion_t3', name: 'Rare XP Potion', cost: 1000, type: 'potion', emoji: '‚≠ê' },
      { id: 'gold_potion_t3', name: 'Rare Gold Potion', cost: 750, type: 'potion', emoji: 'üí∞' },
      { id: 'loot_potion_t3', name: 'Rare Loot Potion', cost: 1000, type: 'potion', emoji: 'üéÅ' },
      { id: 'health_potion_t4', name: 'Epic Health Potion', cost: 1500, type: 'potion', emoji: '‚ù§Ô∏è' },
      { id: 'xp_potion_t4', name: 'Epic XP Potion', cost: 2500, type: 'potion', emoji: '‚≠ê' },
      
      // Rare Materials
      { id: 'mithril_ore', name: 'Mithril Ore', cost: 1000, type: 'material', emoji: '‚õèÔ∏è', quantity: 5 },
      { id: 'adamantite', name: 'Adamantite', cost: 2000, type: 'material', emoji: 'üíé', quantity: 3 },
      { id: 'arcane_essence', name: 'Arcane Essence', cost: 1500, type: 'material', emoji: '‚ú®', quantity: 3 },
      { id: 'dragonhide', name: 'Dragonhide', cost: 2500, type: 'material', emoji: 'üêâ', quantity: 2 },
      { id: 'moonflower', name: 'Moonflower', cost: 1000, type: 'material', emoji: 'üåô', quantity: 3 },
      { id: 'rare_flower', name: 'Rare Flower', cost: 500, type: 'material', emoji: 'üå∏', quantity: 5 },
    ];

    const embed = new EmbedBuilder()
      .setColor(0xffa500)
      .setTitle('üè™ Arena Shop')
      .setDescription(
        `**Your Arena Points:** ${arenaPoints} AP\n` +
        `**Your Rank:** ${this.getArenaRank(arenaPoints)}\n\n` +
        `Spend your hard-earned Arena Points on premium items!`
      );

    // Group items by type
    const potions = shopItems.filter(i => i.type === 'potion');
    const materials = shopItems.filter(i => i.type === 'material');

    const potionsList = potions.map(item => {
      const canBuy = arenaPoints >= item.cost;
      const status = canBuy ? '‚úÖ' : '‚ùå';
      return `${status} ${item.emoji} **${item.name}** - ${item.cost} AP`;
    }).join('\n');

    const materialsList = materials.map(item => {
      const canBuy = arenaPoints >= item.cost;
      const status = canBuy ? '‚úÖ' : '‚ùå';
      const qty = item.quantity ? ` x${item.quantity}` : '';
      return `${status} ${item.emoji} **${item.name}${qty}** - ${item.cost} AP`;
    }).join('\n');

    embed.addFields(
      { name: 'üß™ Premium Potions', value: potionsList, inline: false },
      { name: '‚öíÔ∏è Rare Materials', value: materialsList, inline: false }
    );

    // Create purchase buttons (limited to 5 per row, max 25 items in select menu)
    const selectOptions = shopItems.slice(0, 25).map(item => {
      const canBuy = arenaPoints >= item.cost;
      const qty = item.quantity ? ` x${item.quantity}` : '';
      return {
        label: `${item.name}${qty}`.substring(0, 100),
        value: item.id,
        description: `${item.cost} AP ${canBuy ? '' : '(Not enough AP)'}`.substring(0, 100),
        emoji: item.emoji,
      };
    });

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-arena-shop-buy')
      .setPlaceholder('Select an item to purchase...')
      .addOptions(selectOptions);

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-arena')
        .setLabel('‚Üê Back to Arena')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-hub')
        .setLabel('üè† Hub')
        .setStyle(ButtonStyle.Primary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  /**
   * Handle Arena Shop Purchase
   */
  async handleArenaShopPurchase(interaction, player, itemId) {
    const arenaPoints = player.arenaPoints || 0;

    // Define shop items (same as in handleArenaShop)
    const shopItems = [
      { id: 'health_potion_t3', name: 'Rare Health Potion', cost: 500, type: 'consumable', emoji: '‚ù§Ô∏è' },
      { id: 'xp_potion_t3', name: 'Rare XP Potion', cost: 1000, type: 'consumable', emoji: '‚≠ê' },
      { id: 'gold_potion_t3', name: 'Rare Gold Potion', cost: 750, type: 'consumable', emoji: 'üí∞' },
      { id: 'loot_potion_t3', name: 'Rare Loot Potion', cost: 1000, type: 'consumable', emoji: 'üéÅ' },
      { id: 'health_potion_t4', name: 'Epic Health Potion', cost: 1500, type: 'consumable', emoji: '‚ù§Ô∏è' },
      { id: 'xp_potion_t4', name: 'Epic XP Potion', cost: 2500, type: 'consumable', emoji: '‚≠ê' },
      { id: 'mithril_ore', name: 'Mithril Ore', cost: 1000, type: 'material', emoji: '‚õèÔ∏è', quantity: 5 },
      { id: 'adamantite', name: 'Adamantite', cost: 2000, type: 'material', emoji: 'üíé', quantity: 3 },
      { id: 'arcane_essence', name: 'Arcane Essence', cost: 1500, type: 'material', emoji: '‚ú®', quantity: 3 },
      { id: 'dragonhide', name: 'Dragonhide', cost: 2500, type: 'material', emoji: 'üêâ', quantity: 2 },
      { id: 'moonflower', name: 'Moonflower', cost: 1000, type: 'material', emoji: 'üåô', quantity: 3 },
      { id: 'rare_flower', name: 'Rare Flower', cost: 500, type: 'material', emoji: 'üå∏', quantity: 5 },
    ];

    const item = shopItems.find(i => i.id === itemId);
    if (!item) {
      await interaction.reply({
        content: '‚ùå Invalid item selection.',
        ephemeral: true,
      });
      return;
    }

    // Check if player has enough arena points
    if (arenaPoints < item.cost) {
      await interaction.reply({
        content: `‚ùå Not enough Arena Points! You have ${arenaPoints} AP but need ${item.cost} AP.`,
        ephemeral: true,
      });
      return;
    }

    // Deduct arena points
    player.arenaPoints -= item.cost;

    // Add item to inventory
    const quantity = item.quantity || 1;
    const inventoryItem = {
      id: item.id,
      name: item.name,
      type: item.type,
      quantity: quantity,
      rarity: item.id.includes('t4') ? 'epic' : item.id.includes('t3') ? 'rare' : 'uncommon',
    };

    // Check if item already exists in inventory to stack
    const existingItem = player.inventory.find(i => i && i.id === item.id);
    if (existingItem) {
      existingItem.quantity = (existingItem.quantity || 1) + quantity;
    } else {
      player.inventory.push(inventoryItem);
    }

    this.persistPlayer(player);

    // Show success message
    const qtyText = quantity > 1 ? ` x${quantity}` : '';
    await interaction.reply({
      content: `‚úÖ **Purchase Successful!**\n\n` +
               `${item.emoji} Bought: **${item.name}${qtyText}**\n` +
               `üí∞ Cost: ${item.cost} AP\n` +
               `üí≥ Remaining: ${player.arenaPoints} AP`,
      ephemeral: false,
    });

    // Return to shop after 3 seconds
    setTimeout(async () => {
      try {
        await this.handleArenaShop(interaction, player);
      } catch (e) {
        // Ignore if interaction expired
      }
    }, 3000);
  }

  /**
   * Load market data from file
   */
  loadMarketData() {
    try {
      const marketPath = path.join(process.cwd(), 'rpg', 'data', 'market.json');
      
      if (fs.existsSync(marketPath)) {
        const data = fs.readFileSync(marketPath, 'utf8');
        return JSON.parse(data);
      }
      return { listings: [] };
    } catch (error) {
      console.error('Error loading market data:', error);
      return { listings: [] };
    }
  }

  /**
   * Save market data to file
   */
  saveMarketData(marketData) {
    try {
      const marketPath = path.join(process.cwd(), 'rpg', 'data', 'market.json');
      fs.writeFileSync(marketPath, JSON.stringify(marketData, null, 2), 'utf8');
    } catch (error) {
      console.error('Error saving market data:', error);
    }
  }

  /**
   * Handle Market Main Menu
   */
  async handleMarket(interaction, player) {
    const marketData = this.loadMarketData();
    const activeListings = marketData.listings.filter(l => l.active !== false);
    const myListings = activeListings.filter(l => l.sellerId === player.userId);

    // Get guild rank tax reduction
    const guildRank = this.getGuildRank(player.guildXP || 0);
    const taxReduction = guildRank.buffs?.marketTaxReduction || 0;
    const taxRate = Math.max(0, 10 - taxReduction); // Base 10% tax

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle('üè™ Player Market')
      .setDescription(
        '**Welcome to the Player Market!**\n' +
        `Trade items with other players. Buy low, sell high!\n\n` +
        `**Market Info:**\n` +
        `‚Ä¢ Active Listings: ${activeListings.length}\n` +
        `‚Ä¢ Your Listings: ${myListings.length}\n` +
        `‚Ä¢ Market Tax: ${taxRate}% (Guild Rank Bonus: -${taxReduction}%)\n` +
        `‚Ä¢ Your Gold: ${player.gold || 0}g`
      )
      .addFields(
        { name: 'üìä Browse Market', value: 'View and purchase items from other players', inline: false },
        { name: 'üí∞ Sell Items', value: 'List your items for sale', inline: false },
        { name: 'üìã My Listings', value: 'Manage your active listings', inline: false }
      );

    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-market-browse')
        .setLabel('üìä Browse Market')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-market-sell')
        .setLabel('üí∞ Sell Items')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-market-my-listings')
        .setLabel('üìã My Listings')
        .setStyle(ButtonStyle.Secondary)
        .setDisabled(myListings.length === 0)
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-economy-menu')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2],
    });
  }

  /**
   * Handle Market Browse
   */
  async handleMarketBrowse(interaction, player) {
    const marketData = this.loadMarketData();
    const activeListings = marketData.listings.filter(
      l => l.active !== false && l.sellerId !== player.userId
    );

    if (activeListings.length === 0) {
      await interaction.reply({
        content: 'üè™ The market is currently empty. Check back later!',
        ephemeral: true,
      });
      return;
    }

    // Sort by newest first
    activeListings.sort((a, b) => b.listedAt - a.listedAt);

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle('üìä Market Listings')
      .setDescription(
        `**${activeListings.length} items available**\n` +
        `Your Gold: ${player.gold || 0}g\n\n` +
        `Select an item to purchase:`
      );

    // Show top listings
    const displayListings = activeListings.slice(0, 10);
    const listingsList = displayListings.map(listing => {
      const canAfford = (player.gold || 0) >= listing.price;
      const affordIcon = canAfford ? '‚úÖ' : '‚ùå';
      const qtyText = listing.quantity > 1 ? ` x${listing.quantity}` : '';
      return `${affordIcon} **${listing.itemName}${qtyText}** - ${listing.price}g (by ${listing.sellerName})`;
    }).join('\n');

    embed.addFields({
      name: 'Available Items',
      value: listingsList + (activeListings.length > 10 ? `\n...and ${activeListings.length - 10} more` : ''),
      inline: false,
    });

    // Create select menu
    const selectOptions = displayListings.slice(0, 25).map(listing => {
      const canAfford = (player.gold || 0) >= listing.price;
      const qtyText = listing.quantity > 1 ? ` x${listing.quantity}` : '';
      return {
        label: `${listing.itemName}${qtyText}`.substring(0, 100),
        value: listing.id,
        description: `${listing.price}g by ${listing.sellerName} ${canAfford ? '' : '(Not enough gold)'}`.substring(0, 100),
        emoji: this.getItemTypeEmoji(listing.itemType),
      };
    });

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-market-listing-select')
      .setPlaceholder('Select an item to purchase...')
      .addOptions(selectOptions);

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-market')
        .setLabel('‚Üê Back to Market')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  /**
   * Get item type emoji
   */
  getItemTypeEmoji(type) {
    const emojis = {
      material: '‚öíÔ∏è',
      consumable: 'üß™',
      equipment: '‚öîÔ∏è',
      enchant: '‚ú®',
      quest: 'üìú',
    };
    return emojis[type] || 'üì¶';
  }

  /**
   * Handle Market Purchase
   */
  async handleMarketPurchase(interaction, player, listingId) {
    const marketData = this.loadMarketData();
    const listing = marketData.listings.find(l => l.id === listingId && l.active !== false);

    if (!listing) {
      await interaction.reply({
        content: '‚ùå Listing not found or no longer available.',
        ephemeral: true,
      });
      return;
    }

    // Check if trying to buy own listing
    if (listing.sellerId === player.userId) {
      await interaction.reply({
        content: '‚ùå You cannot purchase your own listing!',
        ephemeral: true,
      });
      return;
    }

    // Check if player has enough gold
    if ((player.gold || 0) < listing.price) {
      await interaction.reply({
        content: `‚ùå Not enough gold! You have ${player.gold || 0}g but need ${listing.price}g.`,
        ephemeral: true,
      });
      return;
    }

    // Deduct gold from buyer
    player.gold -= listing.price;
    this.trackGoldSpent(player, listing.price, 'marketplace');

    // Add item to buyer's inventory
    const purchasedItem = {
      id: listing.itemId,
      name: listing.itemName,
      type: listing.itemType,
      quantity: listing.quantity,
      rarity: listing.rarity || 'common',
    };

    const existingItem = player.inventory.find(i => i && i.id === listing.itemId);
    if (existingItem) {
      existingItem.quantity = (existingItem.quantity || 1) + listing.quantity;
    } else {
      player.inventory.push(purchasedItem);
    }

    // Calculate tax
    const guildRank = this.getGuildRank(player.guildXP || 0);
    const taxReduction = guildRank.buffs?.marketTaxReduction || 0;
    const taxRate = Math.max(0, 10 - taxReduction) / 100;
    const tax = Math.floor(listing.price * taxRate);
    const sellerReceives = listing.price - tax;

    // Give gold to seller (if they exist)
    const seller = this.playerManager.getPlayer(listing.sellerId);
    if (seller) {
      seller.gold = (seller.gold || 0) + sellerReceives;
      this.playerManager.savePlayer(seller);
    }

    // Mark listing as sold
    listing.active = false;
    listing.soldAt = Date.now();
    listing.buyerId = player.userId;
    listing.buyerName = player.username;

    this.saveMarketData(marketData);
    this.persistPlayer(player);

    // Track trade history for buyer
    if (!player.tradeHistory) player.tradeHistory = [];
    player.tradeHistory.push({ type: 'buy', item: listing.itemName, price: listing.price, partner: listing.sellerName || 'Unknown', timestamp: Date.now() });
    if (player.tradeHistory.length > 50) player.tradeHistory = player.tradeHistory.slice(-50);

    // Track trade history for seller
    if (seller) {
      if (!seller.tradeHistory) seller.tradeHistory = [];
      seller.tradeHistory.push({ type: 'sell', item: listing.itemName, price: sellerReceives, partner: player.username, timestamp: Date.now() });
      if (seller.tradeHistory.length > 50) seller.tradeHistory = seller.tradeHistory.slice(-50);
      this.playerManager.savePlayer(seller);
    }

    const qtyText = listing.quantity > 1 ? ` x${listing.quantity}` : '';
    await interaction.reply({
      content: `‚úÖ **Purchase Successful!**\n\n` +
               `üì¶ Bought: **${listing.itemName}${qtyText}**\n` +
               `üí∞ Paid: ${listing.price}g\n` +
               `üèõÔ∏è Market Tax: ${tax}g (${taxRate * 100}%)\n` +
               `üí≥ Remaining: ${player.gold}g\n\n` +
               `Seller received ${sellerReceives}g`,
      ephemeral: false,
    });

    // Return to browse after 2 seconds
    setTimeout(async () => {
      try {
        await this.handleMarketBrowse(interaction, player);
      } catch (e) {
        // Ignore if interaction expired
      }
    }, 2000);
  }

  /**
   * Handle Market Sell Menu
   */
  async handleMarketSellMenu(interaction, player) {
    // Get sellable items from inventory
    const sellableItems = player.inventory.filter(item => 
      item && typeof item === 'object' && 
      item.id && item.name &&
      !item.slot  // Exclude items currently in equipment slots
    );

    if (sellableItems.length === 0) {
      await interaction.reply({
        content: '‚ùå You have no items to sell. Gather materials or craft items first!',
        ephemeral: true,
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0x2ecc71)
      .setTitle('üí∞ Sell Items')
      .setDescription(
        'Choose an item from your inventory to list on the market.\n\n' +
        `**Your Sellable Items:** ${sellableItems.length}\n\n` +
        '_Materials, Consumables, Equipment, and Gems can all be sold!_'
      );

    // Show items
    const itemsList = sellableItems.slice(0, 15).map(item => {
      const qtyText = item.quantity > 1 ? ` x${item.quantity}` : '';
      const rarityText = item.rarity ? ` [${item.rarity}]` : '';
      return `‚Ä¢ ${item.name}${qtyText}${rarityText}`;
    }).join('\n');

    embed.addFields({
      name: 'Available Items',
      value: itemsList + (sellableItems.length > 15 ? `\n...and ${sellableItems.length - 15} more` : ''),
      inline: false,
    });

    // Create select menu
    const selectOptions = sellableItems.slice(0, 25).map(item => {
      const qtyText = item.quantity > 1 ? ` x${item.quantity}` : '';
      const rarityText = item.rarity ? ` [${item.rarity}]` : '';
      return {
        label: `${item.name}${qtyText}`.substring(0, 100),
        value: item.id,
        description: `${item.type}${rarityText}`.substring(0, 100),
        emoji: this.getItemTypeEmoji(item.type),
      };
    });

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-market-item-select')
      .setPlaceholder('Select an item to sell...')
      .addOptions(selectOptions);

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-market')
        .setLabel('‚Üê Back to Market')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  /**
   * Handle Market Item Details (before listing)
   */
  async handleMarketItemDetails(interaction, player, itemId) {
    const item = player.inventory.find(i => i && i.id === itemId);
    
    if (!item) {
      await interaction.reply({
        content: '‚ùå Item not found in your inventory.',
        ephemeral: true,
      });
      return;
    }

    // Show modal for price input
    const modal = new ModalBuilder()
      .setCustomId(`rpg-market-list-${itemId}`)
      .setTitle(`List ${item.name}`);

    const priceInput = new TextInputBuilder()
      .setCustomId('item_price')
      .setLabel('Price (in gold)')
      .setStyle(TextInputStyle.Short)
      .setPlaceholder('e.g., 100')
      .setRequired(true)
      .setMinLength(1)
      .setMaxLength(10);

    const quantityInput = new TextInputBuilder()
      .setCustomId('item_quantity')
      .setLabel(`Quantity (max: ${item.quantity || 1})`)
      .setStyle(TextInputStyle.Short)
      .setPlaceholder('1')
      .setValue('1')
      .setRequired(false)
      .setMinLength(1)
      .setMaxLength(5);

    const priceRow = new ActionRowBuilder().addComponents(priceInput);
    const quantityRow = new ActionRowBuilder().addComponents(quantityInput);

    modal.addComponents(priceRow, quantityRow);

    await interaction.showModal(modal);
  }

  /**
   * Handle Market Create Listing
   */
  async handleMarketCreateListing(interaction, player, itemId, price, quantity) {
    const item = player.inventory.find(i => i && i.id === itemId);
    
    if (!item) {
      await interaction.reply({
        content: '‚ùå Item not found in your inventory.',
        ephemeral: true,
      });
      return;
    }

    if (quantity > (item.quantity || 1)) {
      await interaction.reply({
        content: `‚ùå You only have ${item.quantity || 1} of this item.`,
        ephemeral: true,
      });
      return;
    }

    // Remove item from inventory
    if (quantity >= (item.quantity || 1)) {
      // Remove entire stack
      player.inventory = player.inventory.filter(i => i !== item);
    } else {
      // Reduce quantity
      item.quantity -= quantity;
    }

    // Create listing
    const marketData = this.loadMarketData();
    const listingId = `${Date.now()}_${player.userId}_${itemId}`;
    
    const newListing = {
      id: listingId,
      sellerId: player.userId,
      sellerName: player.username,
      itemId: item.id,
      itemName: item.name,
      itemType: item.type,
      quantity: quantity,
      price: price,
      rarity: item.rarity || 'common',
      listedAt: Date.now(),
      active: true,
    };

    marketData.listings.push(newListing);
    this.saveMarketData(marketData);
    this.persistPlayer(player);

    const qtyText = quantity > 1 ? ` x${quantity}` : '';
    await this.updateInteractionWithTracking(interaction, {
      content: `‚úÖ **Listed on Market!**\n\n` +
               `üì¶ Item: **${item.name}${qtyText}**\n` +
               `üí∞ Price: ${price}g\n` +
               `üè™ Your listing is now visible to all players!`,
      embeds: [],
      components: [],
    });

    // Return to market after 2 seconds
    setTimeout(async () => {
      try {
        await this.handleMarket(interaction, player);
      } catch (e) {
        // Ignore if interaction expired
      }
    }, 2000);
  }

  /**
   * Handle Market My Listings
   */
  async handleMarketMyListings(interaction, player) {
    const marketData = this.loadMarketData();
    const myListings = marketData.listings.filter(
      l => l.sellerId === player.userId && l.active !== false
    );

    if (myListings.length === 0) {
      await interaction.reply({
        content: 'üìã You have no active listings.',
        ephemeral: true,
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0xf39c12)
      .setTitle('üìã My Listings')
      .setDescription(
        `You have **${myListings.length}** active listing(s).\n\n` +
        `Select a listing to cancel and reclaim your item:`
      );

    const listingsList = myListings.map(listing => {
      const qtyText = listing.quantity > 1 ? ` x${listing.quantity}` : '';
      const age = Math.floor((Date.now() - listing.listedAt) / 60000); // minutes
      return `‚Ä¢ **${listing.itemName}${qtyText}** - ${listing.price}g (${age}m ago)`;
    }).join('\n');

    embed.addFields({
      name: 'Your Active Listings',
      value: listingsList,
      inline: false,
    });

    // Create select menu
    const selectOptions = myListings.slice(0, 25).map(listing => {
      const qtyText = listing.quantity > 1 ? ` x${listing.quantity}` : '';
      const age = Math.floor((Date.now() - listing.listedAt) / 60000);
      return {
        label: `${listing.itemName}${qtyText} - ${listing.price}g`.substring(0, 100),
        value: listing.id,
        description: `Listed ${age} minutes ago - Click to cancel`.substring(0, 100),
        emoji: this.getItemTypeEmoji(listing.itemType),
      };
    });

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-market-my-listing-select')
      .setPlaceholder('Select a listing to cancel...')
      .addOptions(selectOptions);

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-market')
        .setLabel('‚Üê Back to Market')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  /**
   * Handle Market Cancel Listing
   */
  async handleMarketCancelListing(interaction, player, listingId) {
    const marketData = this.loadMarketData();
    const listing = marketData.listings.find(l => l.id === listingId && l.active !== false);

    if (!listing) {
      await interaction.reply({
        content: '‚ùå Listing not found.',
        ephemeral: true,
      });
      return;
    }

    if (listing.sellerId !== player.userId) {
      await interaction.reply({
        content: '‚ùå You can only cancel your own listings!',
        ephemeral: true,
      });
      return;
    }

    // Return item to inventory
    const returnedItem = {
      id: listing.itemId,
      name: listing.itemName,
      type: listing.itemType,
      quantity: listing.quantity,
      rarity: listing.rarity || 'common',
    };

    const existingItem = player.inventory.find(i => i && i.id === listing.itemId);
    if (existingItem) {
      existingItem.quantity = (existingItem.quantity || 1) + listing.quantity;
    } else {
      player.inventory.push(returnedItem);
    }

    // Mark listing as cancelled
    listing.active = false;
    listing.cancelledAt = Date.now();

    this.saveMarketData(marketData);
    this.persistPlayer(player);

    const qtyText = listing.quantity > 1 ? ` x${listing.quantity}` : '';
    await this.updateInteractionWithTracking(interaction, {
      content: `‚úÖ **Listing Cancelled**\n\n` +
               `üì¶ Returned: **${listing.itemName}${qtyText}**\n` +
               `Item has been returned to your inventory.`,
      embeds: [],
      components: [],
    });

    // Return to my listings or market if no more listings
    setTimeout(async () => {
      try {
        const updatedListings = marketData.listings.filter(
          l => l.sellerId === player.userId && l.active !== false
        );
        if (updatedListings.length > 0) {
          await this.handleMarketMyListings(interaction, player);
        } else {
          await this.handleMarket(interaction, player);
        }
      } catch (e) {
        // Ignore if interaction expired
      }
    }, 2000);
  }

  /**
   * Quick battle mode
   */
  async handleQuickBattle(interaction, player) {
    await this.handleArena(interaction, player);
  }

  /**
   * Party battle mode
   */
  async handlePartyBattle(interaction, player) {
    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
      return;
    }

    const combatState = this.combatSystem.startCombat(
      player,
      'Party Trial',
      Math.max(1, player.level + 2),
      { meta: { type: 'partyBattle' } }
    );

    this.persistPlayer(player);

    const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
    embed.addFields({
      name: 'üë• Party Battle',
      value: 'Switch members to manage damage and momentum.',
      inline: false,
    });

    const buttons = this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  addInventoryItem(player, item) {
    // Ensure item has a name (fallback if missing)
    if (!item.name || typeof item.name !== 'string') {
      item.name = item.id || 'Unknown Item';
    }
    
    // Equipment items (weapons/armor) should NOT stack - each piece is unique
    // Only stack consumables and materials
    if (item.type === 'equipment' || item.slot) {
      // Add as separate item (don't stack equipment)
      player.inventory.push({ ...item, quantity: 1 });
      this.persistPlayer(player);
      return;
    }
    
    // For non-equipment (consumables), allow stacking
    const existing = player.inventory.find(
      (invItem) => invItem && typeof invItem === 'object' && invItem.id === item.id && invItem.type === item.type
    );
    if (existing) {
      existing.quantity = (existing.quantity || 1) + 1;
      this.persistPlayer(player);
      return;
    }
    player.inventory.push({ ...item, quantity: 1 });
    this.persistPlayer(player);
  }

  /**
   * Handle raids
   */
  async handleRaids(interaction, player) {
    if (player.level < 20) {
      await interaction.reply({
        content: 'üîí **Raids Locked**\nReach level 20 to unlock Raids!',
        ephemeral: true,
      });
      return;
    }
    
    this.trackMenuNavigation(player, 'raids');
    const raids = getAvailableRaids(player.level, player.currentWorld);
    const embed = UIBuilder.createRaidsEmbed(player.level, player.currentWorld);

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    if (raids.length === 0) {
      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [backButton],
      });
      return;
    }

    const validRaids = raids.filter(r => r && r.id && r.name);
    
    if (validRaids.length === 0) {
      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [backButton],
      });
      return;
    }

    const options = validRaids.map(r => {
      const floors = r.floors || 1;
      const floorText = floors > 1 ? ` ‚Ä¢ ${floors} Floors` : '';
      const bossCount = r.bosses?.length || 0;
      const label = `${r.name} (Lvl ${r.minLevel}${floorText})`.substring(0, 100);
      return {
        label: label,
        value: r.id.substring(0, 100),
        description: `${bossCount} Bosses${floorText}`.substring(0, 100),
      };
    });

    const selectMenu = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-select-raid')
        .setPlaceholder('Select a raid to challenge')
        .addOptions(options)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectMenu, backButton],
    });
  }

  /**
   * Handle world boss challenge
   */
  async handleWorldBoss(interaction, player) {
    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({
        content: 'You are already in combat!',
        ephemeral: true,
      });
      return;
    }

    // Get the current world from content system, fall back to local world data
    const contentWorld = getWorldFromContent(player.currentWorld);
    const fallbackWorld = getWorld(player.currentWorld);
    const worldId = contentWorld?.id ?? fallbackWorld?.id ?? player.currentWorld;

    // Get the boss details (content system first, then fallback)
    let boss = null;
    if (contentWorld?.worldBoss) {
      const allBosses = getAllBosses();
      boss = allBosses.find(b => b.id === contentWorld.worldBoss) || null;
    }

    if (!boss) {
      const fallbackBoss = getWorldBoss(player.currentWorld);
      if (fallbackBoss) {
        boss = {
          id: `world_boss_${worldId}`,
          name: fallbackBoss.name,
          level: fallbackBoss.level,
          hp: fallbackBoss.hp,
          xpReward: fallbackBoss.xpReward,
          loot: fallbackBoss.loot,
        };
      }
    }

    if (!boss) {
      await interaction.reply({
        content: 'No world boss available in this world!',
        ephemeral: true,
      });
      return;
    }

    // Check if already defeated
    const defeatedWorlds = (player.worldBossesDefeated || []).map(String);
    if (defeatedWorlds.includes(String(worldId))) {
      await interaction.reply({
        content: `You already defeated the world boss for ${contentWorld?.name || fallbackWorld?.name || 'this world'}.`,
        ephemeral: true,
      });
      return;
    }

    const combatState = this.combatSystem.startCombat(
      player,
      boss.name,
      boss.level,
      { meta: { type: 'worldBoss', worldId: worldId } }
    );

    this.persistPlayer(player);

    const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
    const buttons = this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Retroactively unlock worlds based on boss defeats
   * This grants unlocks to players who defeated bosses before the unlock bug was fixed
   */
  retroactivelyUnlockWorlds(player) {
    const allWorlds = getAllWorlds();
    if (!allWorlds || allWorlds.length === 0) return;

    // Ensure arrays exist
    if (!player.worldBossesDefeated) player.worldBossesDefeated = [];
    if (!player.worldsUnlocked) player.worldsUnlocked = [];

    const sortedWorlds = allWorlds.sort((a, b) => (a.tier || 1) - (b.tier || 1));
    let unlocked = false;

    const defeatedWorldIds = player.worldBossesDefeated.map(String);
    const unlockedWorldIds = player.worldsUnlocked.map(String);

    // For each defeated world boss, unlock the next world tier
    for (const defeatedWorldId of defeatedWorldIds) {
      const defeatedWorld = sortedWorlds.find(w => String(w.id) === defeatedWorldId);
      if (defeatedWorld) {
        const currentTier = defeatedWorld.tier || 1;
        const nextWorld = sortedWorlds.find(w => (w.tier || 1) === currentTier + 1);

        // Unlock the next world if it exists and isn't already unlocked
        if (nextWorld && !unlockedWorldIds.includes(String(nextWorld.id))) {
          player.worldsUnlocked.push(nextWorld.id);
          unlockedWorldIds.push(String(nextWorld.id));
          unlocked = true;
        }
      }
    }

    // ADDITIONAL CHECK: If player level suggests they've progressed beyond a world's max level,
    // assume they defeated that world's boss and unlock subsequent worlds
    const playerLevel = player.level || 1;
    for (const world of sortedWorlds) {
      const maxLevel = world.maxLevel || 999;
      const worldTier = world.tier || 1;
      
      // If player is significantly beyond this world's max level, they likely defeated its boss
      if (playerLevel > maxLevel) {
        // Mark as defeated if not already
        if (!defeatedWorldIds.includes(String(world.id))) {
          player.worldBossesDefeated.push(world.id);
          defeatedWorldIds.push(String(world.id));
          unlocked = true;
        }
        
        // Unlock next tier world
        const nextWorld = sortedWorlds.find(w => (w.tier || 1) === worldTier + 1);
        if (nextWorld && !unlockedWorldIds.includes(String(nextWorld.id))) {
          player.worldsUnlocked.push(nextWorld.id);
          unlockedWorldIds.push(String(nextWorld.id));
          unlocked = true;
        }
      }
    }

    // Also ensure first world is unlocked
    if (sortedWorlds.length > 0 && !unlockedWorldIds.includes(String(sortedWorlds[0].id))) {
      player.worldsUnlocked.push(sortedWorlds[0].id);
      unlocked = true;
    }

    if (unlocked) {
      this.persistPlayer(player);
    }
  }

  /**
   * Handle world travel selection
   */
  async handleWorldTravel(interaction, player) {
    // Retroactively unlock worlds for players who defeated bosses before the bug was fixed
    this.retroactivelyUnlockWorlds(player);

    const allWorlds = getAllWorlds();
    
    if (!allWorlds || allWorlds.length === 0) {
      await interaction.reply({
        content: 'No worlds available yet!',
        ephemeral: true,
      });
      return;
    }

    // Sort worlds by tier
    const sortedWorlds = allWorlds.sort((a, b) => (a.tier || 1) - (b.tier || 1));
    
    const unlockedWorldIds = (player.worldsUnlocked || []).map(String);
    const defeatedWorldIds = (player.worldBossesDefeated || []).map(String);
    const currentWorldId = String(player.currentWorld);

    const embed = new EmbedBuilder()
      .setColor(0x5865F2)
      .setTitle('üåç World Travel')
      .setDescription('Select a world to travel to. Defeat the world boss to unlock the next world!');

    sortedWorlds.forEach((world, index) => {
      const worldKey = String(world.id);
      const isUnlocked = unlockedWorldIds.includes(worldKey);
      const isDefeated = defeatedWorldIds.includes(worldKey);
      const isCurrent = currentWorldId === worldKey;

      const minLevel = world.minLevel || 1;
      const maxLevel = world.maxLevel || '‚àû';
      const levelRange = `Levels ${minLevel} - ${maxLevel}`;
      
      let status = '';
      if (isCurrent) {
        status = 'üìç Current Location';
      } else if (isDefeated) {
        status = '‚úÖ Boss Defeated';
      } else if (isUnlocked) {
        status = 'üîì Unlocked';
      } else {
        // Show the previous world's boss that needs to be defeated
        const prevWorld = index > 0 ? sortedWorlds[index - 1] : null;
        if (prevWorld) {
          // Get boss name from content system
          const allBosses = getAllBosses();
          const prevWorldData = getWorldFromContent(prevWorld.id);
          const bossName = prevWorldData?.worldBoss 
            ? allBosses.find(b => b.id === prevWorldData.worldBoss)?.name || 'World Boss'
            : 'World Boss';
          status = `üîí Defeat ${bossName} in ${prevWorld.name} to unlock`;
        } else {
          status = 'üîí Locked';
        }
      }

      embed.addFields({
        name: `${world.name || `World ${index + 1}`}${isCurrent ? ' ‚¨ÖÔ∏è' : ''}`,
        value: `Tier ${world.tier || 1} ‚Ä¢ ${levelRange}\n${status}`,
        inline: false,
      });
    });

    // Create buttons for unlocked worlds
    const buttons = [];
    const unlockedWorlds = sortedWorlds.filter(w => unlockedWorldIds.includes(String(w.id)));
    
    for (let i = 0; i < Math.min(unlockedWorlds.length, 25); i += 5) {
      const row = new ActionRowBuilder();
      const slice = unlockedWorlds.slice(i, i + 5);
      
      slice.forEach(world => {
        const isCurrent = currentWorldId === String(world.id);
        row.addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-travel-${world.id}`)
            .setLabel(world.name || 'World')
            .setStyle(isCurrent ? ButtonStyle.Success : ButtonStyle.Primary)
            .setDisabled(isCurrent)
        );
      });
      
      buttons.push(row);
    }

    // Add back button
    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('üè† Back to Hub')
        .setStyle(ButtonStyle.Secondary)
    );
    buttons.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Handle traveling to a specific world
   */
  async handleTravelToWorld(interaction, player, worldId) {
    const normalizedWorldId = String(worldId);
    const unlockedWorldIds = (player.worldsUnlocked || []).map(String);

    // Check if world is unlocked
    if (!unlockedWorldIds.includes(normalizedWorldId)) {
      await interaction.reply({
        content: 'This world is not unlocked yet! Defeat the previous world boss first.',
        ephemeral: true,
      });
      return;
    }

    // Update player's current world
    player.currentWorld = normalizedWorldId;
    this.persistPlayer(player);

    const world = getWorldFromContent(normalizedWorldId);
    const worldName = world?.name || 'Unknown World';

    await interaction.reply({
      content: `‚úàÔ∏è You have traveled to **${worldName}**!`,
      ephemeral: true,
    });

    // Show the main menu
    await this.handleCommand(interaction);
  }

  /**
   * Handle Adventurers Guild menu
   */
  async handleGuild(interaction, player) {
    this.trackMenuNavigation(player, 'guild');

    // Check if player is in a guild
    const playerGuild = this.guildManager.getPlayerGuild(player.userId);

    if (!playerGuild) {
      // Player not in guild - show guild browser/creation
      await this.handleGuildBrowser(interaction, player);
      return;
    }

    // Player in guild - show guild dashboard
    await this.handleGuildDashboard(interaction, player, playerGuild);
  }

  /**
   * Guild browser - for players not in a guild
   */
  async handleGuildBrowser(interaction, player) {
    const topGuilds = this.guildManager.getTopGuilds(5);
    const publicGuilds = this.guildManager.getPublicGuilds().slice(0, 10);
    
    let guildList = '**Top Guilds:**\n';
    if (topGuilds.length === 0) {
      guildList += '_No guilds yet. Be the first to create one!_\n\n';
    } else {
      guildList += topGuilds.map((g, i) => {
        const levelInfo = getGuildLevel(g.xp);
        return `${i + 1}. **[${g.tag}] ${g.name}** - Level ${levelInfo.level} (${Object.keys(g.members).length} members)`;
      }).join('\n') + '\n\n';
    }

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle('üè∞ Guild Hall')
      .setDescription(
        '**Welcome to the Guild System!**\n\n' +
        'Guilds are player-run organizations that work together to tackle challenging content, earn rewards, and progress together.\n\n' +
        guildList +
        '**Guild Benefits:**\n' +
        '‚Ä¢ Shared XP and Gold pools\n' +
        '‚Ä¢ Guild Buffs (XP, Gold, Shop discounts)\n' +
        '‚Ä¢ Exclusive Guild Bosses and Raids\n' +
        '‚Ä¢ Guild Vault for shared storage\n' +
        '‚Ä¢ Weekly rewards based on activity'
      );

    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-create')
        .setLabel('üè∞ Create Guild (10,000g)')
        .setStyle(ButtonStyle.Success)
        .setDisabled((player.gold || 0) < 10000),
      new ButtonBuilder()
        .setCustomId('rpg-guild-search')
        .setLabel('üîç Browse Guilds')
        .setStyle(ButtonStyle.Primary)
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-quests')
        .setLabel('üìú Solo Guild Quests')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-guild-bounties')
        .setLabel('üìú Bounty Board')
        .setStyle(ButtonStyle.Secondary)
    );

    const row3 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2, row3],
    });
  }

  /**
   * Guild dashboard - for players in a guild
   */
  async handleGuildDashboard(interaction, player, guild) {
    const guildInfo = this.guildManager.getGuildInfo(guild.id);
    const member = guild.members[player.userId];
    const isLeader = member.role === 'leader';
    const isOfficer = member.role === 'officer' || isLeader;

    const levelInfo = getGuildLevel(guild.xp);
    const buffs = getGuildBuffs(levelInfo.level, guild.buffs);

    // Check for unclaimed achievements
    const unclaimedAchievements = getUnclaimedGuildAchievements(guild);
    const achievementAlert = unclaimedAchievements.length > 0 ? `\nüèÖ **${unclaimedAchievements.length} New Achievement${unclaimedAchievements.length > 1 ? 's' : ''}!**` : '';

    const embed = new EmbedBuilder()
      .setColor(0xffd700)
      .setTitle(`üè∞ [${guild.tag}] ${guild.name}`)
      .setDescription((guild.description || 'No description set') + achievementAlert)
      .addFields(
        { name: 'üìä Level', value: `${levelInfo.level} / 50`, inline: true },
        { name: '‚≠ê XP', value: `${guild.xp} (${guildInfo.xpToNext} to next)`, inline: true },
        { name: 'üë• Members', value: `${guildInfo.memberCount} / ${guildInfo.memberLimit}`, inline: true },
        { name: 'üí∞ Treasury', value: `${guild.gold.toLocaleString()} gold`, inline: true },
        { name: 'üéØ Your Role', value: member.role.charAt(0).toUpperCase() + member.role.slice(1), inline: true },
        { name: 'üèÖ Your Points', value: `${member.contributionPoints || 0} points`, inline: true },
        { 
          name: '‚ú® Active Buffs', 
          value: `+${buffs.xpBonus}% XP | +${buffs.goldBonus}% Gold\n-${buffs.shopDiscount}% Shop | +${buffs.gatheringSpeed}% Gathering`, 
          inline: false 
        }
      )
      .setTimestamp();

    // Row 1: Core features
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-manage')
        .setLabel('üìã Manage')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-guild-achievements')
        .setLabel(unclaimedAchievements.length > 0 ? `üèÖ Achievements (${unclaimedAchievements.length})` : 'üèÖ Achievements')
        .setStyle(unclaimedAchievements.length > 0 ? ButtonStyle.Success : ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-guild-bosses')
        .setLabel('üêâ Bosses')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-guild-rankings')
        .setLabel('üìä Rankings')
        .setStyle(ButtonStyle.Secondary)
    );

    // Row 2: Activities
    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-quests')
        .setLabel('üìú Quests')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-guild-buffs')
        .setLabel('‚ú® Buffs')
        .setStyle(ButtonStyle.Success)
        .setDisabled(!isOfficer),
      new ButtonBuilder()
        .setCustomId('rpg-guild-leave')
        .setLabel(isLeader ? '‚ö†Ô∏è Disband' : 'üö™ Leave')
        .setStyle(ButtonStyle.Danger)
    );

    // Row 3: Back button
    const row3 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2, row3],
    });
  }

  /**
   * Browse public guilds
   */
  async handleGuildSearch(interaction, player) {
    const publicGuilds = this.guildManager.getPublicGuilds();
    
    if (publicGuilds.length === 0) {
      await interaction.reply({
        content: '‚ùå No public guilds available. Create one!',
        ephemeral: true,
      });
      return;
    }

    const listedGuilds = publicGuilds.slice(0, 15);
    let guildList = listedGuilds.map((g, i) => {
      const levelInfo = getGuildLevel(g.xp);
      const memberCount = Object.keys(g.members).length;
      return `${i + 1}. **[${g.tag}] ${g.name}**\n‚îî Level ${levelInfo.level} | ${memberCount}/${levelInfo.info.memberLimit} members`;
    }).join('\n\n');

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle('üîç Public Guilds')
      .setDescription(guildList + '\n\n**Use the buttons below to join a guild.**')
      .setFooter({ text: 'Only public guilds can be joined directly' });

    const rows = [];
    const joinButtons = listedGuilds.slice(0, 6).map(g => (
      new ButtonBuilder()
        .setCustomId(`rpg-guild-join-${g.id}`)
        .setLabel(`Join [${g.tag}]`)
        .setStyle(ButtonStyle.Success)
    ));

    for (let i = 0; i < joinButtons.length; i += 2) {
      rows.push(new ActionRowBuilder().addComponents(...joinButtons.slice(i, i + 2)));
    }

    rows.push(
      new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-guild')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      )
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  /**
   * Guild members list
   */
  async handleGuildMembers(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({
        content: '‚ùå You are not in a guild!',
        ephemeral: true,
      });
      return;
    }

    const member = guild.members[player.userId];
    const isLeader = member.role === 'leader';
    const isOfficer = member.role === 'officer' || isLeader;

    const membersList = Object.values(guild.members)
      .sort((a, b) => {
        const roleOrder = { leader: 0, officer: 1, member: 2 };
        return roleOrder[a.role] - roleOrder[b.role];
      })
      .map(m => {
        const roleIcon = m.role === 'leader' ? 'üëë' : m.role === 'officer' ? '‚≠ê' : 'üë§';
        return `${roleIcon} ${m.userId === player.userId ? '**You**' : `<@${m.userId}>`} - ${m.role}\n‚îî Contributed: ${m.contributedXP} XP | ${m.contributedGold}g`;
      })
      .join('\n\n');

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle(`üë• [${guild.tag}] Members`)
      .setDescription(membersList || 'No members');

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back to Guild')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Guild boss selection
   */
  async handleGuildBosses(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({
        content: '‚ùå You are not in a guild!',
        ephemeral: true,
      });
      return;
    }

    // If there's an active boss, show the boss fight UI instead
    if (guild.activeBoss) {
      return this.handleActiveBossFight(interaction, player, guild);
    }

    const member = guild.members[player.userId];
    const canStart = member.role === 'leader' || member.role === 'officer';

    const levelInfo = getGuildLevel(guild.xp);
    const availableBosses = getAvailableGuildBosses(levelInfo.level);
    const availableWorldBosses = getAvailableWorldBosses(levelInfo.level);

    if (availableBosses.length === 0 && availableWorldBosses.length === 0) {
      await interaction.reply({
        content: '‚ùå No bosses available for your guild level yet! Reach level 5.',
        ephemeral: true,
      });
      return;
    }

    // Determine which bosses can be fought (highest tier and one below)
    const fightableBossIds = new Set();
    if (availableBosses.length > 0) {
      fightableBossIds.add(availableBosses[availableBosses.length - 1].id); // Highest tier
      if (availableBosses.length > 1) {
        fightableBossIds.add(availableBosses[availableBosses.length - 2].id); // One below highest
      }
    }

    let bossList = '**Weekly Guild Bosses:**\n';
    bossList += availableBosses.map((boss, idx) => {
      const canFight = fightableBossIds.has(boss.id);
      const essenceReward = Math.max(1, Math.floor(idx * 1.5)); // Approximate tier-based reward
      const tierLabel = canFight ? '‚úÖ Fightable' : 'üîí Locked';
      return `${boss.icon} **${boss.name}** (Level ${boss.minGuildLevel}+) ${tierLabel}\n‚îî ${boss.maxHP.toLocaleString()} HP | ${boss.rewards.guildXP} Guild XP & ${boss.rewards.guildGold}g\n‚îî Per Player: ${boss.rewards.perPlayer.gold}g & ${boss.rewards.perPlayer.xp} XP | üîÆ Boss Essence (defeat)`;
    }).join('\n\n');

    if (availableWorldBosses.length > 0) {
      bossList += '\n\n**World Bosses (48h events):**\n';
      bossList += availableWorldBosses.map(boss =>
        `${boss.icon} **${boss.name}** (Level ${boss.minGuildLevel}+)\n‚îî ${(boss.maxHP / 1000000).toFixed(1)}M HP | Massive Rewards`
      ).join('\n\n');
    }

    // Add boss essence tooltip
    const essenceTooltip = '\n\n**How to Get Boss Essence:**\nüîÆ Earn from Guild Boss victory (based on tier)\nüîÆ Complete Guild Quests (3-10 per quest)\nüîÆ Use Boss Essence to upgrade Stats, Skills, Talents, and Enchants\n\n**Reward Scaling:**\nüí´ Per-player Gold and XP scale with your level (+1% per level, max +50%)\nüèõÔ∏è You also earn Guild XP from guild boss rewards';

    const embed = new EmbedBuilder()
      .setColor(0xe74c3c)
      .setTitle('üêâ Guild Bosses')
      .setDescription(
        bossList + 
        `\n\n${canStart ? '**You can fight the highest tier boss or one tier below it!**' : '*Only officers and leaders can start boss fights*'}` +
        essenceTooltip
      );

    // Create buttons for each boss
    const rows = [];
    const bossButtons = [];

    availableBosses.forEach((boss, idx) => {
      const canFight = fightableBossIds.has(boss.id);
      bossButtons.push(
        new ButtonBuilder()
          .setCustomId(`rpg-guild-start-boss-${boss.id}`)
          .setLabel(`${boss.icon} ${boss.name}`)
          .setStyle(canFight ? ButtonStyle.Danger : ButtonStyle.Secondary)
          .setDisabled(!canStart || !canFight)
      );
    });

    // Add buttons in rows of 2
    for (let i = 0; i < bossButtons.length; i += 2) {
      const row = new ActionRowBuilder().addComponents(
        ...bossButtons.slice(i, i + 2)
      );
      rows.push(row);
    }

    // Boss upgrade shops
    const upgradeRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-boss-stats-shop')
        .setLabel('üí∞ Stats')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-guild-boss-skills-shop')
        .setLabel('‚öîÔ∏è Skills')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-guild-boss-talents-shop')
        .setLabel('üåü Talents')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-guild-boss-enchants-shop')
        .setLabel('‚ú® Enchants')
        .setStyle(ButtonStyle.Primary)
    );
    rows.push(upgradeRow);

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back to Guild')
        .setStyle(ButtonStyle.Secondary)
    );
    rows.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  /**
   * Show active boss fight UI
   */
  async handleActiveBossFight(interaction, player, guild, statusMessage = null) {
    const boss = guild.activeBoss;
    const now = Date.now();

    if (boss.expiresAt && now >= boss.expiresAt) {
      const finalResult = this.finalizeGuildBossFight(guild, { reason: 'expired' });
      const summary = finalResult?.summary || '‚è∞ The guild boss has expired and rewards have been distributed.';
      const expiredEmbed = new EmbedBuilder()
        .setColor(0xe67e22)
        .setTitle('‚è∞ Boss Expired')
        .setDescription(summary);
      const backRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-guild-bosses')
          .setLabel('üîÑ Back to Bosses')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-guild')
          .setLabel('‚Üê Back to Guild')
          .setStyle(ButtonStyle.Secondary)
      );
      await this.updateInteractionWithTracking(interaction, {
        embeds: [expiredEmbed],
        components: [backRow],
      });
      return;
    }
    
    // Safety checks
    const currentHP = Math.max(0, boss.currentHP || 0);
    const maxHP = Math.max(1, boss.maxHP || 1);
    const hpPercent = ((currentHP / maxHP) * 100).toFixed(1);
    const hpBar = this.buildProgressBar(currentHP, maxHP, 20);

    // Calculate player's damage contribution
    const playerDamage = boss.participants[player.userId] || 0;
    const totalDamage = Object.values(boss.participants).reduce((sum, dmg) => sum + dmg, 0);
    const playerPercent = totalDamage > 0 ? ((playerDamage / totalDamage) * 100).toFixed(1) : 0;

    // Check registration status
    const canParticipate = this.guildManager.canParticipateInBoss(guild.id, player.userId, now);
    const remainingAttempts = this.guildManager.getRemainingBossAttempts(guild.id, player.userId, 3);
    const registrationWindowClosesIn = this.formatTimeUntil(boss.registrationDeadline, now);
    const registrationStatus = now < boss.registrationDeadline 
      ? `üìù **Registration Open** - closes in ${registrationWindowClosesIn}` 
      : `‚úÖ **Registration Closed** - fighting available only for registered participants`;

    // Top 3 contributors
    const topContributors = Object.entries(boss.participants)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 3)
      .map(([userId, damage], idx) => {
        const percent = ((damage / totalDamage) * 100).toFixed(1);
        const medal = ['ü•á', 'ü•à', 'ü•â'][idx];
        return `${medal} <@${userId}>: ${damage.toLocaleString()} (${percent}%)`;
      })
      .join('\n');

    const duration = Math.floor((Date.now() - boss.startedAt) / 1000 / 60);
    const triesLeft = this.getGuildBossAttemptsLeft(player, now);
    const triesResetIn = this.formatTimeUntil(player.guildBossAttemptResetAt, now);
    const bossResetIn = boss.expiresAt ? this.formatTimeUntil(boss.expiresAt, now) : 'Unknown';

    const statusLine = statusMessage ? `${statusMessage}\n\n` : '';

    const embed = new EmbedBuilder()
      .setColor(statusMessage ? 0xe67e22 : 0xe74c3c)
      .setTitle(`${boss.icon} ${boss.name}`)
      .setDescription(
        `${statusLine}` +
        `**HP:** ${boss.currentHP.toLocaleString()} / ${boss.maxHP.toLocaleString()}\n${hpBar}\n\n` +
        `**Defense:** ${boss.defense} | **Attack:** ${boss.attack}\n` +
        `**Duration:** ${duration} minutes\n` +
        `**Boss Reset:** ${bossResetIn}\n` +
        `**Boss Attempts Left:** ${remainingAttempts}/3${remainingAttempts > 0 ? '' : ' ‚ö†Ô∏è NO ATTEMPTS LEFT'}\n` +
        `**Total Participants:** ${Object.keys(boss.participants).length}\n\n` +
        `${registrationStatus}\n\n` +
        `**Your Damage:** ${playerDamage.toLocaleString()} (${playerPercent}%)\n\n` +
        `**Top Contributors:**\n${topContributors || 'No damage dealt yet'}\n\n` +
        `_Attack the boss with your guild members!_`
      );

    const attackButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-boss-attack')
        .setLabel('‚öîÔ∏è Attack!')
        .setStyle(ButtonStyle.Danger)
        .setDisabled(remainingAttempts <= 0),
      new ButtonBuilder()
        .setCustomId('rpg-guild-bosses')
        .setLabel('üîÑ Refresh')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back to Guild')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [attackButton],
    });
  }

  async startGuildBossCombat(interaction, player, guild) {
    const boss = guild.activeBoss;
    if (!boss) {
      await interaction.reply({ content: '‚ùå No active boss fight!', ephemeral: true });
      return;
    }

    const now = Date.now();
    
    // Check if player can participate (registration window or already registered)
    const canParticipate = this.guildManager.canParticipateInBoss(guild.id, player.userId, now);
    if (!canParticipate.canFight) {
      await interaction.reply({
        content: `‚ùå ${canParticipate.reason}!\n\nRegistration window closed <t:${Math.floor(boss.registrationDeadline / 1000)}:R>`,
        ephemeral: true,
      });
      return;
    }

    // Auto-register player if registration window is still open
    if (canParticipate.isRegistrationOpen) {
      this.guildManager.registerForBoss(guild.id, player.userId);
    }

    // Check remaining attempts
    const remainingAttempts = this.guildManager.getRemainingBossAttempts(guild.id, player.userId, 3);
    if (remainingAttempts <= 0) {
      await interaction.reply({
        content: `‚ùå You have used all 3 attempts for this boss cycle! Come back next cycle.`,
        ephemeral: true,
      });
      return;
    }

    const bossLevel = boss.level || boss.minGuildLevel || 1;
    const bossPlayerStats = this.getBossCombatStats(player);
    this.applyBossBattleSnapshot(player, bossPlayerStats);
    const bossStats = {
      strength: Math.max(1, boss.attack || 1),
      defense: Math.max(1, boss.defense || 1),
      intelligence: Math.max(1, Math.floor((boss.attack || 1) * 0.6)),
      agility: Math.max(1, Math.floor((boss.attack || 1) * 0.4)),
    };

    const combatState = this.combatSystem.startCombatWithCustomEnemy(
      player,
      boss.name,
      bossLevel,
      Math.max(1, boss.currentHP || boss.maxHP || 1),
      bossStats,
      boss.skills || [],
      { type: 'guild_boss', guildId: guild.id, bossId: boss.bossId }
    );

    const bossSkills = this.getBossCombatSkills(player);
    combatState.playerStats = bossPlayerStats;
    combatState.playerSkills = bossSkills.length > 0 ? bossSkills : ['slash'];
    combatState.playerSkillLevels = { ...(player.bossSkillLevels || {}) };

    combatState.enemy.maxHp = Math.max(1, boss.maxHP || combatState.enemy.maxHp || 1);
    combatState.enemy.hp = Math.max(1, Math.min(boss.currentHP || combatState.enemy.hp, combatState.enemy.maxHp));

    this.persistPlayer(player);

    const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
    const buttons = this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  getBossCombatStats(player) {
    const defaultStats = {
      strength: 5,
      defense: 5,
      agility: 5,
      intelligence: 5,
      vitality: 5,
      wisdom: 5,
      maxHp: 100,
      maxMana: 50,
    };
    
    // Fix corrupted or old bossStats structure
    let base = { ...defaultStats };
    if (player.bossStats && typeof player.bossStats === 'object' && !player.bossStats.encounters) {
      // Valid structure - merge with defaults
      for (const [key, value] of Object.entries(player.bossStats)) {
        if (typeof value === 'number' && key in defaultStats) {
          base[key] = value;
        }
      }
    }

    const stats = {
      strength: Math.max(1, base.strength || 5),
      defense: Math.max(1, base.defense || 5),
      agility: Math.max(1, base.agility || 5),
      intelligence: Math.max(1, base.intelligence || 5),
      vitality: Math.max(1, base.vitality || 5),
      wisdom: Math.max(1, base.wisdom || 5),
      hp: Math.max(1, base.maxHp || 100),
      mana: Math.max(1, base.maxMana || 50),
    };

    const talentBonuses = {
      boss_power: { strength: 2 },
      boss_guard: { defense: 2 },
      boss_endurance: { hp: 20 },
      boss_focus: { intelligence: 2, wisdom: 1 },
    };

    const bossTalents = player.bossTalents || {};
    for (const [talentId, rank] of Object.entries(bossTalents)) {
      const bonuses = talentBonuses[talentId];
      if (!bonuses || !rank) continue;
      for (const [stat, value] of Object.entries(bonuses)) {
        stats[stat] = (stats[stat] || 0) + (value * rank);
      }
    }

    return stats;
  }

  getBossCombatSkills(player) {
    return Array.isArray(player.bossSkills) ? player.bossSkills : [];
  }

  applyBossBattleSnapshot(player, bossStats) {
    if (!player._bossSnapshot) {
      player._bossSnapshot = {
        maxHp: player.maxHp,
        hp: player.hp,
        maxMana: player.maxMana,
        mana: player.mana,
      };
    }

    player.maxHp = Math.max(1, bossStats.hp || 1);
    player.hp = player.maxHp;
    player.maxMana = Math.max(0, bossStats.mana || 0);
    player.mana = player.maxMana;
    player.clearStatsCache();
  }

  restoreBossBattleSnapshot(player) {
    if (!player._bossSnapshot) return;
    player.maxHp = player._bossSnapshot.maxHp;
    player.hp = Math.min(player._bossSnapshot.hp, player.maxHp);
    player.maxMana = player._bossSnapshot.maxMana;
    player.mana = Math.min(player._bossSnapshot.mana, player.maxMana);
    player._bossSnapshot = null;
    player.clearStatsCache();
  }

  getMaterialCount(player, materialId) {
    const entry = (player.inventory || []).find(
      (item) => item && typeof item === 'object' && item.id === materialId && item.type === 'material'
    );
    return Number(entry?.quantity || 0);
  }

  removeMaterialFromInventory(player, materialId, quantity) {
    if (!quantity || quantity <= 0) return false;
    const entryIndex = (player.inventory || []).findIndex(
      (item) => item && typeof item === 'object' && item.id === materialId && item.type === 'material'
    );
    if (entryIndex === -1) return false;
    const entry = player.inventory[entryIndex];
    if ((entry.quantity || 0) < quantity) return false;
    entry.quantity -= quantity;
    if (entry.quantity <= 0) {
      player.inventory.splice(entryIndex, 1);
    }
    return true;
  }

  /**
   * Calculate overall ranking score (level + xp contribution)
   */
  calculateOverallScore(player) {
    const levelScore = (player.level || 1) * 10000;
    const xpScore = (player.totalXP || 0) / 100;
    return levelScore + xpScore;
  }

  /**
   * Get player's rank and position in overall leaderboard
   */
  async getPlayerOverallRank(player) {
    const players = await this.playerManager.getAllPlayers();
    if (!players || players.length === 0) return null;

    const rankings = players
      .filter(p => p.characterCreated)
      .map(p => ({
        player: p,
        score: this.calculateOverallScore(p)
      }))
      .sort((a, b) => b.score - a.score);

    const rank = rankings.findIndex(r => r.player.userId === player.userId);
    if (rank === -1) return null;

    return {
      rank: rank + 1,
      totalPlayers: rankings.length,
      inTopTen: rank < 10,
      score: rankings[rank].score
    };
  }

  /**
   * Handle guild boss stats shop
   */
  async handleGuildBossStatsShop(interaction, player) {
    const bossEssenceId = 'boss_essence';
    const statsShop = [
      { stat: 'strength', icon: 'üî•', costGold: 500, costEssence: 1, emoji: 'strength', description: 'Increases physical attack power' },
      { stat: 'defense', icon: 'üõ°Ô∏è', costGold: 500, costEssence: 1, emoji: 'defense', description: 'Reduces incoming damage' },
      { stat: 'agility', icon: '‚ö°', costGold: 500, costEssence: 1, emoji: 'agility', description: 'Increases attack speed and dodge chance' },
      { stat: 'intelligence', icon: 'üß†', costGold: 500, costEssence: 1, emoji: 'intelligence', description: 'Boosts magical damage' },
      { stat: 'vitality', icon: '‚ù§Ô∏è', costGold: 500, costEssence: 1, emoji: 'vitality', description: 'Enhances health regeneration' },
      { stat: 'wisdom', icon: '‚ú®', costGold: 500, costEssence: 1, emoji: 'wisdom', description: 'Improves mana pool and recovery' },
      { stat: 'maxHp', icon: 'üíö', costGold: 1000, costEssence: 2, emoji: 'maxHp', display: 'Max HP', description: 'Increases total health by +50 HP per purchase' },
      { stat: 'maxMana', icon: 'üíô', costGold: 1000, costEssence: 2, emoji: 'maxMana', display: 'Max Mana', description: 'Increases total mana by +25 Mana per purchase' },
    ];

    // Ensure all boss stats have default values
    const bossStats = Object.assign({
      strength: 5,
      defense: 5,
      agility: 5,
      intelligence: 5,
      vitality: 5,
      wisdom: 5,
      maxHp: 100,
      maxMana: 50,
    }, player.bossStats || {});

    const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
    const selectOptions = statsShop.map(item => ({
      label: `${item.display || item.stat.charAt(0).toUpperCase() + item.stat.slice(1)} (${item.icon})`,
      value: item.emoji,
      description: `Cost: ${item.costGold}g + ${item.costEssence} Essence | Current: ${bossStats[item.stat] ?? 0}`,
    }));

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-guild-boss-stats-select')
      .setPlaceholder('Select a stat to upgrade')
      .addOptions(selectOptions);

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    const essenceInfo = '**How to Get Boss Essence:**\nüîÆ Win Guild Boss fights (1-3+ per victory depending on tier)\nüîÆ Complete Guild Quests (3-10 per quest)\nüîÆ Higher tier bosses = more essence on victory';

    const embed = new EmbedBuilder()
      .setColor(0xf1c40f)
      .setTitle('üí∞ Guild Boss Stats Shop')
      .setDescription(
        `Purchase base stats to increase your power for boss fights!\n\n` +
        `**Your Gold:** ${player.gold.toLocaleString()}g\n` +
        `**Boss Essence:** ${bossEssenceCount}\n\n` +
        `_Select a stat below to view details and purchase_\n\n` +
        essenceInfo
      );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-bosses')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  async handleGuildBossStatDetail(interaction, player, statEmoji) {
    const bossEssenceId = 'boss_essence';
    const statsShop = [
      { stat: 'strength', icon: 'üî•', costGold: 500, costEssence: 1, emoji: 'strength', description: 'Increases physical attack power' },
      { stat: 'defense', icon: 'üõ°Ô∏è', costGold: 500, costEssence: 1, emoji: 'defense', description: 'Reduces incoming damage' },
      { stat: 'agility', icon: '‚ö°', costGold: 500, costEssence: 1, emoji: 'agility', description: 'Increases attack speed and dodge chance' },
      { stat: 'intelligence', icon: 'üß†', costGold: 500, costEssence: 1, emoji: 'intelligence', description: 'Boosts magical damage' },
      { stat: 'vitality', icon: '‚ù§Ô∏è', costGold: 500, costEssence: 1, emoji: 'vitality', description: 'Enhances health regeneration' },
      { stat: 'wisdom', icon: '‚ú®', costGold: 500, costEssence: 1, emoji: 'wisdom', description: 'Improves mana pool and recovery' },
      { stat: 'maxHp', icon: 'üíö', costGold: 1000, costEssence: 2, emoji: 'maxHp', display: 'Max HP', description: 'Increases total health by +50 HP per purchase' },
      { stat: 'maxMana', icon: 'üíô', costGold: 1000, costEssence: 2, emoji: 'maxMana', display: 'Max Mana', description: 'Increases total mana by +25 Mana per purchase' },
    ];

    const item = statsShop.find(s => s.emoji === statEmoji);
    if (!item) {
      await interaction.reply({ content: '‚ùå Invalid stat!', ephemeral: true });
      return;
    }

    // Ensure all boss stats have default values
    const bossStats = Object.assign({
      strength: 5,
      defense: 5,
      agility: 5,
      intelligence: 5,
      vitality: 5,
      wisdom: 5,
      maxHp: 100,
      maxMana: 50,
    }, player.bossStats || {});

    const currentValue = bossStats[item.stat] ?? 0;
    const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
    const canAfford = player.gold >= item.costGold && bossEssenceCount >= item.costEssence;

    const embed = new EmbedBuilder()
      .setColor(0xf1c40f)
      .setTitle(`${item.icon} Upgrade: ${item.display || item.stat.charAt(0).toUpperCase() + item.stat.slice(1)}`)
      .setDescription(
        `**Description:** ${item.description}\n\n` +
        `**Current Level:** ${currentValue}\n` +
        `**Cost:** ${item.costGold}g + ${item.costEssence} Boss Essence\n\n` +
        `**Your Resources:**\n` +
        `üí∞ Gold: ${player.gold.toLocaleString()}g ${player.gold >= item.costGold ? '‚úÖ' : '‚ùå'}\n` +
        `üîÆ Boss Essence: ${bossEssenceCount} ${bossEssenceCount >= item.costEssence ? '‚úÖ' : '‚ùå'}`
      );

    const buyButton = new ButtonBuilder()
      .setCustomId(`rpg-guild-boss-buy-stat-${item.emoji}`)
      .setLabel(`Purchase +1 ${item.icon}`)
      .setStyle(canAfford ? ButtonStyle.Success : ButtonStyle.Secondary)
      .setDisabled(!canAfford);

    const backButton = new ButtonBuilder()
      .setCustomId('rpg-guild-boss-stats-shop')
      .setLabel('‚Üê Back to Stats')
      .setStyle(ButtonStyle.Secondary);

    const buttonRow = new ActionRowBuilder().addComponents(buyButton, backButton);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttonRow],
    });
  }

  getBossSkillShopItems() {
    return [
      { id: 'slash', name: 'Slash', costGold: 1500, costEssence: 1 },
      { id: 'fireball', name: 'Fireball', costGold: 2000, costEssence: 2 },
      { id: 'whirlwind', name: 'Whirlwind', costGold: 3500, costEssence: 3 },
      { id: 'meteor', name: 'Meteor', costGold: 5000, costEssence: 4 },
    ];
  }

  getBossTalentShopItems() {
    return [
      { id: 'boss_power', name: 'Boss Power', description: '+2 Strength per rank', costGold: 2500, costEssence: 2 },
      { id: 'boss_guard', name: 'Boss Guard', description: '+2 Defense per rank', costGold: 2500, costEssence: 2 },
      { id: 'boss_endurance', name: 'Boss Endurance', description: '+20 HP per rank', costGold: 3000, costEssence: 3 },
      { id: 'boss_focus', name: 'Boss Focus', description: '+2 Int / +1 Wis per rank', costGold: 2500, costEssence: 2 },
    ];
  }

  getBossEnchantShopItems() {
    return [
      { id: 'boss_damage_enchant_t4', name: 'Epic Boss Damage Enchant Recipe', costGold: 8000, costEssence: 5 },
      { id: 'boss_damage_enchant_t5', name: 'Legendary Boss Damage Enchant Recipe', costGold: 15000, costEssence: 8 },
    ];
  }

  async handleGuildBossSkillsShop(interaction, player) {
    const bossEssenceId = 'boss_essence';
    const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
    const items = this.getBossSkillShopItems();
    const owned = new Set(player.bossSkills || []);

    const selectOptions = items.map(item => ({
      label: `${item.name} ${owned.has(item.id) ? '(Owned)' : ''}`,
      value: item.id,
      description: `Cost: ${item.costGold}g + ${item.costEssence} Essence`,
    }));

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-guild-boss-skills-select')
      .setPlaceholder('Select a skill to view')
      .addOptions(selectOptions);

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    const essenceInfo = '**How to Get Boss Essence:**\nüîÆ Win Guild Boss fights (1-3+ per victory depending on tier)\nüîÆ Complete Guild Quests (3-10 per quest)\nüîÆ Higher tier bosses = more essence on victory';

    const embed = new EmbedBuilder()
      .setColor(0xf39c12)
      .setTitle('‚öîÔ∏è Boss Skills Shop')
      .setDescription(
        `Unlock boss-only skills for guild boss fights.\n\n` +
        `**Your Gold:** ${player.gold.toLocaleString()}g\n` +
        `**Boss Essence:** ${bossEssenceCount}\n\n` +
        `_Select a skill below to view details_\n\n` +
        essenceInfo
      );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-bosses')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  async handleGuildBossSkillDetail(interaction, player, skillId) {
    const bossEssenceId = 'boss_essence';
    const items = this.getBossSkillShopItems();
    const item = items.find(s => s.id === skillId);
    const owned = new Set(player.bossSkills || []);

    if (!item) {
      await interaction.reply({ content: '‚ùå Invalid skill!', ephemeral: true });
      return;
    }

    const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
    const canAfford = !owned.has(item.id) && player.gold >= item.costGold && bossEssenceCount >= item.costEssence;
    const isOwned = owned.has(item.id);

    const skillDescriptions = {
      slash: 'A basic melee slash technique. Deals moderate physical damage.',
      fireball: 'Hurl a fireball at your enemy. Deals fire damage.',
      whirlwind: 'Spin rapidly while attacking all nearby enemies. Deals area damage.',
      meteor: 'Rain down meteors from the sky. Deals massive area damage.',
    };

    const embed = new EmbedBuilder()
      .setColor(0xf39c12)
      .setTitle(`‚öîÔ∏è Skill: ${item.name}`)
      .setDescription(
        `${skillDescriptions[item.id] || 'A powerful boss skill.'}\n\n` +
        `**Cost:** ${item.costGold}g + ${item.costEssence} Boss Essence\n` +
        `**Status:** ${isOwned ? '‚úÖ Owned' : 'üîí Not Owned'}\n\n` +
        `**Your Resources:**\n` +
        `üí∞ Gold: ${player.gold.toLocaleString()}g ${player.gold >= item.costGold || isOwned ? '‚úÖ' : '‚ùå'}\n` +
        `üîÆ Boss Essence: ${bossEssenceCount} ${bossEssenceCount >= item.costEssence || isOwned ? '‚úÖ' : '‚ùå'}`
      );

    const buyButton = new ButtonBuilder()
      .setCustomId(`rpg-guild-boss-buy-skill-${item.id}`)
      .setLabel(isOwned ? 'Already Owned' : `Purchase ${item.name}`)
      .setStyle(isOwned ? ButtonStyle.Secondary : (canAfford ? ButtonStyle.Success : ButtonStyle.Secondary))
      .setDisabled(isOwned || !canAfford);

    const backButton = new ButtonBuilder()
      .setCustomId('rpg-guild-boss-skills-shop')
      .setLabel('‚Üê Back to Skills')
      .setStyle(ButtonStyle.Secondary);

    const buttonRow = new ActionRowBuilder().addComponents(buyButton, backButton);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttonRow],
    });
  }

  async handleGuildBossTalentsShop(interaction, player) {
    const bossEssenceId = 'boss_essence';
    const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
    const items = this.getBossTalentShopItems();
    const bossTalents = player.bossTalents || {};

    const selectOptions = items.map(item => ({
      label: `${item.name} (Rank: ${bossTalents[item.id] || 0})`,
      value: item.id,
      description: `${item.description} | Cost: ${item.costGold}g + ${item.costEssence} Essence`,
    }));

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-guild-boss-talents-select')
      .setPlaceholder('Select a talent to upgrade')
      .addOptions(selectOptions);

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    const essenceInfo = '**How to Get Boss Essence:**\nüîÆ Win Guild Boss fights (1-3+ per victory depending on tier)\nüîÆ Complete Guild Quests (3-10 per quest)\nüîÆ Higher tier bosses = more essence on victory';

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle('üåü Boss Talents Shop')
      .setDescription(
        `Upgrade boss-only talents for guild boss fights.\n\n` +
        `**Your Gold:** ${player.gold.toLocaleString()}g\n` +
        `**Boss Essence:** ${bossEssenceCount}\n\n` +
        `_Select a talent below to view details and upgrade_\n\n` +
        essenceInfo
      );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-bosses')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  async handleGuildBossTalentDetail(interaction, player, talentId) {
    const bossEssenceId = 'boss_essence';
    const items = this.getBossTalentShopItems();
    const item = items.find(t => t.id === talentId);
    const bossTalents = player.bossTalents || {};
    const currentRank = bossTalents[item.id] || 0;

    if (!item) {
      await interaction.reply({ content: '‚ùå Invalid talent!', ephemeral: true });
      return;
    }

    const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
    const canAfford = player.gold >= item.costGold && bossEssenceCount >= item.costEssence;

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle(`üåü Talent: ${item.name}`)
      .setDescription(
        `**Effect:** ${item.description}\n\n` +
        `**Current Rank:** ${currentRank}\n` +
        `**Next Rank:** ${currentRank + 1}\n\n` +
        `**Upgrade Cost:** ${item.costGold}g + ${item.costEssence} Boss Essence\n\n` +
        `**Your Resources:**\n` +
        `üí∞ Gold: ${player.gold.toLocaleString()}g ${player.gold >= item.costGold ? '‚úÖ' : '‚ùå'}\n` +
        `üîÆ Boss Essence: ${bossEssenceCount} ${bossEssenceCount >= item.costEssence ? '‚úÖ' : '‚ùå'}`
      );

    const buyButton = new ButtonBuilder()
      .setCustomId(`rpg-guild-boss-buy-talent-${item.id}`)
      .setLabel(`Upgrade to Rank ${currentRank + 1}`)
      .setStyle(canAfford ? ButtonStyle.Success : ButtonStyle.Secondary)
      .setDisabled(!canAfford);

    const backButton = new ButtonBuilder()
      .setCustomId('rpg-guild-boss-talents-shop')
      .setLabel('‚Üê Back to Talents')
      .setStyle(ButtonStyle.Secondary);

    const buttonRow = new ActionRowBuilder().addComponents(buyButton, backButton);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttonRow],
    });
  }

  async handleGuildBossEnchantsShop(interaction, player) {
    const bossEssenceId = 'boss_essence';
    const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
    const items = this.getBossEnchantShopItems();
    const unlocked = new Set(player.bossEnchantRecipesUnlocked || []);

    const selectOptions = items.map(item => ({
      label: `${item.name} ${unlocked.has(item.id) ? '(Unlocked)' : ''}`,
      value: item.id,
      description: `Cost: ${item.costGold}g + ${item.costEssence} Essence`,
    }));

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-guild-boss-enchants-select')
      .setPlaceholder('Select a recipe to view')
      .addOptions(selectOptions);

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    const essenceInfo = '**How to Get Boss Essence:**\nüîÆ Win Guild Boss fights (1-3+ per victory depending on tier)\nüîÆ Complete Guild Quests (3-10 per quest)\nüîÆ Higher tier bosses = more essence on victory';

    const embed = new EmbedBuilder()
      .setColor(0x8e44ad)
      .setTitle('‚ú® Boss Enchant Recipes')
      .setDescription(
        `Unlock high-tier boss damage enchant recipes.\n\n` +
        `**Your Gold:** ${player.gold.toLocaleString()}g\n` +
        `**Boss Essence:** ${bossEssenceCount}\n\n` +
        `_Select a recipe below to view details_\n\n` +
        essenceInfo
      );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-bosses')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  async handleGuildBossEnchantDetail(interaction, player, recipeId) {
    const bossEssenceId = 'boss_essence';
    const items = this.getBossEnchantShopItems();
    const item = items.find(e => e.id === recipeId);
    const unlocked = new Set(player.bossEnchantRecipesUnlocked || []);

    if (!item) {
      await interaction.reply({ content: '‚ùå Invalid recipe!', ephemeral: true });
      return;
    }

    const bossEssenceCount = this.getMaterialCount(player, bossEssenceId);
    const canAfford = !unlocked.has(item.id) && player.gold >= item.costGold && bossEssenceCount >= item.costEssence;
    const isUnlocked = unlocked.has(item.id);

    const enchantDescriptions = {
      boss_damage_enchant_t4: 'Epic-tier damage enchantment for boss-specific weapons. Increases damage output by 30%.',
      boss_damage_enchant_t5: 'Legendary-tier damage enchantment for boss-specific weapons. Increases damage output by 50%.',
    };

    const embed = new EmbedBuilder()
      .setColor(0x8e44ad)
      .setTitle(`‚ú® Recipe: ${item.name}`)
      .setDescription(
        `${enchantDescriptions[item.id] || 'A powerful enchant recipe.'}\n\n` +
        `**Cost:** ${item.costGold}g + ${item.costEssence} Boss Essence\n` +
        `**Status:** ${isUnlocked ? '‚úÖ Unlocked' : 'üîí Not Unlocked'}\n\n` +
        `**Your Resources:**\n` +
        `üí∞ Gold: ${player.gold.toLocaleString()}g ${player.gold >= item.costGold || isUnlocked ? '‚úÖ' : '‚ùå'}\n` +
        `üîÆ Boss Essence: ${bossEssenceCount} ${bossEssenceCount >= item.costEssence || isUnlocked ? '‚úÖ' : '‚ùå'}`
      );

    const buyButton = new ButtonBuilder()
      .setCustomId(`rpg-guild-boss-buy-enchant-${item.id}`)
      .setLabel(isUnlocked ? 'Already Unlocked' : `Unlock Recipe`)
      .setStyle(isUnlocked ? ButtonStyle.Secondary : (canAfford ? ButtonStyle.Success : ButtonStyle.Secondary))
      .setDisabled(isUnlocked || !canAfford);

    const backButton = new ButtonBuilder()
      .setCustomId('rpg-guild-boss-enchants-shop')
      .setLabel('‚Üê Back to Enchants')
      .setStyle(ButtonStyle.Secondary);

    const buttonRow = new ActionRowBuilder().addComponents(buyButton, backButton);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttonRow],
    });
  }

  resolveGuildBossTierRewards(rewards, tier) {
    if (!rewards?.tiers || tier <= 0) return null;

    let base = null;
    if (tier <= 2) base = rewards.tiers.tier1;
    else if (tier <= 4) base = rewards.tiers.tier3;
    else base = rewards.tiers.tier5;

    if (!base) return null;

    const multiplier = tier % 2 === 0 ? 2 : 1;
    const items = (base.items || []).map(item => ({
      id: item.id,
      quantity: Math.max(1, Math.floor((item.quantity || 1) * multiplier)),
    }));

    return {
      gold: Math.floor((base.gold || 0) * multiplier),
      xp: Math.floor((base.xp || 0) * multiplier),
      items,
      multiplier,
    };
  }

  scaleRewardItems(items, multiplier) {
    if (!Array.isArray(items) || multiplier <= 1) return items || [];
    return items.map(item => ({
      id: item.id,
      quantity: Math.max(1, Math.floor((item.quantity || 1) * multiplier)),
    }));
  }

  applyRewardItemsToPlayer(player, items) {
    const names = [];
    for (const rewardItem of (items || [])) {
      const equipment = getEquipment(rewardItem.id);
      const item = getItemByIdDynamic(rewardItem.id);
      const material = getMaterial(rewardItem.id);

      if (equipment) {
        this.addCraftedItem(player, equipment.id, rewardItem.quantity || 1);
        names.push(`${equipment.name} x${rewardItem.quantity || 1}`);
      } else if (item) {
        this.addCraftedItem(player, item.id, rewardItem.quantity || 1);
        names.push(`${item.name} x${rewardItem.quantity || 1}`);
      } else if (material) {
        this.addMaterialToInventory(player, material.id, rewardItem.quantity || 1);
        names.push(`${material.name} x${rewardItem.quantity || 1}`);
      } else {
        this.addCraftedItem(player, rewardItem.id, rewardItem.quantity || 1);
        names.push(`${rewardItem.id} x${rewardItem.quantity || 1}`);
      }
    }
    return names;
  }

  finalizeGuildBossFight(guild, options = {}) {
    const result = this.guildManager.completeBoss(guild.id, options);
    if (!result.success) return null;

    const boss = result.boss;
    const rewards = boss.rewards || {};
    const tier = result.tier || 0;
    const defeated = result.defeated;

    const tierRewards = this.resolveGuildBossTierRewards(rewards, tier);
    const killBonus = defeated ? rewards.killBonus : null;
    const killMultiplier = defeated ? (killBonus?.multiplier || 1) : 1;
    const tierGroupMultiplier = tier > 0 ? Math.ceil(tier / 2) : 0;
    const tierEvenMultiplier = tier > 0 && tier % 2 === 0 ? 2 : 1;
    const guildRewardMultiplier = tierGroupMultiplier * tierEvenMultiplier;

    if (guildRewardMultiplier > 0) {
      guild.xp += Math.floor((rewards.guildXP || 0) * guildRewardMultiplier);
      guild.gold += Math.floor((rewards.guildGold || 0) * guildRewardMultiplier);
    }

    if (defeated && killBonus?.badgeId) {
      if (!guild.badges) guild.badges = [];
      guild.badges.push({
        id: killBonus.badgeId,
        bossId: boss.bossId,
        earnedAt: Date.now(),
      });
    }

    this.guildManager.save();

    const topMultipliers = [1.5, 1.25, 1.1];
    const topContributors = Object.entries(result.participants || {})
      .sort(([, a], [, b]) => b - a)
      .slice(0, 3);
    const topMap = new Map();
    topContributors.forEach(([userId], idx) => {
      topMap.set(userId, topMultipliers[idx] || 1);
    });

    const participantRewards = {};
    for (const [userId, damage] of Object.entries(result.participants || {})) {
      const participant = this.playerManager.getPlayer(userId);
      if (!participant) continue;

      const baseGold = tier > 0 ? (rewards.perPlayer?.gold || 0) : 0;
      const baseXp = tier > 0 ? (rewards.perPlayer?.xp || 0) : 0;

      const tierGold = tierRewards ? Math.floor((tierRewards.gold || 0) * killMultiplier) : 0;
      const tierXp = tierRewards ? Math.floor((tierRewards.xp || 0) * killMultiplier) : 0;
      const tierItems = tierRewards ? this.scaleRewardItems(tierRewards.items, killMultiplier) : [];

      let totalGold = baseGold + tierGold;
      let totalXp = baseXp + tierXp;

      const bonusMultiplier = topMap.get(userId) || 1;
      totalGold = Math.floor(totalGold * bonusMultiplier);
      totalXp = Math.floor(totalXp * bonusMultiplier);

      const level = Number(participant.level || 1);
      const levelMultiplier = 1 + Math.min(0.5, Math.max(0, (level - 1) * 0.01));
      totalGold = Math.floor(totalGold * levelMultiplier);
      totalXp = Math.floor(totalXp * levelMultiplier);

      const baseGuildXp = rewards.perPlayer?.guildXP || Math.floor((baseXp + tierXp) * 0.1);
      const totalGuildXp = Math.floor(baseGuildXp * bonusMultiplier * levelMultiplier);

      if (totalGold > 0) this.addGold(participant, totalGold);
      if (totalXp > 0) participant.addXp(totalXp);
      if (totalGuildXp > 0) {
        participant.guildXP = (participant.guildXP || 0) + totalGuildXp;
        const newRank = getRankKey(participant.guildXP);
        if (newRank && newRank !== participant.guildRank) {
          participant.guildRank = newRank;
        }
      }

      const itemNames = this.applyRewardItemsToPlayer(participant, tierItems);
      
      // Award boss essence based on tier and defeat status
      let bossEssenceAmount = 0;
      if (defeated) {
        bossEssenceAmount = Math.max(1, Math.floor(tier * 1.5)); // 1-2 essence per tier when defeated
        if (bossEssenceAmount > 0) {
          this.addMaterialToInventory(participant, 'boss_essence', bossEssenceAmount);
        }
      }
      
      this.persistPlayer(participant);

      participantRewards[userId] = {
        gold: totalGold,
        xp: totalXp,
        guildXp: totalGuildXp,
        items: itemNames,
        bossEssence: bossEssenceAmount,
        damageDealt: damage,
        bonusMultiplier,
      };
    }

    const tierLabel = tier > 0 ? `Tier ${tier}` : 'No Tier';
    const summary = `${boss.icon} **${boss.name}** ${defeated ? 'defeated' : 'completed'} (${tierLabel})`;

    return {
      ...result,
      participantRewards,
      summary,
      topContributors,
    };
  }

  isGuildBossCombat(player) {
    const combatState = this.combatSystem.getActiveCombat(player.userId);
    return combatState?.meta?.type === 'guild_boss';
  }

  syncGuildBossCombatState(combatState, boss) {
    if (!combatState || !boss) return;
    combatState.enemy.maxHp = Math.max(1, boss.maxHP || combatState.enemy.maxHp || 1);
    combatState.enemy.hp = Math.max(1, Math.min(boss.currentHP || combatState.enemy.hp, combatState.enemy.maxHp));
  }

  buildGuildBossCompletionMessage(finalResult, viewerId) {
    if (!finalResult) return '‚úÖ Guild boss rewards have been distributed.';

    const boss = finalResult.boss;
    const tierLabel = finalResult.tier > 0 ? `Tier ${finalResult.tier}` : 'No Tier';
    const header = `${boss.icon} **${boss.name}** ${finalResult.defeated ? 'Defeated!' : 'Completed'} (${tierLabel})`;

    const guildRewards = boss.rewards || {};
    const guildRewardMultiplier = finalResult.tier > 0 ? Math.ceil(finalResult.tier / 2) * (finalResult.tier % 2 === 0 ? 2 : 1) : 0;
    const guildXp = Math.floor((guildRewards.guildXP || 0) * guildRewardMultiplier);
    const guildGold = Math.floor((guildRewards.guildGold || 0) * guildRewardMultiplier);

    const viewerReward = viewerId ? finalResult.participantRewards?.[viewerId] : null;
    const viewerLines = [];
    if (viewerReward) {
      if (viewerReward.gold) viewerLines.push(`‚îî ${viewerReward.gold} Gold`);
      if (viewerReward.xp) viewerLines.push(`‚îî ${viewerReward.xp} XP`);
      if (viewerReward.guildXp) viewerLines.push(`‚îî ${viewerReward.guildXp} Guild XP`);
      if (viewerReward.items?.length) viewerLines.push(`‚îî Items: ${viewerReward.items.join(', ')}`);
    }

    const topLines = (finalResult.topContributors || []).map(([userId, damage], idx) => {
      const medal = ['ü•á', 'ü•à', 'ü•â'][idx];
      return `${medal} <@${userId}>: ${damage.toLocaleString()}`;
    });

    let message = `${header}\n\n`;
    if (guildRewardMultiplier > 0) {
      message += `**Guild Rewards:**\n‚îî ${guildXp} Guild XP\n‚îî ${guildGold} Guild Gold\n\n`;
    }
    if (viewerReward) {
      message += `**Your Rewards:**\n${viewerLines.join('\n') || '‚îî None'}\n\n`;
    }
    if (topLines.length > 0) {
      message += `**Top Contributors:**\n${topLines.join('\n')}\n`;
    }
    return message.trim();
  }

  async handleGuildBossCombatTurn(interaction, player, action) {
    const combatState = this.combatSystem.getActiveCombat(player.userId);
    if (!combatState || combatState.meta?.type !== 'guild_boss') return false;

    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild || !guild.activeBoss || guild.activeBoss.bossId !== combatState.meta.bossId) {
      this.combatSystem.forceEndCombat(player.userId);
      this.restoreBossBattleSnapshot(player);
      this.persistPlayer(player);
      await interaction.reply({ content: '‚ùå No active guild boss fight found.', ephemeral: true });
      return true;
    }

    const now = Date.now();
    if (guild.activeBoss.expiresAt && now >= guild.activeBoss.expiresAt) {
      const finalResult = this.finalizeGuildBossFight(guild, { reason: 'expired' });
      const summary = this.buildGuildBossCompletionMessage(finalResult, player.userId);
      this.combatSystem.forceEndCombat(player.userId);
      this.restoreBossBattleSnapshot(player);
      this.persistPlayer(player);
      const expiredEmbed = new EmbedBuilder()
        .setColor(0xe67e22)
        .setTitle('‚è∞ Boss Expired')
        .setDescription(summary);
      const backRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-guild-bosses')
          .setLabel('üîÑ Back to Bosses')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-guild')
          .setLabel('‚Üê Back to Guild')
          .setStyle(ButtonStyle.Secondary)
      );
      await this.updateInteractionWithTracking(interaction, {
        embeds: [expiredEmbed],
        components: [backRow],
      });
      return true;
    }

    const triesLeft = this.getGuildBossAttemptsLeft(player, now);
    if (triesLeft <= 0) {
      await interaction.reply({
        content: `‚ùå No guild boss tries left. Reset in ${this.formatTimeUntil(player.guildBossAttemptResetAt, now)}.`,
        ephemeral: true,
      });
      return true;
    }

    this.syncGuildBossCombatState(combatState, guild.activeBoss);
    const preHp = combatState.enemy.hp;

    let result = null;
    if (action.type === 'skill') {
      result = this.combatSystem.executeRoundWithSkill(player.userId, action.skillId);
    } else if (action.type === 'stance') {
      result = this.combatSystem.executeRoundWithStance(player.userId, action.stanceId);
    } else if (action.type === 'switch') {
      result = this.combatSystem.executeRoundWithSwitch(player.userId, action.switchIndex);
    } else if (action.type === 'gear') {
      const equipmentSet = player.equipmentSets?.[action.setIndex];
      if (!equipmentSet || !equipmentSet.items) {
        await interaction.reply({ content: 'Equipment set not found.', ephemeral: true });
        return true;
      }
      player.equippedItems = { ...equipmentSet.items };
      player.clearStatsCache();
      if (combatState.player) {
        combatState.player.equippedItems = { ...equipmentSet.items };
        if (combatState.player.clearStatsCache) {
          combatState.player.clearStatsCache();
        }
      }
      result = this.combatSystem.executeRound(player.userId);
    } else {
      result = this.combatSystem.executeRound(player.userId);
    }

    if (result?.error) {
      await interaction.reply({ content: result.error, ephemeral: true });
      return true;
    }

    if (result?.status === 'error') {
      await interaction.reply({ content: result.error || 'Action cannot be used.', ephemeral: true });
      return true;
    }

    const postHp = result?.combatState?.enemyStatus?.hp ?? result?.enemy?.hp ?? combatState.enemy.hp;
    const damageDealt = Math.max(0, Math.floor(preHp - postHp));
    const applyResult = this.guildManager.applyBossDamage(guild.id, player.userId, damageDealt);
    if (!applyResult.success) {
      await interaction.reply({ content: `‚ùå ${applyResult.error}`, ephemeral: true });
      return true;
    }

    combatState.enemy.hp = applyResult.bossHP;
    combatState.enemy.maxHp = applyResult.bossMaxHP;
    if (result?.combatState?.enemyStatus) {
      result.combatState.enemyStatus.hp = applyResult.bossHP;
      result.combatState.enemyStatus.maxHp = applyResult.bossMaxHP;
    }

    if (applyResult.defeated) {
      this.combatSystem.forceEndCombat(player.userId);
      this.restoreBossBattleSnapshot(player);
      this.trackCombatResult(player, combatState.enemy?.name || 'Guild Boss', 'victory', 'guildBoss');
      this.persistPlayer(player);
      const finalResult = this.finalizeGuildBossFight(guild, { reason: 'defeated' });
      const summary = this.buildGuildBossCompletionMessage(finalResult, player.userId);
      const victoryEmbed = new EmbedBuilder()
        .setColor(0x2ecc71)
        .setTitle('üéâ Guild Boss Defeated!')
        .setDescription(summary);
      const backRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-guild-bosses')
          .setLabel('üîÑ Back to Bosses')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-guild')
          .setLabel('‚Üê Back to Guild')
          .setStyle(ButtonStyle.Secondary)
      );
      await this.updateInteractionWithTracking(interaction, {
        embeds: [victoryEmbed],
        components: [backRow],
      });
      return true;
    }

    if (result?.status === 'ongoing') {
      const embed = UIBuilder.createCombatStateEmbed(result.combatState);
      const buttons = this.createGuildBossCombatButtons();
      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: buttons,
      });
      return true;
    }

    if (result?.status === 'defeat') {
      // Record this defeat (consumes 1 attempt)
      this.guildManager.recordBossDefeat(guild.id, player.userId);
      this.trackCombatResult(player, combatState.enemy?.name || 'Guild Boss', 'defeat', 'guildBoss');
      this.trackDeath(player, combatState.enemy, 'guildBoss');
      
      this.consumeGuildBossAttempt(player, now);
      this.combatSystem.forceEndCombat(player.userId);
      this.restoreBossBattleSnapshot(player);
      this.persistPlayer(player);
      const remainingAttempts = this.guildManager.getRemainingBossAttempts(guild.id, player.userId, 3);
      let defeatText = 'üíÄ You were defeated by the guild boss.';
      if (remainingAttempts > 0) {
        defeatText += ` You have **${remainingAttempts} ${remainingAttempts === 1 ? 'attempt' : 'attempts'}** left.`;
      } else {
        defeatText += ' You have no attempts left for this boss cycle.';
      }
      // Show defeat then transition to boss status view
      await this.handleActiveBossFight(interaction, player, guild, defeatText);
      return true;
    }

    return true;
  }

  /**
   * Guild buff management
   */
  async handleGuildBuffs(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({
        content: '‚ùå You are not in a guild!',
        ephemeral: true,
      });
      return;
    }

    const member = guild.members[player.userId];
    if (member.role !== 'leader' && member.role !== 'officer') {
      await interaction.reply({
        content: '‚ùå Only officers and leaders can manage buffs!',
        ephemeral: true,
      });
      return;
    }

    const levelInfo = getGuildLevel(guild.xp);
    const buffs = getGuildBuffs(levelInfo.level, guild.buffs);

    // Create buff overview
    const buffOverview = [
      `üìä **Current Guild Buffs Overview:**`,
      ``,
      `**Progression Buffs:**`,
      `  ‚≠ê XP Bonus: ${buffs.xpBonus}%`,
      `  üí∞ Gold Bonus: ${buffs.goldBonus}%`,
      ``,
      `**Gathering & Crafting:**`,
      `  ‚õèÔ∏è Gathering Speed: ${buffs.gatheringSpeed}%`,
      `  üî® Crafting Speed: ${buffs.craftingSpeed}%`,
      ``,
      `**Combat & Rewards:**`,
      `  ‚öîÔ∏è Damage Bonus: ${buffs.damageBonus}%`,
      `  üõ°Ô∏è Defense Bonus: ${buffs.defenseBonus}%`,
      `  üêâ Boss Reward Boost: ${buffs.bossRewardBoost}%`,
      ``,
      `**Special:**`,
      `  ‚ú® Rare Drop Rate: +${buffs.rareDropRate}%`,
      `  üè™ Shop Discount: ${buffs.shopDiscount}%`,
    ].join('\n');

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle('‚ú® Guild Buffs Management')
      .setDescription(buffOverview)
      .addFields(
        { name: 'üí∞ Guild Treasury', value: `${guild.gold.toLocaleString()}g`, inline: true },
        { name: 'üéØ Guild Level', value: `${levelInfo.level} / 50`, inline: true }
      );

    // Create selector for buff overview
    const row1 = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-guild-buff-overview')
        .setPlaceholder('üìã View detailed buff info')
        .addOptions(
          { label: '‚≠ê XP Bonus', value: 'xp_info', description: `Current: ${buffs.xpBonus}% | Max Cap: 50%` },
          { label: 'üí∞ Gold Bonus', value: 'gold_info', description: `Current: ${buffs.goldBonus}% | Max Cap: 50%` },
          { label: 'üõí Shop Discount', value: 'shop_info', description: `Current: ${buffs.shopDiscount}% | Max Cap: 30%` },
          { label: '‚õèÔ∏è Gathering Speed', value: 'gathering_info', description: `Current: ${buffs.gatheringSpeed}% | Max Cap: 70%` },
          { label: 'üî® Crafting Speed', value: 'crafting_info', description: `Current: ${buffs.craftingSpeed}% | Max Cap: 45%` },
          { label: 'üêâ Boss Reward Boost', value: 'boss_info', description: `Current: ${buffs.bossRewardBoost}% | Max Cap: 40%` }
        )
    );

    const row2 = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-guild-buff-purchase')
        .setPlaceholder('üí≥ Select buff to purchase')
        .addOptions(
          { label: `‚≠ê XP (${GUILD_BUFF_COSTS.xpBonus.toLocaleString()}g)`, value: 'buy_xp', description: `${buffs.xpBonus}% ‚Üí ${Math.min(buffs.xpBonus + 1, 50)}%` },
          { label: `üí∞ Gold (${GUILD_BUFF_COSTS.goldBonus.toLocaleString()}g)`, value: 'buy_gold', description: `${buffs.goldBonus}% ‚Üí ${Math.min(buffs.goldBonus + 1, 50)}%` },
          { label: `üõí Shop (${GUILD_BUFF_COSTS.shopDiscount.toLocaleString()}g)`, value: 'buy_shop', description: `${buffs.shopDiscount}% ‚Üí ${Math.min(buffs.shopDiscount + 1, 30)}%` },
          { label: `‚õèÔ∏è Gathering (${GUILD_BUFF_COSTS.gatheringSpeed.toLocaleString()}g)`, value: 'buy_gathering', description: `${buffs.gatheringSpeed}% ‚Üí ${Math.min(buffs.gatheringSpeed + 1, 70)}%` },
          { label: `üî® Crafting (${GUILD_BUFF_COSTS.craftingSpeed.toLocaleString()}g)`, value: 'buy_crafting', description: `${buffs.craftingSpeed}% ‚Üí ${Math.min(buffs.craftingSpeed + 1, 45)}%` },
          { label: `üêâ Boss Reward (${GUILD_BUFF_COSTS.bossRewardBoost.toLocaleString()}g)`, value: 'buy_boss', description: `${buffs.bossRewardBoost}% ‚Üí ${Math.min(buffs.bossRewardBoost + 1, 40)}%` }
        )
    );

    const row3 = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-guild-buff-purchase2')
        .setPlaceholder('üí≥ Select more buffs to purchase')
        .addOptions(
          { label: `‚ú® Rare Drop (${GUILD_BUFF_COSTS.rareDropRate.toLocaleString()}g)`, value: 'buy_rare', description: `${buffs.rareDropRate}% ‚Üí ${Math.min(buffs.rareDropRate + 1, 15)}%` },
          { label: `‚öîÔ∏è Damage (${GUILD_BUFF_COSTS.damageBonus.toLocaleString()}g)`, value: 'buy_damage', description: `${buffs.damageBonus}% ‚Üí ${Math.min(buffs.damageBonus + 1, 30)}%` },
          { label: `üõ°Ô∏è Defense (${GUILD_BUFF_COSTS.defenseBonus.toLocaleString()}g)`, value: 'buy_defense', description: `${buffs.defenseBonus}% ‚Üí ${Math.min(buffs.defenseBonus + 1, 30)}%` }
        )
    );

    const row4 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-donate')
        .setLabel('üí∞ Donate Gold')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2, row3, row4],
    });
  }

  /**
   * Show detailed buff information
   */
  async handleGuildBuffOverview(interaction, player, buffType) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
      return;
    }

    const levelInfo = getGuildLevel(guild.xp);
    const buffs = getGuildBuffs(levelInfo.level, guild.buffs);

    const buffInfo = {
      xp_info: {
        name: '‚≠ê XP Bonus',
        current: buffs.xpBonus,
        max: 50,
        description: 'Increases experience earned from all sources',
        benefits: '‚Ä¢ Faster leveling\n‚Ä¢ Accelerates skill progression\n‚Ä¢ Speeds up achievement unlocks',
        cost: GUILD_BUFF_COSTS.xpBonus,
      },
      gold_info: {
        name: 'üí∞ Gold Bonus',
        current: buffs.goldBonus,
        max: 50,
        description: 'Increases gold earned from combat, quests, and activities',
        benefits: '‚Ä¢ More gold for purchasing items\n‚Ä¢ Faster buff purchasing\n‚Ä¢ Better vault expansion funds',
        cost: GUILD_BUFF_COSTS.goldBonus,
      },
      shop_info: {
        name: 'üõí Shop Discount',
        current: buffs.shopDiscount,
        max: 30,
        description: 'Reduces prices in all guild shops',
        benefits: '‚Ä¢ Lower item costs\n‚Ä¢ Save gold on equipment\n‚Ä¢ Better deals on consumables',
        cost: GUILD_BUFF_COSTS.shopDiscount,
      },
      gathering_info: {
        name: '‚õèÔ∏è Gathering Speed',
        current: buffs.gatheringSpeed,
        max: 70,
        description: 'Increases gathering speed and material acquisition rate',
        benefits: '‚Ä¢ Faster material gathering\n‚Ä¢ More items per gathering session\n‚Ä¢ Speeds up crafting prep',
        cost: GUILD_BUFF_COSTS.gatheringSpeed,
      },
      crafting_info: {
        name: 'üî® Crafting Speed',
        current: buffs.craftingSpeed,
        max: 45,
        description: 'Reduces crafting time for all recipes',
        benefits: '‚Ä¢ Faster crafting times\n‚Ä¢ More items crafted per session\n‚Ä¢ Improved production efficiency',
        cost: GUILD_BUFF_COSTS.craftingSpeed,
      },
      boss_info: {
        name: 'üêâ Boss Reward Boost',
        current: buffs.bossRewardBoost,
        max: 40,
        description: 'Increases rewards from boss encounters',
        benefits: '‚Ä¢ More gold from bosses\n‚Ä¢ Increased item drop rates\n‚Ä¢ Enhanced boss XP rewards',
        cost: GUILD_BUFF_COSTS.bossRewardBoost,
      },
    };

    const info = buffInfo[buffType];
    if (!info) {
      await interaction.reply({ content: '‚ùå Invalid buff type.', ephemeral: true });
      return;
    }

    const progressBar = this.buildProgressBar(info.current, info.max, 15);
    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle(`${info.name} Details`)
      .setDescription(info.description)
      .addFields(
        { name: 'üìä Progress', value: `${info.current}% / ${info.max}%\n${progressBar}`, inline: false },
        { name: '‚ú® Benefits', value: info.benefits, inline: false },
        { name: 'üí≥ Purchase Cost', value: `${info.cost.toLocaleString()}g per +1%`, inline: true },
        { name: 'üí∞ Guild Treasury', value: `${guild.gold.toLocaleString()}g`, inline: true }
      );

    const row = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`rpg-guild-buy-buff-${buffType.split('_')[0]}`)
        .setLabel(`Purchase +1% (${info.cost.toLocaleString()}g)`)
        .setStyle(ButtonStyle.Success)
        .setDisabled(guild.gold < info.cost || info.current >= info.max),
      new ButtonBuilder()
        .setCustomId('rpg-guild-buffs')
        .setLabel('‚Üê Back to Buffs')
        .setStyle(ButtonStyle.Secondary)
    );

    await interaction.update({
      embeds: [embed],
      components: [row],
    });
  }

  /**
   * Handle buff purchase from selector menu - show quantity options
   */
  async handleGuildBuffPurchaseFromSelector(interaction, player, action) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
      return;
    }

    const member = guild.members[player.userId];
    if (member.role !== 'leader' && member.role !== 'officer') {
      await interaction.reply({ content: '‚ùå Only officers and leaders can purchase buffs!', ephemeral: true });
      return;
    }

    const buffMap = {
      'buy_xp': 'xpBonus',
      'buy_gold': 'goldBonus',
      'buy_shop': 'shopDiscount',
      'buy_gathering': 'gatheringSpeed',
      'buy_crafting': 'craftingSpeed',
      'buy_boss': 'bossRewardBoost',
      'buy_rare': 'rareDropRate',
      'buy_damage': 'damageBonus',
      'buy_defense': 'defenseBonus',
    };

    const buffKey = buffMap[action];
    if (!buffKey) {
      await interaction.reply({ content: '‚ùå Invalid buff type.', ephemeral: true });
      return;
    }

    const cost = GUILD_BUFF_COSTS[buffKey];
    if (!cost) {
      await interaction.reply({ content: '‚ùå This buff cannot be purchased.', ephemeral: true });
      return;
    }

    const levelInfo = getGuildLevel(guild.xp);
    const buffs = getGuildBuffs(levelInfo.level, guild.buffs);
    
    const buffCaps = {
      xpBonus: 50,
      goldBonus: 50,
      shopDiscount: 30,
      gatheringSpeed: 70,
      craftingSpeed: 45,
      bossRewardBoost: 40,
      rareDropRate: 15,
      damageBonus: 30,
      defenseBonus: 30,
    };

    const currentLevel = buffs[buffKey] || 0;
    const maxLevel = buffCaps[buffKey] || 50;
    const remainingCapacity = maxLevel - currentLevel;
    
    // Calculate max buyable with current gold
    const maxBuysWithGold = Math.floor(guild.gold / cost);
    const maxBuys = Math.min(maxBuysWithGold, remainingCapacity);

    if (maxBuys <= 0) {
      await interaction.reply({ 
        content: `‚ùå Cannot purchase! ${remainingCapacity === 0 ? 'Buff is maxed out.' : 'Not enough guild gold.'}`, 
        ephemeral: true 
      });
      return;
    }

    const buffNames = {
      xpBonus: '‚≠ê XP Bonus',
      goldBonus: 'üí∞ Gold Bonus',
      shopDiscount: 'üõí Shop Discount',
      gatheringSpeed: '‚õèÔ∏è Gathering Speed',
      craftingSpeed: 'üî® Crafting Speed',
      bossRewardBoost: 'üêâ Boss Reward Boost',
      rareDropRate: '‚ú® Rare Drop Rate',
      damageBonus: '‚öîÔ∏è Damage Bonus',
      defenseBonus: 'üõ°Ô∏è Defense Bonus',
    };

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle(`${buffNames[buffKey]} - Purchase Quantity`)
      .setDescription(
        `**Current Level:** ${currentLevel}%\n` +
        `**Maximum Level:** ${maxLevel}%\n` +
        `**Upgrade Cost:** ${cost.toLocaleString()}g per +1%\n` +
        `**Guild Gold:** ${guild.gold.toLocaleString()}g\n\n` +
        `**Available Options:**\n` +
        `‚Ä¢ **Buy 1√ó**: ${cost.toLocaleString()}g\n` +
        `‚Ä¢ **Buy 10√ó**: ${(cost * Math.min(10, maxBuys)).toLocaleString()}g\n` +
        `‚Ä¢ **Buy 25√ó**: ${(cost * Math.min(25, maxBuys)).toLocaleString()}g\n` +
        `‚Ä¢ **Buy Max**: ${(cost * maxBuys).toLocaleString()}g (${maxBuys}√ó levels)`
      );

    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`rpg-guild-buff-buy-qty-${action}-1`)
        .setLabel(`1√ó`)
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId(`rpg-guild-buff-buy-qty-${action}-10`)
        .setLabel(`10√ó`)
        .setStyle(ButtonStyle.Primary)
        .setDisabled(maxBuys < 10),
      new ButtonBuilder()
        .setCustomId(`rpg-guild-buff-buy-qty-${action}-25`)
        .setLabel(`25√ó`)
        .setStyle(ButtonStyle.Primary)
        .setDisabled(maxBuys < 25),
      new ButtonBuilder()
        .setCustomId(`rpg-guild-buff-buy-qty-${action}-${maxBuys}`)
        .setLabel(`Max (${maxBuys}√ó)`)
        .setStyle(ButtonStyle.Success)
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-buffs')
        .setLabel('‚Üê Cancel')
        .setStyle(ButtonStyle.Secondary)
    );

    await interaction.update({
      embeds: [embed],
      components: [row1, row2],
    });
  }

  /**
   * Execute bulk buff purchase
   */
  async handleGuildBuffBulkPurchase(interaction, player, action, quantity) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
      return;
    }

    const member = guild.members[player.userId];
    if (member.role !== 'leader' && member.role !== 'officer') {
      await interaction.reply({ content: '‚ùå Only officers and leaders can purchase buffs!', ephemeral: true });
      return;
    }

    const buffMap = {
      'buy_xp': 'xpBonus',
      'buy_gold': 'goldBonus',
      'buy_shop': 'shopDiscount',
      'buy_gathering': 'gatheringSpeed',
      'buy_crafting': 'craftingSpeed',
      'buy_boss': 'bossRewardBoost',
      'buy_rare': 'rareDropRate',
      'buy_damage': 'damageBonus',
      'buy_defense': 'defenseBonus',
    };

    const buffKey = buffMap[action];
    if (!buffKey) {
      await interaction.reply({ content: '‚ùå Invalid buff type.', ephemeral: true });
      return;
    }

    const cost = GUILD_BUFF_COSTS[buffKey];
    const totalCost = cost * quantity;

    if (guild.gold < totalCost) {
      await interaction.reply({ content: `‚ùå Not enough guild gold! Need ${totalCost.toLocaleString()}g.`, ephemeral: true });
      return;
    }

    // Purchase each level
    let purchased = 0;
    for (let i = 0; i < quantity; i++) {
      const result = this.guildManager.purchaseBuff(guild.id, player.userId, buffKey, cost);
      if (!result.success) {
        break; // Stop if we hit the cap
      }
      purchased++;
    }

    const buffNames = {
      xpBonus: '‚≠ê XP Bonus',
      goldBonus: 'üí∞ Gold Bonus',
      shopDiscount: 'üõí Shop Discount',
      gatheringSpeed: '‚õèÔ∏è Gathering Speed',
      craftingSpeed: 'üî® Crafting Speed',
      bossRewardBoost: 'üêâ Boss Reward Boost',
      rareDropRate: '‚ú® Rare Drop Rate',
      damageBonus: '‚öîÔ∏è Damage Bonus',
      defenseBonus: 'üõ°Ô∏è Defense Bonus',
    };

    await interaction.reply({
      content: `‚úÖ Purchased +${purchased}% **${buffNames[buffKey]}** for ${(cost * purchased).toLocaleString()}g!`,
      ephemeral: true,
    });

    setTimeout(() => {
      interaction.deleteReply().catch(() => {});
    }, 5000);

    // Refresh buffs page
    setTimeout(() => {
      this.handleGuildBuffs(interaction, player);
    }, 1000);
  }

  /**
   * Guild leave confirmation
   */
  async handleGuildLeaveConfirm(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({
        content: '‚ùå You are not in a guild!',
        ephemeral: true,
      });
      return;
    }

    const member = guild.members[player.userId];
    const isLeader = member.role === 'leader';

    const embed = new EmbedBuilder()
      .setColor(0xe74c3c)
      .setTitle(isLeader ? '‚ö†Ô∏è Disband/Leave Guild' : 'üö™ Leave Guild')
      .setDescription(
        isLeader 
          ? `Are you sure you want to leave **[${guild.tag}] ${guild.name}**?\n\n` +
            `‚ö†Ô∏è **Warning:** As the guild leader, if you leave and there are other members, you must transfer leadership first. If you are the only member, the guild will be disbanded.`
          : `Are you sure you want to leave **[${guild.tag}] ${guild.name}**?\n\n` +
            `You will lose access to guild buffs and features.`
      );

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-leave-confirm')
        .setLabel('‚úÖ Yes, Leave Guild')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚ùå Cancel')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Guild settings (placeholder)
   */
  async handleGuildSettings(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({
        content: '‚ùå You are not in a guild!',
        ephemeral: true,
      });
      return;
    }

    const member = guild.members[player.userId];
    if (member.role !== 'leader') {
      await interaction.reply({
        content: '‚ùå Only the guild leader can access settings!',
        ephemeral: true,
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0x95a5a6)
      .setTitle('‚öôÔ∏è Guild Settings')
      .setDescription(
        `Manage your guild's settings below.\n\n` +
        `**Public Listing:** ${guild.settings.isPublic ? '‚úÖ Enabled' : '‚ùå Disabled'}\n` +
        `‚îî ${guild.settings.isPublic ? 'Guild appears in public search' : 'Guild is invite-only'}\n\n` +
        `**Minimum Level:** ${guild.settings.minLevel}\n` +
        `‚îî Required level to join this guild\n\n` +
        `**Application Required:** ${guild.settings.requireApplication ? '‚úÖ Enabled' : '‚ùå Disabled'}\n` +
        `‚îî ${guild.settings.requireApplication ? 'Players must apply to join' : 'Players can join directly'}`
      );

    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-toggle-public')
        .setLabel(guild.settings.isPublic ? 'Make Private' : 'Make Public')
        .setStyle(guild.settings.isPublic ? ButtonStyle.Secondary : ButtonStyle.Success)
        .setEmoji('üîí'),
      new ButtonBuilder()
        .setCustomId('rpg-guild-toggle-application')
        .setLabel(guild.settings.requireApplication ? 'Disable Applications' : 'Require Applications')
        .setStyle(guild.settings.requireApplication ? ButtonStyle.Secondary : ButtonStyle.Primary)
        .setEmoji('üìù')
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-set-minlevel')
        .setLabel('Set Min Level')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üìä'),
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2],
    });
  }

  /**
   * Toggle guild public/private status
   */
  async handleGuildTogglePublic(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
      return;
    }

    const member = guild.members[player.userId];
    if (member.role !== 'leader') {
      await interaction.reply({ content: '‚ùå Only the guild leader can change settings!', ephemeral: true });
      return;
    }

    // Toggle the public setting
    guild.settings.isPublic = !guild.settings.isPublic;
    this.guildManager.save();

    await interaction.reply({
      content: `‚úÖ Guild is now ${guild.settings.isPublic ? '**public**' : '**private (invite-only)**'}!`,
      ephemeral: true
    });

    // Refresh settings view
    setTimeout(() => {
      this.handleGuildSettings(interaction, player);
    }, 1000);
  }

  /**
   * Toggle guild application requirement
   */
  async handleGuildToggleApplication(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({ content: '‚ùå You are not in a guild!', ephemeral: true });
      return;
    }

    const member = guild.members[player.userId];
    if (member.role !== 'leader') {
      await interaction.reply({ content: '‚ùå Only the guild leader can change settings!', ephemeral: true });
      return;
    }

    // Toggle the application requirement
    guild.settings.requireApplication = !guild.settings.requireApplication;
    this.guildManager.save();

    await interaction.reply({
      content: `‚úÖ Applications are now ${guild.settings.requireApplication ? '**required**' : '**not required**'}!`,
      ephemeral: true
    });

    // Refresh settings view
    setTimeout(() => {
      this.handleGuildSettings(interaction, player);
    }, 1000);
  }

  /**
   * Handle unified guild management (Members, Roles, Settings)
   */
  async handleGuildManagement(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    if (!guild) {
      await interaction.reply({
        content: '‚ùå You are not in a guild!',
        ephemeral: true,
      });
      return;
    }

    const member = guild.members[player.userId];
    const isLeader = member.role === 'leader';
    const isOfficer = member.role === 'officer' || isLeader;

    // Build members list
    const membersList = Object.values(guild.members)
      .sort((a, b) => {
        const roleOrder = { leader: 0, officer: 1, member: 2 };
        return roleOrder[a.role] - roleOrder[b.role];
      })
      .map(m => {
        const roleIcon = m.role === 'leader' ? 'üëë' : m.role === 'officer' ? '‚≠ê' : 'üë§';
        return `${roleIcon} ${m.userId === player.userId ? '**You**' : `<@${m.userId}>`} (${m.contributedXP} XP | ${m.contributedGold}g)`;
      })
      .join('\n');

    // Organize members by role
    const allMembers = Object.values(guild.members);
    const leaders = allMembers.filter(m => m.role === 'leader');
    const officers = allMembers.filter(m => m.role === 'officer');
    const regularMembers = allMembers.filter(m => m.role === 'member');

    // Build settings display
    const settingsDisplay = 
      `**Public Listing:** ${guild.settings.isPublic ? '‚úÖ' : '‚ùå'}\n` +
      `**Minimum Level:** ${guild.settings.minLevel}\n` +
      `**Application Required:** ${guild.settings.requireApplication ? '‚úÖ' : '‚ùå'}`;

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle(`üìã [${guild.tag}] Guild Management Center`)
      .setDescription('View and manage members, roles, and guild settings in one place.')
      .addFields(
        {
          name: 'üë• Members by Role',
          value: 
            `**üëë Leaders (${leaders.length}):** ${leaders.map(m => `<@${m.userId}>`).join(', ') || 'None'}\n` +
            `**‚≠ê Officers (${officers.length}):** ${officers.map(m => `<@${m.userId}>`).join(', ') || 'None'}\n` +
            `**üë§ Members (${regularMembers.length}):** ${regularMembers.length > 0 ? `${regularMembers.length} members` : 'None'}`,
          inline: false
        },
        {
          name: '‚öôÔ∏è Guild Settings',
          value: settingsDisplay,
          inline: false
        },
        {
          name: 'üìå Quick Actions',
          value: isOfficer 
            ? '‚úÖ You can manage members and roles\n' + (isLeader ? '‚úÖ You can change guild settings' : '')
            : 'üëÅÔ∏è You can view member information (Read-only)',
          inline: false
        }
      )
      .setFooter({ text: isOfficer ? 'Officers+ can manage. Leaders can change settings.' : 'You have read-only access' });

    const components = [];

    // Member selector for role management (only if officer)
    if (isOfficer) {
      const memberOptions = [];
      const membersToShow = allMembers.filter(m => m.userId !== player.userId).slice(0, 25);
      
      for (const m of membersToShow) {
        try {
          const user = await this.client.users.fetch(m.userId);
          const roleIcon = m.role === 'leader' ? 'üëë' : m.role === 'officer' ? '‚≠ê' : 'üë§';
          memberOptions.push({
            label: `${roleIcon} ${user.username}`,
            value: m.userId,
            description: `Role: ${m.role}`,
          });
        } catch (err) {
          memberOptions.push({
            label: `User ${m.userId}`,
            value: m.userId,
            description: `Role: ${m.role}`,
          });
        }
      }

      if (memberOptions.length > 0) {
        components.push(new ActionRowBuilder().addComponents(
          new StringSelectMenuBuilder()
            .setCustomId('rpg-guild-manage-member-role')
            .setPlaceholder('Select a member to manage role/actions')
            .addOptions(memberOptions)
        ));
      }
    }

    // Settings management buttons (only for leader)
    if (isLeader) {
      const settingsRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-guild-toggle-public')
          .setLabel(guild.settings.isPublic ? 'üîí Make Private' : 'üîì Make Public')
          .setStyle(guild.settings.isPublic ? ButtonStyle.Secondary : ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('rpg-guild-toggle-application')
          .setLabel(guild.settings.requireApplication ? 'üìù Disable Apps' : 'üìù Require Apps')
          .setStyle(guild.settings.requireApplication ? ButtonStyle.Secondary : ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-guild-set-minlevel')
          .setLabel('üìä Min Level')
          .setStyle(ButtonStyle.Primary)
      );
      components.push(settingsRow);
    }

    // Back button
    components.push(new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back to Guild')
        .setStyle(ButtonStyle.Secondary)
    ));

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Check and reset daily/weekly quests
   */
  checkQuestResets(player) {
    const now = Date.now();
    const oneDayMs = 24 * 60 * 60 * 1000;
    const oneWeekMs = 7 * oneDayMs;

    // Get today's UTC midnight timestamp (synchronized for all players)
    const today = new Date(now);
    today.setUTCHours(0, 0, 0, 0);
    const todayMidnight = today.getTime();
    
    // Get this week's Sunday UTC midnight (Week starts on Sunday)
    const thisWeek = new Date(now);
    const dayOfWeek = thisWeek.getUTCDay();
    thisWeek.setUTCHours(0, 0, 0, 0);
    thisWeek.setUTCDate(thisWeek.getUTCDate() - dayOfWeek); // Go back to Sunday
    const weekStartMidnight = thisWeek.getTime();

    // Check daily reset - synchronized at UTC midnight for all players
    if (!player.lastDailyReset || player.lastDailyReset < todayMidnight) {
      player.dailyQuestsCompleted = [];
      this.clearGuildQuestProgressByType(player, 'daily');
      player.lastDailyReset = todayMidnight;
      this.playerManager.savePlayer(player);
    }

    // Check weekly reset - synchronized at UTC Sunday midnight for all players
    if (!player.lastWeeklyReset || player.lastWeeklyReset < weekStartMidnight) {
      player.weeklyQuestsCompleted = [];
      this.clearGuildQuestProgressByType(player, 'weekly');
      player.lastWeeklyReset = weekStartMidnight;
      this.playerManager.savePlayer(player);
    }
  }

  getGuildBossResetConfig() {
    return {
      timeZone: 'America/Toronto',
      hour: 17,
      minute: 0,
      maxAttempts: 3,
      resetDays: 3,
    };
  }

  getTimeZoneParts(date, timeZone) {
    const formatter = new Intl.DateTimeFormat('en-CA', {
      timeZone,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hourCycle: 'h23',
    });
    const parts = formatter.formatToParts(date);
    const map = {};
    for (const part of parts) {
      if (part.type !== 'literal') map[part.type] = part.value;
    }
    return {
      year: Number(map.year),
      month: Number(map.month),
      day: Number(map.day),
      hour: Number(map.hour),
      minute: Number(map.minute),
      second: Number(map.second || 0),
    };
  }

  zonedTimeToUtcMillis(parts, timeZone) {
    const utcGuess = Date.UTC(parts.year, parts.month - 1, parts.day, parts.hour, parts.minute, parts.second || 0);
    const guessDate = new Date(utcGuess);
    const zonedParts = this.getTimeZoneParts(guessDate, timeZone);
    const zonedAsUtc = Date.UTC(
      zonedParts.year,
      zonedParts.month - 1,
      zonedParts.day,
      zonedParts.hour,
      zonedParts.minute,
      zonedParts.second || 0
    );
    return utcGuess + (utcGuess - zonedAsUtc);
  }

  getNextDailyResetAt(timeZone, hour, minute, now = Date.now()) {
    const nowDate = new Date(now);
    const today = this.getTimeZoneParts(nowDate, timeZone);
    const todayReset = this.zonedTimeToUtcMillis({
      year: today.year,
      month: today.month,
      day: today.day,
      hour,
      minute,
      second: 0,
    }, timeZone);

    if (todayReset > now) {
      return todayReset;
    }

    const todayMidnight = this.zonedTimeToUtcMillis({
      year: today.year,
      month: today.month,
      day: today.day,
      hour: 0,
      minute: 0,
      second: 0,
    }, timeZone);
    const tomorrowDate = new Date(todayMidnight + 24 * 60 * 60 * 1000);
    const tomorrow = this.getTimeZoneParts(tomorrowDate, timeZone);
    return this.zonedTimeToUtcMillis({
      year: tomorrow.year,
      month: tomorrow.month,
      day: tomorrow.day,
      hour,
      minute,
      second: 0,
    }, timeZone);
  }

  getNextGuildBossResetAt(now = Date.now()) {
    const cfg = this.getGuildBossResetConfig();
    const nextDaily = this.getNextDailyResetAt(cfg.timeZone, cfg.hour, cfg.minute, now);
    return nextDaily + (cfg.resetDays - 1) * 24 * 60 * 60 * 1000;
  }

  ensureGuildBossAttemptState(player, now = Date.now()) {
    const cfg = this.getGuildBossResetConfig();
    if (!player.guildBossAttemptsToday && player.guildBossAttemptsToday !== 0) {
      player.guildBossAttemptsToday = 0;
    }
    if (!player.guildBossAttemptResetAt) {
      player.guildBossAttemptResetAt = this.getNextGuildBossResetAt(now);
    }

    if (now >= player.guildBossAttemptResetAt) {
      player.guildBossAttemptsToday = 0;
      player.guildBossAttemptResetAt = this.getNextGuildBossResetAt(now);
      this.persistPlayer(player);
    }
  }

  getGuildBossAttemptsLeft(player, now = Date.now()) {
    this.ensureGuildBossAttemptState(player, now);
    const cfg = this.getGuildBossResetConfig();
    return Math.max(0, cfg.maxAttempts - (player.guildBossAttemptsToday || 0));
  }

  consumeGuildBossAttempt(player, now = Date.now()) {
    this.ensureGuildBossAttemptState(player, now);
    const cfg = this.getGuildBossResetConfig();
    const used = player.guildBossAttemptsToday || 0;
    if (used >= cfg.maxAttempts) {
      return { ok: false, remaining: 0, resetAt: player.guildBossAttemptResetAt };
    }
    player.guildBossAttemptsToday = used + 1;
    this.persistPlayer(player);
    return { ok: true, remaining: Math.max(0, cfg.maxAttempts - player.guildBossAttemptsToday), resetAt: player.guildBossAttemptResetAt };
  }

  formatTimeUntil(timestamp, now = Date.now()) {
    const ms = Math.max(0, timestamp - now);
    const totalMinutes = Math.ceil(ms / 60000);
    const hours = Math.floor(totalMinutes / 60);
    const minutes = totalMinutes % 60;
    if (hours <= 0) return `${minutes}m`;
    return `${hours}h ${minutes}m`;
  }

  ensureGuildQuestState(player) {
    if (!player.guildQuestProgress) player.guildQuestProgress = {};
    if (!Array.isArray(player.limitedQuestsCompleted)) player.limitedQuestsCompleted = [];
    if (!Array.isArray(player.dailyQuestsCompleted)) player.dailyQuestsCompleted = [];
    if (!Array.isArray(player.weeklyQuestsCompleted)) player.weeklyQuestsCompleted = [];
  }

  clearGuildQuestProgressByType(player, type) {
    this.ensureGuildQuestState(player);
    const allQuests = getAllGuildQuests();
    const list = allQuests?.[type] || [];
    for (const quest of list) {
      delete player.guildQuestProgress[quest.id];
    }
  }

  getGuildQuestProgressLine(player, quest) {
    this.ensureGuildQuestState(player);
    const objective = normalizeGuildQuestObjective(quest);
    if (!objective) return null;
    const current = player.guildQuestProgress?.[quest.id]?.count || 0;
    const total = Number(objective.count || 1);
    return `**Progress:** ${Math.min(current, total)}/${total}`;
  }

  normalizeQuestTarget(value) {
    return String(value || '')
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '');
  }

  matchesQuestTarget(questTarget, eventTarget) {
    const q = this.normalizeQuestTarget(questTarget);
    const e = this.normalizeQuestTarget(eventTarget);
    if (!q) return true;
    if (!e) return false;
    return e.includes(q) || q.includes(e);
  }

  isLevelSufficient(playerLevel, requiredLevel) {
    return Number(playerLevel || 0) >= Number(requiredLevel || 0);
  }

  guildQuestObjectiveMatches(objective, event) {
    if (!objective || objective.type !== event.type) return false;

    const questTarget = objective.target || '';
    const eventTargets = [event.target, event.targetId, event.targetName].filter(Boolean);

    if (questTarget === 'boss' && event.tags?.includes('boss')) return true;
    if (questTarget === 'world_boss' && event.tags?.includes('world_boss')) return true;
    if (questTarget === 'material' && event.type === 'gather') return true;
    if (questTarget === 'enemy' && event.type === 'kill') return true;
    if (questTarget === 'dungeon' && event.type === 'explore') return true;

    if (eventTargets.length === 0) return true;

    return eventTargets.some(t => this.matchesQuestTarget(questTarget, t));
  }

  awardGuildQuestRewards(player, quest) {
    const rewards = quest.rewards || {};
    const lines = [];

    if (rewards.guildXP) {
      player.guildXP += rewards.guildXP;
      lines.push(`+${rewards.guildXP} Guild XP`);
    }

    if (rewards.gold) {
      this.addGold(player, rewards.gold);
      lines.push(`+${rewards.gold} gold`);
    }

    // Guild quests do not grant XP - gold and Guild XP only
    if (rewards.xp) {
      // XP reward is intentionally ignored for guild quests
    }

    const itemNames = [];
    for (const rewardItem of (rewards.items || [])) {
      const itemId = typeof rewardItem === 'string' ? rewardItem : rewardItem?.id;
      const quantity = typeof rewardItem === 'object' ? rewardItem.quantity || 1 : 1;
      if (!itemId) continue;

      const equipment = getEquipment(itemId);
      const item = getItemByIdDynamic(itemId);
      const material = getMaterial(itemId);

      if (equipment) {
        this.addCraftedItem(player, equipment.id, quantity);
        itemNames.push(`${equipment.name} x${quantity}`);
      } else if (item) {
        this.addCraftedItem(player, item.id, quantity);
        itemNames.push(`${item.name} x${quantity}`);
      } else if (material) {
        this.addMaterialToInventory(player, material.id, quantity);
        itemNames.push(`${material.name} x${quantity}`);
      }
    }

    if (itemNames.length > 0) {
      lines.push(`Items: ${itemNames.join(', ')}`);
    }

    const previousRank = player.guildRank;
    const newRank = getRankKey(player.guildXP);
    if (newRank && newRank !== previousRank) {
      player.guildRank = newRank;
      lines.push(`üéñÔ∏è Rank Up: ${previousRank} ‚Üí ${newRank}`);
    }

    return lines;
  }

  /**
   * Handle guild quests menu with quest type selector
   */
  async handleGuildQuestsMenu(interaction, player) {
    const embed = new EmbedBuilder()
      .setColor('#9370DB')
      .setTitle('üìú Guild Quests')
      .setDescription('Select the type of quests you want to complete.')
      .addFields(
        { name: 'üìÖ Daily Quests', value: 'Reset every 24 hours. Great for consistent rewards!', inline: false },
        { name: 'üìÜ Weekly Quests', value: 'Reset every 7 days. Higher rewards for more commitment.', inline: false },
        { name: '‚ö° Limited Quests', value: 'First-come first-served. Exclusive rewards for the quick!', inline: false }
      );

    const row = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-guild-quests-select')
        .setPlaceholder('Select Quest Type')
        .addOptions(
          {
            label: 'Daily Quests',
            value: 'daily',
            emoji: 'üìÖ',
            description: 'Reset every 24 hours'
          },
          {
            label: 'Weekly Quests',
            value: 'weekly',
            emoji: 'üìÜ',
            description: 'Reset every 7 days'
          },
          {
            label: 'Limited Quests',
            value: 'limited',
            emoji: '‚ö°',
            description: 'First-come first-served'
          }
        )
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row, backRow],
    });
  }

  /**
   * Handle guild daily quests
   */
  async handleGuildDailyQuests(interaction, player) {
    // Check for quest resets
    this.checkQuestResets(player);
    
    const dailyQuests = getAvailableDailyQuests(player.level, player.dailyQuestsCompleted);
    
    // Calculate time until next synchronized daily reset (UTC midnight)
    const now = Date.now();
    const today = new Date(now);
    today.setUTCHours(0, 0, 0, 0);
    const todayMidnight = today.getTime();
    const tomorrowMidnight = todayMidnight + (24 * 60 * 60 * 1000);
    const timeUntilReset = Math.max(0, tomorrowMidnight - now);
    const hoursUntilReset = Math.floor(timeUntilReset / (60 * 60 * 1000));
    const minutesUntilReset = Math.floor((timeUntilReset % (60 * 60 * 1000)) / (60 * 1000));
    
    let descriptionBase = 'Complete daily quests to earn Guild XP and rewards!\n';
    if (dailyQuests.length > 0) {
      descriptionBase += `‚è±Ô∏è **Reset in:** ${hoursUntilReset}h ${minutesUntilReset}m`;
    } else {
      descriptionBase += `‚úÖ All daily quests completed!\n‚è±Ô∏è **Next reset in:** ${hoursUntilReset}h ${minutesUntilReset}m`;
    }
    
    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle('üìÖ Daily Quests')
      .setDescription(descriptionBase)
      .setTimestamp();

    if (dailyQuests.length > 0) {
      dailyQuests.forEach(quest => {
        const progressLine = this.getGuildQuestProgressLine(player, quest);
        const progressText = progressLine ? `\n${progressLine}` : '';
        const rewards = quest.rewards || {};
        const guildXp = Number.isFinite(rewards.guildXP) ? rewards.guildXP : 0;
        const gold = Number.isFinite(rewards.gold) ? rewards.gold : 0;
        embed.addFields({
          name: `${quest.title}`,
          value: `${quest.description}${progressText}\n**Rewards:** ${guildXp} Guild XP, ${gold}g`,
          inline: false
        });
      });
    } else {
      // Show completed quests with checkmarks
      const allDailyQuests = getAllGuildQuests().daily.filter(q => 
        player.level >= (q.minLevel || 1)
      );
      const completedList = allDailyQuests.filter(q => player.dailyQuestsCompleted.includes(q.id));
      completedList.slice(0, 3).forEach(quest => {
        embed.addFields({
          name: `‚úÖ ${quest.title}`,
          value: `Completed!`,
          inline: false
        });
      });
      if (completedList.length > 3) {
        embed.addFields({
          name: '...',
          value: `+${completedList.length - 3} more completed`,
          inline: false
        });
      }
    }

    const components = [];

    // Add navigation buttons for active quests
    if (dailyQuests.length > 0) {
      const questButtons = [];
      for (const quest of dailyQuests.slice(0, 4)) { // Limit to 4 buttons per row
        const navAction = this.getQuestNavigationAction(quest);
        if (navAction) {
          questButtons.push(new ButtonBuilder()
            .setCustomId(`rpg-quest-navigate-${quest.id}`)
            .setLabel(`${navAction.icon} ${quest.title.slice(0, 30)}`)
            .setStyle(ButtonStyle.Primary)
          );
        }
      }
      if (questButtons.length > 0) {
        // Split into rows of 2-3 buttons
        for (let i = 0; i < questButtons.length; i += 2) {
          components.push(new ActionRowBuilder().addComponents(questButtons.slice(i, i + 2)));
        }
      }
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-quests')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-guild-daily-refresh')
        .setLabel('üîÑ Refresh')
        .setStyle(ButtonStyle.Primary)
    );
    components.push(backButton);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Handle guild weekly quests
   */
  async handleGuildWeeklyQuests(interaction, player) {
    const weeklyQuests = getAvailableWeeklyQuests(player.level, player.weeklyQuestsCompleted);
    
    // Calculate time until next synchronized weekly reset (UTC Sunday midnight)
    const now = Date.now();
    const thisWeek = new Date(now);
    const dayOfWeek = thisWeek.getUTCDay();
    thisWeek.setUTCHours(0, 0, 0, 0);
    thisWeek.setUTCDate(thisWeek.getUTCDate() - dayOfWeek); // Go back to Sunday
    const weekStartMidnight = thisWeek.getTime();
    
    const nextWeekMidnight = weekStartMidnight + (7 * 24 * 60 * 60 * 1000);
    const timeUntilReset = Math.max(0, nextWeekMidnight - now);
    const daysUntilReset = Math.floor(timeUntilReset / (24 * 60 * 60 * 1000));
    const hoursUntilReset = Math.floor((timeUntilReset % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
    
    let descriptionBase = 'Complete weekly quests for bigger rewards!\n';
    if (weeklyQuests.length > 0) {
      descriptionBase += `‚è±Ô∏è **Reset in:** ${daysUntilReset}d ${hoursUntilReset}h`;
    } else {
      descriptionBase += `‚úÖ All weekly quests completed!\n‚è±Ô∏è **Next reset in:** ${daysUntilReset}d ${hoursUntilReset}h`;
    }
    
    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle('üìÜ Weekly Quests')
      .setDescription(descriptionBase)
      .setTimestamp();

    weeklyQuests.forEach(quest => {
      const progressLine = this.getGuildQuestProgressLine(player, quest);
      const progressText = progressLine ? `\n${progressLine}` : '';
      embed.addFields({
        name: `${quest.title}`,
        value: `${quest.description}${progressText}\n**Rewards:** ${quest.rewards.guildXP} Guild XP, ${quest.rewards.gold}g`,
        inline: false
      });
    });

    const components = [];
    
    // Add navigation buttons
    if (weeklyQuests.length > 0) {
      const questButtons = [];
      for (const quest of weeklyQuests.slice(0, 4)) {
        const navAction = this.getQuestNavigationAction(quest);
        if (navAction) {
          questButtons.push(new ButtonBuilder()
            .setCustomId(`rpg-quest-navigate-${quest.id}`)
            .setLabel(`${navAction.icon} ${quest.title.slice(0, 30)}`)
            .setStyle(ButtonStyle.Primary)
          );
        }
      }
      if (questButtons.length > 0) {
        for (let i = 0; i < questButtons.length; i += 2) {
          components.push(new ActionRowBuilder().addComponents(questButtons.slice(i, i + 2)));
        }
      }
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-quests')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );
    components.push(backButton);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Handle guild limited quests (first-come first-served)
   */
  async handleGuildLimitedQuests(interaction, player) {
    const limitedQuests = getAvailableLimitedQuests(player.level, player.claimedQuests, player.currentWorld);
    
    const embed = new EmbedBuilder()
      .setColor(0xe74c3c)
      .setTitle('‚ö° Limited Quests')
      .setDescription(limitedQuests.length > 0 
        ? '‚ö†Ô∏è First come, first served! Claim these quests before they\'re gone!'
        : 'üò¢ No limited quests available right now. Check back later!')
      .setTimestamp();

    limitedQuests.forEach(quest => {
      const progressLine = this.getGuildQuestProgressLine(player, quest);
      const progressText = progressLine ? `\n${progressLine}` : '';
      const currentClaims = Number(quest.claimedCount ?? quest.currentClaims ?? 0);
      const maxClaims = Number(quest.maxClaims ?? 0);
      
      let rewardsText = `**Rewards:** ${quest.rewards.guildXP} Guild XP, ${quest.rewards.gold}g`;
      if (quest.rewards.materials) {
        const materialsList = Object.entries(quest.rewards.materials)
          .map(([matId, qty]) => {
            const mat = getMaterial(matId);
            return `${mat ? mat.name : matId} x${qty}`;
          })
          .join(', ');
        rewardsText += `, ${materialsList}`;
      }
      
      embed.addFields({
        name: `${quest.title} [${currentClaims}/${maxClaims} claimed]`,
        value: `${quest.description}${progressText}\n${rewardsText}`,
        inline: false
      });
    });

    const components = [];
    
    if (limitedQuests.length > 0) {
      const selectMenu = new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-guild-claim-limited')
          .setPlaceholder('Select a quest to claim')
          .addOptions(limitedQuests.map(q => ({
            label: q.title,
            value: q.id,
            description: `${q.currentClaims || 0}/${q.maxClaims || 0} claimed`,
          })))
      );
      components.push(selectMenu);
    }

    // Add navigation buttons for claimed (active) limited quests
    const claimedQuests = (player.claimedQuests || [])
      .map(id => getGuildQuestById(id))
      .filter(Boolean)
      .filter(q => !player.limitedQuestsCompleted.includes(q.id));

    if (claimedQuests.length > 0) {
      const questButtons = [];
      for (const quest of claimedQuests.slice(0, 4)) {
        const navAction = this.getQuestNavigationAction(quest);
        if (navAction) {
          questButtons.push(new ButtonBuilder()
            .setCustomId(`rpg-quest-navigate-${quest.id}`)
            .setLabel(`${navAction.icon} ${quest.title.slice(0, 30)}`)
            .setStyle(ButtonStyle.Primary)
          );
        }
      }
      if (questButtons.length > 0) {
        for (let i = 0; i < questButtons.length; i += 2) {
          components.push(new ActionRowBuilder().addComponents(questButtons.slice(i, i + 2)));
        }
      }
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-quests')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );
    components.push(backButton);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Handle guild quest navigation - route player to appropriate activity
   */
  async handleGuildQuestNavigation(interaction, player, questId) {
    const quest = getGuildQuestById(questId);
    if (!quest) {
      await interaction.reply({ content: '‚ùå Quest not found.', ephemeral: true });
      return;
    }

    const navAction = this.getQuestNavigationAction(quest);
    if (!navAction) {
      await interaction.reply({ content: '‚ùå No navigation available for this quest.', ephemeral: true });
      return;
    }

    // For mob hunts, try to find a specific dungeon
    if (navAction.action === 'mob-hunt' && navAction.mobName) {
      const dungeon = this.findDungeonWithMob(navAction.mobName);
      if (dungeon) {
        // Navigate to adventure with this dungeon
        player.selectedWorld = dungeon.world;
        this.persistPlayer(player);
        await this.handleAdventure(interaction, player);
        return;
      }
      // Fallback to general adventure if dungeon not found
      await this.handleAdventure(interaction, player);
      return;
    }

    // For other navigation types, use the standard routes
    const customId = navAction.customId;
    switch (customId) {
      case 'rpg-gather':
        await this.handleGatherMenu(interaction, player);
        break;
      case 'rpg-dungeons':
        await this.handleDungeonSelection(interaction, player);
        break;
      case 'rpg-raids':
        await this.handleRaidSelection(interaction, player);
        break;
      case 'rpg-adventure':
        await this.handleAdventure(interaction, player);
        break;
      default:
        await interaction.reply({ content: '‚ùå Unknown navigation action.', ephemeral: true });
    }
  }

  /**
   * Determine where a guild quest should navigate the player
   * Returns { action, label, icon } or null
   */
  getQuestNavigationAction(quest) {
    const objective = normalizeGuildQuestObjective(quest);
    if (!objective) return null;

    const { type, target } = objective;

    // Gathering quests
    if (type === 'gather' || target === 'material') {
      return { action: 'gather', label: 'Go to Gathering', icon: 'üåø', customId: 'rpg-gather' };
    }

    // Dungeon/Explore quests
    if (type === 'explore' || target === 'dungeon') {
      return { action: 'dungeon', label: 'Go to Dungeons', icon: 'üè∞', customId: 'rpg-dungeons' };
    }

    // Boss/Raid quests
    if (target === 'boss' || (target === 'enemy' && quest.title?.toLowerCase().includes('boss'))) {
      return { action: 'raid', label: 'Go to Raids', icon: 'üëë', customId: 'rpg-raids' };
    }

    // Specific mob quests - try to find lowest level dungeon with that enemy
    if (type === 'kill' && target === 'enemy') {
      const mobName = this.extractMobNameFromObjective(quest);
      if (mobName) {
        // Return special action to find dungeon by mob
        return { action: 'mob-hunt', label: `Hunt ${mobName}`, icon: '‚öîÔ∏è', mobName };
      }
      // Generic combat
      return { action: 'adventure', label: 'Go to Adventures', icon: '‚öîÔ∏è', customId: 'rpg-adventure' };
    }

    // Default to adventure
    return { action: 'adventure', label: 'Go to Adventures', icon: '‚öîÔ∏è', customId: 'rpg-adventure' };
  }

  /**
   * Extract mob/enemy name from quest objective text
   */
  extractMobNameFromObjective(quest) {
    const objectiveText = Array.isArray(quest.objectives) ? quest.objectives[0] : quest.objectives;
    if (!objectiveText) return null;

    const text = String(objectiveText).toLowerCase();
    
    // Try to match patterns like "Defeat X [mob]" or "Hunt X [mob]"
    const patterns = [
      /defeat.*?\b(the\s+)?([a-zA-Z\s]+?)(?:\s*(?:\(\d+\))?$)/i, // "Defeat the X" or "Defeat X"
      /hunt.*?\b(the\s+)?([a-zA-Z\s]+?)(?:\s*(?:\(\d+\))?$)/i,    // "Hunt the X" or "Hunt X"
      /kill.*?\b(the\s+)?([a-zA-Z\s]+?)(?:\s*(?:\(\d+\))?$)/i,    // "Kill the X" or "Kill X"
    ];

    for (const pattern of patterns) {
      const match = objectiveText.match(pattern);
      if (match && match[2]) {
        return match[2].trim().replace(/\s+/g, ' '); // Clean up extra spaces
      }
    }

    return null;
  }

  /**
   * Find the lowest level dungeon containing a specific mob
   */
  findDungeonWithMob(mobName) {
    if (!mobName) return null;

    const name = mobName.toLowerCase();
    const allDungeons = Object.values(DUNGEONS || {})
      .flatMap(world => Array.isArray(world) ? world : [world])
      .filter(d => d && typeof d === 'object');

    // Filter dungeons that might have this enemy (by name match or boss name)
    const candidates = allDungeons.filter(d => {
      const dungeonName = (d.name || '').toLowerCase();
      const bossName = d.boss ? String(d.boss).toLowerCase() : '';
      const bosses = Array.isArray(d.bosses) ? d.bosses.map(b => {
        if (typeof b === 'string') return b.toLowerCase();
        return (b.name || '').toLowerCase();
      }) : [];
      
      return dungeonName.includes(name) || bossName.includes(name) || bosses.some(b => b.includes(name));
    });

    // Sort by min level and return lowest
    if (candidates.length > 0) {
      candidates.sort((a, b) => (a.minLevel || 1) - (b.minLevel || 1));
      return candidates[0];
    }

    return null;
  }

  /**
   * Apply guild quest progress for an event
   * Returns { updates: [], completions: [] }
   */
  applyGuildQuestProgress(player, dailyQuests, weeklyQuests, claimedLimited, event) {
    const updates = [];
    const completions = [];

    this.ensureGuildQuestState(player);

    // Safety checks - ensure all inputs are arrays
    if (!Array.isArray(dailyQuests)) dailyQuests = [];
    if (!Array.isArray(weeklyQuests)) weeklyQuests = [];
    if (!Array.isArray(claimedLimited)) claimedLimited = [];

    const questBuckets = [
      ...dailyQuests.map(q => ({ quest: q, category: 'daily' })),
      ...weeklyQuests.map(q => ({ quest: q, category: 'weekly' })),
      ...claimedLimited.map(q => ({ quest: q, category: 'limited' })),
    ];

    for (const { quest, category } of questBuckets) {
      const objective = normalizeGuildQuestObjective(quest);
      if (!objective) continue;
      if (!this.guildQuestObjectiveMatches(objective, event)) continue;

      const current = player.guildQuestProgress?.[quest.id]?.count || 0;
      const increment = Number(event.count || 1);
      const total = Number(objective.count || 1);
      const updated = Math.min(total, current + increment);

      if (updated === current) continue;

      player.guildQuestProgress[quest.id] = {
        count: updated,
        updatedAt: Date.now(),
      };

      updates.push(`‚Ä¢ ${quest.title}: ${updated}/${total}`);

      if (updated >= total) {
        const rewardLines = this.awardGuildQuestRewards(player, quest);
        if (category === 'daily') player.dailyQuestsCompleted.push(quest.id);
        if (category === 'weekly') player.weeklyQuestsCompleted.push(quest.id);
        if (category === 'limited') player.limitedQuestsCompleted.push(quest.id);
        completions.push(`‚úÖ ${quest.title}${rewardLines.length ? ` (Rewards: ${rewardLines.join(', ')})` : ''}`);
      }
    }

    // Save player after quest progress update
    if (updates.length > 0 || completions.length > 0) {
      this.persistPlayer(player);
    }

    return { updates, completions };
  }

  /**
   * Check if quest objective matches an event
   */
  guildQuestObjectiveMatches(objective, event) {
    if (!objective || !event) return false;
    if (objective.type !== event.type) return false;

    const questTarget = objective.target || '';
    const eventTargets = [event.target, event.targetId, event.targetName].filter(Boolean);

    if (questTarget === 'boss' && event.tags?.includes('boss')) return true;
    if (questTarget === 'world_boss' && event.tags?.includes('world_boss')) return true;
    if (questTarget === 'material' && event.type === 'gather') return true;
    if (questTarget === 'enemy' && event.type === 'kill') return true;
    if (questTarget === 'dungeon' && event.type === 'explore') return true;

    if (eventTargets.length === 0) return true;

    return eventTargets.some(t => this.matchesQuestTarget(questTarget, t));
  }

  /**
   * Award rewards for completing a guild quest
   */
  awardGuildQuestRewards(player, quest) {
    const rewardLines = [];
    const rewards = quest.rewards || {};

    if (rewards.guildXP) {
      player.guildXP = (player.guildXP || 0) + rewards.guildXP;
      rewardLines.push(`+${rewards.guildXP} Guild XP`);
    }

    if (rewards.gold) {
      this.addGold(player, rewards.gold);
      rewardLines.push(`+${rewards.gold} gold`);
    }

    // Guild quests do not grant XP - gold and Guild XP only
    if (rewards.xp) {
      // XP reward is intentionally ignored for guild quests
    }

    // Handle material rewards
    if (rewards.materials) {
      const materialNames = [];
      for (const [materialId, quantity] of Object.entries(rewards.materials)) {
        this.addMaterialToInventory(player, materialId, quantity);
        const material = getMaterial(materialId);
        const materialName = material ? material.name : materialId;
        materialNames.push(`${materialName} x${quantity}`);
      }
      if (materialNames.length > 0) {
        rewardLines.push(`Materials: ${materialNames.join(', ')}`);
      }
    }

    const itemNames = [];
    for (const rewardItem of (rewards.items || [])) {
      const itemId = typeof rewardItem === 'string' ? rewardItem : rewardItem?.id;
      const quantity = typeof rewardItem === 'object' ? rewardItem.quantity || 1 : 1;
      if (!itemId) continue;

      const equipment = getEquipment(itemId);
      const item = getItemByIdDynamic(itemId);
      const material = getMaterial(itemId);

      if (equipment) {
        this.addCraftedItem(player, equipment.id, quantity);
        itemNames.push(`${equipment.name} x${quantity}`);
      } else if (item) {
        this.addCraftedItem(player, item.id, quantity);
        itemNames.push(`${item.name} x${quantity}`);
      } else if (material) {
        this.addMaterialToInventory(player, material.id, quantity);
        itemNames.push(`${material.name} x${quantity}`);
      }
    }

    if (itemNames.length > 0) {
      rewardLines.push(`Items: ${itemNames.join(', ')}`);
    }

    const previousRank = player.guildRank;
    const newRank = getRankKey(player.guildXP);
    if (newRank && newRank !== previousRank) {
      player.guildRank = newRank;
      rewardLines.push(`üéñÔ∏è Rank Up: ${previousRank} ‚Üí ${newRank}`);
    }

    return rewardLines;
  }

  /**
   * Get progress line for a guild quest
   */
  getGuildQuestProgressLine(player, quest) {
    this.ensureGuildQuestState(player);
    const objective = normalizeGuildQuestObjective(quest);
    if (!objective) return null;

    const progress = player.guildQuestProgress[quest.id];
    const current = progress?.count || 0;
    const total = objective.count || 1;

    if (current >= total) {
      return `‚úÖ Progress: ${current}/${total} (Complete!)`;
    }

    const percentage = Math.floor((current / total) * 100);
    return `üìä Progress: ${current}/${total} (${percentage}%)`;
  }

  /**
   * Check and reset daily/weekly quests if needed
   */
  checkQuestResets(player) {
    const now = Date.now();
    const oneDayMs = 24 * 60 * 60 * 1000;
    const oneWeekMs = 7 * 24 * 60 * 60 * 1000;

    // Initialize reset timestamps if missing
    if (!player.lastDailyReset) {
      player.lastDailyReset = now;
    }
    if (!player.lastWeeklyReset) {
      player.lastWeeklyReset = now;
    }

    // Check daily reset
    if (now - player.lastDailyReset >= oneDayMs) {
      player.dailyQuestsCompleted = [];
      player.lastDailyReset = now;
      // Clear progress for daily quests
      if (player.guildQuestProgress) {
        const dailyQuestIds = getAllGuildQuests().daily.map(q => q.id);
        dailyQuestIds.forEach(id => {
          if (player.guildQuestProgress[id]) {
            delete player.guildQuestProgress[id];
          }
        });
      }
      this.persistPlayer(player);
    }

    // Check weekly reset
    if (now - player.lastWeeklyReset >= oneWeekMs) {
      player.weeklyQuestsCompleted = [];
      player.lastWeeklyReset = now;
      // Clear progress for weekly quests
      if (player.guildQuestProgress) {
        const weeklyQuestIds = getAllGuildQuests().weekly.map(q => q.id);
        weeklyQuestIds.forEach(id => {
          if (player.guildQuestProgress[id]) {
            delete player.guildQuestProgress[id];
          }
        });
      }
      this.persistPlayer(player);
    }
  }

  /**
   * Handle guild bounty board - Guild quests have been removed
   */
  async handleGuildBounties(interaction, player) {
    await interaction.update({
      content: '‚ùå Guild quests and bounties have been removed from the system.',
      components: [],
      embeds: []
    });
  }

  async handleCreateBountyModal(interaction, player) {
    await interaction.update({
      content: '‚ùå Guild bounties have been removed from the system.',
      components: [],
      embeds: []
    });
  }

  /**
   * Handle weekly rewards claim
   */
  async handleGuildWeeklyRewards(interaction, player) {
    const now = Date.now();
    const oneWeekMs = 7 * 24 * 60 * 60 * 1000;
    const canClaim = (now - player.lastWeeklyReward) >= oneWeekMs;
    
    const rankInfo = getRankByXP(player.guildXP);
    const rewards = rankInfo.weeklyRewards;
    
    const embed = new EmbedBuilder()
      .setColor(canClaim ? 0x2ecc71 : 0x95a5a6)
      .setTitle(`üéÅ Weekly Rank Rewards - ${rankInfo.name}`)
      .setDescription(canClaim 
        ? '‚úÖ Your weekly rewards are ready to claim!'
        : `‚è∞ Next reward in ${Math.ceil((oneWeekMs - (now - player.lastWeeklyReward)) / (60 * 60 * 1000))} hours`)
      .addFields(
        { name: 'üí∞ Gold', value: `${rewards.gold}g`, inline: true },
        { name: 'üì¶ Items', value: rewards.items.length > 0 ? rewards.items.join(', ') : 'None', inline: true }
      )
      .setTimestamp();

    const rankOrder = ['F', 'E', 'D', 'C', 'B', 'A', 'S'];
    const allRewardsText = rankOrder
      .filter(r => GUILD_RANKS[r])
      .map(r => {
        const info = GUILD_RANKS[r];
        const items = info.weeklyRewards.items?.length ? `, Items: ${info.weeklyRewards.items.length}` : ', Items: 0';
        return `${r}: ${info.weeklyRewards.gold}g${items}`;
      })
      .join('\n');

    const allBuffsText = rankOrder
      .filter(r => GUILD_RANKS[r])
      .map(r => {
        const info = GUILD_RANKS[r];
        return `${r}: Tax -${info.buffs.marketTaxReduction}% ‚Ä¢ Shop -${info.buffs.shopDiscount}% ‚Ä¢ Quest XP +${info.buffs.questXPBonus}%`;
      })
      .join('\n');

    embed.addFields(
      { name: 'üèÜ All Rank Rewards (Weekly)', value: allRewardsText, inline: false },
      { name: 'üõ°Ô∏è All Rank Buffs', value: allBuffsText, inline: false }
    );

    const components = [];
    
    if (canClaim) {
      const claimButton = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-guild-claim-weekly')
          .setLabel('üéÅ Claim Rewards')
          .setStyle(ButtonStyle.Success)
      );
      components.push(claimButton);
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild')
        .setLabel('‚Üê Back to Guild')
        .setStyle(ButtonStyle.Secondary)
    );
    components.push(backButton);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components,
    });
  }

  /**
   * Claim weekly rewards
   */
  async handleClaimWeeklyReward(interaction, player) {
    const now = Date.now();
    const oneWeekMs = 7 * 24 * 60 * 60 * 1000;
    
    if ((now - player.lastWeeklyReward) < oneWeekMs) {
      await interaction.reply({
        content: '‚ùå You can only claim weekly rewards once per week!',
        ephemeral: true,
      });
      return;
    }
    
    const rankInfo = getRankByXP(player.guildXP);
    const rewards = rankInfo.weeklyRewards;
    
    // Give rewards
    this.addGold(player, rewards.gold);
    if (rewards.items && rewards.items.length > 0) {
      player.inventory.push(...rewards.items);
    }
    
    player.lastWeeklyReward = now;
    this.playerManager.savePlayer(player);
    
    await interaction.reply({
      content: `‚úÖ **Weekly Rewards Claimed!**\nüí∞ +${rewards.gold} gold${rewards.items.length > 0 ? `\nüì¶ +${rewards.items.length} items` : ''}`,
      ephemeral: false,
    });
    
    // Refresh the rewards view
    await this.handleGuildWeeklyRewards(interaction, player);
  }

  /**
   * Handle multi-layer raid with team package selection
   */
  async handleLayeredRaid(interaction, player, raid) {
    if (!raid || !raid.layers || raid.layers.length === 0) {
      await interaction.reply({
        content: 'This raid does not have layer support yet.',
        ephemeral: true,
      });
      return;
    }

    // Create an embed showing available layers
    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle(`‚õ∞Ô∏è ${raid.name} - Select Layer`)
      .setDescription('Choose which layer to raid. Higher layers have better rewards!');

    // Add layer options as fields with rarity colors
    raid.layers.forEach((layer, idx) => {
      const rarityColors = {
        'common': '‚ö™',
        'uncommon': 'üü¢',
        'rare': 'üîµ',
        'epic': 'üü£',
        'legendary': 'üü†'
      };
      const pkg = layer.rewardPackages?.[0];
      const color = rarityColors[pkg?.rarity] || '‚ö™';
      
      embed.addFields({
        name: `${color} ${layer.name}`,
        value: `Level ${layer.level} ‚Ä¢ XP: ${pkg?.xp || 0} ‚Ä¢ Gold: ${pkg?.gold || 0}`,
        inline: false
      });
    });

    // Create buttons for each layer
    const buttons = new ActionRowBuilder();
    raid.layers.slice(0, 5).forEach((layer, idx) => {
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId(`raid-layer-${raid.id}-${idx}`)
          .setLabel(`Layer ${idx + 1}`)
          .setStyle(ButtonStyle.Primary)
      );
    });

    buttons.addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Handle team package selection for raids
   * If one player gets legendary, all team members can get it
   */
  async handleRaidPackageSelection(interaction, player, raid, layerIndex) {
    const layer = raid.layers?.[layerIndex];
    if (!layer || !layer.rewardPackages) {
      await interaction.reply({
        content: 'Layer not found.',
        ephemeral: true,
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle(`${layer.name} - Reward Package Selection`)
      .setDescription('Select your reward package. If anyone in your team gets Legendary, everyone can take it!');

    // Show available packages with drop chances
    layer.rewardPackages.forEach((pkg, idx) => {
      const itemCount = (pkg.items?.length || 0) + (pkg.materials?.length || 0);
      embed.addFields({
        name: `${pkg.rarity.toUpperCase()} - ${pkg.name}`,
        value: `Drop Chance: ${pkg.dropChance}% ‚Ä¢ Items: ${itemCount} ‚Ä¢ XP: ${pkg.xp} ‚Ä¢ Gold: ${pkg.gold}`,
        inline: false
      });
    });

    // Create package selection buttons
    const buttons = new ActionRowBuilder();
    layer.rewardPackages.slice(0, 5).forEach((pkg, idx) => {
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId(`raid-pkg-${raid.id}-${layerIndex}-${idx}`)
          .setLabel(pkg.rarity.toUpperCase())
          .setStyle(pkg.rarity === 'legendary' ? ButtonStyle.Success : ButtonStyle.Primary)
      );
    });

    buttons.addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  unlockNextWorld(player, worldId) {
    // Mark this world's boss as defeated
    if (!player.worldBossesDefeated.includes(worldId)) {
      player.worldBossesDefeated.push(worldId);
    }

    // Get all worlds and find the next one by tier
    const allWorlds = getAllWorlds();
    const currentWorld = allWorlds.find(w => w.id === worldId);
    
    if (!currentWorld) {
      this.persistPlayer(player);
      return;
    }

    // Find the next world (next tier)
    const currentTier = currentWorld.tier || 1;
    const nextWorld = allWorlds.find(w => (w.tier || 1) === currentTier + 1);

    // Unlock the next world if it exists
    if (nextWorld && !player.worldsUnlocked.includes(nextWorld.id)) {
      player.worldsUnlocked.push(nextWorld.id);
      // Optionally auto-travel to the next world
      // player.currentWorld = nextWorld.id;
    }

    this.persistPlayer(player);
  }

  /**
   * Handle adventure (main progression mechanic)
   */
  async handleAdventure(interaction, player) {
    this.trackMenuNavigation(player, 'adventure');
    const now = Date.now();
    const timeSinceLastAdventure = now - player.lastAdventureTime;
    const cooldownMs = player.adventureCooldown;

    if (timeSinceLastAdventure < cooldownMs) {
      const remainingMs = cooldownMs - timeSinceLastAdventure;
      const minutesRemaining = Math.ceil(remainingMs / 60000);
      const embed = UIBuilder.createAdventureUnavailableEmbed(minutesRemaining);
      const backButton = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );
      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [backButton],
      });
      return;
    }

    // Run adventure - grant XP based on current level
    const balance = loadBalanceData();
    const baseXp = 50;
    const xpMult = Number(balance.adventureXpMultiplier) || 1;
    const xpGained = Math.floor(baseXp * (1 + player.level * 0.5) * xpMult);
    player.addXp(xpGained);
    player.lastAdventureTime = now;
    player.clearStatsCache(); // Clear cache after stats change

    const materialsFound = this.generateAdventureMaterials(player);
  this.persistPlayer(player);
    const embed = UIBuilder.createAdventureCompletedEmbed(player, xpGained, materialsFound);
    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backButton],
    });
  }

  generateAdventureMaterials(player) {
    const commonPool = ['iron_ore', 'coal', 'herb', 'water', 'leather'];
    const materialsFound = [];

    for (let i = 0; i < 2; i += 1) {
      const materialId = commonPool[Math.floor(Math.random() * commonPool.length)];
      const quantity = 1 + Math.floor(Math.random() * 2);
      this.addMaterialToInventory(player, materialId, quantity);
      const material = getMaterial(materialId) || MATERIALS[materialId];
      materialsFound.push({ id: materialId, name: material?.name || materialId, quantity });
    }

    if (Math.random() < 0.15) {
      const materialId = 'mana_crystal';
      this.addMaterialToInventory(player, materialId, 1);
      const material = getMaterial(materialId) || MATERIALS[materialId];
      materialsFound.push({ id: materialId, name: material?.name || materialId, quantity: 1 });
    }

    return materialsFound;
  }

  /**
   * Handle gather menu - now shows auto-gather skill selection
   */
  async handleGatherMenu(interaction, player, skipTracking = false) {
    // Stop message updates when leaving the gathering overview
    this.autoGatherManager.stopMessageUpdates(player.userId);

    if (!skipTracking) {
      this.trackMenuNavigation(player, 'gather');
    } else {
      // Even when skipping history, update currentMenu so back button works
      player.currentMenu = 'gather';
    }
    
    // Check if already gathering
    const isGathering = player.isAutoGathering;
    const gatheringSkill = isGathering ? getGatheringSkill(player.autoGatherSkill) : null;
    const currentArea = player.currentGatherArea ? getGatheringArea(player.currentGatherArea) : null;
    
    let description = 'Choose a gathering activity to auto-farm resources continuously!\n\nüí° **How it works:**\n‚Ä¢ Gathers every 5 seconds automatically\n‚Ä¢ **Works in the background** - navigate freely!\n‚Ä¢ Return here anytime to check progress or stop\n‚Ä¢ Passive stat boosts as you level!';
    
    // Pick the right icon for the active skill (or default ‚õèÔ∏è)
    const skillIcon = gatheringSkill ? (gatheringSkill.icon || '‚õèÔ∏è') : '‚õèÔ∏è';

    if (isGathering && gatheringSkill) {
      const elapsedMs = Date.now() - player.autoGatherStartTime;
      const elapsedMinutes = Math.floor(elapsedMs / 60000);
      const areaText = currentArea ? ` at **${currentArea.name}**` : '';
      description = `üîÑ **Currently Gathering: ${gatheringSkill.name}**${areaText}\n‚è±Ô∏è Duration: ${elapsedMinutes} minutes\n${skillIcon} Cycles: ${player.autoGatherCount}\nüìà Total XP: ${player.autoGatherTotalXp}\n\n` + description;
    }
    
    const embed = new EmbedBuilder()
      .setColor(isGathering ? 0x27ae60 : 0x3498db)
      .setTitle(`${skillIcon} Auto-Gathering${gatheringSkill ? ': ' + gatheringSkill.name : ''}`)
      .setDescription(description);

    // Show selected gathering area if any
    if (player.currentGatherArea && currentArea) {
      const skillIcons = {
        mining: '‚õèÔ∏è',
        chopping: 'ü™ì',
        gathering: 'üåø'
      };
      const availableSkills = currentArea.skillTypes.map(s => skillIcons[s] || s).join(' ');
      
      embed.addFields({
        name: 'üìç Current Area',
        value: `**${currentArea.name}**\n${currentArea.description}\n‚≠ê Difficulty: ${currentArea.difficulty} | üíé Rare Chance: ${(currentArea.rarity * 100).toFixed(0)}%\nüéØ Available Skills: ${availableSkills}`,
        inline: false,
      });
    }

    const buttons = [];
    
    if (isGathering) {
      // Show status and stop button
      const statusRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-gather-status')
          .setLabel('üìä View Detailed Status')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('rpg-stop-autogather')
          .setLabel('‚èπÔ∏è Stop Gathering')
          .setStyle(ButtonStyle.Danger)
      );
      buttons.push(statusRow);
    } else {
      // Show skill selection - filter based on current area's available skills
      const areaSkillTypes = currentArea?.skillTypes || ['mining', 'chopping', 'gathering'];
      
      const skillRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-autogather-mining')
          .setLabel('‚õèÔ∏è Mining')
          .setStyle(ButtonStyle.Primary)
          .setDisabled(!areaSkillTypes.includes('mining')),
        new ButtonBuilder()
          .setCustomId('rpg-autogather-chopping')
          .setLabel('ü™ì Chopping')
          .setStyle(ButtonStyle.Primary)
          .setDisabled(!areaSkillTypes.includes('chopping')),
        new ButtonBuilder()
          .setCustomId('rpg-autogather-gathering')
          .setLabel('üåø Gathering')
          .setStyle(ButtonStyle.Primary)
          .setDisabled(!areaSkillTypes.includes('gathering'))
      );
      buttons.push(skillRow);

      // Add area selection and manage tools buttons
      const areaRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-gather-choose-area')
          .setLabel('üìç Choose Gathering Area')
          .setStyle(ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-manage-tools')
          .setLabel('üîß Manage Tools')
          .setStyle(ButtonStyle.Secondary)
      );
      buttons.push(areaRow);
    }
    
    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );
    buttons.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Handle gathering area selection - shows compact list
   */
  async handleGatheringAreaSelect(interaction, player, skipTracking = false) {
    if (!skipTracking) {
      this.trackMenuNavigation(player, 'gather-area-select');
    } else {
      // Even when skipping history, update currentMenu so back button works
      player.currentMenu = 'gather-area-select';
    }
    
    const playerLevel = player.level || 1;
    const gatheringLevel = getGatheringProfessionLevel(player);
    const currentTool = getGatheringToolTier(gatheringLevel);
    const toolEquipped = player.gatheringToolTier || 0;
    
    const availableAreas = getAvailableAreas(playerLevel);
    
    if (!availableAreas || availableAreas.length === 0) {
      await interaction.reply({
        content: '‚ùå No gathering areas available.',
        ephemeral: true,
      });
      return;
    }

    // Show compact list
    const areasList = availableAreas
      .map((area) => {
        const locked = playerLevel < area.minLevel ? ' üîí' : '';
        const selected = player.currentGatherArea === area.id ? ' ‚úÖ' : '';
        return `**${area.name}** (Lvl ${area.minLevel}+ | Diff ${area.difficulty})${locked}${selected}`;
      })
      .join('\n');

    const embed = new EmbedBuilder()
      .setColor(0xe74c3c)
      .setTitle('üìç Gathering Areas')
      .setDescription(
        `Select an area below to view details and set it as your gathering location.\n\n` +
        `**Current Tool:** ${currentTool.name} (${currentTool.tier})\n` +
        `**Gathering Level:** ${gatheringLevel}\n` +
        // Check if there's a higher tier tool available at this level
        `${GATHERING_TOOL_TIERS.some(t => gatheringLevel >= t.level && toolEquipped < GATHERING_TOOL_TIERS.indexOf(t)) ? '‚ö†Ô∏è _You can upgrade your tools!_' : '‚úÖ _Tool is up to date_'}`
      )
      .addFields({
        name: 'Available Areas',
        value: areasList,
        inline: false,
      });

    // Create select menu for detailed view
    const selectOptions = availableAreas.map((area) => {
      const isLocked = playerLevel < area.minLevel;
      const skills = area.skillTypes.map(s => s === 'mining' ? '‚õèÔ∏è' : s === 'chopping' ? 'ü™ì' : 'üåø').join('');
      return {
        label: area.name.substring(0, 100),
        value: area.id,
        description: `Lvl ${area.minLevel}+ | Diff ${area.difficulty} | ${(area.rarity * 100).toFixed(0)}% rare | ${skills} ${area.skillTypes.join(', ')}`,
        emoji: area.icon,
        default: player.currentGatherArea === area.id,
      };
    });

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-gather-area-select-menu')
      .setPlaceholder('Select an area to view details')
      .addOptions(selectOptions);

    const selectRow = new ActionRowBuilder().addComponents(selectMenu);

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back-to-gather')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  /**
   * Handle gathering area details view
   */
  async handleGatheringAreaDetails(interaction, player, areaId) {
    this.trackMenuNavigation(player, 'gather-area-details');
    
    const area = getGatheringArea(areaId);
    if (!area) {
      await interaction.reply({
        content: '‚ùå Area not found.',
        ephemeral: true,
      });
      return;
    }

    const playerLevel = player.level || 1;
    const isLocked = playerLevel < area.minLevel;
    const commonMaterials = (area.materials?.common || []).join(', ');
    const rareMaterials = (area.materials?.rare || []).join(', ');
    const skillTypes = area.skillTypes.join(', ');

    // Calculate drop chances for unified view - use cached materials
    const dashboardMaterials = this.getCachedData('dashboard-materials', getMaterials);
    let dropChances = { common: {}, rare: {} };

    const commonCount = area.materials?.common?.length || 0;
    const commonChance = commonCount > 0 ? ((1 - area.rarity) / commonCount) * 100 : 0;

    if (area.materials?.common) {
      area.materials.common.forEach((matId) => {
        const dashMat = dashboardMaterials[matId];
        const displayChance = dashMat?.dropChance || commonChance;
        dropChances.common[matId] = {
          chance: displayChance,
          source: dashMat ? 'dashboard' : 'hardcoded',
          level: dashMat?.adventureLevel || 1,
        };
      });
    }

    const rareCount = area.materials?.rare?.length || 0;
    const rareChance = rareCount > 0 ? (area.rarity / rareCount) * 100 : 0;

    if (area.materials?.rare) {
      area.materials.rare.forEach((matId) => {
        const dashMat = dashboardMaterials[matId];
        const displayChance = dashMat?.dropChance || rareChance;
        dropChances.rare[matId] = {
          chance: displayChance,
          source: dashMat ? 'dashboard' : 'hardcoded',
          level: dashMat?.adventureLevel || 1,
        };
      });
    }

    // Build drop chance field values
    const commonDropValue = Object.entries(dropChances.common)
      .sort((a, b) => b[1].chance - a[1].chance)
      .map(([matId, data]) => {
        const source = data.source === 'dashboard' ? 'üìå' : 'üìù';
        return `${source} **${matId}** - ${data.chance.toFixed(1)}%${data.level > 1 ? ` (Lvl ${data.level}+)` : ''}`;
      })
      .join('\n') || 'None';

    const rareDropValue = Object.entries(dropChances.rare)
      .sort((a, b) => b[1].chance - a[1].chance)
      .map(([matId, data]) => {
        const source = data.source === 'dashboard' ? 'üìå' : 'üìù';
        return `${source} **${matId}** - ${data.chance.toFixed(1)}%${data.level > 1 ? ` (Lvl ${data.level}+)` : ''}`;
      })
      .join('\n') || 'None';

    const embed = new EmbedBuilder()
      .setColor(isLocked ? 0xe74c3c : 0x27ae60)
      .setTitle(area.name)
      .setDescription(area.description)
      .addFields(
        { name: '‚≠ê Difficulty', value: `${area.difficulty}`, inline: true },
        { name: 'üìç Level Required', value: `${area.minLevel}+`, inline: true },
        { name: 'üíé Rare Chance', value: `${(area.rarity * 100).toFixed(0)}%`, inline: true },
        { name: 'üìà Base XP', value: `${area.baseXp}`, inline: true },
        { name: 'üéØ Skills', value: skillTypes, inline: true },
        { name: '', value: '', inline: true }, // spacer
        { name: 'üì¶ Common Materials', value: commonMaterials || 'None', inline: false },
        { name: '‚ú® Rare Materials', value: rareMaterials || 'None', inline: false },
        { name: `üìä Common Drop Chances (${((1 - area.rarity) * 100).toFixed(1)}% total)`, value: commonDropValue, inline: false },
        { name: `üìä Rare Drop Chances (${(area.rarity * 100).toFixed(1)}% total)`, value: rareDropValue, inline: false }
      );

    const rows = [];

    // Top row: Select area button only (no more separate drop chances button)
    const topRowButtons = [];
    if (!isLocked) {
      topRowButtons.push(
        new ButtonBuilder()
          .setCustomId(`rpg-gather-area-${areaId}`)
          .setLabel(`Select ${area.name.substring(0, 30)}`)
          .setStyle(ButtonStyle.Success)
      );
    }

    if (topRowButtons.length > 0) {
      rows.push(new ActionRowBuilder().addComponents(topRowButtons));
    }

    // Back button
    rows.push(
      new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-gather-area-details-back')
          .setLabel('‚Üê Back to Areas')
          .setStyle(ButtonStyle.Secondary)
      )
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  /**
   * Handle showing drop chances for gathering area
   */
  async handleGatheringAreaDrops(interaction, player, areaId) {
    this.trackMenuNavigation(player, 'gather-area-drops');

    const area = getGatheringArea(areaId);
    
    if (!area) {
      await interaction.update({
        content: `‚ùå Area not found.\nReceived ID: "${areaId}"\nAvailable: forest, mine, shadow_forest, deep_mine, enchanted_garden, mithril_mine, ancient_forest, dragon_peak, elders_grotto`,
        embeds: [],
        components: [],
      });
      return;
    }

    const playerLevel = player.level || 1;
    const dashboardMaterials = this.getCachedData('dashboard-materials', getMaterials);

    // Calculate drop chances
    let dropChances = { common: {}, rare: {} };

    // Hardcoded common materials
    const commonCount = area.materials?.common?.length || 0;
    const commonChance = commonCount > 0 ? ((1 - area.rarity) / commonCount) * 100 : 0;

    if (area.materials?.common) {
      area.materials.common.forEach((matId) => {
        const dashMat = dashboardMaterials[matId];
        const displayChance = dashMat?.dropChance || commonChance;
        dropChances.common[matId] = {
          chance: displayChance,
          source: dashMat ? 'dashboard' : 'hardcoded',
          level: dashMat?.adventureLevel || 1,
        };
      });
    }

    // Hardcoded rare materials
    const rareCount = area.materials?.rare?.length || 0;
    const rareChance = rareCount > 0 ? (area.rarity / rareCount) * 100 : 0;

    if (area.materials?.rare) {
      area.materials.rare.forEach((matId) => {
        const dashMat = dashboardMaterials[matId];
        const displayChance = dashMat?.dropChance || rareChance;
        dropChances.rare[matId] = {
          chance: displayChance,
          source: dashMat ? 'dashboard' : 'hardcoded',
          level: dashMat?.adventureLevel || 1,
        };
      });
    }

    // Build drop chance fields
    const commonFieldValue = Object.entries(dropChances.common)
      .sort((a, b) => b[1].chance - a[1].chance)
      .map(([matId, data]) => {
        const source = data.source === 'dashboard' ? 'üìå' : 'üìù';
        return `${source} **${matId}** - ${data.chance.toFixed(1)}%${data.level > 1 ? ` (Lvl ${data.level}+)` : ''}`;
      })
      .join('\n') || 'None';

    const rareFieldValue = Object.entries(dropChances.rare)
      .sort((a, b) => b[1].chance - a[1].chance)
      .map(([matId, data]) => {
        const source = data.source === 'dashboard' ? 'üìå' : 'üìù';
        return `${source} **${matId}** - ${data.chance.toFixed(1)}%${data.level > 1 ? ` (Lvl ${data.level}+)` : ''}`;
      })
      .join('\n') || 'None';

    const embed = new EmbedBuilder()
      .setColor(0x3498db)
      .setTitle(`üìä ${area.name} - Drop Chances`)
      .setDescription('Breakdown of material drop percentages in this area')
      .addFields(
        {
          name: `üì¶ Common Materials (${(((1 - area.rarity) * 100).toFixed(1))}% total)`,
          value: commonFieldValue,
          inline: false,
        },
        {
          name: `‚ú® Rare Materials (${((area.rarity * 100).toFixed(1))}% total)`,
          value: rareFieldValue,
          inline: false,
        },
        {
          name: 'Legend',
          value: 'üìù = Hardcoded Material\nüìå = Dashboard Material (crafting.json)',
          inline: false,
        }
      );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`rpg-gather-area-details-${areaId}`)
        .setLabel('‚Üê Back to Area Details')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backRow],
    });
  }

  /**
   * Handle gather status view - shows detailed overview directly
   */
  async handleGatherStatus(interaction, player) {
    return this.handleGatherDetailedOverview(interaction, player);
  }

  /**
   * Handle detailed gathering overview
   */
  async handleGatherDetailedOverview(interaction, player) {
    this.trackMenuNavigation(player, 'autogather-overview');
    
    if (!player.isAutoGathering) {
      await interaction.reply({ content: 'You are not currently gathering.', ephemeral: true });
      return;
    }

    const skill = getGatheringSkill(player.autoGatherSkill);
    const area = player.currentGatherArea ? getGatheringArea(player.currentGatherArea) : null;
    const elapsedMs = Date.now() - player.autoGatherStartTime;
    const elapsedSeconds = Math.floor(elapsedMs / 1000);
    const elapsedMinutes = Math.floor(elapsedSeconds / 60);
    const elapsedHours = Math.floor(elapsedMinutes / 60);

    const embed = new EmbedBuilder()
      .setColor(0x27ae60)
      .setTitle('üìä Gathering Session Overview')
      .addFields(
        { name: '‚öôÔ∏è Gathering Skill', value: String(skill?.name || player.autoGatherSkill || 'Unknown'), inline: true },
        { name: 'üìç Current Area', value: String(area?.name || 'Random Areas'), inline: true },
        { name: 'üìà Total XP Earned', value: String(player.autoGatherTotalXp || 0), inline: true },
        { name: '‚è±Ô∏è Duration', value: elapsedHours > 0 
          ? `${elapsedHours}h ${elapsedMinutes % 60}m` 
          : `${elapsedMinutes}m ${elapsedSeconds % 60}s`, inline: true },
        { name: '‚õèÔ∏è Gathering Cycles', value: String(player.autoGatherCount || 0), inline: true },
        { name: 'üì¶ Items in Inventory', value: String(player.inventory?.length || 0), inline: true }
      );

    // Show materials collected summary
    if (player.materials && Object.keys(player.materials).length > 0) {
      const materialsList = Object.entries(player.materials)
        .slice(0, 10)
        .map(([matId, qty]) => {
          const mat = getMaterial(matId);
          return `${mat?.name || matId}: **${qty}**`;
        })
        .join('\n');
      
      const remaining = Object.keys(player.materials).length > 10 
        ? `\n+(${Object.keys(player.materials).length - 10} more)`
        : '';
      
      const materialsValue = (materialsList || 'No materials yet') + remaining;
      
      embed.addFields({
        name: 'üíé Materials Collected',
        value: String(materialsValue),
        inline: false,
      });
    }

    // Add note about auto-updating
    embed.addFields({
      name: '‚ú® Auto-Updating',
      value: 'This view updates automatically every 30 seconds while active!',
      inline: false,
    });

    const buttonRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-stop-autogather')
        .setLabel('‚èπÔ∏è Stop Gathering')
        .setStyle(ButtonStyle.Danger),
      new ButtonBuilder()
        .setCustomId('rpg-back-to-gather')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    // Send the message and start updates
    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttonRow],
    });

    // Get message ID from interaction and start periodic updates
    try {
      const message = await interaction.fetchReply();
      if (message) {
        this.autoGatherManager.startMessageUpdates(
          player.userId,
          message.id,
          interaction.channelId,
          this.client
        );
      }
    } catch (err) {
      // Silently fail - message updates optional
    }
  }

  /**
   * Start auto-gathering for a player
   */
  async handleStartAutoGather(interaction, player, skillId) {
    this.trackMenuNavigation(player, 'autogather');
    
    // Handle "Gather All" button - find multi-skill area
    if (skillId === 'all') {
      if (player.pendingGatherAllMaterials && player.pendingGatherAllMaterials.length > 0) {
        const bestArea = this.getBestMultiSkillAreaForMaterials(
          player.pendingGatherAllMaterials,
          player.level || 1,
          player.worldsUnlocked || []
        );
        
        if (bestArea) {
          player.currentGatherArea = bestArea.id;
          // Default to first supported skill for the area
          skillId = bestArea.skillTypes[0];
        } else {
          await interaction.reply({ 
            content: '‚ùå No area found that supports all needed gathering types. Try selecting a specific skill instead.', 
            ephemeral: true 
          });
          return;
        }
        
        player.pendingGatherAllMaterials = null;
        player.pendingGatherMaterialsBySkill = null;
      } else {
        await interaction.reply({ content: '‚ùå No pending materials to gather.', ephemeral: true });
        return;
      }
    }

    const skill = getGatheringSkill(skillId);
    if (!skill) {
      await interaction.reply({ content: 'Unknown gathering skill.', ephemeral: true });
      return;
    }

    if (player.pendingGatherMaterialsBySkill && typeof player.pendingGatherMaterialsBySkill === 'object') {
      const pending = player.pendingGatherMaterialsBySkill[skillId] || [];
      if (pending.length > 0) {
        const bestArea = this.getBestGatheringAreaForMaterials(
          pending,
          skillId,
          player.level || 1,
          player.worldsUnlocked || []
        );
        player.currentGatherArea = bestArea ? bestArea.id : null;
      }
      player.pendingGatherAllMaterials = null;
      player.pendingGatherMaterialsBySkill = null;
      player.pendingGatherSkill = null;
    }

    // Start auto-gather
    const result = this.autoGatherManager.startAutoGather(player, skillId, interaction);
    if (!result.success) {
      await interaction.reply({ content: `Error: ${result.error}`, ephemeral: true });
      return;
    }

    this.persistPlayer(player);

    // Show initial summary
    const embed = this.autoGatherManager.createAutoGatherSummaryEmbed(player, skill);
    const buttons = this.autoGatherManager.getStopButton();

    // Update interaction - no periodic updates, just let them navigate away
    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });

    // Auto-gathering continues silently in background
    // No message updates - user can navigate freely without being interrupted
  }

  /**
   * Auto-gather from a specific area for missing materials
   */
  async handleAutoGatherFromArea(interaction, player, areaId) {
    this.trackMenuNavigation(player, 'autogather');
    
    const area = getGatheringArea(areaId);
    if (!area) {
      await interaction.reply({ content: '‚ùå Gathering area not found.', ephemeral: true });
      return;
    }

    // Set the area for gathering
    player.currentGatherArea = areaId;

    // Determine which skill to use (just use first available skill for this area)
    const skillId = area.skillTypes && area.skillTypes.length > 0 ? area.skillTypes[0] : 'gathering';
    const skill = getGatheringSkill(skillId);
    if (!skill) {
      await interaction.reply({ content: 'Unknown gathering skill.', ephemeral: true });
      return;
    }

    // Start auto-gather
    const result = this.autoGatherManager.startAutoGather(player, skillId, interaction);
    if (!result.success) {
      await interaction.reply({ content: `Error: ${result.error}`, ephemeral: true });
      return;
    }

    this.persistPlayer(player);

    // Show initial summary
    const embed = this.autoGatherManager.createAutoGatherSummaryEmbed(player, skill);
    const buttons = this.autoGatherManager.getStopButton();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Stop auto-gathering (legacy handler for individual gather - now unused)
   */
  async handleGather(interaction, player, skillId) {
    const skill = getGatheringSkill(skillId);
    if (!skill) {
      await interaction.reply({ content: 'Unknown gathering skill.', ephemeral: true });
      return;
    }

    const now = Date.now();
    const timeWaited = now - player.lastGatherTime[skillId];
    const minutesWaited = Math.floor(timeWaited / 60000);

    // Perform gathering - rarity based on wait time
    const balance = loadBalanceData();
    const baseXp = skill.baseXp;
    const xpMult = Number(balance.gatheringXpMultiplier) || 1;
    const xpGained = Math.floor(baseXp * (1 + player.gatheringLevels[skillId] * 0.1) * xpMult);
    const materialsRaw = generateGatheringMaterials(skillId, player.gatheringLevels[skillId], timeWaited);

    // Map materials to include names
    const materials = materialsRaw.map((mat) => {
      const matData = getMaterial(mat.id);
      return {
        ...mat,
        name: matData?.name || mat.id,
      };
    });

    // Add XP and check level up
    const currentLevel = player.gatheringLevels[skillId];
    const currentXpToLevel = getGatheringXpToNextLevel(currentLevel);
    player.gatheringXp[skillId] += xpGained;

    let levelsGained = 0;
    while (player.gatheringXp[skillId] >= currentXpToLevel) {
      player.gatheringXp[skillId] -= currentXpToLevel;
      player.gatheringLevels[skillId] += 1;
      levelsGained += 1;
    }

    // Add materials to inventory
    for (const mat of materials) {
      this.addMaterialToInventory(player, mat.id, mat.quantity);
    }

    // Track guild quest progress for gathering
    const dailyQuests = getAvailableDailyQuests(player.level, player.dailyQuestsCompleted);
    const weeklyQuests = getAvailableWeeklyQuests(player.level, player.weeklyQuestsCompleted);
    const claimedLimited = (player.claimedQuests || [])
      .map(id => getGuildQuestById(id))
      .filter(Boolean)
      .filter(q => !player.limitedQuestsCompleted.includes(q.id));

    if (!player.guildQuestProgress) player.guildQuestProgress = {};

    for (const mat of materials) {
      const event = {
        type: 'gather',
        target: mat.id,
        targetName: mat.name || mat.id,
        count: mat.quantity || 1,
      };
      this.applyGuildQuestProgress(player, dailyQuests, weeklyQuests, claimedLimited, event);
    }

    player.lastGatherTime[skillId] = now;
    player.clearStatsCache(); // Clear cache after gathering (gains stat boosts)
    this.persistPlayer(player);

    // Show results with time bonus info
    const embed = UIBuilder.createGatheringResultEmbed(
      skill,
      xpGained,
      levelsGained,
      player.gatheringLevels[skillId],
      materials,
      minutesWaited
    );

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId(`rpg-gather-again-${skillId}`)
        .setLabel(`${skill.icon} Again`)
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-back-to-gather')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Stop auto-gathering for a player
   */
  async handleStopAutoGather(interaction, player) {
    // Stop message updates
    this.autoGatherManager.stopMessageUpdates(player.userId);

    if (!player.isAutoGathering) {
      await interaction.reply({ content: 'You are not currently auto-gathering.', ephemeral: true });
      return;
    }

    const skill = getGatheringSkill(player.autoGatherSkill);
    const elapsedMs = Date.now() - player.autoGatherStartTime;
    const elapsedSeconds = Math.floor(elapsedMs / 1000);
    const elapsedMinutes = Math.floor(elapsedSeconds / 60);

    // Capture summary data BEFORE stopping (in case it gets cleared)
    const cycles = player.autoGatherCount || 0;
    const totalXp = player.autoGatherTotalXp || 0;
    const currentLevel = player.gatheringLevels[player.autoGatherSkill];
    const materialsGathered = { ...player.autoGatherMaterials }; // Copy the object

    // Transfer gathered materials to actual inventory before stopping
    if (player.autoGatherMaterials && Object.keys(player.autoGatherMaterials).length > 0) {
      for (const [materialId, quantity] of Object.entries(player.autoGatherMaterials)) {
        this.addMaterialToInventory(player, materialId, quantity);
      }
      // Clear the temporary gathering materials after transfer
      player.autoGatherMaterials = {};
    }

    // Stop the gathering
    this.autoGatherManager.stopAutoGather(player);
    this.persistPlayer(player);

    // Create final summary
    const embed = new EmbedBuilder()
      .setColor(0x2ecc71)
      .setTitle(`${skill.icon} Auto-Gathering Complete!`)
      .setDescription(`You finished your auto-gathering session.`)
      .addFields(
        {
          name: '‚è±Ô∏è Total Time',
          value: `${elapsedMinutes}m ${elapsedSeconds % 60}s`,
          inline: true,
        },
        {
          name: '‚õèÔ∏è Cycles',
          value: `${cycles}`,
          inline: true,
        },
        {
          name: 'üìà Total XP',
          value: `${totalXp}`,
          inline: true,
        },
        {
          name: '‚≠ê Level',
          value: `${currentLevel}`,
          inline: true,
        }
      )
      .setTimestamp();

    // Materials summary
    if (Object.keys(materialsGathered).length > 0) {
      let materialsText = Object.entries(materialsGathered)
        .map(([id, qty]) => {
          const mat = getMaterial(id);
          return `‚Ä¢ ${mat?.name || id}: ${qty}`;
        })
        .join('\n');
      embed.addFields({
        name: 'üß∞ Materials Gathered',
        value: materialsText,
        inline: false,
      });
    } else {
      embed.addFields({
        name: 'üß∞ Materials Gathered',
        value: 'No materials gathered yet',
        inline: false,
      });
    }

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Handle goals/objectives display
   */
  async handleGoals(interaction, player) {
    this.trackMenuNavigation(player, 'goals');
    const embed = UIBuilder.createGoalsEmbed(player);
    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Display gathering profession rewards and milestones
   */
  async handleGatheringRewards(interaction, player) {
    this.trackMenuNavigation(player, 'gather-rewards');
    this.applyMissingGatheringRewards(player);
    
    // Import the gathering rewards
    const { getGatheringProfessionLevel } = await import('../data/gathering.js');
    const { getGatheringReward, getNextGatheringMilestone, getGatheringRewardsUpTo } = await import('../data/gathering-rewards.js');
    
    const gatheringLevel = getGatheringProfessionLevel(player);
    const currentReward = getGatheringReward(gatheringLevel);
    const nextMilestone = getNextGatheringMilestone(gatheringLevel);
    const allRewards = getGatheringRewardsUpTo(gatheringLevel);
    
    // Build rewards list
    const rewardsList = allRewards
      .filter(r => !r.isSmall) // Only show major milestones
      .slice(-5) // Show last 5 major milestones
      .map(r => {
        const level = r.level;
        const rewards = r.rewards ? r.rewards.join(', ') : 'None';
        const tools = r.tools ? `\nüîß Tools: ${r.tools.join(', ')}` : '';
        const bonuses = r.passiveBonus ? 
          `\nüìä Stats: ${Object.entries(r.passiveBonus).map(([stat, val]) => `${stat}+${val}`).join(', ')}` : '';
        return `**Level ${level}**\n${rewards}${tools}${bonuses}`;
      })
      .join('\n\n');
    
    const embed = new EmbedBuilder()
      .setColor(0x27ae60)
      .setTitle('üéÅ Gathering Profession Rewards')
      .setDescription(
        `**Your Gathering Level: ${gatheringLevel}**\n\n` +
        `Gathering levels provide powerful bonuses including:\n` +
        `‚Ä¢ **Specialized Tools** that boost gathering efficiency\n` +
        `‚Ä¢ **Passive Stat Bonuses** that make you stronger\n` +
        `‚Ä¢ **Yield & Rarity Bonuses** for better materials\n` +
        `‚Ä¢ **Access to Better Areas** with rarer materials`
      );
    
    if (currentReward) {
      const currentBonuses = currentReward.passiveBonus ? 
        Object.entries(currentReward.passiveBonus).map(([stat, val]) => `${stat.toUpperCase()}+${val}`).join(', ') : 
        'None';
      embed.addFields({
        name: `‚ú® Current Level ${gatheringLevel} Bonuses`,
        value: currentBonuses,
        inline: false
      });
    }
    
    if (nextMilestone) {
      const nextRewards = nextMilestone.reward.rewards ? nextMilestone.reward.rewards.join('\n‚Ä¢ ') : 'None';
      embed.addFields({
        name: `üéØ Next Major Milestone: Level ${nextMilestone.level}`,
        value: `‚Ä¢ ${nextRewards}`,
        inline: false
      });
    }
    
    if (rewardsList) {
      embed.addFields({
        name: 'üìö Recent Milestones Unlocked',
        value: rewardsList || 'None yet',
        inline: false
      });
    }
    
    embed.setFooter({ text: 'Keep gathering to unlock more rewards!' });
    
    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back-to-gather')
        .setLabel('‚Üê Back to Gathering')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-hub')
        .setLabel('üè† Hub')
        .setStyle(ButtonStyle.Primary)
    );
    
    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backRow],
    });
  }

  /**
   * Handle gathering tools management
   */
  async handleGatheringTools(interaction, player) {
    this.trackMenuNavigation(player, 'gathering-tools');
    
    const gatheringLevel = getGatheringProfessionLevel(player);
    const currentToolTier = player.gatheringToolTier || 0;
    const availableToolTier = getGatheringToolTier(gatheringLevel);
    
    const embed = new EmbedBuilder()
      .setColor(0xffa500)
      .setTitle('üõ†Ô∏è Gathering Tools')
      .setDescription(
        `Upgrade your gathering tools to unlock higher tier equipment and improve your efficiency!\n\n` +
        `**Your Gathering Level:** ${gatheringLevel}\n` +
        `**Current Tool Tier:** ${currentToolTier || 'None'}\n` +
        `**Available Tool Tier:** ${availableToolTier.tier} (Level ${availableToolTier.level}+)`
      );

    // Show all tool tiers
    const worldsUnlocked = player.worldsUnlocked || [];
    const toolsList = GATHERING_TOOL_TIERS.map((tool, index) => {
      const isOwned = currentToolTier >= index;
      const hasWorldAccess = !tool.requiredWorld || worldsUnlocked.includes(tool.requiredWorld);
      const canBuy = gatheringLevel >= tool.level && currentToolTier < index && hasWorldAccess;
      const cost = Math.floor(500 * Math.pow(2, index)); // Exponential cost
      
      let status = '';
      if (isOwned) status = '‚úÖ Owned';
      else if (!hasWorldAccess) status = 'üåç Requires Asgard Access';
      else if (canBuy) status = `üí∞ ${cost} gold`;
      else status = `üîí Level ${tool.level}+ required`;
      
      return `**${tool.name}** (${tool.tier})\n‚îî ${status}`;
    }).join('\n\n');

    embed.addFields({
      name: 'üì¶ Available Tools',
      value: toolsList,
      inline: false,
    });

    embed.addFields({
      name: 'üí° Benefits',
      value: 
        '‚Ä¢ **Better Tools** = Higher efficiency\n' +
        '‚Ä¢ **Unlock Tool Recipes** at gathering profession milestones\n' +
        '‚Ä¢ **Automatic Upgrades** when you reach new tier levels',
      inline: false,
    });

    const rows = [];
    
    // Add purchase buttons for available tools
    const buyButtons = [];
    GATHERING_TOOL_TIERS.forEach((tool, index) => {
      const hasWorldAccess = !tool.requiredWorld || worldsUnlocked.includes(tool.requiredWorld);
      const canBuy = gatheringLevel >= tool.level && currentToolTier < index && hasWorldAccess;
      if (canBuy && buyButtons.length < 5) {
        const cost = Math.floor(500 * Math.pow(2, index));
        buyButtons.push(
          new ButtonBuilder()
            .setCustomId(`rpg-buy-gathering-tool-${index}`)
            .setLabel(`${tool.tier} (${cost}g)`)
            .setStyle(ButtonStyle.Success)
            .setDisabled((player.gold || 0) < cost)
        );
      }
    });

    if (buyButtons.length > 0) {
      rows.push(new ActionRowBuilder().addComponents(buyButtons));
    }

    // Back button
    rows.push(
      new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-back-to-gather')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      )
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  /**
   * Handle buying a gathering tool
   */
  async handleBuyGatheringTool(interaction, player, tier) {
    const gatheringLevel = getGatheringProfessionLevel(player);
    const currentToolTier = player.gatheringToolTier || 0;
    const tool = GATHERING_TOOL_TIERS[tier];
    
    if (!tool) {
      await interaction.reply({
        content: '‚ùå Invalid tool tier.',
        ephemeral: true,
      });
      return;
    }

    // Check requirements
    if (gatheringLevel < tool.level) {
      await interaction.reply({
        content: `‚ùå You need gathering level ${tool.level}+ to purchase this tool.`,
        ephemeral: true,
      });
      return;
    }

    // Check world access requirement
    if (tool.requiredWorld) {
      const worldsUnlocked = player.worldsUnlocked || [];
      if (!worldsUnlocked.includes(tool.requiredWorld)) {
        await interaction.reply({
          content: `‚ùå You need to unlock Asgard (Tier 2 World) to purchase this tool!`,
          ephemeral: true,
        });
        return;
      }
    }

    if (currentToolTier >= tier) {
      await interaction.reply({
        content: '‚ùå You already own this or a better tool!',
        ephemeral: true,
      });
      return;
    }

    const cost = Math.floor(500 * Math.pow(2, tier));
    if ((player.gold || 0) < cost) {
      await interaction.reply({
        content: `‚ùå Not enough gold! Need ${cost}, have ${player.gold || 0}.`,
        ephemeral: true,
      });
      return;
    }

    // Purchase the tool
    player.gold -= cost;
    this.trackGoldSpent(player, cost, 'shop');
    player.gatheringToolTier = tier;
    this.persistPlayer(player);

    // Refresh the tools menu
    await this.handleGatheringTools(interaction, player);
  }

  /**
   * Handle Master Blacksmith upgrade purchase
   */
  async handleMasterBlacksmithUpgrade(interaction, player) {
    const hasAsgardAccess = (player.worldsUnlocked || []).includes('world_1770519709022');
    const blacksmithLevel = player.professionLevels?.blacksmith || 0;
    const cost = 50000;

    // Check requirements
    if (!hasAsgardAccess) {
      await interaction.reply({
        content: '‚ùå You must unlock Asgard (Tier 2 World) to upgrade to Master Blacksmith!',
        ephemeral: true,
      });
      return;
    }

    if (blacksmithLevel < 25) {
      await interaction.reply({
        content: `‚ùå You need Blacksmith level 25+ to upgrade! (Current: ${blacksmithLevel})`,
        ephemeral: true,
      });
      return;
    }

    if (player.masterBlacksmith) {
      await interaction.reply({
        content: '‚ùå You are already a Master Blacksmith!',
        ephemeral: true,
      });
      return;
    }

    if ((player.gold || 0) < cost) {
      await interaction.reply({
        content: `‚ùå Not enough gold! Need ${cost.toLocaleString()}, have ${(player.gold || 0).toLocaleString()}.`,
        ephemeral: true,
      });
      return;
    }

    // Purchase the upgrade
    player.gold -= cost;
    this.trackGoldSpent(player, cost, 'upgrades');
    player.masterBlacksmith = true;
    this.persistPlayer(player);

    const embed = new EmbedBuilder()
      .setColor(0xff6600)
      .setTitle('üî• Master Blacksmith Unlocked!')
      .setDescription(
        `You have ascended to the legendary rank of **Master Blacksmith**!\n\n` +
        `**New Abilities Unlocked:**\n` +
        `üíé **Gem Crafting** - Forge powerful gems from rare materials\n` +
        `üî∑ **Gem Socketing** - Socket gems into equipment for bonus stats\n` +
        `üìú **Legendary Recipes** - Access to Norse god-tier gem recipes\n\n` +
        `**Socket Slots:**\n` +
        `‚öîÔ∏è Weapon: 2 sockets\n` +
        `üõ°Ô∏è Chest: 2 sockets\n` +
        `üëñ Legs: 1 socket\n` +
        `üë¢ Boots: 1 socket\n` +
        `üß§ Gloves: 1 socket\n` +
        `‚õëÔ∏è Helmet: 1 socket`
      )
      .setFooter({ text: 'Visit the professions menu to socket gems and craft legendary items!' });

    await interaction.reply({
      embeds: [embed],
      ephemeral: false,
    });
  }

  /**
   * Handle gem socketing interface
   */
  async handleGemSocketing(interaction, player) {
    if (!player.masterBlacksmith) {
      await interaction.reply({
        content: '‚ùå You need to upgrade to Master Blacksmith to socket gems!',
        ephemeral: true,
      });
      return;
    }

    const { getGem, calculateGemStats, getSocketSlots } = await import('../data/gems.js');
    const socketedGems = player.socketedGems || {};
    const gemStats = calculateGemStats(socketedGems);

    const embed = new EmbedBuilder()
      .setColor(0x9d00ff)
      .setTitle('üíé Gem Socketing')
      .setDescription(
        `Socket powerful gems into your equipment to gain bonus stats!\n\n` +
        `**Your Socketed Gems:**`
      );

    // Show currently equipped items and their sockets
    const equippedSlots = ['weapon', 'chest', 'legs', 'boots', 'gloves', 'helmet'];
    const slotEmojis = {
      weapon: '‚öîÔ∏è',
      chest: 'üõ°Ô∏è',
      legs: 'üëñ',
      boots: 'üë¢',
      gloves: 'üß§',
      helmet: '‚õëÔ∏è',
    };

    let socketInfo = '';
    equippedSlots.forEach(slot => {
      const equippedItem = player.equippedItems?.[slot];
      const maxSockets = getSocketSlots(slot);
      const slotGems = socketedGems[slot] || {};
      
      if (equippedItem) {
        socketInfo += `\n${slotEmojis[slot]} **${slot.charAt(0).toUpperCase() + slot.slice(1)}** (${maxSockets} socket${maxSockets > 1 ? 's' : ''})\n`;
        for (let i = 1; i <= maxSockets; i++) {
          const gemId = slotGems[`socket${i}`];
          if (gemId) {
            const gem = getGem(gemId);
            socketInfo += `  ‚îî Socket ${i}: ${gem?.name || 'Unknown Gem'}\n`;
          } else {
            socketInfo += `  ‚îî Socket ${i}: Empty\n`;
          }
        }
      }
    });

    embed.addFields({
      name: 'Equipped Gear',
      value: socketInfo || 'No equipment equipped!',
      inline: false,
    });

    // Show total stats from gems
    if (Object.keys(gemStats).length > 0) {
      const statsList = Object.entries(gemStats)
        .map(([stat, value]) => `${stat}: +${value}`)
        .join('\\n');
      embed.addFields({
        name: 'Total Gem Bonuses',
        value: statsList,
        inline: false,
      });
    }

    // Show available gems in inventory
    const gemIds = Object.keys(await import('../data/gems.js')).filter(k => k !== 'default');
    const availableGems = (player.inventory || []).filter(item => 
      gemIds.some(gemId => item === gemId || item?.id === gemId)
    );

    if (availableGems.length > 0) {
      const gemList = availableGems
        .slice(0, 10)
        .map(item => {
          const itemId = typeof item === 'string' ? item : item.id;
          const gem = getGem(itemId);
          return gem ? `‚Ä¢ ${gem.name} (${gem.tier})` : `‚Ä¢ ${itemId}`;
        })
        .join('\n');
      embed.addFields({
        name: 'Available Gems in Inventory',
        value: gemList + (availableGems.length > 10 ? `\n...and ${availableGems.length - 10} more` : ''),
        inline: false,
      });
    } else {
      embed.addFields({
        name: 'Available Gems',
        value: 'No gems in inventory. Craft gems using blacksmith recipes!',
        inline: false,
      });
    }

    const rows = [
      new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back to Professions')
          .setStyle(ButtonStyle.Secondary)
      ),
    ];

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  /**
   * Handle shop display
   */
  async handleShop(interaction, player) {
    this.trackMenuNavigation(player, 'shop');
    const unlockedTiers = getUnlockedShopTiers(player);
    const getItemDisplayName = (itemId) => {
      const equipment = getEquipment(itemId);
      const item = getItemByIdDynamic(itemId);
      const material = getMaterial(itemId);
      return equipment?.name || item?.name || material?.name || itemId;
    };

    const embed = UIBuilder.createShopEmbed(unlockedTiers, getItemDisplayName);
    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
    });
  }

  /**
   * Start a quest from the detail view
   */
  async handleStartQuestFromDetail(interaction, player, questId) {
    const { main, side, daily } = getQuestCategoriesByWorld(player.currentWorld);
    const weekly = getWeeklyQuests(player) || [];
    const allDefense = loadDefenseQuests();
    
    let quest = null;
    let questType = null;
    
    // Search for quest in all categories
    for (const q of main || []) {
      if (q.id === questId) {
        quest = q;
        questType = 'main';
        break;
      }
    }
    if (!quest) {
      for (const q of side || []) {
        if (q.id === questId) {
          quest = q;
          questType = 'side';
          break;
        }
      }
    }
    if (!quest) {
      for (const q of daily || []) {
        if (q.id === questId) {
          quest = q;
          questType = 'daily';
          break;
        }
      }
    }
    if (!quest) {
      for (const q of weekly || []) {
        if (q.id === questId) {
          quest = q;
          questType = 'weekly';
          break;
        }
      }
    }
    if (!quest) {
      for (const q of allDefense) {
        if (q.id === questId) {
          quest = q;
          questType = 'defense';
          break;
        }
      }
    }

    if (!quest) {
      await interaction.reply({ content: 'Quest not found.', ephemeral: true });
      return;
    }

    const allQuests = [...(main || []), ...(side || []), ...(daily || []), ...weekly, ...allDefense];

    // Check if already completed
    if (player.hasQuestFlag(questId)) {
      await interaction.reply({ content: '‚úÖ You already completed this quest.', ephemeral: true });
      return;
    }

    // Show warning if below recommended level but allow starting
    let levelWarning = '';
    if (player.level < quest.minLevel) {
      levelWarning = `\n‚ö†Ô∏è **Warning:** Recommended level is ${quest.minLevel}, you are level ${player.level}. This may be difficult!`;
    }

    // Handle quests with branches (quest chains with choices)
    const hasLinearStepChain = allQuests.some(q => q.id === `${questId}_step1`);
    const hasChainBranches = Array.isArray(quest.branches) && quest.branches.some(b => b.nextQuestId) && !hasLinearStepChain;
    if (hasChainBranches) {
      // Quest chain with branch selection
      await this.handleQuestChoice(interaction, player, quest, levelWarning);
      return;
    }

    // Handle choice-based quests (outcome-based choices)
    if ((questType === 'defense' && quest.type === 'choice') || quest.type === 'choice') {
      await this.handleQuestChoice(interaction, player, quest, levelWarning);
      return;
    }

    // Start combat for combat quests
    if ((questType === 'defense' && quest.type === 'combat') || questType !== 'defense') {
      // For defense quests, use enemy data
      let enemyData = quest.enemy;
      
      if (!enemyData) {
        // For regular quests, create a scaled enemy based on quest level
        const questLevel = quest.minLevel || player.level;
        
        // Generate enemy name from quest description
        let enemyName = `${quest.name}`;
        
        // Extract enemy type from quest description or name
        const description = (quest.description || '').toLowerCase();
        const questName = (quest.name || '').toLowerCase();
        const combined = description + ' ' + questName;
        
        if (combined.includes('dragon') || combined.includes('wyrm')) {
          enemyName = `Ancient Wyrm`;
        } else if (combined.includes('giant') || combined.includes('titan')) {
          enemyName = `Frost Giant`;
        } else if (combined.includes('dark elf') || combined.includes('elf')) {
          enemyName = `Dark Elf Warrior`;
        } else if (combined.includes('construct') || combined.includes('golem')) {
          enemyName = `Ancient Construct`;
        } else if (combined.includes('demon') || combined.includes('fiend')) {
          enemyName = `Demon Lord`;
        } else if (combined.includes('undead') || combined.includes('skeleton') || combined.includes('zombie')) {
          enemyName = `Undead Champion`;
        } else if (combined.includes('beast') || combined.includes('wolf') || combined.includes('bear')) {
          enemyName = `Mythical Beast`;
        } else if (combined.includes('shadow') || combined.includes('wraith')) {
          enemyName = `Shadow Wraith`;
        } else if (combined.includes('champion') || combined.includes('warlord') || combined.includes('einherjar')) {
          enemyName = `Elite Champion`;
        } else if (combined.includes('bandit') || combined.includes('thief') || combined.includes('raider')) {
          enemyName = `Bandit Leader`;
        } else if (combined.includes('cultist') || combined.includes('ritual')) {
          enemyName = `Dark Cultist`;
        } else {
          enemyName = `${quest.name} - Boss`;
        }
        
        // Scale stats based on quest level (matching Enemy.js scaling)
        const levelMultiplier = 1 + (questLevel - 1) * 0.18;
        
        // Quest enemies are slightly stronger than normal enemies (1.5x multiplier)
        const questMultiplier = 1.5;
        
        // Generate proper stats
        const baseHp = 70;
        const baseStr = 10;
        const baseDef = 8;
        const baseAgi = 6;
        const baseInt = 6;
        
        enemyData = {
          name: enemyName,
          level: questLevel,
          hp: Math.floor(baseHp * levelMultiplier * questMultiplier),
          stats: {
            strength: Math.floor(baseStr * levelMultiplier * questMultiplier),
            defense: Math.floor(baseDef * levelMultiplier * questMultiplier),
            intelligence: Math.floor(baseInt * levelMultiplier * questMultiplier),
            agility: Math.floor(baseAgi * levelMultiplier * questMultiplier)
          },
          skills: [] // Could add skills for higher level quests
        };
        
        // Add a skill for higher level quests (level 50+)
        if (questLevel >= 50) {
          enemyData.skills = ['power_strike']; // Basic combat skill
        }
        if (questLevel >= 80) {
          enemyData.skills.push('shield_bash'); // Add defensive skill
        }
        if (questLevel >= 100) {
          enemyData.skills.push('whirlwind'); // Add AoE skill
        }
      }

      const combatState = this.combatSystem.startCombatWithCustomEnemy(
        player,
        enemyData.name,
        enemyData.level,
        enemyData.hp,
        enemyData.stats,
        enemyData.skills,
        { defenseQuest: questType === 'defense' ? questId : null, worldQuest: questType !== 'defense' ? questId : null }
      );

      const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
      if (levelWarning) {
        embed.setDescription((embed.data.description || '') + levelWarning);
      }

      const row1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-combat-auto')
          .setLabel('‚öîÔ∏è Auto Battle')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-combat-manual')
          .setLabel('üéÆ Manual Combat')
          .setStyle(ButtonStyle.Success)
      );

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], components: [row1] });
    }
  }

  /**
   * Start a defense quest battle
   */
  async handleDefenseQuestComplete(interaction, player, questId) {
    const quest = getDefenseQuestById(questId);
    if (!quest) {
      await interaction.reply({ content: 'Quest not found.', ephemeral: true });
      return;
    }

    if (player.hasQuestFlag(quest.id)) {
      await interaction.reply({ content: 'You already completed this defense quest.', ephemeral: true });
      return;
    }

    // Show warning but allow starting quest below recommended level
    let levelWarning = '';
    if (player.level < quest.minLevel) {
      levelWarning = '‚ö†Ô∏è **Warning:** Recommended level is ' + quest.minLevel + ', you are level ' + player.level + '. This may be difficult!\n\n';
    }

    if (quest.unlocks && !player.hasQuestFlag(quest.unlocks)) {
      await interaction.reply({ content: 'Complete the previous defense quest first.', ephemeral: true });
      return;
    }

    // Handle choice-based quests
    if (quest.type === 'choice' && quest.branches && quest.branches.length > 0) {
      await this.handleQuestChoice(interaction, player, quest, levelWarning);
      return;
    }

    // Start combat with quest enemy
    const enemyData = quest.enemy;
    const combatState = this.combatSystem.startCombatWithCustomEnemy(
      player,
      enemyData.name,
      enemyData.level,
      enemyData.hp,
      enemyData.stats,
      enemyData.skills,
      { defenseQuest: quest.id }
    );

    const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
    
    // Add level warning if exists
    if (levelWarning) {
      embed.setDescription((embed.data.description || '') + '\n\n' + levelWarning);
    }

    const row = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-combat-auto')
        .setLabel('‚öîÔ∏è Auto Battle')
        .setStyle(ButtonStyle.Primary)
    );

    // Use updateInteractionWithTracking instead of reply to keep the menu open
    await this.updateInteractionWithTracking(interaction, { 
      embeds: [embed], 
      components: [row] 
    });
  }

  /**
   * Handle quest choice presentation
   */
  async handleQuestChoice(interaction, player, quest, levelWarning = '') {
    // Check if this is a quest chain branch quest (has nextQuestId) vs outcome-based quest
    const { main, side } = getQuestCategoriesByWorld(player.currentWorld);
    const allQuests = [...(main || []), ...(side || [])];
    const hasLinearStepChain = allQuests.some(q => q.id === `${quest.id}_step1`);
    const isChainBranch = quest.branches?.some(branch => branch.nextQuestId) && !hasLinearStepChain;
    
    if (isChainBranch) {
      // Quest chain branch selection - each branch leads to a different quest
      const { daily } = getQuestCategoriesByWorld(player.currentWorld);
      
      const embed = new EmbedBuilder()
        .setColor(0x5865f2)
        .setTitle(`üìú ${quest.name}`)
        .setDescription(levelWarning + quest.description + '\n\n**Choose your path:**')
        .setFooter({ text: 'Your choice will have consequences and lead to a different ending!' });

      // Create buttons for each branch
      const buttons = quest.branches.slice(0, 5).map((branch, idx) => 
        new ButtonBuilder()
          .setCustomId(`rpg-quest-chain-choice-${quest.id}-${idx}`)
          .setLabel(branch.choice)
          .setStyle(ButtonStyle.Primary)
      );

      // Add branch descriptions with next quest info
      for (let i = 0; i < quest.branches.length; i++) {
        const branch = quest.branches[i];
        const nextQuest = allQuests.find(q => q.id === branch.nextQuestId);
        const nextQuestInfo = nextQuest ? `\n‚Üí Continues as: **${nextQuest.name}** (Lvl ${nextQuest.minLevel})` : '';
        
        embed.addFields({
          name: `Path ${i + 1}: ${branch.choice}`,
          value: nextQuestInfo || 'Next quest: Unknown',
          inline: false,
        });
      }

      const rows = [];
      for (let i = 0; i < buttons.length; i += 5) {
        rows.push(new ActionRowBuilder().addComponents(buttons.slice(i, i + 5)));
      }

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: rows,
      });
    } else {
      // Original outcome-based quest choice system
      const embed = new EmbedBuilder()
        .setColor(0xffa500)
        .setTitle(`üìú ${quest.name}`)
        .setDescription(levelWarning + quest.description + '\n\n**Choose your path:**')
        .setFooter({ text: 'Your choice will have consequences!' });

      // Create buttons for each branch
      const buttons = quest.branches.slice(0, 5).map(branch => 
        new ButtonBuilder()
          .setCustomId(`rpg-quest-choice-${quest.id}-${branch.id}`)
          .setLabel(branch.title)
          .setStyle(ButtonStyle.Primary)
      );

      // Add branch descriptions as fields
      quest.branches.forEach(branch => {
        embed.addFields({
          name: branch.title,
          value: branch.description,
          inline: false,
        });
      });

      const rows = [];
      for (let i = 0; i < buttons.length; i += 5) {
        rows.push(new ActionRowBuilder().addComponents(buttons.slice(i, i + 5)));
      }

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: rows,
      });
    }
  }

  /**
   * Handle quest chain branch selection - starts the next quest in the chain
   */
  async handleQuestChainBranchSelection(interaction, player, questId, branchIdx) {
    const { main, side, daily } = getQuestCategoriesByWorld(player.currentWorld);
    const weekly = getWeeklyQuests(player) || [];
    const allDefense = loadDefenseQuests();
    
    let quest = null;
    let questType = null;
    
    // Search for quest in all categories
    for (const q of [...(main || []), ...(side || []), ...(daily || []), ...weekly, ...allDefense]) {
      if (q.id === questId) {
        quest = q;
        questType = quest.type || (allDefense.includes(q) ? 'defense' : 'side');
        break;
      }
    }

    if (!quest || !quest.branches || !quest.branches[branchIdx]) {
      await interaction.reply({ content: '‚ùå Quest or branch not found.', ephemeral: true });
      return;
    }

    const branch = quest.branches[branchIdx];
    const nextQuestId = branch.nextQuestId;

    if (!nextQuestId) {
      await interaction.reply({ content: '‚ùå This branch has no next quest configured.', ephemeral: true });
      return;
    }

    // Mark the current quest as completed and the choice as made
    player.setQuestFlag(questId, true);
    
    // Store which branch was chosen for reference
    if (!player.questFlags) player.questFlags = {};
    const existingFlag = player.questFlags[questId];
    if (!existingFlag || typeof existingFlag !== 'object') {
      player.questFlags[questId] = { completed: !!existingFlag };
    }
    player.questFlags[questId].chosenBranch = branchIdx;
    player.questFlags[questId].chosenBranchQuestId = nextQuestId;

    // Start the next quest
    await this.handleStartQuestFromDetail(interaction, player, nextQuestId);
  }

  /**
   * Handle quest choice selection
   */
  async handleQuestChoiceSelection(interaction, player, questId, branchId) {
    const quest = getDefenseQuestById(questId);
    if (!quest) {
      await interaction.reply({ content: 'Quest not found.', ephemeral: true });
      return;
    }

    const outcome = quest.outcomes?.find(o => o.branchId === branchId);
    if (!outcome) {
      await interaction.reply({ content: 'Invalid choice.', ephemeral: true });
      return;
    }

    // Apply the outcome
    await this.applyQuestOutcome(player, quest, outcome);

    // Create result embed
    const embed = new EmbedBuilder()
      .setColor(outcome.isNegative ? 0xff0000 : 0x00ff00)
      .setTitle(`${outcome.isNegative ? '‚ö†Ô∏è' : '‚úÖ'} ${outcome.title}`)
      .setDescription(outcome.description);

    // Show rewards/losses
    const rewardText = [];
    if (outcome.reward.xp !== 0) {
      rewardText.push(`**XP:** ${outcome.reward.xp > 0 ? '+' : ''}${outcome.reward.xp}`);
    }
    if (outcome.reward.gold !== 0) {
      rewardText.push(`**Gold:** ${outcome.reward.gold > 0 ? '+' : ''}${outcome.reward.gold}`);
    }
    if (outcome.reward.items?.length > 0) {
      rewardText.push(`**Items:** ${outcome.reward.items.map(i => `${i.id} x${i.quantity || 1}`).join(', ')}`);
    }

    if (rewardText.length > 0) {
      embed.addFields({
        name: outcome.isNegative ? 'Consequences' : 'Rewards',
        value: rewardText.join('\\n'),
        inline: false,
      });
    }

    // Show special effects
    if (outcome.consequences) {
      const consequenceText = [];
      if (outcome.consequences.healthLoss) {
        consequenceText.push(`‚ù§Ô∏è Lost ${outcome.consequences.healthLoss}% health`);
      }
      if (outcome.consequences.debuff) {
        consequenceText.push(`üîª Debuff: ${outcome.consequences.debuff.name}`);
      }
      if (outcome.consequences.permanentDebuff) {
        consequenceText.push(`‚ö†Ô∏è Permanent: ${outcome.consequences.permanentDebuff.name}`);
      }
      if (outcome.consequences.vendorPriceIncrease) {
        consequenceText.push(`üí∞ Vendors charge ${outcome.consequences.vendorPriceIncrease}% more`);
      }
      if (outcome.consequences.goldLossPerDay) {
        consequenceText.push(`üí∏ Lose ${outcome.consequences.goldLossPerDay} gold per day`);
      }

      if (consequenceText.length > 0) {
        embed.addFields({
          name: '‚ö†Ô∏è Additional Effects',
          value: consequenceText.join('\\n'),
          inline: false,
        });
      }
    }

    if (outcome.bonuses) {
      const bonusText = [];
      if (outcome.bonuses.nextCombatBonus) {
        const bonuses = Object.entries(outcome.bonuses.nextCombatBonus)
          .map(([stat, val]) => `+${val} ${stat.toUpperCase()}`)
          .join(', ');
        bonusText.push(`‚öîÔ∏è Next Combat: ${bonuses}`);
      }
      if (outcome.bonuses.permanentBuff) {
        bonusText.push(`‚ú® Permanent: ${outcome.bonuses.permanentBuff.name}`);
      }
      if (outcome.bonuses.skillUnlock) {
        bonusText.push(`üéØ Skill Unlocked: ${outcome.bonuses.skillUnlock}`);
      }

      if (bonusText.length > 0) {
        embed.addFields({
          name: '‚ú® Bonuses',
          value: bonusText.join('\\n'),
          inline: false,
        });
      }
    }

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-quests')
        .setLabel('‚Üê Back to Quests')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backButton],
    });
  }

  /**
   * Apply quest outcome effects to player
   */
  async applyQuestOutcome(player, quest, outcome) {
    // Mark quest as complete
    player.setQuestFlag(quest.id, true);

    // Set outcome flags
    if (outcome.flagsSet) {
      outcome.flagsSet.forEach(flag => player.setQuestFlag(flag, true));
    }

    // Apply rewards
    if (outcome.reward.xp) {
      player.addXp(Math.max(0, outcome.reward.xp));
    }
    if (outcome.reward.gold) {
      player.gold = Math.max(0, player.gold + outcome.reward.gold);
    }
    if (outcome.reward.items) {
      outcome.reward.items.forEach(item => {
        const quantity = item.quantity || 1;
        for (let i = 0; i < quantity; i++) {
          player.inventory.push({
            id: item.id,
            name: item.id,
            type: item.type || 'item',
            quantity: 1,
          });
        }
      });
    }

    // Apply consequences
    if (outcome.consequences) {
      if (outcome.consequences.healthLoss) {
        const lossPercent = outcome.consequences.healthLoss / 100;
        player.hp = Math.max(1, Math.floor(player.hp * (1 - lossPercent)));
      }

      if (outcome.consequences.debuff) {
        if (!player.activeDebuffs) player.activeDebuffs = [];
        player.activeDebuffs.push(outcome.consequences.debuff);
      }

      if (outcome.consequences.permanentDebuff) {
        if (!player.permanentEffects) player.permanentEffects = [];
        player.permanentEffects.push(outcome.consequences.permanentDebuff);
      }

      if (outcome.consequences.vendorPriceIncrease) {
        if (!player.questEffects) player.questEffects = {};
        player.questEffects.vendorPriceIncrease = outcome.consequences.vendorPriceIncrease;
        player.questEffects.vendorPriceIncreaseCount = 3;
      }

      if (outcome.consequences.goldLossPerDay) {
        if (!player.questEffects) player.questEffects = {};
        player.questEffects.goldLossPerDay = outcome.consequences.goldLossPerDay;
      }
    }

    // Apply bonuses
    if (outcome.bonuses) {
      if (outcome.bonuses.nextCombatBonus) {
        if (!player.questEffects) player.questEffects = {};
        player.questEffects.nextCombatBonus = outcome.bonuses.nextCombatBonus;
      }

      if (outcome.bonuses.permanentBuff) {
        if (!player.permanentEffects) player.permanentEffects = [];
        player.permanentEffects.push(outcome.bonuses.permanentBuff);
      }

      if (outcome.bonuses.skillUnlock) {
        if (!player.skills.includes(outcome.bonuses.skillUnlock)) {
          player.skills.push(outcome.bonuses.skillUnlock);
        }
      }
    }

    player.clearStatsCache();
    this.persistPlayer(player);
  }

  /**
   * Start a boss combat encounter
   */
  async handleBossCombat(interaction, player, bossId) {
    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({
        content: 'You are already in combat!',
        ephemeral: true,
      });
      return;
    }

    const bossTemplate = getBossTemplate(bossId);
    if (!bossTemplate) {
      await interaction.reply({
        content: '‚ùå Boss not found!',
        ephemeral: true,
      });
      return;
    }

    // Show combat style selection before boss fight
    const styles = getStylesForClass(player.class || player.internalClass);
    
    if (styles.length > 0) {
      const options = styles.map((style) => ({
        label: style.name,
        value: `boss-style-${bossId}-${style.id}`,
        description: style.description,
        emoji: style.icon,
      }));

      const selectRow = new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-boss-style-select')
          .setPlaceholder('Choose Combat Style for Boss Fight')
          .addOptions(options)
      );

      const embed = new EmbedBuilder()
        .setColor(0xff0000)
        .setTitle(`‚öîÔ∏è ${bossTemplate.name} - Choose Your Style`)
        .setDescription('Select your combat style before facing this boss!')
        .addFields(
          { name: 'Boss Info', value: `Element: ${bossTemplate.element}\nWeakness: ${bossTemplate.weakness}\nResistance: ${bossTemplate.resistance}` }
        );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [selectRow],
      });
    } else {
      await this.startBossFight(interaction, player, bossId);
    }
  }

  async startBossFight(interaction, player, bossId, styleId = null) {
    const bossTemplate = getBossTemplate(bossId);
    if (!bossTemplate) return;

    const combatState = this.combatSystem.startBossCombat(
      player,
      bossTemplate.name,
      bossId,
      Math.max(player.level, 5)
    );

    if (!combatState) {
      await interaction.reply({ content: 'Failed to start boss combat!', ephemeral: true });
      return;
    }

    if (styleId) {
      combatState.combatStyle = getCombatStyle(styleId);
    }

    this.persistPlayer(player);

    const embed = new EmbedBuilder()
      .setColor(0xff0000)
      .setTitle(`üî• Boss Battle: ${combatState.enemy.name}`)
      .setDescription(`${combatState.enemy.hp}/${combatState.enemy.maxHp} HP`)
      .addFields(
        { name: `${combatState.environment.name}`, value: combatState.environment.description },
        { name: '‚öîÔ∏è Phase 1', value: bossTemplate.phase1.description }
      );

    if (combatState.combatStyle) {
      embed.addFields({
        name: `${combatState.combatStyle.icon} ${combatState.combatStyle.name}`,
        value: combatState.combatStyle.description
      });
    }

    const buttons = this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Start a group enemy encounter
   */
  async handleGroupCombat(interaction, player, groupId, scaleFactor = 1) {
    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({
        content: 'You are already in combat!',
        ephemeral: true,
      });
      return;
    }

    const group = getEnemyGroup(groupId);
    if (!group) {
      await interaction.reply({
        content: '‚ùå Enemy group not found!',
        ephemeral: true,
      });
      return;
    }

    // Show combat style selection
    const styles = getStylesForClass(player.class || player.internalClass);
    
    if (styles.length > 0) {
      const options = styles.map((style) => ({
        label: style.name,
        value: `group-style-${groupId}-${style.id}`,
        description: style.description,
        emoji: style.icon,
      }));

      const selectRow = new ActionRowBuilder().addComponents(
        new StringSelectMenuBuilder()
          .setCustomId('rpg-group-style-select')
          .setPlaceholder('Choose Combat Style')
          .addOptions(options)
      );

      const summary = getGroupSummary(group);
      const embed = new EmbedBuilder()
        .setColor(0xffaa00)
        .setTitle(`‚öîÔ∏è ${summary.name} - Choose Your Style`)
        .setDescription(`Difficulty: ${summary.difficulty}`)
        .addFields(
          { name: 'Enemies', value: summary.enemies },
          { name: 'Count', value: `${summary.totalCount} enemies` }
        );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [selectRow],
      });
    } else {
      await this.startGroupFight(interaction, player, groupId, scaleFactor);
    }
  }

  async startGroupFight(interaction, player, groupId, scaleFactor = 1, styleId = null) {
    const group = getEnemyGroup(groupId);
    if (!group) return;

    const combatState = this.combatSystem.startMultiEnemyCombat(
      player,
      groupId,
      scaleFactor
    );

    if (!combatState) {
      await interaction.reply({ content: 'Failed to start group combat!', ephemeral: true });
      return;
    }

    if (styleId) {
      combatState.combatStyle = getCombatStyle(styleId);
    }

    this.persistPlayer(player);

    const summary = getGroupSummary(group);
    const embed = new EmbedBuilder()
      .setColor(0xffaa00)
      .setTitle(`‚öîÔ∏è Group Battle: ${summary.name}`)
      .setDescription(`Facing ${summary.totalCount} enemies`)
      .addFields(
        { name: 'Current Target', value: `${combatState.enemy.name} - ${combatState.enemy.hp}/${combatState.enemy.maxHp} HP` },
        { name: `${combatState.environment.name}`, value: combatState.environment.description }
      );

    if (combatState.combatStyle) {
      embed.addFields({
        name: `${combatState.combatStyle.icon} ${combatState.combatStyle.name}`,
        value: combatState.combatStyle.description
      });
    }

    const buttons = this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Handle normal dungeon encounter selection
   */
  async handleNormalDungeonStart(interaction, player, dungeonId) {
    const dungeon = getAvailableDungeons(player.level, player.currentWorld)
      .find(d => d.id === dungeonId);
    
    if (!dungeon) {
      await interaction.reply({ content: '‚ùå Dungeon not found!', ephemeral: true });
      return;
    }

    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
      return;
    }

    // Start MULTI-FLOOR dungeon combat system (3 floors with risk/reward)
    const currentFloor = 1;
    const totalFloors = dungeon.floors || 3;
    
    // Get first boss/enemy
    let enemyName = 'Dungeon Foe';
    let enemyLevel = Math.max(1, player.level + currentFloor);
    let bossData = null;

    if (dungeon.bosses && dungeon.bosses.length > 0) {
      const firstBoss = dungeon.bosses[0];
      let bossId = null;
      
      if (typeof firstBoss === 'string') {
        bossId = firstBoss;
      } else if (firstBoss && typeof firstBoss === 'object') {
        enemyName = firstBoss.name || enemyName;
        enemyLevel = firstBoss.level || enemyLevel;
      }
      
      if (bossId) {
        const allWorlds = getAllWorlds();
        for (const world of allWorlds) {
          if (world.entities?.worldBosses?.[bossId]) {
            bossData = world.entities.worldBosses[bossId];
            enemyName = bossData.name || enemyName;
            enemyLevel = parseInt(bossData.level) || enemyLevel;
            break;
          }
        }
      }
    }

    // Create combat metadata for multi-floor dungeon
    const combatMeta = {
      type: 'dungeon',
      dungeonId: dungeon.id,
      currentFloor: currentFloor,
      totalFloors: totalFloors,
      bossIndex: 0
    };
    
    // Dungeon difficulty multipliers
    const DUNGEON_HP_MULT = 2.5;
    const DUNGEON_STAT_MULT = 1.8;
    
    let combatState;
    if (bossData && bossData.hp) {
      const baseHp = parseInt(bossData.hp) || 100;
      const baseStr = parseInt(bossData.strength) || 10;
      const baseDef = parseInt(bossData.constitution) || 5;
      const baseInt = parseInt(bossData.intelligence) || 5;
      const baseAgi = parseInt(bossData.dexterity) || 5;
      
      combatState = this.combatSystem.startCombatWithCustomEnemy(
        player,
        enemyName,
        enemyLevel,
        Math.floor(baseHp * DUNGEON_HP_MULT),
        {
          strength: Math.floor(baseStr * DUNGEON_STAT_MULT),
          defense: Math.floor(baseDef * DUNGEON_STAT_MULT),
          intelligence: Math.floor(baseInt * DUNGEON_STAT_MULT),
          agility: Math.floor(baseAgi * DUNGEON_STAT_MULT),
        },
        bossData.abilities || [],
        combatMeta
      );
    } else {
      combatState = this.combatSystem.startCombat(
        player,
        enemyName,
        enemyLevel,
        { meta: combatMeta }
      );
    }

    if (!combatState) {
      await interaction.reply({ content: 'Failed to start dungeon!', ephemeral: true });
      return;
    }

    this.persistPlayer(player);

    const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
    embed.setTitle(`üè∞ **${dungeon.name} - Floor ${currentFloor}/${totalFloors}**`);
    embed.setDescription(`You enter the dungeon and encounter a powerful foe! Defeat all ${totalFloors} floors for maximum rewards!`);
    embed.setFooter({ text: `Floor ${currentFloor}/${totalFloors} - Complete each floor to claim rewards or risk continuing!` });

    const buttons = this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * Handle boss dungeon encounter selection
   */
  async handleBossDungeonStart(interaction, player, dungeonId) {
    const dungeon = getAvailableDungeons(player.level, player.currentWorld)
      .find(d => d.id === dungeonId);
    
    if (!dungeon) {
      await interaction.reply({ content: '‚ùå Dungeon not found!', ephemeral: true });
      return;
    }

    if (this.combatSystem.isInCombat(player.userId)) {
      await interaction.reply({ content: 'You are already in combat!', ephemeral: true });
      return;
    }

    // BOSS ENCOUNTER - Single floor, powerful boss, MASSIVE rewards
    // Get dungeon boss data from dungeon definition first
    let bossData = null;
    let enemyName = dungeon.name + ' Boss';
    let enemyLevel = Math.max(player.level + 5, dungeon.minLevel + 3);

    // Try to get boss from dungeon definition first (preferred method)
    if (dungeon.bosses && dungeon.bosses.length > 0) {
      const firstBoss = dungeon.bosses[0];
      
      if (typeof firstBoss === 'string') {
        // It's a boss ID - try to find it in world entities
        const allWorlds = getAllWorlds();
        for (const world of allWorlds) {
          if (world.entities?.worldBosses?.[firstBoss]) {
            const worldBoss = world.entities.worldBosses[firstBoss];
            enemyName = worldBoss.name || enemyName;
            enemyLevel = parseInt(worldBoss.level) || enemyLevel;
            
            // Create proper loot data with variation - generate based on boss level
            bossData = {
              ...worldBoss,
              xpReward: worldBoss.rewards?.xp || Math.floor(enemyLevel * 250 + Math.random() * 500),
              goldReward: worldBoss.rewards?.gold || Math.floor(enemyLevel * 150 + Math.random() * 300),
              loot: worldBoss.loot || this.generateBossLoot(enemyLevel, 'legendary'),
              materials: worldBoss.materials || this.generateBossMaterials(enemyLevel),
              potions: worldBoss.potions || this.generateBossPotions(enemyLevel),
              enchants: worldBoss.enchants || this.generateBossEnchants(enemyLevel),
            };
            break;
          }
        }
      } else if (firstBoss && typeof firstBoss === 'object') {
        enemyName = firstBoss.name || enemyName;
        enemyLevel = firstBoss.level || enemyLevel;
        
        // Create proper loot data with variation
        bossData = {
          ...firstBoss,
          xpReward: firstBoss.rewards?.xp || Math.floor(enemyLevel * 250 + Math.random() * 500),
          goldReward: firstBoss.rewards?.gold || Math.floor(enemyLevel * 150 + Math.random() * 300),
          loot: firstBoss.loot || this.generateBossLoot(enemyLevel, 'legendary'),
          materials: firstBoss.materials || this.generateBossMaterials(enemyLevel),
          potions: firstBoss.potions || this.generateBossPotions(enemyLevel),
          enchants: firstBoss.enchants || this.generateBossEnchants(enemyLevel),
        };
      }
    }
    
    // Fallback: Use WORLD_BOSSES only if no dungeon-specific boss is defined
    if (!bossData) {
      const worldNum = player.currentWorld || 1;
      if (WORLD_BOSSES[worldNum]) {
        bossData = WORLD_BOSSES[worldNum];
        enemyName = bossData.name || enemyName;
        enemyLevel = parseInt(bossData.minLevel) || enemyLevel;
      }
    }

    // Show combat style selection for boss fight
    const styles = getStylesForClass(player.class || player.internalClass);
    if (!styles || styles.length === 0) {
      // No styles, start boss fight directly
      await this.startDungeonBossFight(interaction, player, dungeon, bossData, null);
      return;
    }

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-dungeon-boss-style-select')
      .setPlaceholder('Choose your combat style...')
      .addOptions(
        styles.map(style => ({
          label: style.name,
          value: style.id,
          description: style.description.substring(0, 100),
          emoji: style.icon || '‚öîÔ∏è'
        }))
      );

    const row = new ActionRowBuilder().addComponents(selectMenu);

    // Store dungeon context for style selection handler
    // Use both memory (fast) and player data (survives bot restarts)
    const contextData = {
      dungeonId: dungeon.id,
      dungeonName: dungeon.name,
      bossData: bossData
    };
    
    if (!this.dungeonBossContext) {
      this.dungeonBossContext = new Map();
    }
    this.dungeonBossContext.set(interaction.user.id, contextData);
    
    // Also save to player data to survive bot restarts
    player.pendingBossDungeon = contextData;
    this.persistPlayer(player);

    const rewardPreview = this.generateBossRewardPreview(bossData, dungeon);

    const embed = new EmbedBuilder()
      .setColor(0xff0000)
      .setTitle(`üëπ **Boss Encounter: ${enemyName}**`)
      .setDescription(`A legendary boss guards this dungeon. Defeat it for MASSIVE rewards!\n\n**Single Floor** - No risk/reward mechanic, just pure boss carnage!`)
      .addFields(
        { name: '‚öîÔ∏è Difficulty', value: `Level ${enemyLevel} - Extremely Dangerous`, inline: true },
        { name: 'üéÅ Rewards', value: rewardPreview, inline: false }
      );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row],
    });
  }

  /**
   * Generate boss reward preview text
   */
  generateBossRewardPreview(bossData, dungeon) {
    if (!bossData) {
      return 'üí∞ Massive XP & Gold\nüéØ Epic Equipment\n‚ú® Legendary Materials\nüß™ High-tier Potions\nüìø Powerful Enchantments';
    }

    const lines = [];
    
    // XP and Gold
    if (bossData.xpReward || bossData.goldReward) {
      lines.push(`üí∞ ${(bossData.xpReward || 0).toLocaleString()} XP & ${(bossData.goldReward || 0).toLocaleString()} Gold`);
    }
    
    // Materials
    if (bossData.materials && bossData.materials.length > 0) {
      const matCount = bossData.materials.reduce((sum, m) => sum + (m.quantity || 1), 0);
      lines.push(`üéÅ ${matCount}+ Legendary Materials`);
    }
    
    // Potions  
    if (bossData.potions && bossData.potions.length > 0) {
      const potionCount = bossData.potions.reduce((sum, p) => sum + (p.quantity || 1), 0);
      lines.push(`üß™ ${potionCount}+ High-tier Potions`);
    }
    
    // Enchantments
    if (bossData.enchants && bossData.enchants.length > 0) {
      const enchantCount = bossData.enchants.reduce((sum, e) => sum + (e.quantity || 1), 0);
      lines.push(`üìø ${enchantCount}+ Powerful Enchantments`);
    }
    
    // Equipment
    if (bossData.loot && bossData.loot.length > 0) {
      lines.push(`‚öîÔ∏è ${bossData.loot.length}+ Epic Equipment`);
    }

    return lines.length > 0 ? lines.join('\n') : 'üíé Legendary Boss Rewards';
  }

  /**
   * Start dungeon boss fight (called after style selection)
   */
  async startDungeonBossFight(interaction, player, dungeon, bossData, styleId = null) {
    let enemyName = dungeon.name + ' Boss';
    let enemyLevel = Math.max(player.level + 5, dungeon.minLevel + 3);

    if (bossData) {
      enemyName = bossData.name || enemyName;
      enemyLevel = parseInt(bossData.level) || enemyLevel;
    }

    // Boss difficulty multipliers (even higher than dungeon)
    const BOSS_HP_MULT = 4.0;  // Bosses have 4x HP
    const BOSS_STAT_MULT = 2.5;  // Bosses have 2.5x stats

    const combatMeta = {
      type: 'boss',
      dungeonId: dungeon.id,
      bossData: bossData,  // Store boss data for reward distribution
      singleFloor: true
    };

    let combatState;
    if (bossData && bossData.hp) {
      const baseHp = parseInt(bossData.hp) || 100;
      const baseStr = parseInt(bossData.strength) || 10;
      const baseDef = parseInt(bossData.constitution) || 5;
      const baseInt = parseInt(bossData.intelligence) || 5;
      const baseAgi = parseInt(bossData.dexterity) || 5;
      
      combatState = this.combatSystem.startCombatWithCustomEnemy(
        player,
        enemyName,
        enemyLevel,
        Math.floor(baseHp * BOSS_HP_MULT),
        {
          strength: Math.floor(baseStr * BOSS_STAT_MULT),
          defense: Math.floor(baseDef * BOSS_STAT_MULT),
          intelligence: Math.floor(baseInt * BOSS_STAT_MULT),
          agility: Math.floor(baseAgi * BOSS_STAT_MULT),
        },
        bossData.abilities || bossData.skills || [],
        combatMeta
      );
    } else {
      // Fallback generic boss
      combatState = this.combatSystem.startCombat(
        player,
        enemyName,
        enemyLevel,
        { meta: combatMeta }
      );
    }

    if (!combatState) {
      await interaction.reply({ content: 'Failed to start boss fight!', ephemeral: true });
      return;
    }

    if (styleId) {
      combatState.combatStyle = getCombatStyle(styleId);
    }

    this.persistPlayer(player);

    const embed = UIBuilder.createCombatStartEmbed(player, combatState.enemy, combatState.worldState);
    embed.setTitle(`üëπ **BOSS: ${enemyName}**`);
    embed.setDescription(`A legendary boss blocks your path! Defeat it for MASSIVE rewards!`);
    embed.setColor(0xff0000);
    embed.setFooter({ text: '‚ö†Ô∏è Boss Encounter - Single Floor - No Retreat!' });

    const buttons = this.createCombatButtons();

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  /**
   * QOL FEATURES - Information & Visibility
   */

  /**
   * Show combat log (last 5 actions)
   */
  async handleCombatLog(interaction, player) {
    const combatLog = this.qolSystem.getCombatLog(player.userId, 5);
    const isInCombat = this.combatSystem.isInCombat(player.userId);
    
    if (combatLog.length === 0) {
      await interaction.reply({
        content: isInCombat ? 'üìñ No combat actions yet. Start your attack!' : 'üìñ No recent combat history. Start a battle first!',
        ephemeral: true
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0x00ff00)
      .setTitle('‚öîÔ∏è **Combat Log**')
      .setDescription(isInCombat ? 'Last 5 actions in current battle:' : 'Last 5 actions from recent battles:');

    combatLog.forEach((action, index) => {
      const timestamp = new Date(action.timestamp).toLocaleTimeString();
      let description = `**${action.source}** ‚Üí ${action.description}`;
      
      if (action.damage > 0) {
        description += ` üí• **${action.damage}** damage`;
      }
      if (action.healing > 0) {
        description += ` üíö **${action.healing}** healing`;
      }
      if (action.environmentalEffect) {
        description += ` üå™Ô∏è ${action.environmentalEffect}`;
      }

      embed.addFields({
        name: `${index + 1}. [${timestamp}]`,
        value: description,
        inline: false
      });
    });

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Show boss guide with templates and strategies
   */
  async handleBossGuide(interaction, player) {
    const bossList = Object.keys(BOSS_ABILITIES);
    if (bossList.length === 0) {
      await interaction.reply({
        content: '‚ùå No boss templates found.',
        ephemeral: true
      });
      return;
    }

    // Create select menu for boss selection
    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-boss-guide-select')
      .setPlaceholder('Choose a boss to learn about...')
      .addOptions(
        bossList.slice(0, 25).map(bossId => {
          const boss = BOSS_ABILITIES[bossId];
          return {
            label: boss.name,
            value: bossId,
            description: boss.description?.substring(0, 100) || 'A powerful boss',
            emoji: 'üëπ'
          };
        })
      );

    const row1 = new ActionRowBuilder().addComponents(selectMenu);
    
    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('Back')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0xff0000)
      .setTitle('üëπ **Boss Guide**')
      .setDescription('Learn about boss mechanics, phases, and recommended strategies')
      .addFields({
        name: 'Available Bosses',
        value: bossList.slice(0, 10).join(', ') + (bossList.length > 10 ? `... and ${bossList.length - 10} more` : ''),
        inline: false
      });

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2],
      ephemeral: true
    });
  }

  /**
   * Show enemy summary before combat
   */
  async handleEnemySummary(interaction, player) {
    const isInCombat = this.combatSystem.isInCombat(player.userId);
    const combatState = isInCombat ? this.combatSystem.getCombatState(player.userId) : null;
    
    let enemy = null;
    let statusText = '';
    
    if (isInCombat && combatState?.enemy) {
      enemy = combatState.enemy;
      statusText = '‚öîÔ∏è Current Combat';
    } else if (player.lastEnemy) {
      enemy = player.lastEnemy;
      statusText = 'üìú Last Enemy Fought';
    } else {
      await interaction.reply({
        content: '‚ùå No enemy data available. Fight an enemy first!',
        ephemeral: true
      });
      return;
    }

    const hpPercent = Math.max(0, Math.round((enemy.currentHp / enemy.maxHp) * 100));

    const embed = new EmbedBuilder()
      .setColor(isInCombat ? 0xff6600 : 0x888888)
      .setTitle(`üìä **${enemy.name} Summary**`)
      .setDescription(`${statusText}\nLevel ${enemy.level} ${enemy.type || 'Enemy'}`)
      .addFields(
        { name: '‚ù§Ô∏è Health', value: `${enemy.currentHp}/${enemy.maxHp} (${hpPercent}%)`, inline: true },
        { name: 'üí™ Strength', value: `${enemy.stats?.strength || 0}`, inline: true },
        { name: 'üß† Intelligence', value: `${enemy.stats?.intelligence || 0}`, inline: true },
        { name: '‚öîÔ∏è Defense', value: `${enemy.stats?.defense || 0}`, inline: true },
        { name: 'üéØ Agility', value: `${enemy.stats?.agility || 0}`, inline: true },
        { name: '‚ú® Special', value: enemy.abilities?.length ? `${enemy.abilities.length} abilities` : 'Standard', inline: true }
      );

    if (enemy.resistances && Object.keys(enemy.resistances).length > 0) {
      embed.addFields({
        name: 'üõ°Ô∏è Resistances',
        value: Object.entries(enemy.resistances)
          .map(([element, value]) => `${element}: ${value}%`)
          .join(', '),
        inline: false
      });
    }

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Show combo preview for current class
   */
  async handleComboPreview(interaction, player) {
    const playerClass = player.class || player.internalClass;
    
    // Auto-populate starting skills if player has class but no skills
    if (playerClass && (!player.skills || player.skills.length === 0)) {
      const classData = getClass(playerClass);
      if (classData && classData.startingSkills) {
        player.skills = [...classData.startingSkills];
        this.persistPlayer(player);
      }
    }
    
    const playerSkills = player.skills || [];
    const combos = getCombosForClass(playerSkills);

    if (!combos || combos.length === 0) {
      await interaction.reply({
        content: `‚ö†Ô∏è No combos available yet. Unlock more skills to discover combos!`,
        ephemeral: true
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0x9900ff)
      .setTitle(`‚ú® **${playerClass} Skill Combos**`)
      .setDescription(`${combos.length} combo chains available`);

    combos.slice(0, 10).forEach(combo => {
      const firstSkill = getSkill(combo.first);
      const secondSkill = getSkill(combo.second);
      const skillChain = `${firstSkill?.name || combo.first} ‚Üí ${secondSkill?.name || combo.second}`;
      const damageMultiplier = combo.bonus?.damageMultiplier || 1;
      const damageBonus = damageMultiplier > 1 ? `+${((damageMultiplier - 1) * 100).toFixed(0)}%` : 'N/A';
      const effect = combo.bonus?.effect ? ` + ${combo.bonus.effect.type}` : '';
      
      embed.addFields({
        name: `${combo.icon || '‚ö°'} ${combo.id}`,
        value: `${combo.description}\n**Chain:** ${skillChain}\n**Bonus:** ${damageBonus}${effect}`,
        inline: false
      });
    });

    if (combos.length > 10) {
      embed.setFooter({ text: `... and ${combos.length - 10} more combos` });
    }

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Show equipment comparison
   */
  async handleEquipmentComparison(interaction, player) {
    const equipped = player.equippedItems || {};
    const hasAnyEquipment = Object.keys(equipped).length > 0;

    if (!hasAnyEquipment) {
      await interaction.reply({
        content: '‚ö†Ô∏è No equipment equipped yet. Equip some gear first!',
        ephemeral: true
      });
      return;
    }

    // Create select menu to pick slot to compare
    const slots = ['weapon', 'armor', 'shield', 'ring', 'amulet'];
    
    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-equipment-compare-select')
      .setPlaceholder('Choose equipment slot to compare...')
      .addOptions(
        slots.map(slot => ({
          label: slot.charAt(0).toUpperCase() + slot.slice(1),
          value: slot,
          emoji: slot === 'weapon' ? '‚öîÔ∏è' : slot === 'armor' ? 'üõ°Ô∏è' : slot === 'shield' ? 'üî∞' : slot === 'ring' ? 'üíç' : 'üìø'
        }))
      );

    const backButton = new ButtonBuilder()
      .setCustomId('rpg-qol-gear')
      .setLabel('Back')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('‚óÄÔ∏è');

    const row1 = new ActionRowBuilder().addComponents(selectMenu);
    const row2 = new ActionRowBuilder().addComponents(backButton);

    const embed = new EmbedBuilder()
      .setColor(0x00ccff)
      .setTitle('üîÑ **Equipment Comparison**')
      .setDescription('Select a slot to compare with your inventory');

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2],
      ephemeral: true
    });
  }

  /**
   * Damage calculator - estimate damage before action
   */
  async handleDamageCalculator(interaction, player) {
    const inCombat = this.combatSystem.isInCombat(player.userId);
    const combatState = inCombat ? this.combatSystem.getCombatState(player.userId) : null;

    // Calculate player stats
    const stats = player.getStats();
    const baseDamage = stats.strength * 1.2;
    const weaponBonus = stats.weaponDamage || 0;
    const totalDamage = Math.round(baseDamage + weaponBonus);

    const critChance = Math.min(95, (stats.dexterity || 0) * 0.5 + 5);
    const critDamage = Math.round(totalDamage * 1.5);

    const styleBonus = player.combatStyle?.statMods?.damageDealt || 0;
    const styledDamage = Math.round(totalDamage * (1 + styleBonus / 100));

    const enemyInfo = combatState?.enemy 
      ? `Current Enemy: ${combatState.enemy.name}` 
      : 'Not in combat - showing base calculations';

    const embed = new EmbedBuilder()
      .setColor(0xff0000)
      .setTitle('üìä **Damage Calculator**')
      .setDescription(enemyInfo)
      .addFields(
        { name: '‚öîÔ∏è Base Attack', value: `${totalDamage} damage`, inline: true },
        { name: 'üéØ Critical Hit', value: `${critDamage} damage (${Math.round(critChance)}% chance)`, inline: true },
        { name: 'üí´ With Style Bonus', value: `${styledDamage} damage (+${styleBonus}%)`, inline: true },
        { name: 'üìä Your Stats', value: `STR: ${stats.strength} | DEX: ${stats.dexterity}`, inline: false }
      );

    if (combatState?.enemy) {
      embed.addFields({ 
        name: '‚ù§Ô∏è Enemy Defense', 
        value: `${combatState.enemy.stats?.defense || 0} (reduces damage by ~${Math.round((combatState.enemy.stats?.defense || 0) * 0.5)})`, 
        inline: false 
      });
    }

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Show Jump Menu - quick access to recent content
   */
  async handleJumpMenu(interaction, player) {
    const recentActions = this.qolSystem.getRecentActions(player.userId, 5);
    
    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-jump-last-combat')
        .setLabel('Last Combat')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('‚öîÔ∏è'),
      new ButtonBuilder()
        .setCustomId('rpg-jump-last-dungeon')
        .setLabel('Last Dungeon')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üóùÔ∏è'),
      new ButtonBuilder()
        .setCustomId('rpg-jump-guild')
        .setLabel('Guild')
        .setStyle(ButtonStyle.Success)
        .setEmoji('üè∞')
    );

    const embed = new EmbedBuilder()
      .setColor(0xffaa00)
      .setTitle('üöÄ **Jump Menu**')
      .setDescription('Quick access to recent activities');

    if (recentActions.length > 0) {
      embed.addFields({
        name: 'Recent Actions',
        value: recentActions.map((a, i) => `${i + 1}. ${a.description}`).join('\n'),
        inline: false
      });
    }

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
      ephemeral: true
    });
  }

  /**
   * Show hotkey favorites menu
   */
  async handleHotkeys(interaction, player) {
    const favorites = player.favorites || [];

    const embed = new EmbedBuilder()
      .setColor(0xff00ff)
      .setTitle('‚≠ê **Hotkey Favorites**')
      .setDescription(`You have ${favorites.length}/3 favorites set`);

    if (favorites.length > 0) {
      embed.addFields({
        name: 'Your Favorites',
        value: favorites.map((fav, i) => `${i + 1}. ${fav.name}`).join('\n'),
        inline: false
      });
    }

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-hotkeys-combat')
        .setLabel('Set Combat')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-hotkeys-guild')
        .setLabel('Set Guild')
        .setStyle(ButtonStyle.Primary),
      new ButtonBuilder()
        .setCustomId('rpg-hotkeys-inventory')
        .setLabel('Set Inventory')
        .setStyle(ButtonStyle.Primary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
      ephemeral: true
    });
  }

  /**
   * Show stats timeline (growth over time)
   */
  async handleStatsTimeline(interaction, player) {
    const history = this.qolSystem.getStatsHistory(player.userId);
    const growth = this.qolSystem.getStatGrowth(player.userId, 4);

    if (!history || history.length < 2) {
      await interaction.reply({
        content: 'üìä Not enough historical data yet. Keep playing to track your growth!',
        ephemeral: true
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0x00ff00)
      .setTitle('üìà **Stats Timeline**')
      .setDescription(`Your growth over the last ${growth.weeksTracked} weeks`);

    if (growth) {
      embed.addFields(
        { name: 'üí™ Strength', value: `+${growth.strengthGrowth}`, inline: true },
        { name: 'üß† Intelligence', value: `+${growth.intelligenceGrowth}`, inline: true },
        { name: 'üéØ Agility', value: `+${growth.agilityGrowth}`, inline: true },
        { name: '‚ù§Ô∏è Constitution', value: `+${growth.constitutionGrowth}`, inline: true },
        { name: 'üìä Level Growth', value: `+${growth.levelGrowth} levels`, inline: true },
        { name: '‚è±Ô∏è Time Period', value: `${growth.weeksTracked} weeks`, inline: true }
      );
    }

    const latestWeek = history[history.length - 1];
    embed.addFields({
      name: 'Current Stats',
      value: `L${latestWeek.level} | STR: ${latestWeek.strength} | INT: ${latestWeek.intelligence} | AGI: ${latestWeek.agility}`,
      inline: false
    });

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Show boss defeat tracker
   */
  async handleBossTracker(interaction, player) {
    const bossesFelled = this.qolSystem.getBossDefeats(player.userId);

    if (bossesFelled.length === 0) {
      await interaction.reply({
        content: 'üëπ No bosses defeated yet. Go challenge yourself!',
        ephemeral: true
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0xff0000)
      .setTitle('üëπ **Boss Defeat Tracker**')
      .setDescription(`You've defeated ${bossesFelled.length} unique boss(es)`);

    bossesFelled.slice(0, 10).forEach(boss => {
      const winRate = Math.round((boss.defeatedCount / boss.totalAttempts) * 100);
      const lastDefeated = new Date(boss.lastDefeated).toLocaleDateString();
      
      embed.addFields({
        name: `‚öîÔ∏è ${boss.bossName}`,
        value: `Defeats: ${boss.defeatedCount} | Attempts: ${boss.totalAttempts} | Win Rate: ${winRate}% | Last: ${lastDefeated}`,
        inline: false
      });
    });

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Show achievement progress with percentages
   */
  async handleAchievementProgress(interaction, player) {
    // Calculate achievement completion percentage
    const achievements = this.getAchievementData(player);
    let totalTiers = 0;
    let completedTiers = 0;
    
    achievements.forEach(achievement => {
      totalTiers += achievement.tiers.length;
      completedTiers += achievement.tiers.filter(tier => achievement.progressValue >= tier.target).length;
    });
    
    const overallProgress = totalTiers > 0 ? Math.round((completedTiers / totalTiers) * 100) : 0;

    const embed = new EmbedBuilder()
      .setColor(0xffaa00)
      .setTitle('üèÜ **Achievement Progress**')
      .setDescription(`Overall Completion: ${overallProgress}%`);

    // Show progress bar
    const filledBars = Math.round(overallProgress / 10);
    const emptyBars = 10 - filledBars;
    const progressBar = '‚ñà'.repeat(filledBars) + '‚ñë'.repeat(emptyBars);

    embed.addFields({
      name: 'Progress Bar',
      value: `[${progressBar}] ${overallProgress}%`,
      inline: false
    });
    
    embed.addFields({
      name: 'üìä Achievement Breakdown',
      value: `**Completed Tiers:** ${completedTiers}/${totalTiers}\n**Total Achievements:** ${achievements.length}`,
      inline: false
    });

    embed.addFields({
      name: 'Keep playing to unlock more achievements!',
      value: 'Achievements track your growth and unlock special rewards.',
      inline: false
    });

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Show class mastery guide
   */
  async handleClassMasteryGuide(interaction, player) {
    const playerClass = player.class || player.internalClass;
    const classData = getClass(playerClass);

    if (!classData) {
      await interaction.reply({
        content: '‚ùå Class data not found.',
        ephemeral: true
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0x6600ff)
      .setTitle(`üìö **${playerClass} Mastery Guide**`)
      .setDescription(`Master your ${playerClass} abilities`);

    // Key stats for this class
    const keyStats = playerClass === 'Mage' 
      ? 'Intelligence & Agility'
      : playerClass === 'Rogue'
      ? 'Agility & Strength'
      : playerClass === 'Paladin'
      ? 'Strength & Constitution'
      : 'Strength & Constitution';

    embed.addFields(
      { name: '‚≠ê Key Stats', value: keyStats, inline: true },
      { name: 'üéØ Primary Role', value: classData.role || 'Balanced', inline: true },
      { name: 'üí™ Passive Ability', value: classData.passive || 'None', inline: false }
    );

    if (classData.skills && classData.skills.length > 0) {
      const topSkills = classData.skills.slice(0, 3).join(', ');
      embed.addFields({
        name: '‚ö° Recommended Skills',
        value: topSkills,
        inline: false
      });
    }

    embed.addFields({
      name: 'üí° Mastery Tips',
      value: `Focus on ${keyStats}. Use your class abilities to combo for higher damage!`,
      inline: false
    });

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Show environment advantage tool
   */
  async handleEnvironmentTool(interaction, player) {
    const envList = Object.keys(ENVIRONMENTS);
    if (envList.length === 0) {
      await interaction.reply({
        content: '‚ùå No environments available.',
        ephemeral: true
      });
      return;
    }

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-env-advantage-select')
      .setPlaceholder('Choose environment to analyze...')
      .addOptions(
        envList.slice(0, 25).map(envId => {
          const env = ENVIRONMENTS[envId];
          return {
            label: env.name,
            value: envId,
            description: env.description?.substring(0, 100) || 'A battle arena',
            emoji: 'üåç'
          };
        })
      );

    const row = new ActionRowBuilder().addComponents(selectMenu);

    const backButton = new ButtonBuilder()
      .setCustomId('rpg-qol-tab-utility')
      .setLabel('Back')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('‚óÄÔ∏è');

    const row2 = new ActionRowBuilder().addComponents(backButton);

    const embed = new EmbedBuilder()
      .setColor(0x00ff00)
      .setTitle('‚öîÔ∏è **Environment Advantage Tool**')
      .setDescription('Learn which elements and strategies work best in each arena');

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row, row2],
      ephemeral: true
    });
  }

  /**
   * REMAINING FEATURES - Quick Spell Wheel, Breadcrumb, Visualizers, etc.
   */

  /**
   * Quick Spell Wheel - Button grid for faster skill access
   */
  async handleQuickSpellWheel(interaction, player) {
    const playerClass = player.class || player.internalClass;
    
    // Auto-populate starting skills if player has class but no skills
    if (playerClass && (!player.skills || player.skills.length === 0)) {
      const classData = getClass(playerClass);
      if (classData && classData.startingSkills) {
        player.skills = [...classData.startingSkills];
        this.persistPlayer(player);
      }
    }
    
    const skills = player.skills || [];

    if (skills.length === 0) {
      await interaction.reply({
        content: '‚ö†Ô∏è No skills unlocked yet. Level up and unlock skills to use the spell wheel!',
        ephemeral: true
      });
      return;
    }

    // Create button grid (max 5 per row)
    const rows = [];
    for (let i = 0; i < skills.length; i += 4) {
      const row = new ActionRowBuilder();
      const slicedSkills = skills.slice(i, i + 4);
      
      slicedSkills.forEach(skillId => {
        const skill = getSkill(skillId);
        if (skill) {
          row.addComponents(
            new ButtonBuilder()
              .setCustomId(`rpg-spell-${skillId}`)
              .setLabel(skill.name?.substring(0, 20))
              .setStyle(ButtonStyle.Primary)
              .setEmoji('‚ö°')
          );
        }
      });
      
      if (row.components.length > 0) {
        rows.push(row);
      }
    }

    // Add back button as last row
    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('Back')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0x9900ff)
      .setTitle('‚ö° **Quick Spell Wheel**')
      .setDescription('Rapid access to your most useful spells')
      .addFields({
        name: 'üéØ Click any spell below to use it in combat',
        value: `${skills.length} spells available`,
        inline: false
      });

    // Combine skill rows and back button (max 5 rows total)
    const allRows = [...rows.slice(0, 4), backRow];

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: allRows,
      ephemeral: true
    });
  }

  /**
   * Handle spell wheel click - Execute spell in combat
   */
  async handleSpellWheelClick(interaction, player, skillId) {
    const skill = getSkill(skillId);

    if (!skill) {
      await interaction.reply({
        content: '‚ùå Skill not found.',
        ephemeral: true
      });
      return;
    }

    // Check if player is in combat
    if (!this.combatSystem.isInCombat(player.userId)) {
      const embed = new EmbedBuilder()
        .setColor(0xff6600)
        .setTitle(`‚ö° **${skill.name}**`)
        .setDescription('Not in combat - spell details only')
        .addFields({
          name: 'üìä Spell Information',
          value: `
            **Damage:** ${skill.damage || 'Variable'}
            **Mana Cost:** ${skill.manaCost || 0}
            **Cooldown:** ${skill.cooldown || 0}s
            **Type:** ${skill.type || 'Physical'}
            **Description:** ${skill.description || 'A powerful spell'}
          `,
          inline: false
        });

      await interaction.reply({
        embeds: [embed],
        ephemeral: true
      });
      return;
    }

    // In combat - attempt to use spell
    const combatState = this.combatSystem.getCombatState(player.userId);
    
    if (!combatState) {
      await interaction.reply({
        content: '‚ùå Combat state lost.',
        ephemeral: true
      });
      return;
    }

    // Check if spell is ready (cooldown check would go here)
    const playerSpellData = player.spellData || {};
    const lastUse = playerSpellData[skillId] || 0;
    const cooldown = skill.cooldown || 0;
    const now = Date.now();

    if (now - lastUse < cooldown * 1000) {
      const timeLeft = Math.ceil((cooldown * 1000 - (now - lastUse)) / 1000);
      await interaction.reply({
        content: `‚è≥ **${skill.name}** is on cooldown for ${timeLeft}s`,
        ephemeral: true
      });
      return;
    }

    // Execute spell
    const damage = (skill.damage || 10) * (1 + player.intelligence / 100);
    const actualDamage = Math.max(1, Math.floor(damage - (combatState.enemy.defense || 0) * 0.5));

    // Record spell use
    playerSpellData[skillId] = now;
    player.spellData = playerSpellData;

    // Apply damage to enemy
    combatState.enemy.hp -= actualDamage;

    const embed = new EmbedBuilder()
      .setColor(0x00ff00)
      .setTitle(`‚ö° **${skill.name}** Used!`)
      .setDescription(`Dealt **${actualDamage}** damage to ${combatState.enemy.name}`)
      .addFields({
        name: `Enemy HP`,
        value: `${Math.max(0, combatState.enemy.hp)} / ${combatState.enemy.maxHp || combatState.enemy.hp + actualDamage}`,
        inline: false
      });

    // Check if enemy is defeated
    if (combatState.enemy.hp <= 0) {
      embed.setColor(0xffff00);
      embed.setTitle('‚ö° **Victory!**');
      embed.setDescription(`${skill.name} defeated ${combatState.enemy.name}!`);
      
      // Handle victory
      this.handleCombatVictory(player, combatState.enemy);
      this.combatSystem.endCombat(player.userId);
    }

    await interaction.reply({
      embeds: [embed],
      ephemeral: true
    });

    this.persistPlayer(player);
  }

  /**
   * Combo Chain Visualizer - Show skill sequences visually  
   */
  async handleComboVisualizer(interaction, player) {
    const playerClass = player.class || player.internalClass;
    
    // Auto-populate starting skills if player has class but no skills
    if (playerClass && (!player.skills || player.skills.length === 0)) {
      const classData = getClass(playerClass);
      if (classData && classData.startingSkills) {
        player.skills = [...classData.startingSkills];
        this.persistPlayer(player);
      }
    }
    
    const playerSkills = player.skills || [];
    const combos = getCombosForClass(playerSkills);

    if (!combos || combos.length === 0) {
      await interaction.reply({
        content: '‚ùå No combos found yet. Unlock more skills to discover powerful combo chains!',
        ephemeral: true
      });
      return;
    }

    const topCombos = combos.slice(0, 3);

    const embed = new EmbedBuilder()
      .setColor(0xff00ff)
      .setTitle('‚ú® **Combo Chain Visualizer**')
      .setDescription('Visual breakdown of your most powerful skill combos');

    topCombos.forEach(combo => {
      const firstSkill = getSkill(combo.first);
      const secondSkill = getSkill(combo.second);
      const visualization = `${firstSkill?.name || combo.first} ‚ûú ${secondSkill?.name || combo.second}`;
      const damageMultiplier = combo.bonus?.damageMultiplier || 1;
      const totalDamage = damageMultiplier > 1 ? `x${damageMultiplier.toFixed(2)}` : 'N/A';
      const effect = combo.bonus?.effect ? `**Effect:** ${combo.bonus.effect.type} (${combo.bonus.effect.duration} turns)` : '';
      
      embed.addFields({
        name: `${combo.icon || '‚ö°'} ${combo.id}`,
        value: `${combo.description}\nüïê ${visualization}\n**Damage Multiplier:** ${totalDamage}\n${effect}`,
        inline: false
      });
    });

    embed.addFields({
      name: 'üí° Pro Tip',
      value: 'Chain these combos in sequence for maximum damage output!',
      inline: false
    });

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Environmental Effect Predictions - Show hazards/buffs ahead of time
   */
  async handleEnvironmentPredictions(interaction, player) {
    const envList = Object.keys(ENVIRONMENTS);

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-env-predict-select')
      .setPlaceholder('Choose environment to predict...')
      .addOptions(
        envList.slice(0, 25).map(envId => {
          const env = ENVIRONMENTS[envId];
          return {
            label: env.name,
            value: envId,
            description: 'Preview hazards and buffs',
            emoji: 'üîÆ'
          };
        })
      );

    const row = new ActionRowBuilder().addComponents(selectMenu);

    const backButton = new ButtonBuilder()
      .setCustomId('rpg-qol-tab-utility')
      .setLabel('Back')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('‚óÄÔ∏è');

    const row2 = new ActionRowBuilder().addComponents(backButton);

    const embed = new EmbedBuilder()
      .setColor(0x6600ff)
      .setTitle('üîÆ **Environmental Effect Predictions**')
      .setDescription('Predict hazards and buffs before entering each arena');

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row, row2],
      ephemeral: true
    });
  }

  /**
   * Profession Efficiency Tips - Optimal gathering/crafting strategies
   */
  async handleProfessionTips(interaction, player) {
    const professions = ['gathering', 'crafting', 'alchemy'];

    const selectMenu = new StringSelectMenuBuilder()
      .setCustomId('rpg-profession-tips-select')
      .setPlaceholder('Choose profession to learn about...')
      .addOptions(
        professions.map(prof => ({
          label: prof.charAt(0).toUpperCase() + prof.slice(1),
          value: prof,
          description: 'View efficiency tips',
          emoji: prof === 'gathering' ? '‚õèÔ∏è' : prof === 'crafting' ? 'üî®' : 'üß™'
        }))
      );

    const row = new ActionRowBuilder().addComponents(selectMenu);

    const embed = new EmbedBuilder()
      .setColor(0x00aa00)
      .setTitle('üí° **Profession Efficiency Tips**')
      .setDescription('Optimize your gathering, crafting, and alchemy for maximum profit')
      .addFields({
        name: 'üí∞ Compare Professions',
        value: 'See which profession is most profitable for your level',
        inline: false
      });

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row],
      ephemeral: true
    });
  }

  /**
   * Guild Leaderboard - Members ranked by stats
   */
  async handleGuildLeaderboard(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    
    if (!guild) {
      await interaction.reply({
        content: '‚ùå You\'re not in a guild!',
        ephemeral: true
      });
      return;
    }

    const leaderboard = this.guildAnalytics.getLeaderboard(guild.id, 'overall');

    if (leaderboard.length === 0) {
      await interaction.reply({
        content: 'üìä No guild members recorded yet.',
        ephemeral: true
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0xffaa00)
      .setTitle('üèÜ **Guild Leaderboard**')
      .setDescription('Top members ranked by overall strength');

    leaderboard.slice(0, 10).forEach((member, index) => {
      const rank = index + 1;
      const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : 'üîπ';
      
      embed.addFields({
        name: `${medal} #${rank}`,
        value: `L${member.level} | üí™ ${member.totalDamage} DMG | üëπ ${member.bossesFelled} Bosses`,
        inline: false
      });
    });

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-tab-guild')
        .setLabel('‚Üê Back to Guild Tab')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, { 
      embeds: [embed], 
      components: [backButton],
      ephemeral: true 
    });
  }

  /**
   * Guild Member Growth Chart - Track guild progress
   */
  async handleGuildGrowthChart(interaction, player) {
    const guild = this.guildManager.getPlayerGuild(player.userId);
    
    if (!guild) {
      await interaction.reply({
        content: '‚ùå You\'re not in a guild!',
        ephemeral: true
      });
      return;
    }

    const avgStats = this.guildAnalytics.getGuildAverageStats(guild.id);

    if (!avgStats) {
      await interaction.reply({
        content: 'üìä Not enough guild data yet.',
        ephemeral: true
      });
      return;
    }

    const embed = new EmbedBuilder()
      .setColor(0x00ccff)
      .setTitle('üìä **Guild Growth Chart**')
      .setDescription('Your guild\'s collective progress');

    const strengthBar = this.createProgressBar(avgStats.guildStrength, avgStats.guildStrength + 50, 15);

    embed.addFields(
      { name: 'üë• Members', value: `${avgStats.memberCount}`, inline: true },
      { name: 'üìà Average Level', value: `L${avgStats.averageLevel}`, inline: true },
      { name: 'üí™ Average Damage', value: `${avgStats.averageDamage}`, inline: true },
      { name: 'üëπ Total Bosses Defeated', value: `${avgStats.totalBossesFelled}`, inline: true },
      { name: '‚≠ê Guild Strength', value: `[${strengthBar}] ${avgStats.guildStrength.toFixed(1)}/100`, inline: false }
    );

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-tab-guild')
        .setLabel('‚Üê Back to Guild Tab')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, { 
      embeds: [embed], 
      components: [backButton],
      ephemeral: true 
    });
  }

  /**
   * Guild Quest Suggestions - Recommend content for members
   */
  async handleGuildQuestSuggestions(interaction, player) {
    if (!player.guildId) {
      await interaction.reply({
        content: '‚ùå You\'re not in a guild!',
        ephemeral: true
      });
      return;
    }

    const suggestions = this.guildAnalytics.suggestGroupContent(player);

    const embed = new EmbedBuilder()
      .setColor(0xff6600)
      .setTitle('üìú **Guild Quest Suggestions**')
      .setDescription('Recommended group activities for you');

    suggestions.slice(0, 5).forEach(suggestion => {
      embed.addFields({
        name: `${suggestion.name}`,
        value: `${suggestion.reason}\nüí∞ Reward: ${suggestion.reward}`,
        inline: false
      });
    });

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * PHASE 2 QOL FEATURES
   */

  /**
   * Equipment Builds - Quick swap between saved equipment loadouts
   */
  async handleEquipmentBuilds(interaction, player) {
    const builds = this.equipmentBuilds.getBuilds(player.userId);

    const embed = new EmbedBuilder()
      .setColor(0x00ccff)
      .setTitle('‚öôÔ∏è **Equipment Builds**')
      .setDescription(`Manage quick-swap equipment loadouts (${builds.length}/3)`);

    if (builds.length > 0) {
      builds.forEach(build => {
        const summary = this.equipmentBuilds.getBuildSummary(build.equipment);
        embed.addFields({
          name: build.name,
          value: `${summary.itemCount} items equipped`,
          inline: true
        });
      });
    }

    const buttons = new ActionRowBuilder();
    buttons.addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-builds-save')
        .setLabel('Save Current')
        .setStyle(ButtonStyle.Success)
        .setEmoji('üíæ'),
      new ButtonBuilder()
        .setCustomId('rpg-builds-load')
        .setLabel('Load Build')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üìÇ')
    );

    if (builds.length > 0) {
      buttons.addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-builds-delete')
          .setLabel('Delete Build')
          .setStyle(ButtonStyle.Danger)
          .setEmoji('üóëÔ∏è')
      );
    }

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [buttons],
      ephemeral: true
    });
  }

  /**
   * Combat Style Recommendations - Suggests best style for current encounter
   */
  async handleCombatStylesRecommendation(interaction, player) {
    const inCombat = this.combatSystem.isInCombat(player.userId);
    const combatState = inCombat ? this.combatSystem.getCombatState(player.userId) : null;
    const enemy = combatState?.enemy;

    if (!inCombat || !enemy) {
      // Show general style tips when not in combat
      const playerClass = player.class || player.internalClass;
      const currentStyle = player.combatStyle?.id || 'balanced';
      
      const embed = new EmbedBuilder()
        .setColor(0xffaa00)
        .setTitle('‚öîÔ∏è **Combat Style Tips**')
        .setDescription('General combat style recommendations for your class.');

      embed.addFields(
        { name: 'üéØ Aggressive Style', value: 'High damage, low defense. Best for quick fights and when you have healing support.', inline: false },
        { name: 'üõ°Ô∏è Defensive Style', value: 'Low damage, high defense. Best for tough enemies and long fights.', inline: false },
        { name: '‚öñÔ∏è Balanced Style', value: 'Moderate damage and defense. Best all-around style for most situations.', inline: false },
        { name: 'üí® Current Style', value: `You are using **${currentStyle}** style.`, inline: false },
        { name: 'üí° Tip', value: 'Enter combat to get specific recommendations for that enemy!', inline: false }
      );

      await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
      return;
    }

    const recommendation = this.combatRecommendations.generateBattleRecommendation(
      player.combatStyle?.id || 'balanced',
      player.element || 'neutral',
      enemy.template || 'standard',
      enemy.stats
    );

    const embed = new EmbedBuilder()
      .setColor(0xffaa00)
      .setTitle(`‚öîÔ∏è **${enemy.name} - Combat Strategy**`)
      .setDescription(`Success Probability: **${recommendation.overall.successProbability}%**`);

    embed.addFields(
      { name: 'üìä Difficulty', value: `${recommendation.overall.difficultyRating}/10`, inline: true },
      { name: '‚è±Ô∏è Estimated Duration', value: recommendation.overall.estimatedDuration, inline: true },
      { name: 'üí´ Current Style', value: `${recommendation.style.current}\n${recommendation.style.effectiveness}`, inline: false },
      { name: 'üéØ Recommended Style', value: recommendation.style.recommended, inline: true },
      { name: '‚ú® Element', value: `Current: ${recommendation.element.current}\nRecommended: ${recommendation.element.recommended}`, inline: true }
    );

    if (recommendation.strengthsToExploit.length > 0) {
      embed.addFields({
        name: 'üí™ Strengths To Exploit',
        value: recommendation.strengthsToExploit.join(', '),
        inline: false
      });
    }

    if (recommendation.tips.length > 0) {
      embed.addFields({
        name: 'üí° Battle Tips',
        value: recommendation.tips.slice(0, 3).join('\n'),
        inline: false
      });
    }

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Critical Hit Chance Display - Shows crit calculations
   */
  async handleCriticalHitDisplay(interaction, player) {
    const baseCrit = 5; // 5% base
    const agilityBonus = (player.agility || 0) * 0.4; // 0.4% per agility
    const gearBonus = (player.equipment?.weapon?.crit || 0); // From gear
    const styleBonus = (player.combatStyle?.statMods?.crit || 0);

    const totalCrit = Math.min(95, baseCrit + agilityBonus + gearBonus + styleBonus);
    const critDamage = 150; // Default 50% bonus damage on crit

    const embed = new EmbedBuilder()
      .setColor(0xff0000)
      .setTitle('üéØ **Critical Hit Analysis**')
      .setDescription(`Your current critical strike chance`)
      .addFields(
        { name: 'Base Crit Chance', value: `${baseCrit.toFixed(1)}%`, inline: true },
        { name: 'From Agility', value: `+${agilityBonus.toFixed(1)}%`, inline: true },
        { name: 'From Gear', value: `+${gearBonus.toFixed(1)}%`, inline: true },
        { name: 'From Style', value: `+${styleBonus.toFixed(1)}%`, inline: true },
        { name: '‚ö° TOTAL CRIT', value: `**${totalCrit.toFixed(1)}%**`, inline: false },
        { name: 'Crit Damage', value: `${critDamage}% of base damage`, inline: true }
      );

    // Show how much agility would help
    const needPercentage = Math.max(0, 50 - totalCrit);
    if (needPercentage > 0) {
      const agilityNeeded = Math.ceil(needPercentage / 0.4);
      embed.addFields({
        name: 'üí° Path to 50% Crit',
        value: `Need +${agilityNeeded} Agility or +${needPercentage.toFixed(1)}% Crit from gear`,
        inline: false
      });
    }

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Damage Breakdown - Shows damage source allocation
   */
  async handleDamageBreakdown(interaction, player) {
    const baseStr = player.strength || 0;
    const baseDamage = baseStr * 1.2;

    const weaponDamage = player.equipment?.weapon?.damage || 0;
    const equipmentDamage = (player.equipment?.armor?.damage || 0) + 
                            (player.equipment?.ring?.damage || 0) + 
                            (player.equipment?.amulet?.damage || 0);
    const styleDamage = ((player.combatStyle?.statMods?.damageDealt || 0) / 100) * baseDamage;
    const totalDamage = baseDamage + weaponDamage + equipmentDamage + styleDamage;

    // Calculate percentages
    const basePct = (baseDamage / totalDamage * 100).toFixed(1);
    const weaponPct = (weaponDamage / totalDamage * 100).toFixed(1);
    const equipPct = (equipmentDamage / totalDamage * 100).toFixed(1);
    const stylePct = (styleDamage / totalDamage * 100).toFixed(1);

    const embed = new EmbedBuilder()
      .setColor(0xff0000)
      .setTitle('üí• **Damage Breakdown**')
      .setDescription(`Total Attack Power: **${Math.round(totalDamage)}**`)
      .addFields(
        { name: 'üí™ Base (from Strength)', value: `${Math.round(baseDamage)} (${basePct}%)`, inline: true },
        { name: '‚öîÔ∏è Weapon', value: `${Math.round(weaponDamage)} (${weaponPct}%)`, inline: true },
        { name: '‚öôÔ∏è Gear', value: `${Math.round(equipmentDamage)} (${equipPct}%)`, inline: true },
        { name: 'üí´ Style Bonus', value: `${Math.round(styleDamage)} (${stylePct}%)`, inline: true }
      );

    // Show how to maximize damage
    const highestSource = Math.max(baseDamage, weaponDamage, equipmentDamage, styleDamage);
    let recommendation = '';
    if (highestSource === baseDamage) {
      const strNeeded = Math.ceil((totalDamage * 0.2) / 1.2);
      recommendation = `Increase Strength by ${strNeeded} to boost damage`;
    } else if (highestSource === weaponDamage) {
      recommendation = 'Your weapon is your strongest asset - upgrade it!';
    } else if (highestSource === styleDamage) {
      recommendation = 'Your combat style is highly optimized';
    }

    embed.addFields({
      name: 'üí° Optimization Tip',
      value: recommendation,
      inline: false
    });

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Milestone Notifications - Show approaching level-ups and milestones
   */
  async handleMilestoneNotifications(interaction, player) {
    const milestones = this.qolSystem.getMilestonesApproaching(player);

    let embed = new EmbedBuilder()
      .setColor(0xffaa00)
      .setTitle('üéØ **Upcoming Milestones**')
      .setDescription(`Your progress towards major goals`);

    if (milestones.length === 0) {
      embed.addFields({
        name: '‚úÖ All Clear',
        value: 'No immediate milestones. Keep grinding!',
        inline: false
      });
    } else {
      milestones.forEach(milestone => {
        const progressBar = this.createProgressBar(milestone.progress, milestone.target, 10);
        embed.addFields({
          name: `üéØ ${milestone.description}`,
          value: `[${progressBar}] ${milestone.progress}/${milestone.target}`,
          inline: false
        });
      });
    }

    // Add next major milestones
    const nextLevel = Math.ceil(player.level / 5) * 5;
    const levelProgress = player.level / nextLevel;
    
    embed.addFields({
      name: '‚≠ê Next Level Milestone',
      value: `Level ${nextLevel} (Currently L${player.level})`,
      inline: true
    });

    await this.updateInteractionWithTracking(interaction, { embeds: [embed], ephemeral: true });
  }

  /**
   * Helper: Create visual progress bar
   */
  createProgressBar(current, max, length = 10) {
    const percentage = Math.min(1, current / max);
    const filled = Math.round(percentage * length);
    const empty = length - filled;
    return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
  }

  /**
   * Main QOL Menu - Hub for all quality-of-life features
   */
  async handleQOLMenu(interaction, player) {
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-tab-stats')
        .setLabel('Stats')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üìä'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-tab-combat')
        .setLabel('Combat')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('‚öîÔ∏è'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-tab-progress')
        .setLabel('Progress')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üéØ'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-tab-gear')
        .setLabel('Gear')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚öôÔ∏è'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-tab-utility')
        .setLabel('Utility')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üß∞')
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-tab-guild')
        .setLabel('Guild')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üèÜ'),
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary),
      new ButtonBuilder()
        .setCustomId('rpg-back-to-hub')
        .setLabel('üè† Hub')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0x00ff00)
      .setTitle('üí° **Quality-of-Life Tools**')
      .setDescription('Choose a tab to access all QOL tools.')
      .addFields(
        { name: 'üìä Stats', value: 'Damage, crits, breakdowns, sessions', inline: true },
        { name: '‚öîÔ∏è Combat', value: 'Combat log, boss tools, combos, spell wheel', inline: true },
        { name: 'üéØ Progress', value: 'Achievements, milestones, quests, mastery', inline: true },
        { name: '‚öôÔ∏è Gear', value: 'Builds, compare, favorites, auto-sell, crafting', inline: true },
        { name: 'üß∞ Utility', value: 'Navigation, hotkeys, notifications, themes, timezones', inline: true },
        { name: 'üèÜ Guild', value: 'Leaderboards and growth', inline: true }
      );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2],
      ephemeral: false
    });
  }

  /**
   * QOL Stats Tab
   */
  async handleQOLStatsMenu(interaction, player) {
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-stats-timeline')
        .setLabel('Stats Timeline')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üìà'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-damage-calc')
        .setLabel('Damage Calc')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üí•'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-crit-display')
        .setLabel('Crit Analysis')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üéØ'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-damage-breakdown')
        .setLabel('Damage Breakdown')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üìä')
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-damage-tracker')
        .setLabel('Damage Tracker')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('‚öîÔ∏è'),
      new ButtonBuilder()
        .setCustomId('rpg-session-stats')
        .setLabel('Session Stats')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üìä')
    );

    const row3 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0x00bfff)
      .setTitle('üìä **QOL Stats**')
      .setDescription('All combat and performance stats in one place.');

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2, row3],
      ephemeral: false
    });
  }

  /**
   * QOL Combat Tab
   */
  async handleQOLCombatMenu(interaction, player) {
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-combat-log')
        .setLabel('Combat Log')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üìñ'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-boss-guide')
        .setLabel('Boss Guide')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üëπ'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-enemy-summary')
        .setLabel('Enemy Summary')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üìä'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-combo-preview')
        .setLabel('Combos')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('‚ú®')
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-spell-wheel')
        .setLabel('Spell Wheel')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚ö°'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-combo-viz')
        .setLabel('Combo Visuals')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚ú®'),
      new ButtonBuilder()
        .setCustomId('rpg-boss-analyzer')
        .setLabel('Boss Analyzer')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üëπ')
    );

    const row3 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0xff5555)
      .setTitle('‚öîÔ∏è **QOL Combat**')
      .setDescription('Combat planning, tracking, and execution tools.');

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2, row3],
      ephemeral: false
    });
  }

  /**
   * QOL Progress Tab
   */
  async handleQOLProgressMenu(interaction, player) {
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-achievements')
        .setLabel('Achievements')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üèÜ'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-milestones')
        .setLabel('Milestones')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üéØ'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-boss-tracker')
        .setLabel('Boss Tracker')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üëπ')
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-skill-mastery')
        .setLabel('Skill Mastery')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('‚≠ê'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-class-guide')
        .setLabel('Class Guide')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üìö'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-profession')
        .setLabel('Prof Tips')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üí°'),
      new ButtonBuilder()
        .setCustomId('rpg-crafting-queue')
        .setLabel('Crafting')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('‚öíÔ∏è')
    );

    const row3 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0x00ff88)
      .setTitle('üéØ **QOL Progress**')
      .setDescription('Progression, mastery, and long-term goals.');

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2, row3],
      ephemeral: false
    });
  }

  /**
   * QOL Gear Tab
   */
  async handleQOLGearMenu(interaction, player) {
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-equipment-compare')
        .setLabel('Gear Compare')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚öôÔ∏è'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-equipment-builds')
        .setLabel('Gear Builds')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üíæ'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-style-recommendation')
        .setLabel('Style Tips')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üí°'),
      new ButtonBuilder()
        .setCustomId('rpg-favorite-items')
        .setLabel('Favorites')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üíé')
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-stat-comparison')
        .setLabel('Stat Comp')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üìê'),
      new ButtonBuilder()
        .setCustomId('rpg-loot-analytics')
        .setLabel('Loot Analytics')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('üéÅ'),
      new ButtonBuilder()
        .setCustomId('rpg-auto-sell')
        .setLabel('Auto-Sell')
        .setStyle(ButtonStyle.Primary)
        .setEmoji('ü§ñ')
    );

    const row3 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0xffaa00)
      .setTitle('‚öôÔ∏è **QOL Gear**')
      .setDescription('Build, compare, craft, and optimize your loadout.');

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2, row3],
      ephemeral: false
    });
  }

  /**
   * QOL Utility Tab
   */
  async handleQOLUtilityMenu(interaction, player) {
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-notifications')
        .setLabel('Notifications')
        .setStyle(ButtonStyle.Success)
        .setEmoji('üîî')
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-enemy-encyclopedia')
        .setLabel('Encyclopedia')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üìö'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-env-tool')
        .setLabel('Env Tool')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üåç'),
      new ButtonBuilder()
        .setCustomId('rpg-qol-env-predict')
        .setLabel('Env Predict')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üîÆ'),
      new ButtonBuilder()
        .setCustomId('rpg-timezone')
        .setLabel('Timezone')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üïí')
    );

    const row3 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-ui-theme')
        .setLabel('UI Theme')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üé®')
    );

    const row4 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0x6aa0ff)
      .setTitle('üß∞ **QOL Utility**')
      .setDescription('Navigation, notifications, and UI preferences.');

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2, row3, row4],
      ephemeral: false
    });
  }

  /**
   * QOL Guild Tab
   */
  async handleQOLGuildMenu(interaction, player) {
    const row1 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-guild-leaderboard')
        .setLabel('Guild Leaderboard')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üèÜ'),
      new ButtonBuilder()
        .setCustomId('rpg-guild-growth')
        .setLabel('Guild Growth')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('üìä')
    );

    const row2 = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-qol-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0x9b59b6)
      .setTitle('üèÜ **QOL Guild**')
      .setDescription('Guild analytics and ranking tools.');

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [row1, row2],
      ephemeral: false
    });
  }

  /**
   * Handler for Daily Quest Tracker feature
   */
  async handleDailyQuests(interaction, player) {
    try {
      const questData = this.dailyQuestTracker.getPlayerQuests(player.id);
      const dailyCount = questData.daily.filter(q => !q.completed).length;
      const weeklyCount = questData.weekly.filter(q => !q.completed).length;
      const totalRewards = questData.totalClaimedRewards || 0;

      const embed = new EmbedBuilder()
        .setColor(0x00aaff)
        .setTitle('üìã **Daily Quest Tracker**')
        .setDescription(`Active Daily: ${dailyCount} | Active Weekly: ${weeklyCount}\nTotal Claimed Rewards: ${totalRewards}`)
        .addFields(
          { name: 'üìÖ Daily Quests', value: questData.daily.map(q => `${q.completed ? '‚úÖ' : '‚è≥'} ${q.name} - ${q.progress}/${q.goal}`).join('\n') || 'No daily quests', inline: false },
          { name: 'üìÜ Weekly Quests', value: questData.weekly.map(q => `${q.completed ? '‚úÖ' : '‚è≥'} ${q.name} - ${q.progress}/${q.goal}`).join('\n') || 'No weekly quests', inline: false },
          { name: '‚è∞ Time to Reset', value: this.dailyQuestTracker.getTimeToReset(), inline: true }
        )
        .setTimestamp();

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-daily-claim-all').setLabel('Claim All Rewards').setStyle(ButtonStyle.Success)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleDailyQuests:', error);
      await interaction.reply({ content: 'Failed to load daily quests.', ephemeral: true });
    }
  }

  getDailyRewardState(player, now = Date.now()) {
    const dayMs = 24 * 60 * 60 * 1000;
    const lastClaimAt = Number(player.dailyRewardLastClaimAt || 0);
    const streak = Number(player.dailyRewardStreak || 0);

    if (!lastClaimAt) {
      return {
        canClaim: true,
        missedDays: 0,
        restoreCost: 0,
        streak,
        lastClaimAt: null,
        nextClaimAt: now,
        streakExpired: false,
      };
    }

    const daysSince = Math.floor((now - lastClaimAt) / dayMs);
    const canClaim = daysSince >= 1;
    const missedDays = canClaim ? Math.max(0, daysSince - 1) : 0;
    const streakExpired = missedDays >= 4;
    const restoreCost = missedDays > 0 && !streakExpired ? 500 * missedDays * missedDays : 0;
    const nextClaimAt = lastClaimAt + dayMs;

    return {
      canClaim,
      missedDays,
      restoreCost,
      streak,
      lastClaimAt,
      nextClaimAt,
      streakExpired,
    };
  }

  getDailyLootboxTiersForDay(streakDay) {
    const tiers = ['common'];
    if (streakDay % 3 === 0) tiers.push('uncommon');
    if (streakDay % 7 === 0) tiers.push('rare');
    if (streakDay % 14 === 0) tiers.push('epic');
    if (streakDay % 30 === 0) tiers.push('legendary');
    return tiers;
  }

  getDailyLootboxPools() {
    return {
      common: {
        weights: { material: 0.4, potion: 0.35, enchant: 0.15, gear: 0.1 },
        material: ['iron_ore', 'granite', 'rare_flower', 'moonflower'],
        potion: ['health_potion_t1', 'xp_potion_t1', 'gold_potion_t1'],
        enchant: ['damage_enchant_t1', 'loot_enchant_t1'],
        gear: ['bronze_sword'],
      },
      uncommon: {
        weights: { material: 0.35, potion: 0.3, enchant: 0.2, gear: 0.15 },
        material: ['iron_ore', 'mana_crystal', 'granite', 'rare_flower'],
        potion: ['health_potion_t1', 'xp_potion_t2', 'gold_potion_t1'],
        enchant: ['damage_enchant_t1', 'loot_enchant_t1', 'xp_enchant_t1'],
        gear: ['iron_greatsword', 'steel_longsword'],
      },
      rare: {
        weights: { material: 0.3, potion: 0.25, enchant: 0.25, gear: 0.2 },
        material: ['mithril_ore', 'mana_crystal', 'ice_crystal', 'boss_essence'],
        potion: ['health_potion_t2', 'xp_potion_t2', 'gold_potion_t2', 'loot_potion_t1'],
        enchant: ['damage_enchant_t2', 'loot_enchant_t2', 'xp_enchant_t2'],
        gear: ['mithril_blade', 'odin_blade', 'hermes_staff'],
      },
      epic: {
        weights: { material: 0.25, potion: 0.25, enchant: 0.25, gear: 0.25 },
        material: ['adamantite', 'arcane_essence', 'dragonhide', 'boss_essence'],
        potion: ['health_potion_t3', 'xp_potion_t3', 'gold_potion_t3', 'loot_potion_t2'],
        enchant: ['damage_enchant_t3', 'loot_enchant_t3', 'doublehit_enchant_t2'],
        gear: ['thor_axe_junior', 'athena_staff_junior', 'hermes_daggers', 'zeus_hammer_junior'],
      },
      legendary: {
        weights: { material: 0.2, potion: 0.2, enchant: 0.25, gear: 0.35 },
        material: ['dragonstone', 'phoenix_feather', 'boss_essence', 'titan_core'],
        potion: ['health_potion_t4', 'xp_potion_t4', 'loot_potion_t3'],
        enchant: ['damage_enchant_t3', 'loot_enchant_t3', 'doublehit_enchant_t3'],
        gear: ['cosmic_destroyer', 'astral_conduit', 'reality_shards', 'eternal_arbiter'],
      },
    };
  }

  getLootboxItemId(tier) {
    return `lootbox_${tier}`;
  }

  getLootboxDisplayName(tier) {
    const label = String(tier || 'common');
    return `${label.charAt(0).toUpperCase()}${label.slice(1)} Lootbox`;
  }

  getLootboxTierFromId(lootboxId) {
    const match = String(lootboxId || '').match(/^lootbox_(.+)$/);
    return match ? match[1] : 'common';
  }

  addLootboxToInventory(player, tier, quantity = 1) {
    if (!player.inventory) player.inventory = [];
    const id = this.getLootboxItemId(tier);
    const existing = player.inventory.find(item =>
      item && typeof item === 'object' && item.id === id && item.type === 'consumable' && item.subtype === 'lootbox'
    );
    if (existing) {
      existing.quantity = (existing.quantity || 1) + quantity;
      return;
    }

    player.inventory.push({
      id,
      name: this.getLootboxDisplayName(tier),
      type: 'consumable',
      subtype: 'lootbox',
      rarity: tier,
      quantity,
    });
  }

  removeLootboxFromInventory(player, lootboxId, quantity = 1) {
    if (!player.inventory) return false;
    const item = player.inventory.find(i =>
      i && typeof i === 'object' && i.id === lootboxId && i.type === 'consumable' && i.subtype === 'lootbox'
    );
    if (!item) return false;
    const currentQty = item.quantity || 1;
    if (currentQty < quantity) return false;

    if (currentQty > quantity) {
      item.quantity = currentQty - quantity;
    } else {
      const index = player.inventory.indexOf(item);
      if (index > -1) player.inventory.splice(index, 1);
    }
    return true;
  }

  getLootboxInventoryItems(player) {
    if (!player.inventory) return [];
    return player.inventory.filter(item =>
      item && typeof item === 'object' && item.type === 'consumable' && item.subtype === 'lootbox'
    );
  }

  getLootboxRewardDisplayName(rewardId) {
    const equipment = getEquipment(rewardId);
    if (equipment?.name) return equipment.name;
    const item = getItemByIdDynamic(rewardId);
    if (item?.name) return item.name;
    const material = getMaterial(rewardId);
    if (material?.name) return material.name;
    return rewardId;
  }

  generateDailyLootboxReward(tier) {
    const pools = this.getDailyLootboxPools();
    const pool = pools[tier];
    if (!pool) return null;

    const rewardType = this.pickWeighted(pool.weights);
    const rewardId = this.pickRandom(pool[rewardType]);
    if (!rewardId) return null;

    const quantity = rewardType === 'material'
      ? Math.max(1, Math.floor(Math.random() * 3) + 1)
      : 1;

    return { tier, rewardType, rewardId, quantity };
  }

  applyDailyLootboxReward(player, reward) {
    if (!reward) return null;
    const { rewardType, rewardId, quantity } = reward;

    if (rewardType === 'material' || rewardId === 'boss_essence') {
      this.addMaterialToInventory(player, rewardId, quantity);
      const material = getMaterial(rewardId);
      return `${material?.name || rewardId} x${quantity}`;
    }

    this.addCraftedItem(player, rewardId, quantity);
    const displayName = this.getLootboxRewardDisplayName(rewardId);
    return `${displayName}${quantity > 1 ? ` x${quantity}` : ''}`;
  }

  getLootboxRollItems(tier) {
    const pools = this.getDailyLootboxPools();
    const pool = pools[tier];
    if (!pool) return [];

    const allIds = []
      .concat(pool.material || [])
      .concat(pool.potion || [])
      .concat(pool.enchant || [])
      .concat(pool.gear || []);

    const names = allIds.map(id => this.getLootboxRewardDisplayName(id));
    return names.filter((value, index, self) => self.indexOf(value) === index);
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  pickWeighted(weights) {
    const entries = Object.entries(weights);
    const total = entries.reduce((sum, [, weight]) => sum + weight, 0);
    let roll = Math.random() * total;
    for (const [key, weight] of entries) {
      roll -= weight;
      if (roll <= 0) return key;
    }
    return entries[0]?.[0] || 'material';
  }

  pickRandom(list) {
    if (!Array.isArray(list) || list.length === 0) return null;
    return list[Math.floor(Math.random() * list.length)];
  }

  rollDailyLootboxRewards(player, tier) {
    const reward = this.generateDailyLootboxReward(tier);
    if (!reward) return [];
    const applied = this.applyDailyLootboxReward(player, reward);
    return applied ? [applied] : [];
  }

  grantDailyRewardsForDay(player, streakDay) {
    const tiers = this.getDailyLootboxTiersForDay(streakDay);
    const lines = [];

    tiers.forEach((tier) => {
      this.addLootboxToInventory(player, tier, 1);
      lines.push(`üéÅ ${tier.toUpperCase()} Lootbox added to inventory`);
    });

    return { tiers, lines };
  }

  async handleDailyRewards(interaction, player) {
    this.trackMenuNavigation(player, 'daily-rewards');
    const now = Date.now();
    const state = this.getDailyRewardState(player, now);

    const nextClaimText = state.canClaim
      ? 'Available now'
      : `Next claim in ${this.formatTimeUntil(state.nextClaimAt, now)}`;

    const streakText = state.streak > 0 ? `${state.streak} day(s)` : 'No active streak';
    const missedText = state.missedDays > 0
      ? `${state.missedDays} day(s)`
      : 'None';
    const previewStartDay = Math.max(1, state.streak + 1);
    const previewLines = [];
    for (let i = 0; i < 5; i += 1) {
      const day = previewStartDay + i;
      const tiers = this.getDailyLootboxTiersForDay(day);
      const tierNames = tiers.map(t => `${t.charAt(0).toUpperCase()}${t.slice(1)}`).join(', ');
      previewLines.push(`Day ${day}: ${tierNames}`);
    }

    const embed = new EmbedBuilder()
      .setColor(0xf1c40f)
      .setTitle('üéÅ Daily Rewards')
      .setDescription(
        `**Streak:** ${streakText}\n` +
        `**Next Claim:** ${nextClaimText}\n` +
        `**Missed Days:** ${missedText}`
      )
      .addFields(
        { name: 'Lootboxes', value: 'Lootboxes are added to your inventory. Common daily, with bonus tiers at 3/7/14/30 day streaks.', inline: false },
        { name: 'Next 5 Rewards', value: previewLines.join('\n'), inline: false },
        { name: 'Missed Days', value: 'You can restore up to 3 missed days for a coin fee. 4+ missed days resets the streak.', inline: false }
      );

    if (state.missedDays > 0 && !state.streakExpired) {
      embed.addFields({
        name: 'Restore Cost',
        value: `${state.restoreCost.toLocaleString()}g to restore and claim missed rewards`,
        inline: false,
      });
    }

    if (state.streakExpired) {
      embed.addFields({
        name: 'Streak Lost',
        value: 'You missed 4+ days. Claiming today starts a new streak.',
        inline: false,
      });
    }

    const buttons = [];
    const row = new ActionRowBuilder();
    if (state.canClaim) {
      row.addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-daily-claim')
          .setLabel('Claim Daily Rewards')
          .setStyle(ButtonStyle.Success)
      );
    }

    if (state.canClaim && state.missedDays > 0 && !state.streakExpired) {
      row.addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-daily-restore')
          .setLabel(`Restore Streak (${state.restoreCost}g)`)
          .setStyle(ButtonStyle.Primary)
      );
    }

    if (row.components.length > 0) {
      buttons.push(row);
    }

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );
    buttons.push(backRow);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: buttons,
    });
  }

  async handleDailyRewardClaim(interaction, player, options = {}) {
    const now = Date.now();
    const state = this.getDailyRewardState(player, now);

    if (!state.canClaim) {
      await interaction.reply({
        content: `‚è≥ Daily rewards are not ready yet. Next claim in ${this.formatTimeUntil(state.nextClaimAt, now)}.`,
        ephemeral: true,
      });
      return;
    }

    if (state.missedDays > 0 && state.streakExpired) {
      // Streak lost, only allow reset claim
      options.restore = false;
    }

    if (options.restore && state.missedDays > 0) {
      if ((player.gold || 0) < state.restoreCost) {
        await interaction.reply({
          content: `‚ùå Not enough gold to restore the streak. Need ${state.restoreCost}g.`,
          ephemeral: true,
        });
        return;
      }
      player.gold -= state.restoreCost;
      this.trackGoldSpent(player, state.restoreCost, 'other');
    } else if (state.missedDays > 0) {
      // Reset streak if not restoring
      player.dailyRewardStreak = 0;
    }

    const daysToGrant = options.restore && state.missedDays > 0
      ? state.missedDays + 1
      : 1;

    let streak = Number(player.dailyRewardStreak || 0);
    const rewardLines = [];

    for (let i = 0; i < daysToGrant; i += 1) {
      streak += 1;
      const reward = this.grantDailyRewardsForDay(player, streak);
      rewardLines.push(`**Day ${streak}:**\n${reward.lines.join('\n')}`);
    }

    player.dailyRewardStreak = streak;
    player.dailyRewardLastClaimAt = now;
    player.dailyRewardTotalClaims = (player.dailyRewardTotalClaims || 0) + daysToGrant;
    this.persistPlayer(player);

    const embed = new EmbedBuilder()
      .setColor(0x2ecc71)
      .setTitle('‚úÖ Daily Rewards Claimed')
      .setDescription(rewardLines.join('\n\n'))
      .addFields({
        name: 'Open Lootboxes',
        value: 'Go to üéí Inventory and choose "Open Lootbox" to reveal the rewards.',
        inline: false,
      })
      .setFooter({ text: `Current Streak: ${player.dailyRewardStreak} day(s)` });

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-back')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [backRow],
    });
  }

  async handleOpenLootboxMenu(interaction, player) {
    this.trackMenuNavigation(player, 'lootbox-menu');
    const lootboxes = this.getLootboxInventoryItems(player);

    if (!lootboxes.length) {
      await interaction.reply({ content: 'You do not have any lootboxes to open.', ephemeral: true });
      return;
    }

    const grouped = new Map();
    for (const lootbox of lootboxes) {
      const id = lootbox.id;
      const current = grouped.get(id) || {
        id,
        name: lootbox.name || this.getLootboxDisplayName(this.getLootboxTierFromId(id)),
        rarity: lootbox.rarity || this.getLootboxTierFromId(id),
        quantity: 0,
      };
      current.quantity += lootbox.quantity || 1;
      grouped.set(id, current);
    }

    const options = Array.from(grouped.values()).slice(0, 25).map(box => ({
      label: `${box.name} (x${box.quantity})`.substring(0, 100),
      value: box.id,
      description: `Rarity: ${box.rarity}`.substring(0, 100),
      emoji: 'üéÅ',
    }));

    const selectRow = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-open-lootbox-select')
        .setPlaceholder('Select a lootbox to open')
        .addOptions(options)
    );

    const backRow = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-inventory')
        .setLabel('‚Üê Back to Inventory')
        .setStyle(ButtonStyle.Secondary)
    );

    const embed = new EmbedBuilder()
      .setColor(0xf1c40f)
      .setTitle('üéÅ Open Lootbox')
      .setDescription('Pick a lootbox to open. You can open multiple at once.');

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: [selectRow, backRow],
    });
  }

  async handleOpenLootboxQuantityMenu(interaction, player, lootboxId) {
    this.trackMenuNavigation(player, 'lootbox-quantity');
    const lootboxes = this.getLootboxInventoryItems(player);
    const selected = lootboxes.find(box => box.id === lootboxId);

    if (!selected) {
      await interaction.reply({ content: 'Lootbox not found in inventory.', ephemeral: true });
      return;
    }

    const available = selected.quantity || 1;
    const tier = this.getLootboxTierFromId(lootboxId);
    const displayName = selected.name || this.getLootboxDisplayName(tier);

    const quantities = [1, 5, 10, 25, 50, 100].filter(qty => qty <= available);
    if (available > 1 && !quantities.includes(available)) quantities.push(available);
    quantities.sort((a, b) => a - b);

    const buttons = quantities.map(qty =>
      new ButtonBuilder()
        .setCustomId(`rpg-open-lootbox-qty-${lootboxId}-${qty}`)
        .setLabel(`Open ${qty}x`)
        .setStyle(qty === 1 ? ButtonStyle.Primary : ButtonStyle.Success)
    );

    buttons.push(
      new ButtonBuilder()
        .setCustomId('rpg-open-lootbox')
        .setLabel('‚Üê Change Lootbox')
        .setStyle(ButtonStyle.Secondary)
    );

    const rows = [];
    for (let i = 0; i < buttons.length; i += 5) {
      rows.push(new ActionRowBuilder().addComponents(buttons.slice(i, i + 5)));
    }

    const embed = new EmbedBuilder()
      .setColor(0xf1c40f)
      .setTitle(`üéÅ ${displayName}`)
      .setDescription(`You have **${available}** available. Choose how many to open.`);

    await this.updateInteractionWithTracking(interaction, {
      embeds: [embed],
      components: rows,
    });
  }

  async handleOpenLootbox(interaction, player, lootboxId, quantity = 1) {
    this.trackMenuNavigation(player, 'lootbox-open');
    const tier = this.getLootboxTierFromId(lootboxId);
    const displayName = this.getLootboxDisplayName(tier);
    const openCount = quantity === 'max' ? Number.MAX_SAFE_INTEGER : parseInt(quantity, 10) || 1;

    const available = this.getLootboxInventoryItems(player)
      .filter(box => box.id === lootboxId)
      .reduce((sum, box) => sum + (box.quantity || 1), 0);

    const finalCount = Math.min(openCount, available);
    if (finalCount <= 0) {
      await interaction.reply({ content: 'Lootbox not found in inventory.', ephemeral: true });
      return;
    }

    if (!this.removeLootboxFromInventory(player, lootboxId, finalCount)) {
      await interaction.reply({ content: 'Lootbox not found in inventory.', ephemeral: true });
      return;
    }

    const rollPool = this.getLootboxRollItems(tier);
    const pool = rollPool.length > 0 ? rollPool : [displayName];

    const buildRollWindow = (forceReward) => {
      const size = 7;
      const items = [];
      for (let i = 0; i < size; i += 1) {
        items.push(pool[Math.floor(Math.random() * pool.length)]);
      }
      if (forceReward) {
        items[Math.floor(size / 2)] = pool[Math.floor(Math.random() * pool.length)];
      }
      return items;
    };

    const renderRoll = (items, highlightIndex) => {
      return items
        .map((name, idx) => (idx === highlightIndex ? `‚û°Ô∏è ${name}` : `  ${name}`))
        .join('\n');
    };

    const highlightIndex = 3;
    const frames = [
      buildRollWindow(false),
      buildRollWindow(false),
      buildRollWindow(true),
    ];

    if (!interaction.deferred && !interaction.replied) {
      await interaction.deferUpdate();
    }

    for (let i = 0; i < frames.length; i += 1) {
      const embed = new EmbedBuilder()
        .setColor(0xf1c40f)
        .setTitle(`üéÅ ${displayName}`)
        .setDescription(`Spinning x${finalCount}...\n\n${renderRoll(frames[i], highlightIndex)}`)
        .setFooter({ text: 'Rolling rewards...' });

      await interaction.editReply({ embeds: [embed], components: [] });
      await this.sleep(550);
    }

    const rewardSummary = new Map();
    for (let i = 0; i < finalCount; i += 1) {
      const reward = this.generateDailyLootboxReward(tier);
      if (!reward) continue;
      this.applyDailyLootboxReward(player, reward);
      const total = rewardSummary.get(reward.rewardId) || 0;
      rewardSummary.set(reward.rewardId, total + (reward.quantity || 1));
    }

    this.persistPlayer(player);

    const summaryLines = Array.from(rewardSummary.entries()).map(([rewardId, qty]) => {
      const name = this.getLootboxRewardDisplayName(rewardId);
      return qty > 1 ? `${name} x${qty}` : name;
    });

    const finalEmbed = new EmbedBuilder()
      .setColor(0x2ecc71)
      .setTitle(`‚úÖ ${displayName} Opened x${finalCount}`)
      .setDescription(summaryLines.length > 0 ? summaryLines.join('\n') : 'No rewards found.')
      .setFooter({ text: 'Loot delivered to your inventory.' });

    const buttons = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-open-lootbox')
        .setLabel('Open Another')
        .setStyle(ButtonStyle.Success),
      new ButtonBuilder()
        .setCustomId('rpg-inventory')
        .setLabel('‚Üê Back to Inventory')
        .setStyle(ButtonStyle.Secondary)
    );

    await interaction.editReply({ embeds: [finalEmbed], components: [buttons] });
  }

  /**
   * Handler for Damage Tracker feature
   */
  async handleDamageTracker(interaction, player) {
    try {
      // Use progress stats data
      const stats = player.progressStats || {};
      const monstersDefeated = stats.monstersDefeated || 0;
      const criticalHits = stats.criticalHits || 0;
      const dungeonsCleared = stats.dungeonsCleared || 0;
      const raidsCleared = stats.raidsCleared || 0;

      // Estimate total damage based on monsters defeated and player stats
      const playerStats = player.getStats();
      const strength = playerStats.strength || 0;
      const agility = playerStats.agility || 0;
      const level = player.level || 1;
      
      // Calculate average damage per fight using strength, agility, and level
      const avgDamagePerFight = Math.round(strength * 8 + agility * 3 + level * 5);
      const estimatedDamage = monstersDefeated * avgDamagePerFight;

      const embed = new EmbedBuilder()
        .setColor(0xff5555)
        .setTitle('‚öîÔ∏è **Damage Tracker**')
        .setDescription(`Estimated Total Damage: ${estimatedDamage.toLocaleString()}`)
        .addFields(
          { name: 'üíÄ Monsters Defeated', value: `${monstersDefeated.toLocaleString()}`, inline: true },
          { name: 'üí• Critical Hits', value: `${criticalHits.toLocaleString()}`, inline: true },
          { name: 'üìä Crit Rate', value: `${monstersDefeated > 0 ? Math.round((criticalHits / monstersDefeated) * 100) : 0}%`, inline: true },
          { name: 'üè∞ Dungeons Cleared', value: `${dungeonsCleared}`, inline: true },
          { name: 'üêâ Raids Cleared', value: `${raidsCleared}`, inline: true },
          { name: '‚öîÔ∏è Avg Damage/Kill', value: `~${avgDamagePerFight.toLocaleString()}`, inline: true }
        )
        .setTimestamp();

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleDamageTracker:', error);
      await interaction.reply({ content: 'Failed to load damage statistics.', ephemeral: true });
    }
  }

  /**
   * Handler for Boss Weakness Analyzer feature
   */
  async handleBossAnalyzer(interaction, player) {
    try {
      const bosses = this.bossWeaknessAnalyzer.getAllBossStats(player.userId);
      const recommendations = this.bossWeaknessAnalyzer.getRecommendations(player.userId);

      const fields = [];
      
      // Check if there's any boss data
      if (!bosses || Object.keys(bosses).length === 0) {
        await interaction.reply({
          content: 'üëπ No boss encounter data yet. Defeat some bosses to see their analysis!',
          ephemeral: true
        });
        return;
      }
      
      for (const bossName in bosses) {
        const boss = bosses[bossName];
        const weakness = this.bossWeaknessAnalyzer.getElementalWeakness(bossName, player.userId);
        fields.push({
          name: `${bossName} (Win Rate: ${boss.winRate}%)`,
          value: `Difficulty: ${boss.difficulty} | Best Strategy: ${weakness || 'Mixed'}`,
          inline: false
        });
      }

      const embed = new EmbedBuilder()
        .setColor(0xcc00cc)
        .setTitle('üëπ **Boss Weakness Analyzer**')
        .setDescription('Analyze your boss encounter history and get recommendations')
        .addFields(...fields)
        .addFields({ name: 'üí° Recommendations', value: recommendations || 'Keep exploring!', inline: false })
        .setTimestamp();

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleBossAnalyzer:', error);
      await interaction.reply({ content: 'üëπ No boss data available yet. Defeat bosses to unlock analysis!', ephemeral: true });
    }
  }

  /**
   * Handler for Loot Analytics feature
   */
  async handleLootAnalytics(interaction, player) {
    try {
      const rarityDist = this.lootAnalytics.getRarityDistribution(player.userId) || { total: 0, distribution: [] };
      const efficiency = this.lootAnalytics.getFarmingEfficiency(player.userId) || [];
      const recentDrops = this.lootAnalytics.getRecentDrops(player.userId, 5) || [];

      const dropList = rarityDist.distribution.slice(0, 5).map(d => `${d.rarity}: ${d.count} (${d.percentage}%)`).join('\n');
      const efficiencyList = efficiency.slice(0, 3).map(e => `${e.enemyName}: ${e.profitability}`).join('\n');

      const embed = new EmbedBuilder()
        .setColor(0xffaa00)
        .setTitle('üéÅ **Loot Analytics**')
        .setDescription('Track your drops and farming efficiency')
        .addFields(
          { name: 'üìä Drop Distribution', value: dropList || 'No drops yet', inline: true },
          { name: '‚ö° Best Farms', value: efficiencyList || 'No data yet', inline: true },
          { name: 'üîÑ Recent Drops', value: recentDrops.map(d => `${d.itemName} (${d.timeAgo})`).join('\n') || 'None', inline: false }
        )
        .setFooter({ text: `Total Drops: ${rarityDist.total}` })
        .setTimestamp();

      const backButton = new ButtonBuilder()
        .setCustomId('rpg-qol-tab-gear')
        .setLabel('Back')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚óÄÔ∏è');

      const row = new ActionRowBuilder().addComponents(backButton);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleLootAnalytics:', error);
      await interaction.reply({ content: 'Failed to load loot analytics.', ephemeral: true });
    }
  }

  /**
   * Handler for Skill Mastery feature
   */
  async handleSkillMastery(interaction, player) {
    try {
      const skills = this.skillMastery.getPlayerSkills(player.id);
      const masteries = this.skillMastery.getAchievedMasteries(player.id);

      const skillList = Object.entries(skills).slice(0, 8).map(([skill, data]) => 
        `${skill}: Lvl ${data.level} ${data.level >= 10 ? '‚≠ê' : ''}`
      ).join('\n');

      const embed = new EmbedBuilder()
        .setColor(0x00ff88)
        .setTitle('‚≠ê **Skill Mastery System**')
        .setDescription(`Masteries Achieved: ${masteries.length}`)
        .addFields(
          { name: 'üéØ Your Skills', value: skillList || 'No skills learned yet', inline: false },
          { name: 'üèÜ Achieved Masteries', value: masteries.join(', ') || 'Keep leveling!', inline: false }
        )
        .setTimestamp();

      const buttons = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-skills-details').setLabel('Skill Details').setStyle(ButtonStyle.Secondary),
        new ButtonBuilder().setCustomId('rpg-skills-variants').setLabel('Variants').setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [buttons],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleSkillMastery:', error);
      await interaction.reply({ content: 'Failed to load skill mastery data.', ephemeral: true });
    }
  }

  /**
   * Handler for Favorite Item Loadout feature
   */
  async handleFavoriteItems(interaction, player) {
    try {
      const favoritesData = this.favoriteItemLoadout.getFavorites(player.userId);
      const favorites = favoritesData.items || [];

      // For suggested, we'd need inventory items - for now show placeholder
      const suggested = [];

      const favList = favorites.map((fav, i) => `${i + 1}. ${fav.itemName} (${fav.itemSlot})`).join('\n');

      const embed = new EmbedBuilder()
        .setColor(0xff00ff)
        .setTitle('‚≠ê **Favorite Items**')
        .setDescription(`${favoritesData.total}/${favoritesData.maxSlots} Favorites Saved`)
        .addFields(
          { name: 'üíé Your Favorites', value: favList || 'No favorites set', inline: false },
          { name: 'üí° Info', value: 'Mark items as favorites for quick access!', inline: false }
        )
        .setTimestamp();

      const row1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-fav-add').setLabel('Add Favorite').setStyle(ButtonStyle.Primary).setDisabled(true),
        new ButtonBuilder().setCustomId('rpg-fav-equip').setLabel('Quick Equip').setStyle(ButtonStyle.Success).setDisabled(true)
      );

      const backButton = new ButtonBuilder()
        .setCustomId('rpg-qol-tab-gear')
        .setLabel('Back')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚óÄÔ∏è');

      const row2 = new ActionRowBuilder().addComponents(backButton);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row1, row2],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleFavoriteItems:', error);
      await interaction.reply({ content: 'Failed to load favorite items.', ephemeral: true });
    }
  }

  /**
   * Handler for Notification System feature
   */
  async handleNotifications(interaction, player) {
    try {
      const unreadData = this.notificationSystem.getUnreadNotifications(player.userId);
      const preferences = this.notificationSystem.getPreferences(player.userId);
      const history = this.notificationSystem.getAllNotifications(player.userId, 10);

      const notifList = unreadData.notifications.slice(0, 5).map(n => `${n.icon} ${n.type}: ${n.description}`).join('\n');
      const enabledPrefs = Object.entries(preferences).filter(([k, v]) => v && k !== 'playerId').map(([k]) => k).join(', ');

      const embed = new EmbedBuilder()
        .setColor(0x0088ff)
        .setTitle('üîî **Notifications**')
        .setDescription(`${unreadData.count} Unread Notifications`)
        .addFields(
          { name: 'üì¨ Recent', value: notifList || 'All caught up!', inline: false },
          { name: '‚öôÔ∏è Enabled Types', value: enabledPrefs || 'All enabled', inline: false }
        )
        .setTimestamp();

      const row1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-notif-clear').setLabel('Clear All').setStyle(ButtonStyle.Danger).setDisabled(true),
        new ButtonBuilder().setCustomId('rpg-notif-prefs').setLabel('Preferences').setStyle(ButtonStyle.Secondary).setDisabled(true)
      );

      const backButton = new ButtonBuilder()
        .setCustomId('rpg-qol-tab-utility')
        .setLabel('Back')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚óÄÔ∏è');

      const row2 = new ActionRowBuilder().addComponents(backButton);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row1, row2],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleNotifications:', error);
      await interaction.reply({ content: 'Failed to load notifications.', ephemeral: true });
    }
  }

  /**
   * Handler for Enemy Encyclopedia feature
   */
  async handleEnemyEncyclopedia(interaction, player) {
    try {
      const encyclopedia = this.enemyEncyclopedia.getEncyclopedia(player.userId);
      const trophies = this.enemyEncyclopedia.getTrophies(player.userId);
      
      const topEnemies = Object.values(encyclopedia.enemies || {}).sort((a, b) => b.encounters - a.encounters).slice(0, 5);
      const enemyList = topEnemies.map(data => `${data.enemyName}: ${data.defeatRate || 0}% WR (${data.encounters} encounters)`).join('\n');

      const embed = new EmbedBuilder()
        .setColor(0xaa0000)
        .setTitle('üìö **Enemy Encyclopedia**')
        .setDescription(`${encyclopedia.uniqueEnemies} Enemies Encountered`)
        .addFields(
          { name: '‚öîÔ∏è Most Encountered', value: enemyList || 'No enemies yet', inline: false },
          { name: 'üèÜ Trophies', value: `${trophies.length} Trophy Sets Completed`, inline: true }
        )
        .setTimestamp();

      const row1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-enc-view').setLabel('View All').setStyle(ButtonStyle.Primary).setDisabled(true),
        new ButtonBuilder().setCustomId('rpg-enc-trophies').setLabel('Trophies').setStyle(ButtonStyle.Secondary).setDisabled(true)
      );

      const backButton = new ButtonBuilder()
        .setCustomId('rpg-qol-tab-utility')
        .setLabel('Back')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚óÄÔ∏è');

      const row2 = new ActionRowBuilder().addComponents(backButton);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row1, row2],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleEnemyEncyclopedia:', error);
      await interaction.reply({ content: 'Failed to load enemy encyclopedia.', ephemeral: true });
    }
  }

  /**
   * Handler for Command Hotkeys feature
   */
  async handleCommandHotkeys(interaction, player) {
    try {
      const hotkeys = this.shorthandCommandTips.getPlayerHotkeys(player.id);
      const defaultHotkeys = this.shorthandCommandTips.getDefaultHotkeys();
      const favorites = this.shorthandCommandTips.getFavorites(player.id);

      const customHotkeys = Object.entries(hotkeys.custom || {}).slice(0, 5).map(([key, cmd]) => `\`${key}\` ‚Üí ${cmd}`).join('\n');

      const embed = new EmbedBuilder()
        .setColor(0x00ddff)
        .setTitle('‚å®Ô∏è **Command Hotkeys**')
        .setDescription('Quick access to common commands')
        .addFields(
          { name: '‚≠ê Favorites', value: (favorites || []).slice(0, 5).join(', ') || 'None', inline: false },
          { name: 'üîß Custom Bindings', value: customHotkeys || 'None set', inline: false }
        )
        .setTimestamp();

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-hotkey-add').setLabel('Add Hotkey').setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId('rpg-hotkey-view').setLabel('View All').setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleCommandHotkeys:', error);
      await interaction.reply({ content: 'Failed to load command hotkeys.', ephemeral: true });
    }
  }

  /**
   * Handler for Crafting Queue feature
   */
  async handleCraftingQueue(interaction, player) {
    try {
      const queue = this.craftingQueue.getPlayerQueue(player.id);
      const stats = this.craftingQueue.getQueueStats(player.id);

      const queueList = queue.slice(0, 5).map((item, i) => `${i + 1}. ${item.name} - ${item.estimatedTime}s`).join('\n');

      const embed = new EmbedBuilder()
        .setColor(0xffcc00)
        .setTitle('‚öíÔ∏è **Crafting Queue**')
        .setDescription(`${queue.length}/20 Items Queued`)
        .addFields(
          { name: 'üìã Queue', value: queueList || 'Queue empty', inline: false },
          { name: 'üìä Stats', value: `Total Crafted: ${stats.totalCrafted} | This Session: ${queue.length}`, inline: true },
          { name: '‚è±Ô∏è Est. Time', value: `${stats.totalEstimatedTime}s`, inline: true }
        )
        .setTimestamp();

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-craft-add').setLabel('Add Item').setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId('rpg-craft-start').setLabel('Start Crafting').setStyle(ButtonStyle.Success)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleCraftingQueue:', error);
      await interaction.reply({ content: 'Failed to load crafting queue.', ephemeral: true });
    }
  }

  /**
   * Handler for Auto-Sell Junk feature
   */
  async handleAutoSellSettings(interaction, player) {
    try {
      const settings = this.autoSellJunk.getSettings(player.userId);
      const stats = this.autoSellJunk.getStatistics(player.userId);

      const filters = stats.rarityFilter.length > 0 ? stats.rarityFilter.join(', ') : 'None';
      const excluded = settings.excludedItems.length > 0 ? settings.excludedItems.slice(0, 5).map(e => e.itemName).join(', ') : 'None';

      const embed = new EmbedBuilder()
        .setColor(0xffa500)
        .setTitle('ü§ñ **Auto-Sell Junk**')
        .setDescription('Configure automatic selling of low-value items')
        .addFields(
          { name: '‚öôÔ∏è Status', value: settings.enabled ? '‚úÖ Enabled' : '‚ùå Disabled', inline: true },
          { name: 'üìä Rarity Filter', value: filters, inline: false },
          { name: 'üí∞ Stats', value: `Items Sold: ${stats.totalItemsSold} | Gold Earned: ${stats.totalGoldEarned}`, inline: false },
          { name: '‚õî Excluded Items', value: excluded, inline: false }
        )
        .setTimestamp();

      const row1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-sell-toggle').setLabel(settings.enabled ? 'Disable' : 'Enable').setStyle(settings.enabled ? ButtonStyle.Danger : ButtonStyle.Success).setDisabled(true),
        new ButtonBuilder().setCustomId('rpg-sell-config').setLabel('Configure').setStyle(ButtonStyle.Primary).setDisabled(true)
      );

      const backButton = new ButtonBuilder()
        .setCustomId('rpg-qol-tab-gear')
        .setLabel('Back')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚óÄÔ∏è');

      const row2 = new ActionRowBuilder().addComponents(backButton);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row1, row2],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleAutoSellSettings:', error);
      await interaction.reply({ content: 'Failed to load auto-sell settings.', ephemeral: true });
    }
  }

  /**
   * Handler for Stat Comparison feature
   */
  async handleStatComparison(interaction, player) {
    try {
      const equipped = player.equippedItems || {};
      const stats = player.getStats();

      const slots = ['weapon', 'armor', 'shield', 'ring', 'amulet'];
      const equipmentInfo = slots.map(slot => {
        const item = equipped[slot];
        return `${slot.charAt(0).toUpperCase() + slot.slice(1)}: ${item ? `${item.name} (${item.rarity || 'Common'})` : 'Empty'}`;
      }).join('\n');

      const embed = new EmbedBuilder()
        .setColor(0x0066ff)
        .setTitle('‚öîÔ∏è **Stat Comparison**')
        .setDescription('View your current equipment and stats')
        .addFields(
          { name: 'üó°Ô∏è Equipment', value: equipmentInfo, inline: false },
          { name: 'üìä Total Stats', value: `Attack: ${stats.attack || 0}\nDefense: ${stats.defense || 0}\nHP: ${stats.maxHp || 0}`, inline: true },
          { name: '‚ö° Combat Stats', value: `Strength: ${stats.strength || 0}\nAgility: ${stats.agility || 0}\nIntelligence: ${stats.intelligence || 0}`, inline: true }
        )
        .setTimestamp();

      const row1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-comp-slot-view').setLabel('View Slot Details').setStyle(ButtonStyle.Primary).setDisabled(true),
        new ButtonBuilder().setCustomId('rpg-comp-set-compare').setLabel('Set Comparison').setStyle(ButtonStyle.Secondary).setDisabled(true)
      );

      const backButton = new ButtonBuilder()
        .setCustomId('rpg-qol-tab-gear')
        .setLabel('Back')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚óÄÔ∏è');

      const row2 = new ActionRowBuilder().addComponents(backButton);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row1, row2],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleStatComparison:', error);
      await interaction.reply({ content: 'Failed to load stat comparison.', ephemeral: true });
    }
  }

  /**
   * Handler for Timezone Support feature
   */
  async handleTimezoneSettings(interaction, player) {
    try {
      const settings = this.timeZoneSupport.getPlayerSettings(player.userId);
      const currentTime = this.timeZoneSupport.getCurrentLocalTime(player.userId);

      const embed = new EmbedBuilder()
        .setColor(0x00ffaa)
        .setTitle('üåç **Timezone Support**')
        .setDescription(`Current Timezone: ${settings.timeZone}`)
        .addFields(
          { name: '‚è∞ Local Time', value: `${currentTime.time} (${currentTime.utcOffset})`, inline: true },
          { name: 'üìÖ Date', value: currentTime.localDate, inline: true },
          { name: 'üí° Info', value: 'Set your timezone for accurate event scheduling!', inline: false }
        )
        .setTimestamp();

      const row1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-tz-change').setLabel('Change Timezone').setStyle(ButtonStyle.Primary).setDisabled(true),
        new ButtonBuilder().setCustomId('rpg-tz-schedule').setLabel('View Full Schedule').setStyle(ButtonStyle.Secondary).setDisabled(true)
      );

      const backButton = new ButtonBuilder()
        .setCustomId('rpg-qol-tab-utility')
        .setLabel('Back')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚óÄÔ∏è');

      const row2 = new ActionRowBuilder().addComponents(backButton);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row1, row2],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleTimezoneSettings:', error);
      await interaction.reply({ content: 'Failed to load timezone settings.', ephemeral: true });
    }
  }

  /**
   * Handler for UI Theme Manager feature
   */
  async handleUIThemeSettings(interaction, player) {
    try {
      const themeSettings = this.uiThemeManager.getPlayerTheme(player.userId);
      const availableThemes = this.uiThemeManager.getAvailableThemes();

      const currentTheme = themeSettings.currentTheme || 'dark';

      const embed = new EmbedBuilder()
        .setColor(0xff00ff)
        .setTitle('üé® **UI Theme Manager**')
        .setDescription(`Current Theme: **${currentTheme}**`)
        .addFields(
          { name: 'üé™ Available Themes', value: `${availableThemes.length} themes available`, inline: true },
          { name: '‚öôÔ∏è Settings', value: `Font: ${themeSettings.fontSize || 'medium'} | Animations: ${themeSettings.animations !== false ? 'On' : 'Off'}`, inline: true }
        )
        .setTimestamp();

      const select = new StringSelectMenuBuilder()
        .setCustomId('rpg-theme-select')
        .setPlaceholder('Choose a theme...')
        .addOptions(availableThemes.slice(0, 25).map(t => ({
          label: t.name,
          value: t.id,
          description: t.description?.substring(0, 100) || 'Theme option'
        })));

      const row1 = new ActionRowBuilder().addComponents(select);

      const backButton = new ButtonBuilder()
        .setCustomId('rpg-qol-tab-utility')
        .setLabel('Back')
        .setStyle(ButtonStyle.Secondary)
        .setEmoji('‚óÄÔ∏è');

      const row2 = new ActionRowBuilder().addComponents(backButton);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row1, row2],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleUIThemeSettings:', error);
      await interaction.reply({ content: 'Failed to load theme settings.', ephemeral: true });
    }
  }

  /**
   * Handler for Session Statistics feature
   */
  async handleSessionStats(interaction, player) {
    try {
      // Use progress stats data for session overview
      const stats = player.progressStats || {};
      const monstersDefeated = stats.monstersDefeated || 0;
      const gatheringActions = stats.gatheringActions || 0;
      const craftsCompleted = stats.craftsCompleted || 0;
      const goldEarned = stats.goldEarned || 0;

      // Calculate session info
      const level = player.level || 1;
      const xp = player.xp || 0;
      const gold = player.gold || 0;
      const recentActivity = this.combatSystem.isInCombat(player.userId) ? '‚öîÔ∏è In Combat' : 'üõ°Ô∏è Idle';

      const embed = new EmbedBuilder()
        .setColor(0x00ff00)
        .setTitle('üìä **Session Statistics**')
        .setDescription(`Level ${level} | ${xp.toLocaleString()} XP | ${gold.toLocaleString()}g`)
        .addFields(
          { name: 'üéÆ Current Status', value: recentActivity, inline: false },
          { name: 'üíÄ Monsters Defeated', value: `${monstersDefeated.toLocaleString()}`, inline: true },
          { name: '‚õèÔ∏è Resources Gathered', value: `${gatheringActions.toLocaleString()}`, inline: true },
          { name: 'üî® Items Crafted', value: `${craftsCompleted.toLocaleString()}`, inline: true },
          { name: 'üí∞ Total Gold Earned', value: `${goldEarned.toLocaleString()}g`, inline: true },
          { name: 'üèÜ Dungeons Cleared', value: `${stats.dungeonsCleared || 0}`, inline: true },
          { name: 'üêâ Raids Cleared', value: `${stats.raidsCleared || 0}`, inline: true }
        )
        .setTimestamp();

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder().setCustomId('rpg-back').setLabel('Back').setStyle(ButtonStyle.Secondary),
        new ButtonBuilder().setCustomId('rpg-progress-menu').setLabel('Progress Menu').setStyle(ButtonStyle.Primary),
        new ButtonBuilder().setCustomId('rpg-achievements').setLabel('Achievements').setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleSessionStats:', error);
      await interaction.reply({ content: 'Failed to load session statistics.', ephemeral: true });
    }
  }

  /**
   * Handle roguelike dungeon start
   */
  async handleRoguelikeStart(interaction, player) {
    try {
      const roguelike = new RoguelikeManager();

      // Check if player is eligible (Tier 2+)
      if (!roguelike.isPlayerEligible(player)) {
        await interaction.reply({
          content: 'üîí You must unlock World 2 (Tier 2) to access the Roguelike Dungeon!',
          ephemeral: true,
        });
        return;
      }

      // Check if player is already in a run
      if (player.roguelikeState && player.roguelikeState.isActive) {
        // Safety check: if run started more than 24 hours ago, auto-clear it
        const runAge = Date.now() - (player.roguelikeState.startedAt || 0);
        const twentyFourHours = 24 * 60 * 60 * 1000;
        
        if (runAge > twentyFourHours) {
          console.log(`Auto-clearing stuck roguelike run for ${player.userId} (age: ${Math.floor(runAge / 3600000)} hours)`);
          player.roguelikeState = null;
          await this.playerManager.savePlayer(player);
        } else {
          await interaction.reply({
            content: '‚ö†Ô∏è You are already in a roguelike run! Complete or exit your current run first.\n*Tip: Use `/roguelike exit` to leave your current run.*',
            ephemeral: true,
          });
          return;
        }
      }

      const embed = new EmbedBuilder()
        .setColor(0x9b59b6)
        .setTitle('üé≤ Roguelike Dungeon')
        .setDescription(
          '**The Roguelike Challenge**\n\n' +
          '**26 Floors of Procedurally-Generated Dungeons**\n' +
          '‚Ä¢ 5 bosses at every 5 floors\n' +
          '‚Ä¢ 1 final boss on floor 26\n' +
          '‚Ä¢ Difficulty scales per boss section\n\n' +
          '**Starting Conditions**\n' +
          '‚Ä¢ Start at Level 1 with base stats\n' +
          '‚Ä¢ All skills and equipment reset\n' +
          '‚Ä¢ Gain skills from skill rooms\n\n' +
          '**Currency System**\n' +
          'üíé Currency A: Permanent roguelike upgrades\n' +
          '‚≠ê Currency B: Unlock room types during run\n' +
          'üèÜ Currency C: Character upgrades outside roguelike\n\n' +
          '**Rewards**\n' +
          'üíÄ Death: 100% currency rewards\n' +
          'üö™ Voluntary Exit: 50% currency rewards\n\n' +
          `**Your Roguelike Stats**\n` +
          `Runs Completed: ${player.roguelikeStats.totalRunsCompleted}\n` +
          `Highest Floor: ${player.roguelikeStats.highestFloorReached}/26\n` +
          `Total Currency A: ${player.roguelikeCurrencies.currencyA}\n` +
          `Total Currency B: ${player.roguelikeCurrencies.currencyB}\n` +
          `Total Currency C: ${player.roguelikeCurrencies.currencyC}`
        )
        .setColor(0x9b59b6);

      const row1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-start-new')
          .setLabel('üé≤ Start New Run')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-upgrades')
          .setLabel('üíé Upgrades')
          .setStyle(ButtonStyle.Primary)
      );

      const row2 = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-stats')
          .setLabel('üìä Statistics')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row1, row2],
      });
    } catch (error) {
      console.error('Error in handleRoguelikeStart:', error);
      await interaction.reply({
        content: 'Failed to load roguelike dungeon.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle starting a new roguelike run
   */
  async handleRoguelikeStartNew(interaction, player) {
    try {
      const roguelike = new RoguelikeManager();

      // Initialize new run
      player.roguelikeState = roguelike.initializeRun(player);
      player.roguelikeState.isActive = true;

      // Save player
      await this.playerManager.savePlayer(player);

      // Show floor 1
      await this.handleRoguelikeFloor(interaction, player);
    } catch (error) {
      console.error('Error starting roguelike run:', error);
      await interaction.reply({
        content: 'Failed to start roguelike run.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle displaying a roguelike floor
   */
  async handleRoguelikeFloor(interaction, player) {
    try {
      if (!player.roguelikeState || !player.roguelikeState.isActive) {
        await interaction.reply({
          content: 'No active roguelike run. Start one first!',
          ephemeral: true,
        });
        return;
      }

      const roguelike = new RoguelikeManager();
      const state = player.roguelikeState;
      const currentFloor = state.currentFloor;
      const isBossFloor = currentFloor % 5 === 0 || currentFloor === 26;

      let floorTitle = `üé≤ Floor ${currentFloor}/26`;
      if (isBossFloor) {
        const bossNum = currentFloor === 26 ? 6 : Math.ceil(currentFloor / 5);
        floorTitle = `üëπ BOSS FLOOR ${bossNum}`;
      }

      // Generate rooms for this floor
      const rooms = roguelike.generateFloorRooms(state, currentFloor);
      state.currentFloorRooms = rooms;

      const embed = new EmbedBuilder()
        .setColor(0x9b59b6)
        .setTitle(floorTitle)
        .setDescription(
          `**Progress:** Floor ${currentFloor}/26 | Bosses Defeated: ${state.bossesDefeated}/5\n` +
          `**Mini-Bosses Defeated:** ${state.miniBossesDefeated || 0}\n\n` +
          `**Your Stats**\n` +
          `‚ù§Ô∏è HP: ${state.hp}/${state.stats.maxHp}\n` +
          `üíô Mana: ${state.mana}/${state.stats.maxMana}\n` +
          `‚öîÔ∏è Strength: ${state.stats.strength}\n` +
          `üõ°Ô∏è Defense: ${state.stats.defense}\n\n` +
          `**Available Rooms**\n` +
          rooms.map((r, i) => {
            const roomEmoji = this.ROOM_EMOJIS[r.type] || 'üìç';
            const roomName = this.ROOM_NAMES[r.type] || r.type;
            const miniBossIndicator = r.miniBoss ? ' ‚öîÔ∏è' : '';
            const modifierIndicator = r.modifier ? ` ${r.modifier.name.split(' ')[0]}` : '';
            return `${i + 1}. ${roomEmoji}${miniBossIndicator} ${roomName}${modifierIndicator} - ${r.description}`;
          }).join('\n')
        )
        .setColor(isBossFloor ? 0xff0000 : 0x9b59b6);

      // Create room selection buttons
      const buttons = [];
      for (let i = 0; i < rooms.length; i += 5) {
        const batchButtons = rooms.slice(i, Math.min(i + 5, rooms.length)).map((room, idx) => {
          const buttonNum = i + idx + 1;
          return new ButtonBuilder()
            .setCustomId(`rpg-roguelike-room-${room.id}`)
            .setLabel(`${buttonNum}. ${this.ROOM_NAMES[room.type] || room.type}`)
            .setStyle(ButtonStyle.Primary);
        });

        if (batchButtons.length > 0) {
          buttons.push(new ActionRowBuilder().addComponents(batchButtons));
        }
      }

      // Add exit button
      const bottomRow = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-exit')
          .setLabel('üö™ Exit Dungeon (50% rewards)')
          .setStyle(ButtonStyle.Danger)
      );
      buttons.push(bottomRow);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: buttons,
      });
    } catch (error) {
      console.error('Error in handleRoguelikeFloor:', error);
      await interaction.reply({
        content: 'Failed to load floor.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle room selection
   */
  async handleRoguelikeRoomSelect(interaction, player, roomId) {
    try {
      if (!player.roguelikeState || !player.roguelikeState.isActive) {
        await interaction.reply({
          content: 'No active run.',
          ephemeral: true,
        });
        return;
      }

      const state = player.roguelikeState;
      const room = state.currentFloorRooms.find(r => r.id === roomId);

      if (!room) {
        await interaction.reply({
          content: 'Room not found.',
          ephemeral: true,
        });
        return;
      }

      const roguelike = new RoguelikeManager();
      const isBossFloor = state.currentFloor % 5 === 0 || state.currentFloor === 26;

      // Boss floors should always offer the boss encounter (except skill rooms)
      if (isBossFloor && room.type !== 'skill') {
        await this.handleRoguelikeBossRoom(interaction, player, room);
      } else if (room.miniBoss && !room.miniBoss.defeated) {
        // Show mini-boss encounter
        await this.handleRoguelikeMiniBossRoom(interaction, player, room);
      } else if (room.type === 'skill') {
        // Skill room - show skill and offer to accept
        await this.handleRoguelikeSkillRoom(interaction, player, room);
      } else if (room.type === 'shop') {
        // Shop room - show shop interface
        await this.handleRoguelikeShopRoom(interaction, player, room);
      } else {
        // Regular room - process and advance
        const actionResults = {};
        roguelike.completeRoom(state, room, actionResults);
        state.currentFloor++;

        // Save and show next floor
        await this.playerManager.savePlayer(player);
        await this.handleRoguelikeFloor(interaction, player);
      }
    } catch (error) {
      console.error('Error in handleRoguelikeRoomSelect:', error);
      await interaction.reply({
        content: 'Failed to process room selection.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle mini-boss room encounter
   */
  async handleRoguelikeMiniBossRoom(interaction, player, room) {
    try {
      const state = player.roguelikeState;
      const miniBoss = room.miniBoss;

      const embed = new EmbedBuilder()
        .setColor(0xff6b6b)
        .setTitle(`‚öîÔ∏è ${miniBoss.name} Appears!`)
        .setDescription(
          `A fierce ${miniBoss.name} blocks your path in this ${this.ROOM_NAMES[room.type] || room.type}!\n\n` +
          `**Mini-Boss Stats**\n` +
          `‚ù§Ô∏è Health: ${miniBoss.health}/${miniBoss.maxHealth}\n` +
          `‚öîÔ∏è Damage: ${miniBoss.damage}\n` +
          `üõ°Ô∏è Defense: ${miniBoss.defense}\n` +
          `‚ú® Special: ${miniBoss.ability.name} - ${miniBoss.ability.description}\n\n` +
          `**Your Stats**\n` +
          `‚ù§Ô∏è HP: ${state.hp}/${state.stats.maxHp}\n` +
          `üíô Mana: ${state.mana}/${state.stats.maxMana}\n` +
          `‚öîÔ∏è Strength: ${state.stats.strength}\n` +
          `üõ°Ô∏è Defense: ${state.stats.defense}`
        );

      // Add modifier and event info if present
      if (room.modifier) {
        embed.addFields({ 
          name: `${room.modifier.name}`, 
          value: room.modifier.description, 
          inline: true 
        });
      }
      if (room.event) {
        embed.addFields({ 
          name: `üìú ${room.event.name}`, 
          value: `Complete this challenge for bonus rewards!`, 
          inline: true 
        });
      }

      // Show potential loot
      if (miniBoss.loot && miniBoss.loot.length > 0) {
        const lootPreview = miniBoss.loot.slice(0, 3).map(l => `${l.rarity === 'legendary' ? '‚≠ê' : l.rarity === 'rare' ? 'üíé' : 'üí∞'} ${l.name}`).join(', ');
        embed.addFields({ 
          name: 'üéÅ Potential Loot', 
          value: lootPreview + (miniBoss.loot.length > 3 ? '...' : ''), 
          inline: false 
        });
      }

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-roguelike-miniboss-fight-${room.id}`)
          .setLabel('‚öîÔ∏è Fight Mini-Boss')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-exit')
          .setLabel('üö™ Flee (50% rewards)')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
      });
    } catch (error) {
      console.error('Error in handleRoguelikeMiniBossRoom:', error);
      await interaction.reply({
        content: 'Failed to load mini-boss encounter.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle skill room selection
   */
  async handleRoguelikeSkillRoom(interaction, player, room, victoryContext = null) {
    try {
      const skills = Array.isArray(room.skillOptions) && room.skillOptions.length
        ? room.skillOptions
        : (room.skill ? [room.skill] : []);

      if (skills.length === 0) {
        await interaction.reply({
          content: 'No skills available in this room.',
          ephemeral: true,
        });
        return;
      }

      const skillsList = skills
        .map((skill, index) =>
          `**${index + 1}. ${skill.name}** - ${skill.description}\n` +
          `‚öîÔ∏è ${skill.damage} DMG | üíô ${skill.mana} Mana`
        )
        .join('\n\n');

      const victoryText = victoryContext
        ? `**Victory Rewards**\n` +
          `üíé Currency A: +${victoryContext.currencyA}\n` +
          `‚≠ê Currency B: +${victoryContext.currencyB}\n` +
          (victoryContext.lootGained && victoryContext.lootGained.length > 0
            ? `üéÅ Loot: ${victoryContext.lootGained.map(l => l.name).join(', ')}\n`
            : '') +
          '\n'
        : '';

      const embed = new EmbedBuilder()
        .setColor(0xf39c12)
        .setTitle('‚ö° Choose a Skill')
        .setDescription(
          `${victoryText}` +
          `**Available Skills**\n\n` +
          `${skillsList}\n\n` +
          `*Pick one skill to add to your run.*`
        );

      const rows = [];
      let currentRow = new ActionRowBuilder();

      skills.forEach((skill, index) => {
        const button = new ButtonBuilder()
          .setCustomId(`rpg-roguelike-skill-choose-${room.id}-${index}`)
          .setLabel(`${index + 1}. ${skill.name}`.slice(0, 80))
          .setStyle(ButtonStyle.Success);

        if (currentRow.components.length >= 5) {
          rows.push(currentRow);
          currentRow = new ActionRowBuilder();
        }

        currentRow.addComponents(button);
      });

      if (currentRow.components.length > 0) {
        rows.push(currentRow);
      }

      rows.push(
        new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId(`rpg-roguelike-skill-decline-${room.id}`)
            .setLabel('‚úó Skip Skill')
            .setStyle(ButtonStyle.Secondary)
        )
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: rows,
      });
    } catch (error) {
      console.error('Error in handleRoguelikeSkillRoom:', error);
      await interaction.reply({
        content: 'Failed to load skill room.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle boss room
   */
  async handleRoguelikeBossRoom(interaction, player, room) {
    try {
      const roguelike = new RoguelikeManager();
      const state = player.roguelikeState;

      // Calculate boss stats
      const nextBossNum = state.bossesDefeated + 1;
      const bossStats = roguelike.calculateBossStats(nextBossNum, state);

      const embed = new EmbedBuilder()
        .setColor(0xff0000)
        .setTitle(`üëπ ${bossStats.name}`)
        .setDescription(bossStats.description)
        .addFields(
          { name: '‚ù§Ô∏è Health', value: `${bossStats.health}`, inline: true },
          { name: '‚öîÔ∏è Damage', value: `${bossStats.damage}`, inline: true },
          { name: 'üõ°Ô∏è Defense', value: `${bossStats.defense}`, inline: true },
          { name: '‚ö†Ô∏è Warning', value: 'This is a powerful opponent. Your skills and items will help you survive!' }
        )
        .setColor(0xff0000);

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-boss-fight')
          .setLabel('‚öîÔ∏è Fight Boss')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-exit')
          .setLabel('üö™ Flee (50% rewards)')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
      });
    } catch (error) {
      console.error('Error in handleRoguelikeBossRoom:', error);
      await interaction.reply({
        content: 'Failed to load boss room.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle shop room with enhanced interface
   */
  async handleRoguelikeShopRoom(interaction, player, room) {
    try {
      const state = player.roguelikeState;
      const roguelike = new RoguelikeManager();

      // Get available gold
      const gold = state.currencyAEarned || 0;

      // Format shop items
      let itemsList = room.items.map((item, index) => {
        const canAfford = gold >= item.cost;
        const status = canAfford ? '‚úÖ' : '‚ùå';
        return `${status} **${item.name}** - ${item.cost} gold\n   ${item.effect}`;
      }).join('\n\n');

      const embed = new EmbedBuilder()
        .setColor(0x3498db)
        .setTitle(`üè™ Shop - Floor ${state.currentFloor}`)
        .setDescription(
          `**Welcome to the Shop!**\n` +
          `üí∞ Your Gold: **${gold}**\n\n` +
          `**Available Items:**\n${itemsList}\n\n` +
          `*Tip: View the full catalog to see all possible shop items!*`
        )
        .setFooter({ text: 'Items scale with floor level' });

      const row1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-shop-catalog')
          .setLabel('üìã View Full Catalog')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-shop-leave')
          .setLabel('üö™ Leave Shop')
          .setStyle(ButtonStyle.Secondary)
      );

      // Create buy buttons for affordable items (max 5 per row)
      const affordableItems = room.items.filter(item => gold >= item.cost).slice(0, 5);
      const components = [row1];
      
      if (affordableItems.length > 0) {
        const row2 = new ActionRowBuilder();
        affordableItems.slice(0, 5).forEach((item, index) => {
          row2.addComponents(
            new ButtonBuilder()
              .setCustomId(`rpg-roguelike-shop-buy_${index}`)
              .setLabel(`Buy ${item.name.slice(0, 20)}`)
              .setStyle(ButtonStyle.Success)
          );
        });
        components.push(row2);
      }

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components,
      });
    } catch (error) {
      console.error('Error in handleRoguelikeShopRoom:', error);
      await interaction.reply({
        content: 'Failed to load shop.',
        ephemeral: true,
      });
    }
  }

  /**
   * Show full shop catalog
   */
  async handleRoguelikeShopCatalog(interaction, player) {
    try {
      const state = player.roguelikeState;
      const roguelike = new RoguelikeManager();
      const catalog = roguelike.getShopCatalog(state.currentFloor);

      const embed = new EmbedBuilder()
        .setColor(0x2ecc71)
        .setTitle('üìã Shop Catalog - All Available Items')
        .setDescription(
          `*This catalog shows all items that can appear in shops throughout your run.*\n` +
          `*Prices scale with floor level. Current floor: ${state.currentFloor}*\n\n`
        )
        .addFields(
          {
            name: '‚ù§Ô∏è CONSUMABLES',
            value: catalog.consumables.map(item => `**${item.name}** - ${item.cost}g\n   ‚îî ${item.effect}`).join('\n'),
            inline: false
          },
          {
            name: 'üí™ TEMPORARY BUFFS',
            value: catalog.buffs.map(item => `**${item.name}** - ${item.cost}g\n   ‚îî ${item.effect}`).join('\n'),
            inline: false
          },
          {
            name: '‚öîÔ∏è EQUIPMENT',
            value: catalog.equipment.map(item => `**${item.name}** - ${item.cost}g\n   ‚îî ${item.effect}`).join('\n'),
            inline: false
          },
          {
            name: '‚ú® SPECIAL ITEMS',
            value: catalog.special.map(item => `**${item.name}** - ${item.cost}g\n   ‚îî ${item.effect}`).join('\n').slice(0, 1024),
            inline: false
          },
          {
            name: 'üîß UTILITY',
            value: catalog.utility.map(item => `**${item.name}** - ${item.cost}g\n   ‚îî ${item.effect}`).join('\n'),
            inline: false
          }
        )
        .setFooter({ text: 'Shops offer 5-7 random items per visit' });

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-shop-back')
          .setLabel('‚Üê Back to Shop')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
      });
    } catch (error) {
      console.error('Error in handleRoguelikeShopCatalog:', error);
      await interaction.reply({
        content: 'Failed to load catalog.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle shop item purchase
   */
  async handleRoguelikeShopBuy(interaction, player, itemIndex) {
    try {
      const state = player.roguelikeState;
      if (!state || !state.isActive) {
        await interaction.reply({
          content: 'No active run.',
          ephemeral: true,
        });
        return;
      }

      const room = state.currentFloorRooms.find(r => r.type === 'shop');
      if (!room || !room.items || !room.items[itemIndex]) {
        await interaction.reply({
          content: 'Item not found.',
          ephemeral: true,
        });
        return;
      }

      const item = room.items[itemIndex];
      const gold = state.currencyAEarned || 0;

      // Check if can afford
      if (gold < item.cost) {
        await interaction.reply({
          content: `‚ö†Ô∏è Not enough gold! You need ${item.cost} gold but only have ${gold}.`,
          ephemeral: true,
        });
        return;
      }

      // Purchase item
      state.currencyAEarned -= item.cost;
      state.items.push({ ...item, purchasedAt: Date.now() });
      state.shopUpgradesPurchased++;

      // Apply item effect if it's a stat boost
      if (item.id.includes('Potion') || item.id.includes('Elixir')) {
        if (item.id.includes('strength')) {
          const boost = item.id.includes('Elixir') ? 10 : 5;
          state.stats.strength += boost;
        } else if (item.id.includes('defense')) {
          const boost = item.id.includes('Elixir') ? 10 : 5;
          state.stats.defense += boost;
        } else if (item.id.includes('speed')) {
          const boost = item.id.includes('Elixir') ? 10 : 5;
          state.stats.agility += boost;
        } else if (item.id.includes('intelligence')) {
          state.stats.intelligence += 5;
        } else if (item.id.includes('wisdom')) {
          state.stats.wisdom += 5;
        }
      }

      // Save player
      await this.playerManager.savePlayer(player);

      // Show confirmation and return to shop
      await interaction.reply({
        content: `‚úÖ Purchased **${item.name}** for ${item.cost} gold!\n${item.effect}`,
        ephemeral: true,
      });

      // Refresh shop display
      setTimeout(async () => {
        await this.handleRoguelikeShopRoom(interaction, player, room);
      }, 1000);

    } catch (error) {
      console.error('Error in handleRoguelikeShopBuy:', error);
      await interaction.reply({
        content: 'Failed to purchase item.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle roguelike exit
   */
  async handleRoguelikeExit(interaction, player) {
    try {
      if (!player.roguelikeState || !player.roguelikeState.isActive) {
        await interaction.reply({
          content: 'No active run.',
          ephemeral: true,
        });
        return;
      }

      const roguelike = new RoguelikeManager();
      const state = player.roguelikeState;

      // Calculate rewards (50% for voluntary exit)
      const rewards = roguelike.calculateRewards(state, 'voluntaryExit');

      // Update player
      player.roguelikeCurrencies.currencyA += rewards.currencyA;
      player.roguelikeCurrencies.currencyB += rewards.currencyB;
      player.roguelikeCurrencies.currencyC += rewards.currencyC;

      // Update stats
      player.roguelikeStats.totalRunsCompleted++;
      player.roguelikeStats.highestFloorReached = Math.max(
        player.roguelikeStats.highestFloorReached,
        state.currentFloor
      );
      player.roguelikeStats.voluntaryExits++;

      // Clear run state
      player.roguelikeState = null;

      // Save player
      await this.playerManager.savePlayer(player);

      const embed = new EmbedBuilder()
        .setColor(0x2ecc71)
        .setTitle('üé≤ Roguelike Run Complete')
        .setDescription(
          `**You've exited the dungeon!**\n\n` +
          `**Rewards Earned (50% multiplier)**\n` +
          `üíé Currency A: +${rewards.currencyA}\n` +
          `‚≠ê Currency B: +${rewards.currencyB}\n` +
          `üèÜ Currency C: +${rewards.currencyC}\n\n` +
          `**Run Summary**\n` +
          `üìç Floors Cleared: ${state.floorsCleared}\n` +
          `üëπ Bosses Defeated: ${state.bossesDefeated}`
        )
        .setColor(0x2ecc71);

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike')
          .setLabel('üé≤ Back to Roguelike')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-combat-menu')
          .setLabel('‚öîÔ∏è Combat Menu')
          .setStyle(ButtonStyle.Primary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
      });
    } catch (error) {
      console.error('Error in handleRoguelikeExit:', error);
      await interaction.reply({
        content: 'Failed to exit run.',
        ephemeral: true,
      });
    }
  }

  // Room emojis and names for display
  get ROOM_EMOJIS() {
    return {
      skill: '‚ö°',
      treasure: 'üíé',
      healing: '‚ù§Ô∏è',
      rest: 'üò¥',
      trap: '‚ö†Ô∏è',
      shop: 'üè™',
      libraryRoom: 'üìö',
      armoryRoom: 'üõ°Ô∏è',
      alchemyRoom: 'üß™',
    };
  }

  get ROOM_NAMES() {
    return {
      skill: 'Skill Room',
      treasure: 'Treasure',
      healing: 'Healing',
      rest: 'Rest',
      trap: 'Trap',
      shop: 'Shop',
      libraryRoom: 'Library',
      armoryRoom: 'Armory',
      alchemyRoom: 'Alchemy',
      combat: 'Combat Chamber',
      mystery: 'Mystery Room',
      elite: 'Elite Chamber',
    };
  }

  /**
   * Handle accepting skill in roguelike
   */
  async handleRoguelikeSkillAccept(interaction, player) {
    try {
      if (!player.roguelikeState || !player.roguelikeState.isActive) {
        await interaction.reply({ content: 'No active run.', ephemeral: true });
        return;
      }

      const state = player.roguelikeState;
      const room = state.currentFloorRooms.find(r => r.type === 'skill');
      const fallbackSkills = room?.skillOptions || (room?.skill ? [room.skill] : []);

      if (!room || fallbackSkills.length === 0) {
        await interaction.reply({ content: 'No skill room found.', ephemeral: true });
        return;
      }

      await this.handleRoguelikeSkillChoose(interaction, player, room.id, 0);
    } catch (error) {
      console.error('Error accepting skill:', error);
      await interaction.reply({ content: 'Failed to accept skill.', ephemeral: true });
    }
  }

  /**
   * Handle declining skill in roguelike
   */
  async handleRoguelikeSkillDecline(interaction, player, roomId = null) {
    try {
      if (!player.roguelikeState || !player.roguelikeState.isActive) {
        await interaction.reply({ content: 'No active run.', ephemeral: true });
        return;
      }

      const state = player.roguelikeState;
      const room = roomId
        ? state.currentFloorRooms.find(r => r.id === roomId)
        : state.currentFloorRooms.find(r => r.type === 'skill');

      if (!room) {
        await interaction.reply({ content: 'Skill room not found.', ephemeral: true });
        return;
      }

      const roguelike = new RoguelikeManager();
      const actionResults = { accepted: false, bossDefeated: !!room.miniBoss };
      roguelike.completeRoom(state, room, actionResults);
      state.currentFloor++;

      await this.playerManager.savePlayer(player);
      await this.handleRoguelikeFloor(interaction, player);
    } catch (error) {
      console.error('Error declining skill:', error);
      await interaction.reply({ content: 'Failed to decline skill.', ephemeral: true });
    }
  }

  /**
   * Handle selecting a specific skill option
   */
  async handleRoguelikeSkillChoose(interaction, player, roomId, skillIndex) {
    try {
      if (!player.roguelikeState || !player.roguelikeState.isActive) {
        await interaction.reply({ content: 'No active run.', ephemeral: true });
        return;
      }

      const state = player.roguelikeState;
      const room = state.currentFloorRooms.find(r => r.id === roomId);

      if (!room) {
        await interaction.reply({ content: 'Skill room not found.', ephemeral: true });
        return;
      }

      const skillOptions = room.skillOptions || (room.skill ? [room.skill] : []);
      const selectedSkill = skillOptions[skillIndex];

      if (!selectedSkill) {
        await interaction.reply({ content: 'Invalid skill selection.', ephemeral: true });
        return;
      }

      const roguelike = new RoguelikeManager();
      const actionResults = { accepted: true, selectedSkill, bossDefeated: !!room.miniBoss };
      roguelike.completeRoom(state, room, actionResults);

      state.currentFloor++;
      await this.playerManager.savePlayer(player);
      await this.handleRoguelikeFloor(interaction, player);
    } catch (error) {
      console.error('Error selecting skill:', error);
      await interaction.reply({ content: 'Failed to select skill.', ephemeral: true });
    }
  }

  /**
   * Handle boss fight in roguelike
   */
  async handleRoguelikeBossFight(interaction, player) {
    try {
      if (!player.roguelikeState || !player.roguelikeState.isActive) {
        await interaction.reply({ content: 'No active run.', ephemeral: true });
        return;
      }

      const roguelike = new RoguelikeManager();
      const state = player.roguelikeState;
      const nextBossNum = state.bossesDefeated + 1;
      const bossStats = roguelike.calculateBossStats(nextBossNum, state);

      // Simulate boss fight - for now, assume player wins (simplified for MVP)
      // In full implementation, this would integrate with CombatSystem
      state.bossesDefeated++;
      state.currencyAEarned += Math.floor(50 * state.difficultyMultiplier);
      state.currencyBEarned += Math.floor(30 * state.difficultyMultiplier);
      state.currencyCEarned += Math.floor(25 * state.difficultyMultiplier);

      // Increase difficulty for next boss
      state.difficultyMultiplier *= 1.2;

      // Move to next floor
      state.currentFloor++;

      // Check if final boss defeated
      if (state.currentFloor > 26) {
        await this.handleRoguelikeComplete(interaction, player);
        return;
      }

      await this.playerManager.savePlayer(player);
      await this.handleRoguelikeFloor(interaction, player);
    } catch (error) {
      console.error('Error in boss fight:', error);
      await interaction.reply({ content: 'Failed to process boss fight.', ephemeral: true });
    }
  }

  /**
   * Handle mini-boss fight in a room
   */
  async handleRoguelikeMiniBossFight(interaction, player, roomId) {
    try {
      if (!player.roguelikeState || !player.roguelikeState.isActive) {
        await interaction.reply({ content: 'No active run.', ephemeral: true });
        return;
      }

      const state = player.roguelikeState;
      const room = state.currentFloorRooms.find(r => r.id === roomId);

      if (!room || !room.miniBoss) {
        await interaction.reply({ content: 'Mini-boss not found!', ephemeral: true });
        return;
      }

      const miniBoss = room.miniBoss;
      const roguelike = new RoguelikeManager();

      // Simulate mini-boss fight (simplified - assumes player wins)
      // In a full implementation, this would use the CombatSystem
      const playerDamage = state.stats.strength + Math.floor(Math.random() * 10);
      const damageTaken = Math.max(0, miniBoss.damage - state.stats.defense);
      
      // Mark mini-boss as defeated
      miniBoss.defeated = true;
      
      // Update player state
      state.hp = Math.max(1, state.hp - damageTaken);
      state.totalDamageTaken += damageTaken;
      state.totalDamageDealt += playerDamage;
      
      // Apply room modifier bonuses if present
      let rewardMultiplier = 1.0;
      if (room.modifier && room.modifier.rewardMultiplier) {
        rewardMultiplier = room.modifier.rewardMultiplier;
      }

      // Grant rewards
      const currencyA = Math.floor((15 + state.currentFloor * 2) * rewardMultiplier);
      const currencyB = Math.floor((10 + state.currentFloor) * rewardMultiplier);
      
      state.currencyAEarned += currencyA;
      state.currencyBEarned += currencyB;
      state.miniBossesDefeated++;

      // Grant loot
      const lootGained = miniBoss.loot || [];
      lootGained.forEach(loot => {
        if (loot.isArtifact) {
          state.artifacts.push(loot);
        } else {
          state.items.push(loot);
        }
      });

      if (room.type === 'skill') {
        await this.playerManager.savePlayer(player);
        await this.handleRoguelikeSkillRoom(interaction, player, room, {
          currencyA,
          currencyB,
          lootGained,
        });
        return;
      }

      // Build result embed
      const embed = new EmbedBuilder()
        .setColor(0x00ff00)
        .setTitle('‚öîÔ∏è Victory!')
        .setDescription(
          `You defeated the **${miniBoss.name}**!\n\n` +
          `üíî Damage taken: ${damageTaken}\n` +
          `‚ù§Ô∏è HP remaining: ${state.hp}/${state.stats.maxHp}\n\n` +
          `**Rewards**\n` +
          `üíé Currency A: +${currencyA}\n` +
          `‚≠ê Currency B: +${currencyB}\n` +
          (lootGained.length > 0 ? `üéÅ Loot: ${lootGained.map(l => l.name).join(', ')}\n` : '')
        );

      // Process room completion
      const actionResults = { bossDefeated: true };
      roguelike.completeRoom(state, room, actionResults);
      
      // Advance to next floor
      state.currentFloor++;

      // Save and continue
      await this.playerManager.savePlayer(player);

      // Check if player survived
      if (state.hp <= 0) {
        embed.setColor(0xff0000);
        embed.setTitle('üíÄ Defeated!');
        embed.setDescription('You were defeated by the mini-boss...');
        await this.handleRoguelikeExit(interaction, player);
        return;
      }

      // Add continue button
      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-continue')
          .setLabel('‚û°Ô∏è Continue to Next Floor')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-exit')
          .setLabel('üö™ Exit (50% rewards)')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
      });
    } catch (error) {
      console.error('Error in mini-boss fight:', error);
      await interaction.reply({ content: 'Failed to process mini-boss fight.', ephemeral: true });
    }
  }

  /**
   * Handle roguelike complete (all bosses defeated)
   */
  async handleRoguelikeComplete(interaction, player) {
    try {
      const roguelike = new RoguelikeManager();
      const state = player.roguelikeState;

      // Calculate rewards (100% for completion)
      const rewards = roguelike.calculateRewards(state, 'death');

      // Update player
      player.roguelikeCurrencies.currencyA += rewards.currencyA;
      player.roguelikeCurrencies.currencyB += rewards.currencyB;
      player.roguelikeCurrencies.currencyC += rewards.currencyC;

      // Update stats
      player.roguelikeStats.totalRunsCompleted++;
      player.roguelikeStats.highestFloorReached = Math.max(
        player.roguelikeStats.highestFloorReached,
        state.currentFloor
      );
      player.roguelikeStats.totalCurrencyEarned.A += rewards.currencyA;
      player.roguelikeStats.totalCurrencyEarned.B += rewards.currencyB;
      player.roguelikeStats.totalCurrencyEarned.C += rewards.currencyC;
      player.roguelikeStats.bossesDefeated += 6; // 5 bosses + final boss

      // Clear run state
      player.roguelikeState = null;

      // Save player
      await this.playerManager.savePlayer(player);

      const embed = new EmbedBuilder()
        .setColor(0xffd700)
        .setTitle('üé≤ Roguelike Complete!')
        .setDescription(
          `**üèÜ YOU CONQUERED THE ROGUELIKE DUNGEON! üèÜ**\n\n` +
          `**Rewards Earned (100% multiplier)**\n` +
          `üíé Currency A: +${rewards.currencyA}\n` +
          `‚≠ê Currency B: +${rewards.currencyB}\n` +
          `üèÜ Currency C: +${rewards.currencyC}\n\n` +
          `**Run Summary**\n` +
          `üìç Floors Cleared: 26/26 ‚úì\n` +
          `üëπ Bosses Defeated: 6/6 ‚úì\n` +
          `‚è±Ô∏è Difficulty Multiplier: ${state.difficultyMultiplier.toFixed(2)}x`
        )
        .setColor(0xffd700);

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike')
          .setLabel('üé≤ Again')
          .setStyle(ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-upgrades')
          .setLabel('üíé Upgrade Stats')
          .setStyle(ButtonStyle.Primary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
      });
    } catch (error) {
      console.error('Error in roguelike complete:', error);
      await interaction.reply({
        content: 'Failed to complete roguelike.',
        ephemeral: true,
      });
    }
  }

  /**
   * Handle roguelike upgrades menu
   */
  async handleRoguelikeUpgrades(interaction, player, category = 'all') {
    try {
      const roguelike = new RoguelikeManager();
      const allUpgrades = roguelike.getAvailableUpgrades(player.roguelikeUpgrades);
      
      // Filter upgrades by category if specified
      const filteredUpgrades = category === 'all' 
        ? allUpgrades 
        : allUpgrades.filter(u => u.category === category);

      // Create embed with currency explanations
      const embed = new EmbedBuilder()
        .setColor(0x9b59b6)
        .setTitle('üíé Roguelike Permanent Upgrades')
        .setDescription(
          `**Understanding Currencies:**\n\n` +
          `üíé **Currency A** (${player.roguelikeCurrencies.currencyA})\n` +
          `Used to purchase permanent upgrades that apply to all future roguelike runs. ` +
          `Earned by completing floors, defeating bosses, and reaching milestones.\n\n` +
          `‚≠ê **Currency B** (${player.roguelikeCurrencies.currencyB})\n` +
          `Used inside roguelike runs to unlock special rooms (Library, Armory, Alchemy). ` +
          `Earned during runs and resets when you exit.\n\n` +
          `üèÜ **Currency C** (${player.roguelikeCurrencies.currencyC})\n` +
          `Used for player upgrades outside the dungeon. ` +
          `Earned from completing runs and achievements.\n\n` +
          `**Viewing:** ${category === 'all' ? 'All Upgrades' : category.charAt(0).toUpperCase() + category.slice(1)} ` +
          `(${filteredUpgrades.length} available)\n` +
          `Select an upgrade below to view details and purchase.`
        );

      // Create select menu for upgrades
      const selectMenu = new StringSelectMenuBuilder()
        .setCustomId('rpg-roguelike-upgrade-select')
        .setPlaceholder('Choose an upgrade to view...')
        .setMinValues(1)
        .setMaxValues(1);

      // Add upgrade options to select menu (max 25)
      filteredUpgrades.slice(0, 25).forEach(upgrade => {
        const status = upgrade.isMaxed ? 'MAX' : `${upgrade.cost} üíé`;
        const label = `${upgrade.name} - ${status}`;
        const description = `Lv ${upgrade.currentLevel}/${upgrade.maxLevel} | ${upgrade.description}`.slice(0, 100);
        
        selectMenu.addOptions({
          label: label.slice(0, 100),
          description: description,
          value: upgrade.id,
          emoji: upgrade.emoji,
        });
      });

      const rows = [new ActionRowBuilder().addComponents(selectMenu)];

      // Add category filter buttons
      const categoryButtons = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-upgrades-category-all')
          .setLabel('All')
          .setStyle(category === 'all' ? ButtonStyle.Primary : ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-upgrades-category-survival')
          .setLabel('üõ°Ô∏è Survival')
          .setStyle(category === 'survival' ? ButtonStyle.Primary : ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-upgrades-category-offense')
          .setLabel('‚öîÔ∏è Offense')
          .setStyle(category === 'offense' ? ButtonStyle.Primary : ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-upgrades-category-magic')
          .setLabel('üîÆ Magic')
          .setStyle(category === 'magic' ? ButtonStyle.Primary : ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-upgrades-category-utility')
          .setLabel('üí® Utility')
          .setStyle(category === 'utility' ? ButtonStyle.Primary : ButtonStyle.Secondary)
      );
      rows.push(categoryButtons);

      // Add progression category and back button
      const bottomButtons = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-upgrades-category-progression')
          .setLabel('‚≠ê Progression')
          .setStyle(category === 'progression' ? ButtonStyle.Primary : ButtonStyle.Secondary),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Danger)
      );
      rows.push(bottomButtons);

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: rows,
      });
    } catch (error) {
      console.error('Error in upgrades:', error);
      await interaction.reply({ content: 'Failed to load upgrades.', ephemeral: true });
    }
  }

  /**
   * Handle roguelike statistics
   */
  async handleRoguelikeStats(interaction, player) {
    try {
      const stats = player.roguelikeStats;

      const embed = new EmbedBuilder()
        .setColor(0x9b59b6)
        .setTitle('üìä Roguelike Statistics')
        .setDescription('Your roguelike dungeon records and achievements.')
        .addFields(
          { name: 'Runs Completed', value: `${stats.totalRunsCompleted}`, inline: true },
          { name: 'Highest Floor', value: `${stats.highestFloorReached}/26`, inline: true },
          { name: 'Bosses Defeated', value: `${stats.bossesDefeated}`, inline: true },
          { name: 'Voluntary Exits', value: `${stats.voluntaryExits}`, inline: true },
          { name: 'Deaths', value: `${stats.deathCount}`, inline: true },
          {
            name: 'Total Currency Earned',
            value: `üíé A: ${stats.totalCurrencyEarned.A}\n‚≠ê B: ${stats.totalCurrencyEarned.B}\nüèÜ C: ${stats.totalCurrencyEarned.C}`,
            inline: false,
          }
        )
        .setColor(0x9b59b6);

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-roguelike')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
      });
    } catch (error) {
      console.error('Error in stats:', error);
      await interaction.reply({ content: 'Failed to load statistics.', ephemeral: true });
    }
  }

  /**
   * Handle viewing upgrade details
   */
  async handleRoguelikeUpgradeView(interaction, player, upgradeId) {
    try {
      const roguelike = new RoguelikeManager();
      const upgradeDetails = roguelike.getUpgradeDetails(upgradeId, player.roguelikeUpgrades);
      
      if (!upgradeDetails) {
        await interaction.reply({ content: '‚ùå Invalid upgrade!', ephemeral: true });
        return;
      }

      const embed = new EmbedBuilder()
        .setColor(0x9b59b6)
        .setTitle(`${upgradeDetails.emoji} ${upgradeDetails.name}`)
        .setDescription(upgradeDetails.detailDescription)
        .addFields(
          { 
            name: 'üìä Current Status', 
            value: `Level: **${upgradeDetails.currentLevel}/${upgradeDetails.maxLevel}**\n` +
                   `Current Bonus: **+${upgradeDetails.currentBonus}**\n` +
                   `Next Bonus: **+${upgradeDetails.nextBonus}**`,
            inline: true 
          },
          { 
            name: 'üíé Cost Information', 
            value: upgradeDetails.isMaxed 
              ? '‚úÖ **MAX LEVEL**' 
              : `Next Level Cost: **${upgradeDetails.cost}** Currency A\n` +
                `Your Currency: **${player.roguelikeCurrencies.currencyA}**`,
            inline: true 
          },
          {
            name: 'üìà Upgrade Path (Next 5 Levels)',
            value: upgradeDetails.costProgression.length > 0
              ? upgradeDetails.costProgression.map(p => `Lv ${p.level}: ${p.cost} üíé`).join('\n')
              : '‚úÖ Max level reached!',
            inline: false
          }
        )
        .setFooter({ text: `Category: ${upgradeDetails.category.toUpperCase()} | +${upgradeDetails.increment} per level` });

      const canAfford = !upgradeDetails.isMaxed && player.roguelikeCurrencies.currencyA >= upgradeDetails.cost;
      
      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-roguelike-upgrade-buy-${upgradeId}`)
          .setLabel(upgradeDetails.isMaxed ? '‚úÖ Maxed' : `üíé Purchase (${upgradeDetails.cost})`)
          .setStyle(upgradeDetails.isMaxed ? ButtonStyle.Secondary : ButtonStyle.Success)
          .setDisabled(upgradeDetails.isMaxed || !canAfford),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-upgrades')
          .setLabel('‚Üê Back to Upgrades')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
      });
    } catch (error) {
      console.error('Error viewing upgrade:', error);
      await interaction.reply({ content: '‚ùå Failed to view upgrade details.', ephemeral: true });
    }
  }

  /**
   * Handle purchasing an upgrade
   */
  async handleRoguelikeUpgradePurchase(interaction, player, upgradeId) {
    try {
      const roguelike = new RoguelikeManager();
      const result = roguelike.purchaseUpgrade(player, upgradeId);
      
      if (!result.success) {
        await interaction.reply({ content: `‚ùå ${result.message}`, ephemeral: true });
        return;
      }

      // Save player
      await this.playerManager.savePlayer(player);

      // Show success message and return to upgrade details
      const upgradeDetails = roguelike.getUpgradeDetails(upgradeId, player.roguelikeUpgrades);
      
      const embed = new EmbedBuilder()
        .setColor(0x00ff00)
        .setTitle('‚úÖ Upgrade Purchased!')
        .setDescription(
          `**${upgradeDetails.emoji} ${upgradeDetails.name}** upgraded to **Level ${result.newLevel}**!\n\n` +
          `‚ú® Bonus gained: **+${result.bonusGained}**\n` +
          `üíé Currency remaining: **${result.currencyRemaining}**`
        )
        .addFields(
          { 
            name: 'üìä Current Status', 
            value: `Level: **${upgradeDetails.currentLevel}/${upgradeDetails.maxLevel}**\n` +
                   `Total Bonus: **+${upgradeDetails.currentBonus}**`,
            inline: true 
          },
          { 
            name: 'üíé Next Upgrade', 
            value: upgradeDetails.isMaxed 
              ? '‚úÖ **MAX LEVEL**' 
              : `Cost: **${upgradeDetails.cost}** Currency A`,
            inline: true 
          }
        );

      const canAfford = !upgradeDetails.isMaxed && player.roguelikeCurrencies.currencyA >= upgradeDetails.cost;
      
      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId(`rpg-roguelike-upgrade-buy-${upgradeId}`)
          .setLabel(upgradeDetails.isMaxed ? '‚úÖ Maxed' : `üíé Buy Again (${upgradeDetails.cost})`)
          .setStyle(upgradeDetails.isMaxed ? ButtonStyle.Secondary : ButtonStyle.Success)
          .setDisabled(upgradeDetails.isMaxed || !canAfford),
        new ButtonBuilder()
          .setCustomId(`rpg-roguelike-upgrade-view-${upgradeId}`)
          .setLabel('üìä View Details')
          .setStyle(ButtonStyle.Primary),
        new ButtonBuilder()
          .setCustomId('rpg-roguelike-upgrades')
          .setLabel('‚Üê Back to Upgrades')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
      });
    } catch (error) {
      console.error('Error purchasing upgrade:', error);
      await interaction.reply({ content: '‚ùå Failed to purchase upgrade.', ephemeral: true });
    }
  }

  /**
   * Display leaderboards selector menu
   */
  async handleLeaderboards(interaction) {
    const embed = new EmbedBuilder()
      .setColor(0xffe700)
      .setTitle('üèÜ Player Leaderboards')
      .setDescription(
        `View top players across multiple categories!\n\n` +
        `üìä Select a leaderboard category below to see the rankings.`
      )
      .addFields(
        { name: '‚≠ê Available Categories', value: '‚Ä¢ Overall Score\n‚Ä¢ Experience & Level\n‚Ä¢ Total Gold\n‚Ä¢ Boss Essence\n‚Ä¢ Equipment Power\n‚Ä¢ Guild Ranks\n‚Ä¢ Arena Wins', inline: false }
      );

    const row = new ActionRowBuilder().addComponents(
      new StringSelectMenuBuilder()
        .setCustomId('rpg-leaderboard-select')
        .setPlaceholder('Select a leaderboard category')
        .addOptions(
          { label: 'üåü Overall Score', value: 'overall', emoji: 'üåü', description: 'Top players by combined level and experience' },
          { label: '‚≠ê Level / Experience', value: 'level', emoji: '‚≠ê', description: 'Top players by character level and total XP' },
          { label: 'üí∞ Total Gold', value: 'gold', emoji: 'üí∞', description: 'Richest players by total gold owned' },
          { label: 'üîÆ Boss Essence', value: 'essence', emoji: 'üîÆ', description: 'Players with most Boss Essence' },
          { label: '‚öîÔ∏è Equipment Power', value: 'equipment', emoji: '‚öîÔ∏è', description: 'Highest average equipment rating' },
          { label: 'üè∞ Guild Leadership', value: 'guild', emoji: 'üè∞', description: 'Top guild leaders and officers' },
          { label: 'ü•ä Arena Wins', value: 'arena', emoji: 'ü•ä', description: 'Players with most arena victories' }
        )
    );

    // For slash commands, use deferReply/editReply. For components, use update
    if (interaction.isChatInputCommand()) {
      await interaction.deferReply({ ephemeral: false });
      await interaction.editReply({
        embeds: [embed],
        components: [row],
      });
    } else {
      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
      });
    }
  }

  /**
   * Display specific leaderboard
   */
  async handleLeaderboardView(interaction, category) {
    // Don't defer again if already deferred
    if (!interaction.deferred && !interaction.replied) {
      await interaction.deferReply({ ephemeral: false });
    }

    // Get all players from storage
    const players = await this.playerManager.getAllPlayers();
    if (!players || players.length === 0) {
      await interaction.editReply({
        content: '‚ùå No players found.',
        components: [new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-leaderboard')
            .setLabel('‚Üê Back')
            .setStyle(ButtonStyle.Secondary)
        )],
      });
      return;
    }

    let entries = [];
    let title = '';
    let emoji = '';
    let pageSize = 10;

    switch(category) {
      case 'overall':
        title = 'üåü Overall Score Leaderboard';
        emoji = 'üåü';
        entries = players
          .filter(p => p.characterCreated)
          .map(p => ({
            player: p,
            value: this.calculateOverallScore(p),
            secondary: p.level,
            displayValue: `Lvl ${p.level} | Score: ${Math.floor(this.calculateOverallScore(p)).toLocaleString()}`
          }))
          .sort((a, b) => b.value - a.value);
        break;

      case 'level':
        title = '‚≠ê Experience & Level Leaderboard';
        emoji = '‚≠ê';
        entries = players
          .filter(p => p.characterCreated)
          .map(p => ({
            player: p,
            value: p.level,
            secondary: p.totalXP || 0,
            displayValue: `Lvl ${p.level} (${(p.totalXP || 0).toLocaleString()} XP)`
          }))
          .sort((a, b) => b.value !== a.value ? b.value - a.value : b.secondary - a.secondary);
        break;

      case 'gold':
        title = 'üí∞ Total Gold Leaderboard';
        emoji = 'üí∞';
        entries = players
          .filter(p => p.characterCreated)
          .map(p => ({
            player: p,
            value: p.gold || 0,
            displayValue: `${(p.gold || 0).toLocaleString()}g`
          }))
          .sort((a, b) => b.value - a.value);
        break;

      case 'essence':
        title = 'üîÆ Boss Essence Leaderboard';
        emoji = 'üîÆ';
        entries = players
          .filter(p => p.characterCreated)
          .map(p => {
            const essenceCount = this.getMaterialCount(p, 'boss_essence');
            return {
              player: p,
              value: essenceCount,
              displayValue: `${essenceCount.toLocaleString()} Essence`
            };
          })
          .sort((a, b) => b.value - a.value)
          .filter(e => e.value > 0);
        break;

      case 'equipment':
        title = '‚öîÔ∏è Equipment Power Leaderboard';
        emoji = '‚öîÔ∏è';
        entries = players
          .filter(p => p.characterCreated && p.inventory && p.inventory.length > 0)
          .map(p => {
            const equipment = p.inventory.filter(i => i && i.type === 'equipment' && i.equipped);
            const powerScore = equipment.reduce((sum, eq) => sum + (eq.rarity === 'legendary' ? 100 : eq.rarity === 'epic' ? 75 : eq.rarity === 'rare' ? 50 : 25), 0);
            return {
              player: p,
              value: powerScore,
              secondary: equipment.length,
              displayValue: `${powerScore} Power (${equipment.length} items)`
            };
          })
          .sort((a, b) => b.value !== a.value ? b.value - a.value : b.secondary - a.secondary)
          .filter(e => e.value > 0);
        break;

      case 'guild':
        title = 'üè∞ Guild Leadership Leaderboard';
        emoji = 'üè∞';
        const guildEntries = new Map();
        players.forEach(p => {
          if (p.characterCreated) {
            const guild = this.guildManager.getPlayerGuild(p.userId);
            if (guild && guild.leader === p.userId) {
              guildEntries.set(p.userId, {
                player: p,
                guild: guild,
                value: guild.members ? Object.keys(guild.members).length : 1,
                displayValue: `[${guild.tag}] ${guild.name} (${guild.members ? Object.keys(guild.members).length : 1} members)`
              });
            }
          }
        });
        entries = Array.from(guildEntries.values()).sort((a, b) => b.value - a.value);
        break;

      case 'arena':
        title = 'ü•ä Arena Wins Leaderboard';
        emoji = 'ü•ä';
        entries = players
          .filter(p => p.characterCreated && (p.arenaWins || 0) > 0)
          .map(p => ({
            player: p,
            value: p.arenaWins || 0,
            secondary: p.arenaLosses || 0,
            displayValue: `${p.arenaWins || 0} Wins / ${p.arenaLosses || 0} Losses`
          }))
          .sort((a, b) => b.value - a.value);
        break;

      default:
        await interaction.editReply({ content: '‚ùå Unknown leaderboard category.' });
        return;
    }

    if (entries.length === 0) {
      await interaction.editReply({
        content: `‚ùå No data available for this leaderboard yet.`,
        components: [new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-leaderboard')
            .setLabel('‚Üê Back')
            .setStyle(ButtonStyle.Secondary)
        )],
      });
      return;
    }

    // Create leaderboard display (top 10)
    const leaderboardText = entries.slice(0, pageSize)
      .map((entry, idx) => {
        const medal = ['ü•á', 'ü•à', 'ü•â'][idx] || `#${idx + 1}`;
        return `${medal} **${entry.player.username}** - ${entry.displayValue}`;
      })
      .join('\n');

    const embed = new EmbedBuilder()
      .setColor(0xffe700)
      .setTitle(`${emoji} ${title}`)
      .setDescription(leaderboardText || 'No entries')
      .setFooter({ text: `Showing top ${Math.min(pageSize, entries.length)} of ${entries.length} players` });

    const backButton = new ActionRowBuilder().addComponents(
      new ButtonBuilder()
        .setCustomId('rpg-leaderboard')
        .setLabel('‚Üê Back')
        .setStyle(ButtonStyle.Secondary)
    );

    await interaction.editReply({
      embeds: [embed],
      components: [backButton],
    });
  }

  /**
   * Display specific leaderboard from select menu (uses update instead of deferReply)
   */
  async handleLeaderboardViewFromSelect(interaction, category) {
    try {
      // Get all players from storage
      const players = await this.playerManager.getAllPlayers();
      if (!players || players.length === 0) {
        await this.updateInteractionWithTracking(interaction, {
          content: '‚ùå No players found.',
          components: [new ActionRowBuilder().addComponents(
            new ButtonBuilder()
              .setCustomId('rpg-leaderboard')
              .setLabel('‚Üê Back')
              .setStyle(ButtonStyle.Secondary)
          )],
        });
        return;
      }

      let entries = [];
      let title = '';
      let emoji = '';
      let pageSize = 10;

      switch(category) {
        case 'overall':
          title = 'üåü Overall Score Leaderboard';
          emoji = 'üåü';
          entries = players
            .filter(p => p.characterCreated)
            .map(p => ({
              player: p,
              value: this.calculateOverallScore(p),
              secondary: p.level,
              displayValue: `Lvl ${p.level} | Score: ${Math.floor(this.calculateOverallScore(p)).toLocaleString()}`
            }))
            .sort((a, b) => b.value - a.value);
          break;

        case 'level':
          title = '‚≠ê Experience & Level Leaderboard';
          emoji = '‚≠ê';
          entries = players
            .filter(p => p.characterCreated)
            .map(p => ({
              player: p,
              value: p.level,
              secondary: p.totalXP || 0,
              displayValue: `Lvl ${p.level} (${(p.totalXP || 0).toLocaleString()} XP)`
            }))
            .sort((a, b) => b.value !== a.value ? b.value - a.value : b.secondary - a.secondary);
          break;

        case 'gold':
          title = 'üí∞ Total Gold Leaderboard';
          emoji = 'üí∞';
          entries = players
            .filter(p => p.characterCreated)
            .map(p => ({
              player: p,
              value: p.gold || 0,
              displayValue: `${(p.gold || 0).toLocaleString()}g`
            }))
            .sort((a, b) => b.value - a.value);
          break;

        case 'essence':
          title = 'üîÆ Boss Essence Leaderboard';
          emoji = 'üîÆ';
          entries = players
            .filter(p => p.characterCreated)
            .map(p => {
              const essenceCount = this.getMaterialCount(p, 'boss_essence');
              return {
                player: p,
                value: essenceCount,
                displayValue: `${essenceCount.toLocaleString()} Essence`
              };
            })
            .sort((a, b) => b.value - a.value)
            .filter(e => e.value > 0);
          break;

        case 'equipment':
          title = '‚öîÔ∏è Equipment Power Leaderboard';
          emoji = '‚öîÔ∏è';
          entries = players
            .filter(p => p.characterCreated && p.inventory && p.inventory.length > 0)
            .map(p => {
              const equipment = p.inventory.filter(i => i && i.type === 'equipment' && i.equipped);
              const powerScore = equipment.reduce((sum, eq) => sum + (eq.rarity === 'legendary' ? 100 : eq.rarity === 'epic' ? 75 : eq.rarity === 'rare' ? 50 : 25), 0);
              return {
                player: p,
                value: powerScore,
                secondary: equipment.length,
                displayValue: `${powerScore} Power (${equipment.length} items)`
              };
            })
            .sort((a, b) => b.value !== a.value ? b.value - a.value : b.secondary - a.secondary)
            .filter(e => e.value > 0);
          break;

        case 'guild':
          title = 'üè∞ Guild Leadership Leaderboard';
          emoji = 'üè∞';
          const guildEntries = new Map();
          players.forEach(p => {
            try {
              if (p.characterCreated && this.guildManager) {
                const guild = this.guildManager.getPlayerGuild(p.userId);
                if (guild && guild.leader === p.userId) {
                  guildEntries.set(p.userId, {
                    player: p,
                    guild: guild,
                    value: guild.members ? Object.keys(guild.members).length : 1,
                    displayValue: `[${guild.tag}] ${guild.name} (${guild.members ? Object.keys(guild.members).length : 1} members)`
                  });
                }
              }
            } catch (err) {
              // Skip this guild entry if there's an error
              console.warn(`[Leaderboard] Error processing guild for ${p.username}:`, err.message);
            }
          });
          entries = Array.from(guildEntries.values()).sort((a, b) => b.value - a.value);
          break;

        case 'arena':
          title = 'ü•ä Arena Wins Leaderboard';
          emoji = 'ü•ä';
          entries = players
            .filter(p => p.characterCreated && (p.arenaWins || 0) > 0)
            .map(p => ({
              player: p,
              value: p.arenaWins || 0,
              secondary: p.arenaLosses || 0,
              displayValue: `${p.arenaWins || 0} Wins / ${p.arenaLosses || 0} Losses`
            }))
            .sort((a, b) => b.value - a.value);
          break;

        default:
          await this.updateInteractionWithTracking(interaction, { content: '‚ùå Unknown leaderboard category.' });
          return;
      }

      if (entries.length === 0) {
        await this.updateInteractionWithTracking(interaction, {
          content: `‚ùå No data available for this leaderboard yet.`,
          components: [new ActionRowBuilder().addComponents(
            new ButtonBuilder()
              .setCustomId('rpg-leaderboard')
              .setLabel('‚Üê Back')
              .setStyle(ButtonStyle.Secondary)
          )],
        });
        return;
      }

      // Create leaderboard display (top 10)
      const leaderboardText = entries.slice(0, pageSize)
        .map((entry, idx) => {
          const medal = ['ü•á', 'ü•à', 'ü•â'][idx] || `#${idx + 1}`;
          return `${medal} **${entry.player.username}** - ${entry.displayValue}`;
        })
        .join('\n');

      const embed = new EmbedBuilder()
        .setColor(0xffe700)
        .setTitle(`${emoji} ${title}`)
        .setDescription(leaderboardText || 'No entries')
        .setFooter({ text: `Showing top ${Math.min(pageSize, entries.length)} of ${entries.length} players` });

      const backButton = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-leaderboard')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [backButton],
      });
    } catch (error) {
      console.error('[Leaderboard] Error in handleLeaderboardViewFromSelect:', error);
      await this.updateInteractionWithTracking(interaction, {
        content: '‚ùå An error occurred while loading the leaderboards.',
        components: [new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-leaderboard')
            .setLabel('‚Üê Back')
            .setStyle(ButtonStyle.Secondary)
        )],
      });
    }
  }

  /**
   * Handle progress tab leaderboard view with player rank displayed
   */
  async handleProgressLeaderboardView(interaction, player, category) {
    try {
      // Get all players from storage
      const players = await this.playerManager.getAllPlayers();
      if (!players || players.length === 0) {
        await this.updateInteractionWithTracking(interaction, {
          content: '‚ùå No players found.',
          components: [new ActionRowBuilder().addComponents(
            new ButtonBuilder()
              .setCustomId('rpg-progress-leaderboards')
              .setLabel('‚Üê Back')
              .setStyle(ButtonStyle.Secondary)
          )],
        });
        return;
      }

      let entries = [];
      let title = '';
      let emoji = '';
      let pageSize = 10;

      switch(category) {
        case 'overall':
          title = 'üåü Overall Score Leaderboard';
          emoji = 'üåü';
          entries = players
            .filter(p => p.characterCreated)
            .map(p => ({
              player: p,
              value: this.calculateOverallScore(p),
              secondary: p.level,
              displayValue: `Lvl ${p.level} | Score: ${Math.floor(this.calculateOverallScore(p)).toLocaleString()}`
            }))
            .sort((a, b) => b.value - a.value);
          break;

        case 'level':
          title = '‚≠ê Experience & Level Leaderboard';
          emoji = '‚≠ê';
          entries = players
            .filter(p => p.characterCreated)
            .map(p => ({
              player: p,
              value: p.level,
              secondary: p.totalXP || 0,
              displayValue: `Lvl ${p.level} (${(p.totalXP || 0).toLocaleString()} XP)`
            }))
            .sort((a, b) => b.value !== a.value ? b.value - a.value : b.secondary - a.secondary);
          break;

        case 'gold':
          title = 'üí∞ Total Gold Leaderboard';
          emoji = 'üí∞';
          entries = players
            .filter(p => p.characterCreated)
            .map(p => ({
              player: p,
              value: p.gold || 0,
              displayValue: `${(p.gold || 0).toLocaleString()}g`
            }))
            .sort((a, b) => b.value - a.value);
          break;

        case 'essence':
          title = 'üîÆ Boss Essence Leaderboard';
          emoji = 'üîÆ';
          entries = players
            .filter(p => p.characterCreated)
            .map(p => {
              const essenceCount = this.getMaterialCount(p, 'boss_essence');
              return {
                player: p,
                value: essenceCount,
                displayValue: `${essenceCount.toLocaleString()} Essence`
              };
            })
            .sort((a, b) => b.value - a.value)
            .filter(e => e.value > 0);
          break;

        case 'equipment':
          title = '‚öîÔ∏è Equipment Power Leaderboard';
          emoji = '‚öîÔ∏è';
          entries = players
            .filter(p => p.characterCreated && p.inventory && p.inventory.length > 0)
            .map(p => {
              const equipment = p.inventory.filter(i => i && i.type === 'equipment' && i.equipped);
              const powerScore = equipment.reduce((sum, eq) => sum + (eq.rarity === 'legendary' ? 100 : eq.rarity === 'epic' ? 75 : eq.rarity === 'rare' ? 50 : 25), 0);
              return {
                player: p,
                value: powerScore,
                secondary: equipment.length,
                displayValue: `${powerScore} Power (${equipment.length} items)`
              };
            })
            .sort((a, b) => b.value !== a.value ? b.value - a.value : b.secondary - a.secondary)
            .filter(e => e.value > 0);
          break;

        case 'guild':
          title = 'üè∞ Guild Leadership Leaderboard';
          emoji = 'üè∞';
          const guildEntries = new Map();
          players.forEach(p => {
            if (p.characterCreated) {
              const guild = this.guildManager.getPlayerGuild(p.userId);
              if (guild && guild.leader === p.userId) {
                guildEntries.set(p.userId, {
                  player: p,
                  guild: guild,
                  value: guild.members ? Object.keys(guild.members).length : 1,
                  displayValue: `[${guild.tag}] ${guild.name} (${guild.members ? Object.keys(guild.members).length : 1} members)`
                });
              }
            }
          });
          entries = Array.from(guildEntries.values()).sort((a, b) => b.value - a.value);
          break;

        case 'arena':
          title = 'ü•ä Arena Wins Leaderboard';
          emoji = 'ü•ä';
          entries = players
            .filter(p => p.characterCreated && (p.arenaWins || 0) > 0)
            .map(p => ({
              player: p,
              value: p.arenaWins || 0,
              secondary: p.arenaLosses || 0,
              displayValue: `${p.arenaWins || 0} Wins / ${p.arenaLosses || 0} Losses`
            }))
            .sort((a, b) => b.value - a.value);
          break;

        default:
          await this.updateInteractionWithTracking(interaction, {
            content: '‚ùå Unknown leaderboard category.'
          });
          return;
      }

      if (entries.length === 0) {
        await this.updateInteractionWithTracking(interaction, {
          content: `‚ùå No data available for this leaderboard yet.`,
          components: [new ActionRowBuilder().addComponents(
            new ButtonBuilder()
              .setCustomId('rpg-progress-leaderboards')
              .setLabel('‚Üê Back')
              .setStyle(ButtonStyle.Secondary)
          )],
        });
        return;
      }

      // Create leaderboard display (top 10)
      const leaderboardText = entries.slice(0, pageSize)
        .map((entry, idx) => {
          const medal = ['ü•á', 'ü•à', 'ü•â'][idx] || `#${idx + 1}`;
          const highlight = entry.player.userId === player.userId ? ' ‚≠ê' : '';
          return `${medal} **${entry.player.username}** - ${entry.displayValue}${highlight}`;
        })
        .join('\n');

      // Find player's rank
      let playerRankInfo = '';
      const playerRank = entries.findIndex(e => e.player.userId === player.userId);
      if (playerRank !== -1) {
        const medal = ['ü•á', 'ü•à', 'ü•â'][playerRank] || `#${playerRank + 1}`;
        playerRankInfo = `\n\n**Your Rank:** ${medal} #${playerRank + 1} out of ${entries.length}`;
      } else {
        playerRankInfo = `\n\n**Your Rank:** Not ranked in this category`;
      }

      const embed = new EmbedBuilder()
        .setColor(0xffe700)
        .setTitle(`${emoji} ${title}`)
        .setDescription(leaderboardText || 'No entries')
        .setFooter({ text: `Showing top ${Math.min(pageSize, entries.length)} of ${entries.length} players` });

      const backButton = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-progress-leaderboards')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [backButton],
      });

      // If player is in top 10, show message
      if (playerRank !== -1 && playerRank < 10) {
        const medal = ['ü•á', 'ü•à', 'ü•â'][playerRank] || `#${playerRank + 1}`;
        await interaction.followUp({
          content: `üéâ **Congratulations!** You're ${medal} #${playerRank + 1} in this category!`,
          ephemeral: true
        });
      }
    } catch (error) {
      console.error('[Leaderboard] Error in handleProgressLeaderboardView:', error);
      await this.updateInteractionWithTracking(interaction, {
        content: '‚ùå An error occurred while loading the leaderboards.',
        components: [new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-progress-leaderboards')
            .setLabel('‚Üê Back')
            .setStyle(ButtonStyle.Secondary)
        )],
      });
    }
  }

  /**
   * ========================================
   * NIFLHEIM TOWER HANDLERS
   * ========================================
   */

  /**
   * Handle tower start - show overview and entry options
   */
  async handleTowerStart(interaction, player) {
    try {
      const tower = new TowerManager();
      
      // Check if player meets requirements
      const canEnter = tower.canEnterTower(player);
      if (!canEnter.allowed) {
        await interaction.reply({
          content: `üîí ${canEnter.reason}`,
          ephemeral: true
        });
        return;
      }

      const towerStatus = tower.getTowerStatus(player);

      const embed = new EmbedBuilder()
        .setColor(0x00d4ff)
        .setTitle('‚ùÑÔ∏è NIFLHEIM TOWER')
        .setDescription(
          '**The Infinite Tower Challenge**\n\n' +
          'üèîÔ∏è **100 Floors** of escalating difficulty\n' +
          '‚öîÔ∏è Combat every floor, **Boss every 5 floors**\n' +
         '‚ùÑÔ∏è Face the ultimate frozen challenge\n\n' +
          '**Rewards Per Floor:**\n' +
          'üí∞ **Gold** - Scales with floor\n' +
          'üîÆ **Guild Boss Essence** - For guild upgrades\n' +
          '‚õèÔ∏è **Materials** - Crafting resources\n' +
          'üì¶ **Lootboxes** - Better on boss floors\n' +
          '‚ú® **Enchants** - Tier scales with floor\n' +
          'üß™ **Potions** - Higher tiers at higher floors\n\n' +
          '**Special Bonuses:**\n' +
          '‚Ä¢ Floors 10, 20, 30... give **2x rewards**\n' +
          '‚Ä¢ Floor 100 gives **5x rewards** + **5 Legendary Lootboxes**\n' +
          '‚Ä¢ Difficulty increases **exponentially** - prepare well!\n\n' +
          `**Your Progress:**\n` +
          `Current Floor: **${towerStatus.currentFloor}/${tower.TOTAL_FLOORS}**\n` +
          `Highest Floor: **${towerStatus.highestFloor}/${tower.TOTAL_FLOORS}** (${towerStatus.percentComplete}%)\n` +
          `Total Clears: **${towerStatus.totalClears}**\n` +
          `Total Attempts: **${towerStatus.totalAttempts}**\n\n` +
          `**Lifetime Rewards:**\n` +
          `üí∞ ${towerStatus.lifetimeRewards.gold.toLocaleString()} Gold\n` +
          `üîÆ ${towerStatus.lifetimeRewards.essence.toLocaleString()} Essence\n` +
          `üì¶ ${towerStatus.lifetimeRewards.lootboxes} Lootboxes\n` +
          `‚õèÔ∏è ${towerStatus.lifetimeRewards.materials.toLocaleString()} Materials`
        )
        .setFooter({ text: `Next Floor: ${towerStatus.nextIsBoss ? 'üëë BOSS FLOOR' : '‚öîÔ∏è Combat'}` });

      const row1 = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-tower-enter')
          .setLabel(`‚öîÔ∏è Enter Floor ${towerStatus.currentFloor}`)
          .setStyle(towerStatus.nextIsBoss ? ButtonStyle.Danger : ButtonStyle.Success),
        new ButtonBuilder()
          .setCustomId('rpg-tower-status')
          .setLabel('üìä Detailed Stats')
          .setStyle(ButtonStyle.Primary)
      );

      const row2 = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-tower-reset')
          .setLabel('üîÑ Reset to Floor 1')
          .setStyle(ButtonStyle.Secondary)
          .setDisabled(towerStatus.currentFloor === 1),
        new ButtonBuilder()
          .setCustomId('rpg-back')
          .setLabel('‚Üê Back to Combat')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row1, row2],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleTowerStart:', error);
      await interaction.reply({
        content: '‚ùå Failed to load Niflheim Tower.',
        ephemeral: true
      });
    }
  }

  /**
   * Handle tower enter - start combat on current floor
   */
  async handleTowerEnter(interaction, player) {
    try {
      const tower = new TowerManager();
      const towerStatus = tower.getTowerStatus(player);
      const currentFloor = towerStatus.currentFloor;
      const isBoss = tower.isBossFloor(currentFloor);

      // Generate enemy
      const enemy = tower.generateEnemy(currentFloor, isBoss);

      // Store enemy in player state for combat
      if (!player.towerState) {
        player.towerState = {};
      }
      player.towerState.currentEnemy = enemy;
      player.towerState.currentFloor = currentFloor;
      await this.playerManager.savePlayer(player);

      const embed = new EmbedBuilder()
        .setColor(isBoss ? 0xff0000 : 0x00d4ff)
        .setTitle(`${isBoss ? 'üëë BOSS FLOOR' : '‚öîÔ∏è TOWER COMBAT'} - Floor ${currentFloor}`)
        .setDescription(
          `${enemy.emoji} **${enemy.name}**\n\n` +
          `**Enemy Stats:**\n` +
          `‚ù§Ô∏è HP: ${enemy.hp.toLocaleString()}/${enemy.maxHp.toLocaleString()}\n` +
          `‚öîÔ∏è Damage: ${enemy.damage.toLocaleString()}\n` +
          `üõ°Ô∏è Defense: ${enemy.defense.toLocaleString()}\n\n` +
          `${isBoss ? '‚ö†Ô∏è **This is a BOSS floor!** Victory grants enhanced rewards!' : ''}\n\n` +
          `**Prepare for battle!**`
        );

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-tower-fight')
          .setLabel('‚öîÔ∏è Fight!')
          .setStyle(ButtonStyle.Danger),
        new ButtonBuilder()
          .setCustomId('rpg-tower')
          .setLabel('‚Üê Back')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleTowerEnter:', error);
      await interaction.reply({
        content: '‚ùå Failed to enter tower floor.',
        ephemeral: true
      });
    }
  }

  /**
   * Handle tower fight - execute combat
   */
  async handleTowerFight(interaction, player) {
    try {
      if (!player.towerState || !player.towerState.currentEnemy) {
        await interaction.reply({
          content: '‚ùå No active tower combat found.',
          ephemeral: true
        });
        return;
      }

      const tower = new TowerManager();
      const enemy = player.towerState.currentEnemy;
      const currentFloor = player.towerState.currentFloor;

      // Use existing combat system
      const combat = new CombatSystem();
      const result = await combat.executeCombat(player, enemy);

      if (result.victory) {
        // Player won - complete floor
        const completion = tower.completeFloor(player, currentFloor, result);
        await this.playerManager.savePlayer(player);

        // Build rewards display and distribute
        let rewardsText = '';
        
        // Add gold
        if (completion.rewards.gold > 0) {
          rewardsText += `üí∞ ${completion.rewards.gold.toLocaleString()} Gold\n`;
          player.gold = (player.gold || 0) + completion.rewards.gold;
        }
        
        // Add guild boss essence as material
        if (completion.rewards.guildEssence > 0) {
          rewardsText += `üîÆ ${completion.rewards.guildEssence.toLocaleString()} Guild Boss Essence\n`;
          this.addMaterialToInventory(player, 'boss_essence', completion.rewards.guildEssence);
        }
        
        // Add materials
        if (completion.rewards.materials.length > 0) {
          rewardsText += `‚õèÔ∏è Materials:\n`;
          for (const mat of completion.rewards.materials) {
            rewardsText += `  ‚Ä¢ ${mat.id}: ${mat.quantity}\n`;
            this.addMaterialToInventory(player, mat.id, mat.quantity);
          }
        }
        
        // Add lootboxes
        if (completion.rewards.lootboxes.length > 0) {
          rewardsText += `üì¶ Lootboxes:\n`;
          for (const box of completion.rewards.lootboxes) {
            rewardsText += `  ‚Ä¢ ${box.type} x${box.quantity}\n`;
            this.addLootboxToInventory(player, box.type, box.quantity);
          }
        }
        
        // Add enchants
        if (completion.rewards.enchants.length > 0) {
          rewardsText += `‚ú® Enchants:\n`;
          for (const ench of completion.rewards.enchants) {
            rewardsText += `  ‚Ä¢ ${ench.id} x${ench.quantity}\n`;
            // Add enchants to inventory properly
            for (let i = 0; i < ench.quantity; i++) {
              if (!player.inventory) player.inventory = [];
              player.inventory.push({
                id: ench.id,
                name: ench.id,
                type: 'consumable',
                subtype: 'enchant',
                quantity: 1
              });
            }
          }
        }
        
        // Add potions
        if (completion.rewards.potions.length > 0) {
          rewardsText += `üß™ Potions:\n`;
          for (const pot of completion.rewards.potions) {
            rewardsText += `  ‚Ä¢ ${pot.id} x${pot.quantity}\n`;
            // Add potions to inventory properly
            for (let i = 0; i < pot.quantity; i++) {
              if (!player.inventory) player.inventory = [];
              player.inventory.push({
                id: pot.id,
                name: pot.id,
                type: 'consumable',
                subtype: 'potion',
                quantity: 1
              });
            }
          }
        }

        const embed = new EmbedBuilder()
          .setColor(0x00ff00)
          .setTitle('‚úÖ FLOOR CLEARED!')
          .setDescription(
            `${enemy.emoji} **${enemy.name}** defeated!\n\n` +
            `**Combat Summary:**\n` +
            `‚öîÔ∏è Damage Dealt: ${result.damageDealt.toLocaleString()}\n` +
            `üíî Damage Taken: ${result.damageTaken.toLocaleString()}\n` +
            `‚è±Ô∏è Combat Duration: ${result.turns} turns\n\n` +
            `**Floor ${currentFloor} Rewards:**\n${rewardsText}\n` +
            `${completion.completedTower ? 'üéâ **TOWER COMPLETED!** You conquered all 100 floors!' : `‚û°Ô∏è Next: Floor ${completion.nextFloor}${tower.isBossFloor(completion.nextFloor) ? ' (BOSS)' : ''}`}`
          );

        const row = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-tower-continue')
            .setLabel(completion.completedTower ? 'üéâ Return to Tower' : `‚û°Ô∏è Continue to Floor ${completion.nextFloor}`)
            .setStyle(ButtonStyle.Success),
          new ButtonBuilder()
            .setCustomId('rpg-tower')
            .setLabel('üìä Tower Overview')
            .setStyle(ButtonStyle.Primary)
        );

        // Clear tower state
        player.towerState = null;
        await this.playerManager.savePlayer(player);

        await this.updateInteractionWithTracking(interaction, {
          embeds: [embed],
          components: [row],
          ephemeral: true
        });
      } else {
        // Player lost
        tower.handleDefeat(player, currentFloor);
        player.towerState = null;
        await this.playerManager.savePlayer(player);

        const embed = new EmbedBuilder()
          .setColor(0xff0000)
          .setTitle('üíÄ DEFEATED')
          .setDescription(
            `${enemy.emoji} **${enemy.name}** has defeated you on Floor ${currentFloor}!\n\n` +
            `**Combat Summary:**\n` +
            `‚öîÔ∏è Damage Dealt: ${result.damageDealt.toLocaleString()}\n` +
            `üíî Damage Taken: ${result.damageTaken.toLocaleString()}\n` +
            `‚è±Ô∏è Survived: ${result.turns} turns\n\n` +
            `You can retry from Floor 1 or continue from your last checkpoint.`
          );

        const row = new ActionRowBuilder().addComponents(
          new ButtonBuilder()
            .setCustomId('rpg-tower-reset')
            .setLabel('üîÑ Start from Floor 1')
            .setStyle(ButtonStyle.Primary),
          new ButtonBuilder()
            .setCustomId('rpg-tower')
            .setLabel('‚Üê Back to Tower')
            .setStyle(ButtonStyle.Secondary)
        );

        await this.updateInteractionWithTracking(interaction, {
          embeds: [embed],
          components: [row],
          ephemeral: true
        });
      }
    } catch (error) {
      console.error('Error in handleTowerFight:', error);
      await interaction.reply({
        content: '‚ùå Combat error occurred.',
        ephemeral: true
      });
    }
  }

  /**
   * Handle tower continue - proceed to next floor
   */
  async handleTowerContinue(interaction, player) {
    // Just redirect to tower start which will show current floor
    await this.handleTowerStart(interaction, player);
  }

  /**
   * Handle tower reset - start over from floor 1
   */
  async handleTowerReset(interaction, player) {
    try {
      const tower = new TowerManager();
      tower.resetProgress(player);
      await this.playerManager.savePlayer(player);

      await interaction.reply({
        content: 'üîÑ Tower progress reset! Starting from Floor 1.',
        ephemeral: true
      });

      // Show tower start
      await this.handleTowerStart(interaction, player);
    } catch (error) {
      console.error('Error in handleTowerReset:', error);
      await interaction.reply({
        content: '‚ùå Failed to reset tower progress.',
        ephemeral: true
      });
    }
  }

  /**
   * Handle tower status - show detailed statistics
   */
  async handleTowerStatus(interaction, player) {
    try {
      const tower = new TowerManager();
      const towerStatus = tower.getTowerStatus(player);

      const embed = new EmbedBuilder()
        .setColor(0x00d4ff)
        .setTitle('üìä NIFLHEIM TOWER STATISTICS')
        .addFields(
          {
            name: 'üèîÔ∏è Progress',
            value: `Current Floor: **${towerStatus.currentFloor}/${tower.TOTAL_FLOORS}**\n` +
                   `Highest Floor: **${towerStatus.highestFloor}/${tower.TOTAL_FLOORS}**\n` +
                   `Completion: **${towerStatus.percentComplete}%**`,
            inline: true
          },
          {
            name: 'üèÜ Achievements',
            value: `Total Clears: **${towerStatus.totalClears}**\n` +
                   `Total Attempts: **${towerStatus.totalAttempts}**\n` +
                   `Success Rate: **${towerStatus.totalAttempts > 0 ? ((towerStatus.totalClears / towerStatus.totalAttempts) * 100).toFixed(1) : 0}%**`,
            inline: true
          },
          {
            name: 'üí∞ Lifetime Rewards',
            value: `Gold: **${towerStatus.lifetimeRewards.gold.toLocaleString()}** üí∞\n` +
                   `Essence: **${towerStatus.lifetimeRewards.essence.toLocaleString()}** üîÆ\n` +
                   `Lootboxes: **${towerStatus.lifetimeRewards.lootboxes}** üì¶\n` +
                   `Materials: **${towerStatus.lifetimeRewards.materials.toLocaleString()}** ‚õèÔ∏è`,
            inline: false
          },
          {
            name: 'üìà Next Milestones',
            value: this.getTowerMilestones(towerStatus.currentFloor),
            inline: false
          }
        );

      const row = new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setCustomId('rpg-tower')
          .setLabel('‚Üê Back to Tower')
          .setStyle(ButtonStyle.Secondary)
      );

      await this.updateInteractionWithTracking(interaction, {
        embeds: [embed],
        components: [row],
        ephemeral: true
      });
    } catch (error) {
      console.error('Error in handleTowerStatus:', error);
      await interaction.reply({
        content: '‚ùå Failed to load tower statistics.',
        ephemeral: true
      });
    }
  }

  /**
   * Get tower milestones for display
   */
  getTowerMilestones(currentFloor) {
    const milestones = [];
    const checkpoints = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
    
    for (const checkpoint of checkpoints) {
      if (checkpoint >= currentFloor) {
        const floorsAway = checkpoint - currentFloor;
        const isClose = floorsAway <= 5;
        milestones.push(
          `${isClose ? 'üî•' : 'üìç'} Floor ${checkpoint} - ${floorsAway === 0 ? '**NEXT!**' : `${floorsAway} floors away`} ${checkpoint % 10 === 0 ? '(2x Rewards)' : ''}`
        );
        if (milestones.length >= 3) break;
      }
    }
    
    return milestones.length > 0 ? milestones.join('\n') : 'Tower Complete! üéâ';
  }
}

